Difference of "shaders" between "1.9.0.0" (beta of "1.9.0") and "1.9.0.2" (beta of "1.9.0").

Added file "hummingbird/CohColorMixingPS.hlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	// Formulas for color mixing from https://www.w3.org/TR/compositing-1/#blending
	#define SAMPLE2D(tex, uv) tex.Sample(TextureSampler0, uv)
	
	float Lum(float3 color)
	{
		return 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;
	}
	
	float3 ClipColor(float3 color)
	{
		float L = Lum(color);
		float fmin = min(min(color.r, color.g), color.b);
		float fmax = max(max(color.r, color.g), color.b);
	
		if (fmin < 0.0)
		{
			color = L + (((color - L) * L) / (L - fmin));
		}
		if (fmax > 1.0)
		{
			color = L + (((color - L) * (1 - L)) / (fmax - L));
		}
	
		return color;
	}
	
	float3 SetLum(float3 color, float lum)
	{
		float d = lum - Lum(color);
		color += d;
		return ClipColor(color);
	}
	
	float Sat(float3 color)
	{
		return max(max(color.r, color.g), color.b) -
			min(min(color.r, color.g), color.b);
	}
	
	float3 SetSatInner(float3 color, float sat)
	{
		// Here the |color| values are in ascending order, i.e.
		// color.x <= color.y <= color.z
	
		if (color.z > color.x)
		{
			color.y = (((color.y - color.x) * sat) / (color.z - color.x));
			color.z = sat;
		}
		else
		{
			color.yz = float2(0.0, 0.0);
		}
		return float3(0.0, color.y, color.z);
	}
	
	float3 SetSat(float3 color, float sat)
	{
		if (color.r <= color.g)
		{
			if (color.g <= color.b)
			{
				color.rgb = SetSatInner(color.rgb, sat);
			}
			else if (color.r <= color.b)
			{
				color.rbg = SetSatInner(color.rbg, sat);
			}
			else
			{
				color.brg = SetSatInner(color.brg, sat);
			}
		}
		else if (color.r <= color.b)
		{
			color.grb = SetSatInner(color.grb, sat);
		}
		else if (color.g <= color.b)
		{
			color.gbr = SetSatInner(color.gbr, sat);
		}
		else
		{
			color.bgr = SetSatInner(color.bgr, sat);
		}
		return color;
	}
	
	float3 ColorMixScreen(float3 backdrop, float3 source)
	{
		return backdrop + source - backdrop * source;
	}
	
	float3 ColorMixMultiply(float3 backdrop, float3 source)
	{
		return backdrop * source;
	}
	
	float3 ColorMixHardLight(float3 backdrop, float3 source)
	{
		// if (Cs <= 0.5) B(Cb, Cs) = Multiply(Cb, 2 x Cs)
		// else           B(Cb, Cs) = Screen(Cb, 2 x Cs - 1)
		float3 coef = step(source, 0.5);
		return lerp(ColorMixScreen(backdrop, 2 * source - 1),
			ColorMixMultiply(backdrop, 2 * source), coef);
	}
	
	float3 ColorMixSoftLight(float3 backdrop, float3 source)
	{
		// TODO: Check if branching perf is better, diffuseB calc is heavy
		float3 diffuseBCoef = step(backdrop, 0.25);
		float3 diffuseB = lerp(sqrt(backdrop),
			((16 * backdrop - 12) * backdrop + 4) * backdrop,
			diffuseBCoef);
	
		float3 coef = step(source, 0.5);
		return lerp(backdrop + (2 * source - 1) * (diffuseB - backdrop),
			backdrop - (1 - 2 * source) * backdrop * (1 - backdrop),
			coef);
	}
	
	float3 BlendFunction(float3 backdrop, float3 source, int mode)
	{
		// Switch not supported in SM3
		if (mode == 0)
		{
			// Normal mode
			return source;
		}
		else if (mode == 1)
		{
			// Multiply
			return ColorMixMultiply(backdrop, source);
		}
		else if (mode == 2)
		{
			// Screen
			return ColorMixScreen(backdrop, source);
		}
		else if (mode == 3)
		{
			// Overlay
			return ColorMixHardLight(source, backdrop); // Inverted hard-light
		}
		else if (mode == 4)
		{
			// Darken
			return min(source, backdrop);
		}
		else if (mode == 5)
		{
			// Lighten
			return max(source, backdrop);
		}
		else if (mode == 6)
		{
			// Color dodge
			return min(1, backdrop / max(1 - source, 0.0001));
		}
		else if (mode == 7)
		{
			// Color burn
			return 1 - min(1, (1 - backdrop) / max(source, 0.0001));
		}
		else if (mode == 8)
		{
			// Hard light
			return ColorMixHardLight(backdrop, source);
		}
		else if (mode == 9)
		{
			// Soft light
			return ColorMixSoftLight(backdrop, source);
		}
		else if (mode == 10)
		{
			// Difference
			return abs(backdrop - source);
		}
		else if (mode == 11)
		{
			// Exclusion
			return backdrop + source - 2 * backdrop * source;
		}
		else if (mode == 12)
		{
			// Hue
			return SetLum(SetSat(source, Sat(backdrop)), Lum(backdrop));
		}
		else if (mode == 13)
		{
			// Saturation
			return SetLum(SetSat(backdrop, Sat(source)), Lum(backdrop));
		}
		else if (mode == 14)
		{
			// Color
			return SetLum(source, Lum(backdrop));
		}
		else if (mode == 15)
		{
			// Luminosity
			return SetLum(backdrop, Lum(source));
		}
		else
		{
			return 0;
		}
	}
	
	
	struct PS_Input {
		float4 Position : SV_Position;
		float4 Color : TEXCOORD0;
		float4 Additional: TEXCOORD1;
		float3 ScreenNormalPosition : TEXCOORD2;
	};
	
	struct PS_Output {
		float4 color : SV_Target;
	};
	
	void main(in PS_Input PSInput, out PS_Output PSOutput)
	{
		float4 backdrop = SAMPLE2D(TEXTURE_0, input.Additional.zw);
		float4 source = SAMPLE2D(TEXTURE_1, input.Additional.xy) * input.Color.a;
	
		float3 backdropUnprem = backdrop.rgb / max(backdrop.a, 0.0001);
		float3 sourceUnprem = source.rgb / max(source.a, 0.0001);
		float4 result =
			(1 - backdrop.a) * source +
			source.a * backdrop.a * float4(
				saturate(BlendFunction(backdropUnprem, sourceUnprem, int(PRIM_PROPS_0.x))), 1) +
			(1 - source.a) * backdrop;
	
		PS_Output.color = result;
	}
	
	'''
Changed file "hummingbird/CohPathVS.hlsl":
	Total line: 57 (+1, -11)
	        '''
	        ...
	33 33   EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	34 34   */
	35 35   
	36 36   #include "../ShaderConstants.fxh"
	37 37   
	38    - struct VS_Input
	39    - {
	40    - 	float4 Position : POSITION;
	41    - };
	42    - 
	43    - struct PS_Input
	44    - {
	45    - 	float4 Position : SV_Position; // Why not position3
	46    - 	float2 ExtraParams : TEXCOORD0;
	47    - };
	48    - 
	   38 + struct VS_Input {
	   39 + 	float4 Position : HB_POSITION;
	   40 + };
	49    - float4 CoherentMul(float4 vec, float4x4 mat) {
	50    - 	return mul(vec, mat);
	51    - }
	52 41   
	   42 + struct PS_Input {
	   43 + 	float4 Position : SV_Position;
	   44 + 	float2 ExtraParams : TEXCOORD0;
	   45 + };
	53    - float4 CoherentPosition(float3 pos) {
	54    - 	return float4(pos, 1);
	55    - }
	56 46   
	   47 + void main(in VS_Input VSInput, out PS_Input PSInput)
	57    - void main(in VS_Input VSInput, out PS_Input PSOutput)
	58 48   {
	   49 + 	PSInput.Position = mul(float4(VSInput.Position.xy, 0.0f, 1.0f), TRANSFORM);
	59    - 	PSOutput.Position = CoherentMul(CoherentPosition(float3(VSInput.Position.xy, 0.0f)), TRANSFORM);
	60 50   
	61 51   	// Translate to -1..1 with perspective correction
	   52 + 	float w = PSInput.Position.w;
	   53 + 	PSInput.Position.x = PSInput.Position.x * 2 - w;
	   54 + 	PSInput.Position.y = (w - PSInput.Position.y) * 2 - w;
	62    - 	float w = PSOutput.Position.w;
	63    - 	PSOutput.Position.x = PSOutput.Position.x * 2 - w;
	64    - 	PSOutput.Position.y = (w - PSOutput.Position.y) * 2 - w;
	65 55   
	   56 + 	PSInput.ExtraParams = VSInput.Position.zw;
	66    - 	PSOutput.ExtraParams = VSInput.Position.zw;
	67 57   }
	        '''
Changed file "hummingbird/CohRenoirShaderVS.hlsl":
	Total line: 75 (+5, -6)
	        '''
	        ...
	33 33   EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	34 34   */
	35 35   
	36 36   #include "../ShaderConstants.fxh"
	37 37   
	   38 + #define USE_ADDITIONAL_COORDS 2.0
	   39 + 
	38 40   struct VS_Input {
	   41 + 	float4 Position : HB_POSITION;
	   42 + 	float4 Color : HB_COLOR;
	   43 + 	float4 Additional : HB_ADDITIONAL;
	39    - 	float3 Position : POSITION_3;
	40    - 	float4 Color : COLOR_4;
	41    - 	float4 Additional : ADDITIONAL;
	42 44   };
	43 45   
	44 46   struct PS_Input {
	45 47   	float4 Position : SV_Position;
	46    - 	float4 Color : TEXCOORD0;
	47    - 	float4 Additional: TEXCOORD1;
	   48 + 	float4 Color : TEXCOORD0;
	   49 + 	float4 Additional: TEXCOORD1;
	   50 + 	float3 ScreenNormalPosition : TEXCOORD2;
	48    - 	float3 ScreenNormalPosition : TEXCOORD2;
	49    - 	float4 VaryingParam0 : TEXCOORD3;
	50    - 	float4 VaryingParam1 : TEXCOORD4;
	51    - };
	52    - 
	   51 + 	float4 VaryingParam0 : TEXCOORD3;
	   52 + 	float4 VaryingParam1 : TEXCOORD4;
	   53 + };
	53    - float4 CoherentMul(float4 vec, float4x4 mat) {
	54    - 	return mul(vec, mat);
	55    - }
	56 54   
	   55 + void main(in VS_Input VSInput, out PS_Input PSInput) {
	57    - float4 CoherentPosition(float3 pos) {
	   56 + 	PSInput.Position = mul(VSInput.Position, TRANSFORM);
	   57 + 	PSInput.ScreenNormalPosition = VSInput.Position.xyz;
	58    - 	return float4(pos, 1);
	59    - }
	60 58   
	   59 + 	float4 coords = VSInput.Position;
	   60 + 	if (VSInput.Additional.z == USE_ADDITIONAL_COORDS) {
	61    - void main(in VS_Input VSInput, out PS_Input PSInput) {
	   61 + 		coords = float4(VSInput.Additional.xy, 0, 1);
	   62 + 	}
	62    - 	PSInput.Position = CoherentMul(CoherentPosition(VSInput.Position), TRANSFORM);
	63    - 	PSInput.ScreenNormalPosition = VSInput.Position;
	64 63   
	   64 + 	PSInput.VaryingParam0 = mul(coords, COORD_TRANSFORM);
	65    - 	PSInput.VaryingParam0 = CoherentMul(float4(VSInput.Position, 1), COORD_TRANSFORM);
	66 65   	PSInput.VaryingParam1.x = VSInput.Position.x * RENOIR_SHADER_VS_PROPS_0.x + RENOIR_SHADER_VS_PROPS_0.z;
	67 66   	PSInput.VaryingParam1.y = VSInput.Position.y * RENOIR_SHADER_VS_PROPS_0.y + RENOIR_SHADER_VS_PROPS_0.w;
	68 67   
	69 68   	// Translate to -1..1 with perspective correction
	70 69   	float w = PSInput.Position.w;
	        ...
	        '''
Changed file "hummingbird/CohShadeGeometry.ihlsl":
	Total line: 90 (+6, -105)
	          '''
	          ...
	 31  31   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	 32  32   ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	 33  33   EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 34  34   */
	 35  35   
	 36     - #define SAMPLE2D(tex, uv) tex.Sample(TextureSampler0, uv)
	 37     - #define SAMPLE2D_LOD(tex, uv) tex.Sample(TextureSampler0, uv.xy)
	 38     - #define COH_A8_SAMPLE_MASK .r
	 39     - 
	 40     - void ShadeGeometry(in PS_Input input, inout float4 outColor, inout float alpha)
	 41     - {
	 42     - 	// Rect/stroke rect
	 43     - 	if(SHADER_TYPE == 0)
	 44     - 	{
	 45     - 		alpha = min(1.0, input.Additional.z * input.Additional.w);
	 46     - 	}
	 47     - 	// Circle / Rounded rect
	 48     - 	else if (SHADER_TYPE == 1)
	 49     - 	{
	 50     - 		const float2 posPixels = input.ScreenNormalPosition.xy;
	 51     - 		const float distance2edge = length(posPixels - input.Additional.xy) - input.Additional.z;
	 52     - 		alpha = clamp(0.5 - distance2edge, 0, 1);
	 53     - 	}
	 54     - 	// Stroke Circle / Rounded rect
	 55     - 	else if (SHADER_TYPE == 2)
	 56     - 	{
	 57     - 		const float2 posPixels = input.ScreenNormalPosition.xy;
	 58     - 		const float de = length(posPixels - input.Additional.xy);
	 59     - 		const float distance2OuterEdge = de - (input.Additional.z + input.Additional.w / 2);
	 60     - 		const float distance2InnerEdge = de - (input.Additional.z - input.Additional.w / 2);
	 61     - 		alpha = clamp(0.5 - distance2OuterEdge, 0, 1);
	 62     - 		alpha *= 1 - clamp(0.5 - distance2InnerEdge, 0, 1);
	 63     - 	}
	 64     - 	// Image
	 65     - 	else if (SHADER_TYPE == 3)
	 66     - 	{
	 67     - 		outColor = SAMPLE2D(TEXTURE_0, input.Additional.xy);
	 68     - 		alpha = input.Color.a * saturate(input.Additional.z);
	 69     - 	}
	 70     - 
	 71     - 	// Ellipse
	 72     - 	else if (SHADER_TYPE == 4)
	 73     - 	{
	 74     - 		const float2 offset = (input.ScreenNormalPosition.xy - input.Additional.xy) * rcp(input.Additional.zw);
	 75     - 		const float test = dot(offset, offset) - 1.0;
	 76     - 		const float2 dudx = ddx(offset);
	 77     - 		const float2 dudy = ddy(offset);
	 78     - 		const float2 gradient = float2(2.0 * offset.x * dudx.x + 2.0 * offset.y * dudx.y,
	 79     - 										2.0 * offset.x * dudy.x + 2.0 * offset.y * dudy.y);
	 80     - 		const float grad_dot = max(dot(gradient, gradient), 1.0e-4);
	 81     - 		const float invlen = rsqrt(grad_dot);
	 82     - 
	 83     - 		alpha = saturate(0.5 - test * invlen);
	 84     - 	}
	 85     - 
	 86     - 	// Stroke Ellipse
	 87     - 	else if (SHADER_TYPE == 5)
	 88     - 	{
	 89     - 		float2 offset = (input.ScreenNormalPosition.xy - input.Additional.xy) * rcp(input.Additional.zw + (PRIM_PROPS_0.x / 2.0));
	 90     - 		float test = dot(offset, offset) - 1.0;
	 91     - 		float2 dudx = ddx(offset);
	 92     - 		float2 dudy = ddy(offset);
	 93     - 		float2 gradient = float2(2.0 * offset.x * dudx.x + 2.0 * offset.y * dudx.y,
	 94     - 								2.0 * offset.x * dudy.x + 2.0 * offset.y * dudy.y);
	 95     - 		float grad_dot = max(dot(gradient, gradient), 1.0e-4);
	 96     - 		float invlen = rsqrt(grad_dot);
	 97     - 
	 98     - 		alpha = saturate(0.5 - test * invlen);
	 99     - 
	100     - 		offset = (input.ScreenNormalPosition.xy - input.Additional.xy) * rcp((input.Additional.zw - (PRIM_PROPS_0.x / 2.0)));
	101     - 		test = dot(offset, offset) - 1.0;
	102     - 		dudx = ddx(offset);
	103     - 		dudy = ddy(offset);
	104     - 		gradient = float2(2.0 * offset.x * dudx.x + 2.0 * offset.y * dudx.y,
	105     - 						2.0 * offset.x * dudy.x + 2.0 * offset.y * dudy.y);
	106     - 		grad_dot = max(dot(gradient, gradient), 1.0e-4);
	107     - 		invlen = rsqrt(grad_dot);
	108     - 
	109     - 		alpha *= saturate(0.5 + test * invlen);
	110     - 	}
	111     - 
	112     - 	// Blur
	113     - 	else if (SHADER_TYPE == 6)
	114     - 	{
	115     - 		outColor = float4(0, 0, 0, 0);
	116     - #if !defined(__DX9__)
	117     - 		const uint stepsCount = uint(PRIM_PROPS_0.x);
	118     - 		for (uint i = 0; i < stepsCount; ++i) {
	119     - #else
	120     - 		for (int i = 0; i < PRIM_PROPS_0.x; ++i) {
	121     - #endif
	122     - 			float coeff = COEFFICIENTS[i / 4][i % 4];
	     36 + // Keep in sync w/ SDFGenerator
	     37 + #define DISTANCE_FIELD_MULTIPLIER 7.96875f
	     38 + #define DISTANCE_FIELD_MULTIPLIER_DIV2 3.984375f
	     39 + #define DISTANCE_FIELD_THRESHOLD 0.50196078431f
	     40 + 
	     41 + #define SHOW_DF 0
	123     - 			float2 offset;
	124     - 			offset.x = PIXEL_OFFSETS[(i*2) / 4][(i*2) % 4];
	125     - 			offset.y = PIXEL_OFFSETS[(i*2 + 1) / 4][(i*2 + 1) % 4];
	126     - 			
	127     - 			//float coeff = COEFFICIENTS[i];
	128     - 			//float2 offset = PIXEL_OFFSETS[i];
	129  42   
	130     - 			outColor += coeff
	131     - 				* (SAMPLE2D_LOD(TEXTURE_0, float4(input.Additional.xy + offset, 0, 0))
	132     - 				+ SAMPLE2D_LOD(TEXTURE_0, float4(input.Additional.xy - offset, 0, 0)));
	133     - 		}
	     43 + #define SAMPLE2D(tex, uv) tex.Sample(TextureSampler0, uv)
	     44 + #define COH_A8_SAMPLE_MASK .r
	134     - 		alpha = input.Color.a;
	135     - 	}
	136  45   
	     46 + float GetLuminance(float3 color)
	137     - 	// Image with color matrix
	138     - 	else if (SHADER_TYPE == 7)
	     47 + {
	139     - 	{
	140     - 		float4 baseColor = SAMPLE2D(TEXTURE_0, input.Additional.xy);
	     48 + 	return 0.2126f * color.r + 0.7152f * color.g + 0.0722f * color.b;
	     49 + }
	141     - 		float nonZeroAlpha = max(baseColor.a, 0.00001);
	142     - 		baseColor = float4(baseColor.rgb / nonZeroAlpha, nonZeroAlpha);
	143  50   
	     51 + void ShadeGeometry(in PS_Input input, inout float4 outColor, inout float alpha)
	144     - 		// TODO: Rename the members of the constant buffer so they are not weird for non-blurs
	145     - 		outColor.r = dot(baseColor, COEFFICIENTS[0]);
	     52 + {
	     53 + 	// Rect/stroke rect
	     54 + 	if (SHADER_TYPE == 0)
	     55 + 	{
	     56 + 		alpha = min(1.0, input.Additional.z * input.Additional.w);
	     57 + 	}
	     58 + 	// Image
	     59 + 	else if (SHADER_TYPE == 3)
	     60 + 	{
	     61 + 		outColor = SAMPLE2D(TEXTURE_0, input.Additional.xy);
	146     - 		outColor.g = dot(baseColor, COEFFICIENTS[1]);
	147     - 		outColor.b = dot(baseColor, COEFFICIENTS[2]);
	148     - 		outColor.a = dot(baseColor, PIXEL_OFFSETS[0]);
	149     - 		outColor += PIXEL_OFFSETS[1];
	150     - 
	151     - 		//outColor.r = dot(baseColor, float4(COEFFICIENTS[0], COEFFICIENTS[1], COEFFICIENTS[2], COEFFICIENTS[3]));
	152     - 		//outColor.g = dot(baseColor, float4(COEFFICIENTS[4], COEFFICIENTS[5], COEFFICIENTS[6], COEFFICIENTS[7]));
	153     - 		//outColor.b = dot(baseColor, float4(COEFFICIENTS[8], COEFFICIENTS[9], COEFFICIENTS[10], COEFFICIENTS[11]));
	154     - 		//outColor.a = dot(baseColor, float4(PIXEL_OFFSETS[0].x, PIXEL_OFFSETS[0].y, PIXEL_OFFSETS[1].x, PIXEL_OFFSETS[1].y));
	155     - 		//outColor += float4(PIXEL_OFFSETS[2].x, PIXEL_OFFSETS[2].y, PIXEL_OFFSETS[3].x, PIXEL_OFFSETS[3].y);
	156     - 
	     62 + 		alpha = input.Color.a * saturate(input.Additional.z);
	157     - 		alpha = outColor.a * input.Color.a;
	158     - 		outColor.a = 1;
	159  63   	}
	160     - 	// YUV2RGB (9) YUVA2RGB (12)
	     64 + 	else if (SHADER_TYPE == 17)
	161     - 	else if (SHADER_TYPE == 9 || SHADER_TYPE == 12)
	162  65   	{
	163     - 		float3 YCbCr;
	164     - 		YCbCr.x = SAMPLE2D(TEXTURE_0, input.Additional.xy) COH_A8_SAMPLE_MASK;
	165     - 		YCbCr.y = SAMPLE2D(TEXTURE_1, input.Additional.xy) COH_A8_SAMPLE_MASK;
	     66 + 		// Raster text
	166     - 		YCbCr.z = SAMPLE2D(TEXTURE_2, input.Additional.xy) COH_A8_SAMPLE_MASK;
	167  67   
	     68 + 		float dfValue = SAMPLE2D(TEXTURE_1, input.Additional.xy) COH_A8_SAMPLE_MASK;
	     69 + 		const float lum = GetLuminance(input.Color.xyz);
	168     - 		YCbCr -= float3(0.0625, 0.5, 0.5);
	     70 + 		outColor = input.Color * pow(dfValue, 1.45f - lum);
	     71 + 	}
	     72 + 	else if (SHADER_TYPE == 18)
	     73 + 	{
	     74 + 		// SDF Text
	169     - 		float3x3 yuv2rgb = float3x3(float3(1.164, 0, 1.596), float3(1.164, -0.391, -0.813), float3(1.164, 2.018, 0));
	170     - 		float3 rgb = mul(yuv2rgb, YCbCr);
	171     - 
	172     - 		alpha = input.Color.a;
	173     - 		outColor = float4(rgb, 1.0f);
	174  75   
	175     - 		if (SHADER_TYPE == 12)
	176     - 		{
	     76 + 		float dfValue = SAMPLE2D(TEXTURE_2, input.Additional.xy) COH_A8_SAMPLE_MASK;
	177     - 			float a = SAMPLE2D(TEXTURE_3, input.Additional.xy) COH_A8_SAMPLE_MASK;
	     77 + 	#if SHOW_DF
	     78 + 		outColor = float4(dfValue.xxx, 1);
	     79 + 		return;
	     80 + 	#endif
	     81 + 		// Values should be in [-4, 4]
	     82 + 		dfValue = (dfValue * DISTANCE_FIELD_MULTIPLIER) - DISTANCE_FIELD_MULTIPLIER_DIV2;
	     83 + 
	     84 + 		dfValue = smoothstep(-DISTANCE_FIELD_THRESHOLD / PRIM_PROPS_0.x, DISTANCE_FIELD_THRESHOLD / PRIM_PROPS_0.x, dfValue);
	     85 + 
	     86 + 		const float lum = GetLuminance(input.Color.xyz);
	     87 + 		outColor = input.Color * pow(dfValue, 1.45f - lum);
	178     - 			alpha *= a;
	179     - 		}
	180     - 	}
	181     - 	// Hairline
	182     - 	else if(SHADER_TYPE == 11)
	183     - 	{
	184     - 		const float3 posPixels = float3(input.ScreenNormalPosition.xy, 1);
	185     - 		const float distance2line = abs(dot(input.Additional.xyz, posPixels));
	186     - 		alpha = 1 - saturate(distance2line);
	187  88   	}
	188  89   }
	189  90   
	          '''
Added file "hummingbird/CohShadeGeometryRare.ihlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	#define SHOW_DF 0
	
	#define SAMPLE2D(tex, uv) tex.Sample(TextureSampler0, uv)
	#define SAMPLE2D_LOD(tex, uv) tex.Sample(TextureSampler0, uv.xy)
	#define COH_A8_SAMPLE_MASK .r
	
	void ShadeGeometry(in PS_Input input, inout float4 outColor, inout float alpha)
	{
		// Circle / Rounded rect
		if (SHADER_TYPE == 1)
		{
			const float2 posPixels = input.ScreenNormalPosition.xy;
			const float distance2edge = length(posPixels - input.Additional.xy) - input.Additional.z;
			alpha = clamp(0.5 - distance2edge, 0, 1);
		}
		// Stroke Circle / Rounded rect
		else if (SHADER_TYPE == 2)
		{
			const float2 posPixels = input.ScreenNormalPosition.xy;
			const float de = length(posPixels - input.Additional.xy);
			const float distance2OuterEdge = de - (input.Additional.z + input.Additional.w / 2);
			const float distance2InnerEdge = de - (input.Additional.z - input.Additional.w / 2);
			alpha = clamp(0.5 - distance2OuterEdge, 0, 1);
			alpha *= 1 - clamp(0.5 - distance2InnerEdge, 0, 1);
		}
		// Ellipse
		else if (SHADER_TYPE == 4)
		{
			const float2 offset = (input.ScreenNormalPosition.xy - input.Additional.xy) * rcp(input.Additional.zw);
			const float test = dot(offset, offset) - 1.0;
			const float2 dudx = ddx(offset);
			const float2 dudy = ddy(offset);
			const float2 gradient = float2(2.0 * offset.x * dudx.x + 2.0 * offset.y * dudx.y,
											2.0 * offset.x * dudy.x + 2.0 * offset.y * dudy.y);
			const float grad_dot = max(dot(gradient, gradient), 1.0e-4);
			const float invlen = rsqrt(grad_dot);
	
			alpha = saturate(0.5 - test * invlen);
		}
		// Stroke Ellipse
		else if (SHADER_TYPE == 5)
		{
			float2 offset = (input.ScreenNormalPosition.xy - input.Additional.xy) * rcp(input.Additional.zw + (PRIM_PROPS_0.x / 2.0));
			float test = dot(offset, offset) - 1.0;
			float2 dudx = ddx(offset);
			float2 dudy = ddy(offset);
			float2 gradient = float2(2.0 * offset.x * dudx.x + 2.0 * offset.y * dudx.y,
									2.0 * offset.x * dudy.x + 2.0 * offset.y * dudy.y);
			float grad_dot = max(dot(gradient, gradient), 1.0e-4);
			float invlen = rsqrt(grad_dot);
	
			alpha = saturate(0.5 - test * invlen);
	
			offset = (input.ScreenNormalPosition.xy - input.Additional.xy) * rcp((input.Additional.zw - (PRIM_PROPS_0.x / 2.0)));
			test = dot(offset, offset) - 1.0;
			dudx = ddx(offset);
			dudy = ddy(offset);
			gradient = float2(2.0 * offset.x * dudx.x + 2.0 * offset.y * dudx.y,
							2.0 * offset.x * dudy.x + 2.0 * offset.y * dudy.y);
			grad_dot = max(dot(gradient, gradient), 1.0e-4);
			invlen = rsqrt(grad_dot);
	
			alpha *= saturate(0.5 + test * invlen);
		}
		// Blur
		else if (SHADER_TYPE == 6)
		{
			outColor = float4(0, 0, 0, 0);
			for (int i = 0; i < PRIM_PROPS_0.x; ++i) {
				float coeff = COEFFICIENTS[i / 4][i % 4];
				float2 offset;
				offset.x = PIXEL_OFFSETS[(i*2) / 4][(i*2) % 4];
				offset.y = PIXEL_OFFSETS[(i*2 + 1) / 4][(i*2 + 1) % 4];
				outColor += coeff
					* (SAMPLE2D_LOD(TEXTURE_0, float4(input.Additional.xy + offset, 0, 0))
					+ SAMPLE2D_LOD(TEXTURE_0, float4(input.Additional.xy - offset, 0, 0)));
			}
			alpha = input.Color.a;
		}
		// Image with color matrix
		else if (SHADER_TYPE == 7)
		{
			float4 baseColor = SAMPLE2D(TEXTURE_0, input.Additional.xy);
			float nonZeroAlpha = max(baseColor.a, 0.00001);
			baseColor = float4(baseColor.rgb / nonZeroAlpha, nonZeroAlpha);
	
			// TODO: Rename the members of the constant buffer so they are not weird for non-blurs
			outColor.r = dot(baseColor, COEFFICIENTS[0]);
			outColor.g = dot(baseColor, COEFFICIENTS[1]);
			outColor.b = dot(baseColor, COEFFICIENTS[2]);
			outColor.a = dot(baseColor, PIXEL_OFFSETS[0]);
			outColor += PIXEL_OFFSETS[1];
	
			alpha = outColor.a * input.Color.a;
			outColor.a = 1;
		}
		// YUV2RGB (9) YUVA2RGB (12)
		else if (SHADER_TYPE == 9 || SHADER_TYPE == 12)
		{
			float3 YCbCr;
			YCbCr.x = SAMPLE2D(TEXTURE_0, input.Additional.xy) COH_A8_SAMPLE_MASK;
			YCbCr.y = SAMPLE2D(TEXTURE_1, input.Additional.xy) COH_A8_SAMPLE_MASK;
			YCbCr.z = SAMPLE2D(TEXTURE_2, input.Additional.xy) COH_A8_SAMPLE_MASK;
	
			YCbCr -= float3(0.0625, 0.5, 0.5);
			float3x3 yuv2rgb = float3x3(float3(1.164, 0, 1.596), float3(1.164, -0.391, -0.813), float3(1.164, 2.018, 0));
			float3 rgb = mul(yuv2rgb, YCbCr);
	
			alpha = input.Color.a;
			outColor = float4(rgb, 1.0f);
	
			if (SHADER_TYPE == 12)
			{
				float a = SAMPLE2D(TEXTURE_3, input.Additional.xy) COH_A8_SAMPLE_MASK;
				alpha *= a;
			}
		}
		// Hairline
		else if(SHADER_TYPE == 11)
		{
			const float3 posPixels = float3(input.ScreenNormalPosition.xy, 1);
			const float distance2line = abs(dot(input.Additional.xyz, posPixels));
			alpha = 1 - saturate(distance2line);
		}
		else if (SHADER_TYPE == 19)
		{
			// SDF Text (outline)
			float dfValue = SAMPLE2D(TEXTURE_0, input.Additional.xy) COH_A8_SAMPLE_MASK;
		#if SHOW_DF
			outColor = float4(dfValue.xxx, 1);
			return;
		#endif
			const float scale = sqrt(PRIM_PROPS_0.y * 0.5);
	
			const float bias = 0.5 * scale - 0.9;
			const float outlineWidth = PRIM_PROPS_0.z / PRIM_PROPS_0.y * 0.5 * scale;
			dfValue *= scale;
	
			float4 c = lerp(PRIM_PROPS_1, input.Color, saturate(dfValue - (bias + outlineWidth)));
	
			c *= saturate(dfValue - max(0, bias - outlineWidth));
			outColor = c;
		}
	}
	
	'''
Added file "hummingbird/CohShadeGeometryStencil.ihlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	// Keep in sync w/ SDFGenerator
	#define DISTANCE_FIELD_MULTIPLIER 7.96875f
	#define DISTANCE_FIELD_MULTIPLIER_DIV2 3.984375f
	#define DISTANCE_FIELD_THRESHOLD 0.50196078431f
	#define SHOW_DF 0
	
	#define SAMPLE2D(tex, uv) tex.Sample(TextureSampler0, uv)
	#define COH_A8_SAMPLE_MASK .r
	
	float GetLuminance(float3 color)
	{
		return 0.2126f * color.r + 0.7152f * color.g + 0.0722f * color.b;
	}
	
	void ShadeGeometry(in PS_Input input, inout float4 outColor, inout float alpha)
	{
		// Rect/stroke rect
		if(SHADER_TYPE == 0)
		{
			alpha = min(1.0, input.Additional.z * input.Additional.w);
		}
		// Image
		else if (SHADER_TYPE == 3)
		{
			outColor = SAMPLE2D(TEXTURE_0, input.Additional.xy);
			alpha = input.Color.a * saturate(input.Additional.z);
		}
		else if (SHADER_TYPE == 17)
		{
			// Raster text
	
			float dfValue = SAMPLE2D(TEXTURE_1, input.Additional.xy) COH_A8_SAMPLE_MASK;
			const float lum = GetLuminance(input.Color.xyz);
			outColor = input.Color * pow(dfValue, 1.45f - lum);
		}
		else if (SHADER_TYPE == 18)
		{
			// SDF Text
	
			float dfValue = SAMPLE2D(TEXTURE_2, input.Additional.xy) COH_A8_SAMPLE_MASK;
		#if SHOW_DF
			outColor = float4(dfValue.xxx, 1);
			return;
		#endif
			// Values should be in [-4, 4]
			dfValue = (dfValue * DISTANCE_FIELD_MULTIPLIER) - DISTANCE_FIELD_MULTIPLIER_DIV2;
	
			dfValue = smoothstep(-DISTANCE_FIELD_THRESHOLD / PRIM_PROPS_0.x, DISTANCE_FIELD_THRESHOLD / PRIM_PROPS_0.x, dfValue);
	
			const float lum = GetLuminance(input.Color.xyz);
			outColor = input.Color * pow(dfValue, 1.45f - lum);
		}
	}
	
	'''
Changed file "hummingbird/CohStandardPS.hlsl":
	Total line: 58 (+0, -0)
	        '''
	        ...
	34 34   */
	35 35   
	36 36   #include "../ShaderConstants.fxh"
	37 37   
	38 38   struct PS_Input {
	   39 + 	float4 Position : SV_Position;
	39    - 	float4 Position : SV_Position; // Why not position3
	40 40   	float4 Color : TEXCOORD0;
	41 41   	float4 Additional: TEXCOORD1;
	42 42   	float3 ScreenNormalPosition : TEXCOORD2;
	43 43   };
	44 44   
	        ...
	48 48   
	49 49   #include "CohShadeGeometry.ihlsl"
	50 50   
	51 51   void main(in PS_Input PSInput, out PS_Output PSOutput)
	52 52   {
	   53 + 	float alpha = 1.0f;
	53    - 	float alpha = 0.1f;
	54 54   	float4 outColor = PSInput.Color;
	55 55   
	56 56   	ShadeGeometry(PSInput, outColor, alpha);
	57 57   	PSOutput.color = outColor * alpha;
	58 58   }
	        '''
Added file "hummingbird/CohStandardRarePS.hlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	#include "../ShaderConstants.fxh"
	
	struct PS_Input {
		float4 Position : SV_Position;
		float4 Color : TEXCOORD0;
		float4 Additional: TEXCOORD1;
		float3 ScreenNormalPosition : TEXCOORD2;
	};
	
	struct PS_Output {
		float4 color : SV_Target;
	};
	
	#include "CohShadeGeometryRare.ihlsl"
	
	void main(in PS_Input PSInput, out PS_Output PSOutput)
	{
		float alpha = 1.0f;
		float4 outColor = PSInput.Color;
	
		ShadeGeometry(PSInput, outColor, alpha);
		PSOutput.color = outColor * alpha;
	}
	'''
Changed file "hummingbird/CohStandardVS.hlsl":
	Total line: 64 (+3, -12)
	        '''
	        ...
	35 35   */
	36 36   
	37 37   #include "../ShaderConstants.fxh"
	38 38   
	39 39   struct VS_Input {
	40    - 	float3 Position : POSITION_3;
	41    - 	float4 Color : COLOR_4;
	42    - 	float4 Additional : ADDITIONAL;
	43    - };
	44    - 
	45    - struct PS_Input {
	46    - 	float4 Position : SV_Position; // Why not position3
	47    - 	float4 Color : TEXCOORD0;
	48    - 	float4 Additional: TEXCOORD1;
	49    - 	float3 ScreenNormalPosition : TEXCOORD2;
	50    - };
	   40 + 	float4 Position : HB_POSITION;
	   41 + 	float4 Color : HB_COLOR;
	   42 + 	float4 Additional : HB_ADDITIONAL;
	   43 + };
	51    - 
	52    - float4 CoherentMul(float4 vec, float4x4 mat) {
	53    -     return mul(vec, mat);
	54    - }
	55 44   
	   45 + struct PS_Input {
	   46 + 	float4 Position : SV_Position;
	   47 + 	float4 Color : TEXCOORD0;
	   48 + 	float4 Additional: TEXCOORD1;
	   49 + 	float3 ScreenNormalPosition : TEXCOORD2;
	   50 + };
	56    - float4 CoherentPosition(float3 pos) {
	57    -     return float4(pos, 1);
	58    - }
	59 51   
	60 52   void main(in VS_Input VSInput, out PS_Input PSInput) {
	61    - 	PSInput.Position = CoherentMul(CoherentPosition(VSInput.Position),
	   53 + 	PSInput.Position = mul(VSInput.Position, TRANSFORM);
	62    - 								  TRANSFORM);
	63 54   	PSInput.ScreenNormalPosition = VSInput.Position;
	64 55   
	65 56   	// Translate to -1..1 with perspective correction
	66 57   	float w = PSInput.Position.w;
	67 58   	PSInput.Position.x = PSInput.Position.x * 2 - w;
	        ...
	        '''
Changed file "hummingbird/CohStencilPS.hlsl":
	Total line: 61 (+0, -0)
	        '''
	        ...
	40 40   	float4 Color : TEXCOORD0;
	41 41   	float4 Additional: TEXCOORD1;
	42 42   	float3 ScreenNormalPosition : TEXCOORD2;
	43 43   };
	44 44   
	   45 + #include "CohShadeGeometryStencil.ihlsl"
	45    - #include "CohShadeGeometry.ihlsl"
	46 46   
	47 47   void main(in PS_Input PSInput) {
	48 48   	float alpha = 1.0f;
	49 49   	float4 outColor = PSInput.Color;
	50 50   
	        ...
	        '''
Added file "hummingbird/CohStencilRarePS.hlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	#include "../ShaderConstants.fxh"
	
	struct PS_Input {
		float4 Position : SV_Position;
		float4 Color : TEXCOORD0;
		float4 Additional: TEXCOORD1;
		float3 ScreenNormalPosition : TEXCOORD2;
	};
	
	#include "CohShadeGeometryRare.ihlsl"
	
	void main(in PS_Input PSInput) {
		float alpha = 1.0f;
		float4 outColor = PSInput.Color;
	
		ShadeGeometry(PSInput, outColor, alpha);
	
		// Image
		if (SHADER_TYPE == 3) {
			alpha = outColor.a;
		}
	
		if (alpha < 0.00390625f) {
			discard;
		}
	}
	'''
Removed file "hummingbird/CohTextPS.hlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	#define SAMPLE2D(tex, uv) tex.Sample(TextureSampler0, uv)
	#define SAMPLE2D_LOD(tex, uv) tex.Sample(TextureSampler0, uv.xy)
	#define COH_A8_SAMPLE_MASK .r
	
	#include "../ShaderConstants.fxh"
	
	// Keep in sync w/ SDFGenerator
	#define DISTANCE_FIELD_MULTIPLIER 7.96875f
	#define DISTANCE_FIELD_MULTIPLIER_DIV2 3.984375f
	#define DISTANCE_FIELD_THRESHOLD 0.50196078431f
	
	#define SHOW_DF 0
	
	struct PS_Input {
		float4 Position : SV_Position;
		float4 Color : VS_SEMANTIC_COLOR;
		float4 Additional: TEXCOORD0;
		float3 ScreenNormalPosition : TEXCOORD1;
	};
	
	struct PS_Output {
		float4 color : SV_Target;
	};
	
	float GetLuminance(float3 color) {
		return 0.2126f * color.r + 0.7152f * color.g + 0.0722f * color.b;
	}
	
	void main(in PS_Input input, out PS_Output PSOutput) {
		float dfValue = SAMPLE2D(TEXTURE_0, input.Additional.xy) COH_A8_SAMPLE_MASK;
	#if SHOW_DF
		PSOutput.color = float4(dfValue.xxx, 1);
	#endif
		if (SHADER_TYPE == 1) {
			// Values should be in [-4, 4]
			dfValue = (dfValue * DISTANCE_FIELD_MULTIPLIER) - DISTANCE_FIELD_MULTIPLIER_DIV2;
	
			dfValue = smoothstep(-DISTANCE_FIELD_THRESHOLD / PRIM_PROPS_0.x, DISTANCE_FIELD_THRESHOLD / PRIM_PROPS_0.x, dfValue);
		} else if (SHADER_TYPE == 2) {
			const float scale = sqrt(PRIM_PROPS_0.y * 0.5);
	
			const float bias = 0.5 * scale - 0.9;
			const float outlineWidth = PRIM_PROPS_0.z / PRIM_PROPS_0.y * 0.5 * scale;
			dfValue *= scale;
	
			float4 c = lerp(PRIM_PROPS_1, input.Color, saturate(dfValue - (bias + outlineWidth)));
	
			c *= saturate(dfValue - max(0, bias - outlineWidth));
			PSOutput.color = c;
		}
	
		const float lum = GetLuminance(input.Color.xyz);
	
		// dfValue is in the [0,1] range here so warning X3571 can be safely ignored
		PSOutput.color = input.Color * pow(dfValue, 1.45f - lum);
	}
	'''
Removed file "hummingbird/CohTextVS.hlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	#include "../ShaderConstants.fxh"
	
	struct VS_Input {
		float3 Position : POSITION_3;
		float4 Color : COLOR_4;
		float4 Additional : ADDITIONAL;
	};
	
	struct PS_Input {
		float4 Position : SV_Position; // Why not position3
		float4 Color : VS_SEMANTIC_COLOR;
		float4 Additional: TEXCOORD0;
		float3 ScreenNormalPosition : TEXCOORD1;
	};
	
	float4 CoherentMul(float4 vec, float4x4 mat) {
	    return mul(vec, mat);
	}
	
	float4 CoherentPosition(float3 pos) {
	    return float4(pos, 1);
	}
	
	void main(in VS_Input VSInput, out PS_Input PSInput) {
		PSInput.Position = CoherentMul(CoherentPosition(VSInput.Position), TRANSFORM);
		PSInput.ScreenNormalPosition = VSInput.Position;
	
		// Translate to -1..1 with perspective correction
		float w = PSInput.Position.w;
		PSInput.Position.x = PSInput.Position.x * 2 - w;
		PSInput.Position.y = (w - PSInput.Position.y) * 2 - w;
	
		PSInput.Color = VSInput.Color;
		PSInput.Additional = VSInput.Additional;
	}
	'''