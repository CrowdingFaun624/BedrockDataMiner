Difference of "shaders" between "1.5.3" and "1.6.0.1" (beta of "1.6.0").

Changed file "ShaderConstants.fxh":
	Total line: 258 (+71, -44)
	          '''
	          ...
	 40  40   	"CBV(b1, visibility=SHADER_VISIBILITY_PIXEL), " \
	 41  41   	"CBV(b2, visibility=SHADER_VISIBILITY_PIXEL), " \
	 42  42   	"CBV(b3, visibility=SHADER_VISIBILITY_PIXEL), " \
	 43  43   	"CBV(b4, visibility=SHADER_VISIBILITY_PIXEL), " \
	 44  44   	"CBV(b5, visibility=SHADER_VISIBILITY_PIXEL), " \
	     45 + 	"CBV(b6, visibility=SHADER_VISIBILITY_PIXEL), " \
	     46 + 	"CBV(b0, visibility=SHADER_VISIBILITY_VERTEX), " \
	     47 + 	"CBV(b1, visibility=SHADER_VISIBILITY_VERTEX), " \
	     48 + 	"CBV(b2, visibility=SHADER_VISIBILITY_VERTEX), " \
	     49 + 	"CBV(b3, visibility=SHADER_VISIBILITY_VERTEX), " \
	     50 + 	"CBV(b4, visibility=SHADER_VISIBILITY_VERTEX), " \
	     51 + 	"CBV(b5, visibility=SHADER_VISIBILITY_VERTEX), " \
	     52 + 	"CBV(b6, visibility=SHADER_VISIBILITY_VERTEX)"
	     53 + 
	     54 + // HLSL root signatures require SM 5.0 or higher.  We only use SM 5.0
	     55 + // or higher when the Feature Level is 11_0 or above.  Specifying a 
	     56 + // root signature when compiling for DX11 silently ignores the root
	     57 + // signature.
	     58 + #if (VERSION >= 0xb000) 
	     59 + #define ROOT_SIGNATURE [RootSignature(MinecraftRootSignature)]
	     60 + #else
	     61 + #define ROOT_SIGNATURE 
	     62 + #endif
	     63 + 
	     64 + #if (defined(USE_STEREO_TEXTURE_ARRAY) || defined(ARRAY_TEXTURE_0)) && (VERSION >= 0xa000)
	     65 + Texture2DArray TEXTURE_0 : register (t0);
	     66 + #else
	     67 + Texture2DMS<float4> TEXTURE_0_MS : register(t0);
	     68 + Texture2D TEXTURE_0 : register(t0);
	     69 + #endif
	     70 + 
	     71 + Texture2DMS<float4> TEXTURE_1_MS : register(t1);
	     72 + Texture2D TEXTURE_1 : register(t1);
	     73 + Texture2D TEXTURE_2 : register(t2);
	     74 + #ifndef NO_TEX_3
	     75 + Texture2D TEXTURE_3 : register(t3);
	     76 + sampler TextureSampler3 : register(s3);
	     77 + #endif
	     78 + 
	     79 + // Make sure this thing is actually getting bound
	     80 + sampler TextureSampler0 : register(s0);
	     81 + sampler TextureSampler1 : register(s1);
	     82 + sampler TextureSampler2 : register(s2);
	     83 + 
	     84 + #ifdef LOW_PRECISION
	     85 + #define lpfloat min16float
	     86 + #define lpfloat2 min16float2
	     87 + #define lpfloat4 min16float4
	     88 + #else
	     89 + #define lpfloat float
	     90 + #define lpfloat2 float2
	     91 + #define lpfloat4 float4
	     92 + #endif
	 45     - 	"CBV(b0, visibility=SHADER_VISIBILITY_VERTEX), " \
	 46     - 	"CBV(b1, visibility=SHADER_VISIBILITY_VERTEX), " \
	 47     - 	"CBV(b2, visibility=SHADER_VISIBILITY_VERTEX), " \
	 48     - 	"CBV(b3, visibility=SHADER_VISIBILITY_VERTEX), " \
	 49     - 	"CBV(b4, visibility=SHADER_VISIBILITY_VERTEX), " \
	 50     - 	"CBV(b5, visibility=SHADER_VISIBILITY_VERTEX)"
	 51  93   
	     94 + #if defined(MSAA_FRAMEBUFFER_ENABLED)
	 52     - // HLSL root signatures require SM 5.0 or higher.  We only use SM 5.0
	 53     - // or higher when the Feature Level is 11_0 or above.  Specifying a 
	     95 + #define TEXCOORD_0_FB_MSAA TEXCOORD_0_centroid
	     96 + #define TEXCOORD_1_FB_MSAA TEXCOORD_1_centroid
	     97 + #define TEXCOORD_2_FB_MSAA TEXCOORD_2_centroid
	     98 + #define TEXCOORD_3_FB_MSAA TEXCOORD_3_centroid
	 54     - // root signature when compiling for DX11 silently ignores the root
	 55     - // signature.
	 56     - #if (VERSION >= 0xb000) 
	 57     - #define ROOT_SIGNATURE [RootSignature(MinecraftRootSignature)]
	 58  99   #else
	    100 + #define TEXCOORD_0_FB_MSAA TEXCOORD_0
	    101 + #define TEXCOORD_1_FB_MSAA TEXCOORD_1
	    102 + #define TEXCOORD_2_FB_MSAA TEXCOORD_2
	    103 + #define TEXCOORD_3_FB_MSAA TEXCOORD_3
	 59     - #define ROOT_SIGNATURE 
	 60 104   #endif
	    105 + 
	 61 106   
	 62     - #if (defined(USE_STEREO_TEXTURE_ARRAY) || defined(ARRAY_TEXTURE_0)) && (VERSION >= 0xa000)
	    107 + cbuffer RenderChunkConstants : register(b0)
	 63     - Texture2DArray TEXTURE_0 : register (t0);
	    108 + {
	    109 +     float4 CHUNK_ORIGIN_AND_SCALE;
	    110 +     float RENDER_CHUNK_FOG_ALPHA;
	    111 + }
	    112 + 
	 64     - #else
	 65     - Texture2DMS<float4> TEXTURE_0_MS : register(t0);
	 66     - Texture2D TEXTURE_0 : register(t0);
	 67     - #endif
	 68 113   
	    114 + cbuffer EntityConstants
	    115 + {
	 69     - Texture2DMS<float4> TEXTURE_1_MS : register(t1);
	 70     - Texture2D TEXTURE_1 : register(t1);
	    116 +     float4 OVERLAY_COLOR;
	    117 +     float4 TILE_LIGHT_COLOR;
	    118 +     float4 CHANGE_COLOR;
	    119 +     float4 GLINT_COLOR;
	    120 +     float4 UV_ANIM;
	    121 +     float2 UV_OFFSET;
	    122 +     float2 UV_ROTATION;
	    123 +     float2 GLINT_UV_SCALE;
	    124 +     float4 MULTIPLICATIVE_TINT_CHANGE_COLOR;
	    125 + }
	 71     - Texture2D TEXTURE_2 : register(t2);
	 72     - #ifndef NO_TEX_3
	 73     - Texture2D TEXTURE_3 : register(t3);
	 74     - sampler TextureSampler3 : register(s3);
	 75     - #endif
	 76     - 
	 77     - // Make sure this thing is actually getting bound
	 78     - sampler TextureSampler0 : register(s0);
	 79     - sampler TextureSampler1 : register(s1);
	 80     - sampler TextureSampler2 : register(s2);
	 81 126   
	 82     - #ifdef LOW_PRECISION
	 83     - #define lpfloat min16float
	 84     - #define lpfloat2 min16float2
	    127 + cbuffer PerFrameConstants : register(b2)
	    128 + {
	    129 + 
	    130 +     float3 VIEW_POS;
	    131 +     float TIME;
	 85     - #define lpfloat4 min16float4
	 86     - #else
	 87     - #define lpfloat float
	 88     - #define lpfloat2 float2
	 89     - #define lpfloat4 float4
	 90     - #endif
	 91 132   
	 92     - #if defined(MSAA_FRAMEBUFFER_ENABLED)
	 93     - #define TEXCOORD_0_FB_MSAA TEXCOORD_0_centroid
	 94     - #define TEXCOORD_1_FB_MSAA TEXCOORD_1_centroid
	    133 +     float4 FOG_COLOR;
	    134 + 
	    135 +     float2 FOG_CONTROL;
	    136 + 
	    137 +     float RENDER_DISTANCE;
	    138 +     float FAR_CHUNKS_DISTANCE;
	    139 + }
	    140 + 
	 95     - #define TEXCOORD_2_FB_MSAA TEXCOORD_2_centroid
	 96     - #define TEXCOORD_3_FB_MSAA TEXCOORD_3_centroid
	 97     - #else
	 98     - #define TEXCOORD_0_FB_MSAA TEXCOORD_0
	 99     - #define TEXCOORD_1_FB_MSAA TEXCOORD_1
	100     - #define TEXCOORD_2_FB_MSAA TEXCOORD_2
	101     - #define TEXCOORD_3_FB_MSAA TEXCOORD_3
	102     - #endif
	103 141   
	    142 + #if !defined(INSTANCEDSTEREO)
	104 143   
	    144 + cbuffer WorldConstants : register(b1)
	105     - cbuffer RenderChunkConstants : register(b0)
	106 145   {
	    146 +     float4x4 WORLDVIEWPROJ;
	    147 +     float4x4 WORLD;
	    148 +     float4x4 WORLDVIEW;
	    149 +     float4x4 PROJ;
	107     -     float4 CHUNK_ORIGIN_AND_SCALE;
	108     -     float RENDER_CHUNK_FOG_ALPHA;
	109 150   }
	110 151   
	    152 + #else
	111 153   
	    154 + cbuffer WorldConstantsStereographic {
	112     - cbuffer EntityConstants
	113     - {
	    155 + 	float4x4 WORLDVIEWPROJ_STEREO[2];
	    156 + 	float4x4 WORLD_STEREO;
	    157 + 	float4x4 WORLDVIEW_STEREO[2];
	    158 + 	float4x4 PROJ_STEREO[2];
	114     -     float4 OVERLAY_COLOR;
	115     -     float4 TILE_LIGHT_COLOR;
	116     -     float4 CHANGE_COLOR;
	117     -     float4 GLINT_COLOR;
	    159 + }
	    160 + 
	    161 + #endif
	    162 + 
	    163 + cbuffer AnimationConstants {
	    164 + 	float4x4 BONES[8];
	118     -     float4 UV_ANIM;
	119     -     float2 UV_OFFSET;
	120     -     float2 UV_ROTATION;
	121     -     float2 GLINT_UV_SCALE;
	122     -     float4 MULTIPLICATIVE_TINT_CHANGE_COLOR;
	123 165   }
	124 166   
	    167 + cbuffer ShaderConstants : register(b3)
	125     - cbuffer PerFrameConstants : register(b2)
	126 168   {
	127     - 
	    169 +     float4 CURRENT_COLOR;
	    170 +     float4 DARKEN;
	128     -     float3 VIEW_POS;
	129     -     float TIME;
	130     - 
	    171 +     float3 TEXTURE_DIMENSIONS;
	131     -     float4 FOG_COLOR;
	132     - 
	    172 +     float1 HUD_OPACITY;
	133     -     float2 FOG_CONTROL;
	134     - 
	    173 +     float4x4 UV_TRANSFORM;
	    174 + 	int MSAA_SAMPLECOUNT;
	135     -     float RENDER_DISTANCE;
	136     -     float FAR_CHUNKS_DISTANCE;
	137 175   }
	138     - 
	139 176   
	    177 + cbuffer WeatherConstants
	    178 + {
	    179 +     float4 POSITION_OFFSET;
	    180 +     float4 VELOCITY;
	    181 +     float4 ALPHA;
	    182 +     float4 VIEW_POSITION;
	140     - #if !defined(INSTANCEDSTEREO)
	141     - 
	142     - cbuffer WorldConstants : register(b1)
	143     - {
	    183 +     float4 SIZE_SCALE;
	    184 +     float4 FORWARD;
	    185 +     float4 UV_INFO;
	    186 +     float4 PARTICLE_BOX;
	144     -     float4x4 WORLDVIEWPROJ;
	145     -     float4x4 WORLD;
	146     -     float4x4 WORLDVIEW;
	147     -     float4x4 PROJ;
	148 187   }
	149     - 
	150     - #else
	151 188   
	    189 + cbuffer FlipbookTextureConstants
	152     - cbuffer WorldConstantsStereographic {
	153     - 	float4x4 WORLDVIEWPROJ_STEREO[2];
	    190 + {
	    191 +     float1 V_OFFSET;
	    192 +     float1 V_BLEND_OFFSET;
	154     - 	float4x4 WORLD_STEREO;
	155     - 	float4x4 WORLDVIEW_STEREO[2];
	156     - 	float4x4 PROJ_STEREO[2];
	157 193   }
	158     - 
	159     - #endif
	160 194   
	    195 + cbuffer EffectsConstants
	161     - cbuffer ShaderConstants : register(b3)
	162 196   {
	163     -     float4 CURRENT_COLOR;
	164     -     float4 DARKEN;
	165     -     float3 TEXTURE_DIMENSIONS;
	166     -     float1 HUD_OPACITY;
	    197 +     float2 EFFECT_UV_OFFSET;
	167     -     float4x4 UV_TRANSFORM;
	    198 + 
	    199 + 
	168     - 	int MSAA_SAMPLECOUNT;
	169 200   }
	170 201   
	    202 + cbuffer BannerConstants
	171     - cbuffer WeatherConstants
	172 203   {
	    204 +     float4 BANNER_COLORS[7];
	173     -     float4 POSITION_OFFSET;
	    205 +     float4 BANNER_UV_OFFSETS[7];
	174     -     float4 VELOCITY;
	    206 + }
	    207 + 
	    208 + cbuffer TextConstants
	    209 + {
	    210 +     float1 GLYPH_SMOOTH_RADIUS;
	    211 +     float1 GLYPH_CUTOFF;
	    212 +     float1 OUTLINE_CUTOFF;
	175     -     float4 ALPHA;
	176     -     float4 VIEW_POSITION;
	177     -     float4 SIZE_SCALE;
	178     -     float4 FORWARD;
	179     -     float4 UV_INFO;
	180     -     float4 PARTICLE_BOX;
	181     - }
	182     - 
	    213 +     float4 OUTLINE_COLOR;
	    214 +     float1 SHADOW_SMOOTH_RADIUS;
	    215 +     float4 SHADOW_COLOR;
	    216 +     float2 SHADOW_OFFSET;
	183     - cbuffer FlipbookTextureConstants
	184     - {
	185     -     float1 V_OFFSET;
	186     -     float1 V_BLEND_OFFSET;
	187 217   }
	188     - 
	    218 + cbuffer DebugConstants
	189     - cbuffer EffectsConstants
	190 219   {
	    220 +     float TEXTURE_ARRAY_INDEX_0;
	191     -     float2 EFFECT_UV_OFFSET;
	192     - 
	193     - 
	    221 + };
	194     - }
	195 222   
	    223 + cbuffer InterFrameConstants
	196     - cbuffer BannerConstants
	197 224   {
	    225 + 	// in secs. This is reset every 2 mins. so the range is [0, 120)
	    226 + 	// make sure your shader handles the case when it transitions from 120 to 0
	    227 +     float TOTAL_REAL_WORLD_TIME;
	    228 +     float4x4 CUBE_MAP_ROTATION;
	    229 + };
	198     -     float4 BANNER_COLORS[7];
	199     -     float4 BANNER_UV_OFFSETS[7];
	200     - }
	201 230   
	    231 + cbuffer PostProcessConstants {
	202     - cbuffer TextConstants
	    232 + 	int GaussianBlurSize;
	    233 + 	float DepthOfFieldNearEndDepth;
	    234 + 	float DepthOfFieldFarStartDepth;
	    235 + 	float DepthOfFieldFarEndDepth;
	    236 + };
	    237 + 
	    238 + cbuffer UITransformsConstants
	    239 + {
	    240 +     float4x4 TRANSFORM;
	    241 + };
	203     - {
	204     -     float1 GLYPH_SMOOTH_RADIUS;
	205     -     float1 GLYPH_CUTOFF;
	206     -     float1 OUTLINE_CUTOFF;
	207     -     float4 OUTLINE_COLOR;
	208     -     float1 SHADOW_SMOOTH_RADIUS;
	209     -     float4 SHADOW_COLOR;
	210     -     float2 SHADOW_OFFSET;
	211     - }
	    242 + 
	    243 + cbuffer UIStandardPrimitivePixelConstants
	212     - cbuffer DebugConstants
	213 244   {
	    245 +     int SHADER_TYPE;
	214     -     float TEXTURE_ARRAY_INDEX_0;
	215 246   };
	216 247   
	    248 + cbuffer UIStandardPrimitiveAdditionalPixelConstants
	217     - cbuffer InterFrameConstants
	218 249   {
	219     - 	// in secs. This is reset every 2 mins. so the range is [0, 120)
	220     - 	// make sure your shader handles the case when it transitions from 120 to 0
	    250 +     float4 PRIM_PROPS_0;
	    251 +     float4 PRIM_PROPS_1;
	221     -     float TOTAL_REAL_WORLD_TIME;
	222     -     float4x4 CUBE_MAP_ROTATION;
	223 252   };
	224 253   
	    254 + cbuffer UIEffectsPixelConstants
	225     - cbuffer PostProcessConstants {
	226     - 	int GaussianBlurSize;
	    255 + {
	    256 +     float4 COEFFICIENTS[3];
	    257 +     float4 PIXEL_OFFSETS[6];
	227     - 	float DepthOfFieldNearEndDepth;
	228     - 	float DepthOfFieldFarStartDepth;
	229     - 	float DepthOfFieldFarEndDepth;
	230 258   };
	231     - 
	          '''
Changed file "banner.vertex.hlsl":
	Total line: 137 (+21, -10)
	          '''
	  1   1   #include "ShaderConstants.fxh"
	  2   2   
	  3   3   struct VS_Input {
	  4   4   	float3 position : POSITION;
	      5 + #ifdef USE_SKINNING
	      6 + #ifdef USE_INT_INDEXING
	      7 + 	uint boneId : BONEID_0;
	      8 + #else
	      9 + 	float boneId : BONEID_0;
	     10 + #endif
	     11 + #endif
	  5  12   	float4 normal : NORMAL;
	  6  13   	float2 texCoords : TEXCOORD_0;
	  7  14   	float4 color : COLOR;
	  8  15   
	  9  16   #ifdef INSTANCEDSTEREO
	          ...
	 46  53   	return RGBA8_SNORM * float(2.0).xxxx - float(1.0).xxxx;
	 47  54   #else
	 48  55   	return RGBA8_SNORM;
	 49  56   #endif
	 50  57   }
	 51     - 
	 52  58   
	 53     - float lightIntensity(const float4 position, const float4 normal) {
	 54     - #ifdef FANCY
	 55  59   
	     60 + float lightIntensity(const float4x4 worldMat, const float4 position, const float4 normal) {
	 56     - #if !defined(INSTANCEDSTEREO)
	 57     - 	float3 N = normalize(mul(WORLD, normal)).xyz;
	     61 + #ifdef FANCY
	     62 + 	float3 N = normalize(mul(worldMat, normal)).xyz;
	 58     - #else
	 59     - 	float3 N = normalize(mul(WORLD_STEREO, normal)).xyz;
	 60     - #endif
	 61  63   
	 62  64   	N.y *= TILE_LIGHT_COLOR.a;
	 63  65   
	 64  66   	//take care of double sided polygons on materials without culling
	 65  67   #ifdef FLIP_BACKFACES
	 66     - #if !defined(INSTANCEDSTEREO)
	 67     - 	float3 viewDir = normalize((mul(WORLD, position)).xyz);
	 68     - #else
	     68 + 	float3 viewDir = normalize((mul(worldMat, position)).xyz);
	 69     - 	float3 viewDir = normalize((mul(WORLD_STEREO, position)).xyz);
	 70     - #endif
	 71  69   	if (dot(N, viewDir) > 0.0) {
	 72  70   		N *= -1.0;
	 73  71   	}
	 74  72   #endif
	 75  73   
	          ...
	 83  81   ROOT_SIGNATURE
	 84  82   void main(in VS_Input VSInput, out PS_Input PSInput)
	 85  83   {
	 86  84   #ifdef INSTANCEDSTEREO
	 87  85   	int i = VSInput.instanceID;
	     86 + 	#ifdef USE_SKINNING
	     87 + 		PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], mul(BONES[int(VSInput.boneId)], float4(VSInput.position, 1)));
	     88 + 	#else
	     89 + 		PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], float4(VSInput.position, 1));
	 88     - 	PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], float4(VSInput.position, 1));
	     90 + 	#endif
	     91 + 	#ifdef GEOMETRY_INSTANCEDSTEREO
	     92 + 		PSInput.instanceID = i;
	     93 + 	#endif 
	     94 + 	#ifdef VERTEXSHADER_INSTANCEDSTEREO
	     95 + 		PSInput.renTarget_id = i;
	     96 + 	#endif
	 89     - #ifdef GEOMETRY_INSTANCEDSTEREO
	 90     - 	PSInput.instanceID = i;
	 91     - #endif 
	 92     - #ifdef VERTEXSHADER_INSTANCEDSTEREO
	 93     - 	PSInput.renTarget_id = i;
	 94     - #endif
	     97 + #else
	     98 + 	#ifdef USE_SKINNING
	     99 + 		PSInput.position = mul(WORLDVIEWPROJ, mul(BONES[int(VSInput.boneId)], float4(VSInput.position, 1)));
	    100 + 	#else
	    101 + 		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	 95     -     
	 96     - #else
	 97     - 	PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	    102 + 	#endif
	 98 103   #endif
	    104 + 
	    105 + #ifdef ENABLE_LIGHT
	    106 + 	float4 normal = TransformRGBA8_SNORM(VSInput.normal);
	 99 107   
	    108 + #ifdef USE_SKINNING
	    109 + 	float L = lightIntensity(BONES[int(VSInput.boneId)], float4(VSInput.position, 1), normal);
	    110 + #elif !defined(INSTANCEDSTEREO)
	    111 + 	float L = lightIntensity(WORLD, float4(VSInput.position, 1), normal);
	    112 + #else
	    113 + 	float L = lightIntensity(WORLD_STEREO, float4(VSInput.position, 1), normal);
	100     - #ifdef ENABLE_LIGHT
	101     - 	float4 normal = TransformRGBA8_SNORM(VSInput.normal);
	102     - 
	103     - 	float L = lightIntensity(float4(VSInput.position, 1), normal);
	    114 + #endif
	104 115   
	105 116   	PSInput.light = float4(L.xxx * TILE_LIGHT_COLOR.rgb, 1.0);
	106 117   #endif
	107 118   
	108 119   	int frameIndex = int(VSInput.color.a * 255.0f);
	          ...
	          '''
Added file "barrier.vertex.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct VS_Input {
		float3 position : POSITION;
	    float4 color : COLOR;
	    float2 uv : TEXCOORD_0;
	    float2 light_uv : TEXCOORD_1;
	};
	
	
	struct PS_Input {
		float4 position : SV_Position;
	
		// passing color so we can avoid having an extra shader and just use renderchunk.fragment
		lpfloat4 color : COLOR;
	    snorm float2 uv : TEXCOORD_0_FB_MSAA;
	    snorm float2 light_uv : TEXCOORD_1_FB_MSAA;
	};
	
	void main(in VS_Input VSInput, out PS_Input PSInput) {
		float3 inputPos = VSInput.position.xyz * CHUNK_ORIGIN_AND_SCALE.w + CHUNK_ORIGIN_AND_SCALE.xyz;
		float3 center = inputPos + float3(0.5f, 0.5f, 0.5f);
	
		// the view position needs to be in sortof-steve space
		// the translation seems to be already embedded for some reason.
		float3 viewPos = VIEW_POS * CHUNK_ORIGIN_AND_SCALE.w;
	
		float3 forward = normalize(center - viewPos);
		// not orthogonal so need to normalize
		float3 right = normalize(cross(float3(0.0f, 1.0f, 0.0f), forward));
		// orthogonal so dont need to normalize
		float3 up = cross(forward, right);
	
	
		// color is only positive, so we have to offset by .5
		// we have to subtract because we passed in uvs
	
		// we multiply our offsets by the basis vectors and subtract them to get our verts
		float3 vertPos = center - up * (VSInput.color.z - 0.5f) - right * (VSInput.color.x - 0.5f);
	
	
		PSInput.position = mul(WORLDVIEW, float4( vertPos, 1.0f ));
		PSInput.position = mul(PROJ, PSInput.position);
	
		PSInput.uv = VSInput.uv;
		PSInput.light_uv = VSInput.light_uv;
	
		// color is hardcoded white
		PSInput.color = float4(1.0f, 1.0f, 1.0f, 1.0f);
	}
	'''
Changed file "entity.vertex.hlsl":
	Total line: 171 (+49, -36)
	          '''
	  1   1   #include "ShaderConstants.fxh"
	  2   2   
	  3   3   struct VS_Input {
	  4   4   	float3 position : POSITION;
	      5 + #ifdef USE_SKINNING
	      6 + #ifdef USE_INT_INDEXING
	      7 + 	uint boneId : BONEID_0;
	      8 + #else
	      9 + 	float boneId : BONEID_0;
	     10 + #endif
	     11 + #endif
	     12 + 	float4 normal : NORMAL;
	     13 + 	float2 texCoords : TEXCOORD_0;
	     14 + #ifdef COLOR_BASED
	     15 + 	float4 color : COLOR;
	     16 + #endif
	     17 + #ifdef INSTANCEDSTEREO
	     18 + 	uint instanceID : SV_InstanceID;
	     19 + #endif
	     20 + };
	     21 + 
	     22 + 
	     23 + struct PS_Input {
	     24 + 	float4 position : SV_Position;
	     25 + 
	     26 + 	float4 light : LIGHT;
	     27 + 	float4 fogColor : FOG_COLOR;
	     28 + 
	     29 + #ifdef GLINT
	     30 + 	// there is some alignment issue on the Windows Phone 1320 that causes the position
	     31 + 	// to get corrupted if this is two floats and last in the struct memory wise
	     32 + 	float4 layerUV : GLINT_UVS;
	  5     - 	float4 normal : NORMAL;
	  6     - 	float2 texCoords : TEXCOORD_0;
	  7     - #ifdef COLOR_BASED
	  8     - 	float4 color : COLOR;
	  9  33   #endif
	     34 + 
	     35 + #ifdef USE_OVERLAY
	     36 + 	float4 overlayColor : OVERLAY_COLOR;
	 10     - #ifdef INSTANCEDSTEREO
	 11     - 	uint instanceID : SV_InstanceID;
	 12  37   #endif
	 13     - };
	 14     - 
	 15  38   
	     39 + #ifdef TINTED_ALPHA_TEST
	     40 + 	// With MSAA Enabled, making this field a float results in a DX11 internal compiler error
	     41 + 	// We assume it is trying to pack the single float with the centroid-interpolated UV coordinates, which it can't do
	     42 + 	float4 alphaTestMultiplier : ALPHA_MULTIPLIER;
	 16     - struct PS_Input {
	 17     - 	float4 position : SV_Position;
	     43 + #endif
	 18  44   
	     45 + 	float2 uv : TEXCOORD_0_FB_MSAA;
	 19     - 	float4 light : LIGHT;
	     46 + 	
	 20     - 	float4 fogColor : FOG_COLOR;
	 21  47   
	 22     - #ifdef GLINT
	 23     - 	// there is some alignment issue on the Windows Phone 1320 that causes the position
	     48 + #ifdef GEOMETRY_INSTANCEDSTEREO
	     49 + 	uint instanceID : SV_InstanceID;
	 24     - 	// to get corrupted if this is two floats and last in the struct memory wise
	 25     - 	float4 layerUV : GLINT_UVS;
	 26  50   #endif
	 27     - 
	     51 + #ifdef VERTEXSHADER_INSTANCEDSTEREO
	     52 + 	uint renTarget_id : SV_RenderTargetArrayIndex;
	 28     - #ifdef USE_OVERLAY
	 29     - 	float4 overlayColor : OVERLAY_COLOR;
	 30  53   #endif
	     54 + };
	     55 + 
	     56 + static const float AMBIENT = 0.45;
	 31  57   
	 32     - #ifdef TINTED_ALPHA_TEST
	 33     - 	// With MSAA Enabled, making this field a float results in a DX11 internal compiler error
	     58 + static const float XFAC = -0.1;
	     59 + static const float ZFAC = 0.1;
	     60 + 
	 34     - 	// We assume it is trying to pack the single float with the centroid-interpolated UV coordinates, which it can't do
	 35     - 	float4 alphaTestMultiplier : ALPHA_MULTIPLIER;
	 36     - #endif
	 37  61   
	     62 + float4 TransformRGBA8_SNORM(const float4 RGBA8_SNORM) {
	 38     - 	float2 uv : TEXCOORD_0_FB_MSAA;
	 39     - 	
	     63 + #ifdef R8G8B8A8_SNORM_UNSUPPORTED
	     64 + 	return RGBA8_SNORM * float(2.0).xxxx - float(1.0).xxxx;
	     65 + #else
	 40     - #ifdef GEOMETRY_INSTANCEDSTEREO
	 41     - 	uint instanceID : SV_InstanceID;
	 42     - #endif
	 43     - #ifdef VERTEXSHADER_INSTANCEDSTEREO
	     66 + 	return RGBA8_SNORM;
	 44     - 	uint renTarget_id : SV_RenderTargetArrayIndex;
	 45  67   #endif
	     68 + }
	 46     - };
	 47  69   
	 48     - static const float AMBIENT = 0.45;
	 49  70   
	     71 + float lightIntensity(const float4x4 worldMat, const float4 position, const float4 normal) {
	     72 + #ifdef FANCY
	 50     - static const float XFAC = -0.1;
	     73 + 	float3 N = normalize(mul(worldMat, normal)).xyz;
	 51     - static const float ZFAC = 0.1;
	 52  74   
	     75 + 	N.y *= TILE_LIGHT_COLOR.a;
	 53  76   
	 54     - float4 TransformRGBA8_SNORM(const float4 RGBA8_SNORM) {
	 55     - #ifdef R8G8B8A8_SNORM_UNSUPPORTED
	 56     - 	return RGBA8_SNORM * float(2.0).xxxx - float(1.0).xxxx;
	     77 + 	//take care of double sided polygons on materials without culling
	     78 + #ifdef FLIP_BACKFACES
	     79 + 	float3 viewDir = normalize((mul(worldMat, position)).xyz);
	     80 + 	if (dot(N, viewDir) > 0.0) {
	 57     - #else
	 58     - 	return RGBA8_SNORM;
	 59     - #endif
	 60     - }
	 61     - 
	     81 + 		N *= -1.0;
	     82 + 	}
	     83 + #endif
	 62     - 
	 63     - float lightIntensity(const float4 position, const float4 normal) {
	 64     - #ifdef FANCY
	 65  84   
	     85 + 	float yLight = (1.0 + N.y) * 0.5;
	 66     - #if !defined(INSTANCEDSTEREO)
	     86 + 	return yLight * (1.0 - AMBIENT) + N.x*N.x * XFAC + N.z*N.z * ZFAC + AMBIENT;
	 67     - 	float3 N = normalize(mul(WORLD, normal)).xyz;
	 68  87   #else
	     88 + 	return 1.0;
	 69     - 	float3 N = normalize(mul(WORLD_STEREO, normal)).xyz;
	 70  89   #endif
	     90 + }
	 71     - 
	 72     - 	N.y *= TILE_LIGHT_COLOR.a;
	 73  91   
	     92 + #ifdef GLINT
	     93 + float2 calculateLayerUV(float2 origUV, float offset, float rotation) {
	 74     - 	//take care of double sided polygons on materials without culling
	     94 + 	float2 uv = origUV;
	     95 + 	uv -= 0.5;
	     96 + 	float rsin = sin(rotation);
	 75     - #ifdef FLIP_BACKFACES
	 76     - #if !defined(INSTANCEDSTEREO)
	 77     - 	float3 viewDir = normalize((mul(WORLD, position)).xyz);
	 78     - #else
	     97 + 	float rcos = cos(rotation);
	     98 + 	uv = mul(uv, float2x2(rcos, -rsin, rsin, rcos));
	     99 + 	uv.x += offset;
	    100 + 	uv += 0.5;
	 79     - 	float3 viewDir = normalize((mul(WORLD_STEREO, position)).xyz);
	 80     - #endif
	 81     - 	if (dot(N, viewDir) > 0.0) {
	 82     - 		N *= -1.0;
	 83     - 	}
	 84     - #endif
	 85 101   
	 86     - 	float yLight = (1.0 + N.y) * 0.5;
	 87     - 	return yLight * (1.0 - AMBIENT) + N.x*N.x * XFAC + N.z*N.z * ZFAC + AMBIENT;
	 88     - #else
	    102 + 	return uv * GLINT_UV_SCALE;
	 89     - 	return 1.0;
	    103 + }
	 90 104   #endif
	 91     - }
	 92 105   
	 93     - #ifdef GLINT
	 94     - float2 calculateLayerUV(float2 origUV, float offset, float rotation) {
	 95     - 	float2 uv = origUV;
	    106 + ROOT_SIGNATURE
	    107 + void main(in VS_Input VSInput, out PS_Input PSInput)
	    108 + {
	    109 + #ifdef INSTANCEDSTEREO
	    110 + 	int i = VSInput.instanceID;
	    111 + 	#ifdef USE_SKINNING
	    112 + 		PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], mul(BONES[int(VSInput.boneId)], float4(VSInput.position, 1)));
	    113 + 	#else
	    114 + 		PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], float4(VSInput.position, 1));
	    115 + 	#endif
	 96     - 	uv -= 0.5;
	 97     - 	float rsin = sin(rotation);
	 98     - 	float rcos = cos(rotation);
	 99     - 	uv = mul(uv, float2x2(rcos, -rsin, rsin, rcos));
	100     - 	uv.x += offset;
	101     - 	uv += 0.5;
	102     - 
	103     - 	return uv * GLINT_UV_SCALE;
	104     - }
	105     - #endif
	106     - 
	107     - ROOT_SIGNATURE
	108     - void main(in VS_Input VSInput, out PS_Input PSInput)
	    116 + #else
	    117 + 	#ifdef USE_SKINNING
	109     - {
	110     - #ifdef INSTANCEDSTEREO
	    118 + 		PSInput.position = mul(WORLDVIEWPROJ, mul(BONES[int(VSInput.boneId)], float4(VSInput.position, 1)));
	    119 + 	#else
	    120 + 		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	111     - 	int i = VSInput.instanceID;
	112     - 	PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], float4(VSInput.position, 1));
	    121 + 	#endif
	    122 + #endif
	113     - #else
	    123 + #ifdef GEOMETRY_INSTANCEDSTEREO
	    124 + 	PSInput.instanceID = VSInput.instanceID;
	    125 + #endif 
	    126 + #ifdef VERTEXSHADER_INSTANCEDSTEREO
	    127 + 	PSInput.renTarget_id = VSInput.instanceID;
	    128 + #endif
	114     - 	PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	115     - #endif
	116     - #ifdef GEOMETRY_INSTANCEDSTEREO
	117     - 	PSInput.instanceID = VSInput.instanceID;
	118     - #endif 
	    129 + 	float4 normal = TransformRGBA8_SNORM(VSInput.normal);
	    130 + 
	    131 + #ifdef USE_SKINNING
	    132 + 	float L = lightIntensity(BONES[int(VSInput.boneId)], float4(VSInput.position, 1), normal);
	    133 + #elif !defined(INSTANCEDSTEREO)
	    134 + 	float L = lightIntensity(WORLD, float4(VSInput.position, 1), normal);
	    135 + #else
	    136 + 	float L = lightIntensity(WORLD_STEREO, float4(VSInput.position, 1), normal);
	119     - #ifdef VERTEXSHADER_INSTANCEDSTEREO
	120     - 	PSInput.renTarget_id = VSInput.instanceID;
	121     - #endif
	122     - 	float4 normal = TransformRGBA8_SNORM(VSInput.normal);
	123     - 
	124     - 	float L = lightIntensity(float4(VSInput.position, 1), normal);
	    137 + #endif
	125 138   
	126 139   #ifdef USE_OVERLAY
	127 140   	L += OVERLAY_COLOR.a * 0.35;
	128 141   	PSInput.overlayColor = OVERLAY_COLOR;
	129 142   #endif
	          ...
	          '''
Added file "hummingbird/CohPathPS.hlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	#include "../ShaderConstants.fxh"
	
	struct PS_Input
	{
		float4 Position : SV_Position; // Why not position3
		float2 ExtraParams : TEXCOORD0;
	};
	
	struct PS_Output {
		float4 color : SV_Target;
	};
	
	void main(in PS_Input PSInput, out PS_Output PSOutput)
	{
		if (SHADER_TYPE == 14)
		{
			// Hairline quads
			float2 px = ddx(PSInput.ExtraParams);
			float2 py = ddy(PSInput.ExtraParams);
	
			float fx = (2 * PSInput.ExtraParams.x) * px.x - px.y;
			float fy = (2 * PSInput.ExtraParams.x) * py.x - py.y;
	
			float edgeAlpha = (PSInput.ExtraParams.x * PSInput.ExtraParams.x - PSInput.ExtraParams.y);
			float sd = sqrt((edgeAlpha * edgeAlpha) / (fx * fx + fy * fy));
	
			float alpha = 1.0 - sd;
	
			PSOutput.color = PRIM_PROPS_0 * PRIM_PROPS_1.x * alpha;
		}
		else if (SHADER_TYPE == 11)
		{
			// Hairline lines
			PSOutput.color = PRIM_PROPS_0 * min(1.0f, (1.0f - abs(PSInput.ExtraParams.y)) * PRIM_PROPS_1.x);
		}
		else
		{
			// non-hairline paths
			PSOutput.color = PRIM_PROPS_0 * PSInput.ExtraParams.y;
		}
	}
	'''
Added file "hummingbird/CohPathVS.hlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	#include "../ShaderConstants.fxh"
	
	struct VS_Input
	{
		float4 Position : POSITION;
	};
	
	struct PS_Input
	{
		float4 Position : SV_Position; // Why not position3
		float2 ExtraParams : TEXCOORD0;
	};
	
	float4 CoherentMul(float4 vec, float4x4 mat) {
		return mul(vec, mat);
	}
	
	float4 CoherentPosition(float3 pos) {
		return float4(pos, 1);
	}
	
	void main(in VS_Input VSInput, out PS_Input PSOutput)
	{
		PSOutput.Position = CoherentMul(CoherentPosition(float3(VSInput.Position.xy, 0.0f)), TRANSFORM);
	
		// Translate to -1..1 with perspective correction
		float w = PSOutput.Position.w;
		PSOutput.Position.x = PSOutput.Position.x * 2 - w;
		PSOutput.Position.y = (w - PSOutput.Position.y) * 2 - w;
	
		PSOutput.ExtraParams = VSInput.Position.zw;
	}
	'''
Added file "hummingbird/CohShadeGeometry.ihlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	#define SAMPLE2D(tex, uv) tex.Sample(TextureSampler0, uv)
	#define SAMPLE2D_LOD(tex, uv) tex.Sample(TextureSampler0, uv.xy)
	#define COH_A8_SAMPLE_MASK .r
	
	void ShadeGeometry(in PS_Input input, inout float4 outColor, inout float alpha)
	{
		// Rect/stroke rect
		if(SHADER_TYPE == 0)
		{
			alpha = min(1.0, input.Additional.z * input.Additional.w);
		}
		// Circle / Rounded rect
		else if (SHADER_TYPE == 1)
		{
			const float2 posPixels = input.ScreenNormalPosition.xy;
			const float distance2edge = length(posPixels - input.Additional.xy) - input.Additional.z;
			alpha = clamp(0.5 - distance2edge, 0, 1);
		}
		// Stroke Circle / Rounded rect
		else if (SHADER_TYPE == 2)
		{
			const float2 posPixels = input.ScreenNormalPosition.xy;
			const float de = length(posPixels - input.Additional.xy);
			const float distance2OuterEdge = de - (input.Additional.z + input.Additional.w / 2);
			const float distance2InnerEdge = de - (input.Additional.z - input.Additional.w / 2);
			alpha = clamp(0.5 - distance2OuterEdge, 0, 1);
			alpha *= 1 - clamp(0.5 - distance2InnerEdge, 0, 1);
		}
		// Image
		else if (SHADER_TYPE == 3)
		{
			outColor = SAMPLE2D(TEXTURE_0, input.Additional.xy);
			alpha = input.Color.a * saturate(input.Additional.z);
		}
	
		// Ellipse
		else if (SHADER_TYPE == 4)
		{
			const float2 offset = (input.ScreenNormalPosition.xy - input.Additional.xy) * rcp(input.Additional.zw);
			const float test = dot(offset, offset) - 1.0;
			const float2 dudx = ddx(offset);
			const float2 dudy = ddy(offset);
			const float2 gradient = float2(2.0 * offset.x * dudx.x + 2.0 * offset.y * dudx.y,
											2.0 * offset.x * dudy.x + 2.0 * offset.y * dudy.y);
			const float grad_dot = max(dot(gradient, gradient), 1.0e-4);
			const float invlen = rsqrt(grad_dot);
	
			alpha = saturate(0.5 - test * invlen);
		}
	
		// Stroke Ellipse
		else if (SHADER_TYPE == 5)
		{
			float2 offset = (input.ScreenNormalPosition.xy - input.Additional.xy) * rcp(input.Additional.zw + (PRIM_PROPS_0.x / 2.0));
			float test = dot(offset, offset) - 1.0;
			float2 dudx = ddx(offset);
			float2 dudy = ddy(offset);
			float2 gradient = float2(2.0 * offset.x * dudx.x + 2.0 * offset.y * dudx.y,
									2.0 * offset.x * dudy.x + 2.0 * offset.y * dudy.y);
			float grad_dot = max(dot(gradient, gradient), 1.0e-4);
			float invlen = rsqrt(grad_dot);
	
			alpha = saturate(0.5 - test * invlen);
	
			offset = (input.ScreenNormalPosition.xy - input.Additional.xy) * rcp((input.Additional.zw - (PRIM_PROPS_0.x / 2.0)));
			test = dot(offset, offset) - 1.0;
			dudx = ddx(offset);
			dudy = ddy(offset);
			gradient = float2(2.0 * offset.x * dudx.x + 2.0 * offset.y * dudx.y,
							2.0 * offset.x * dudy.x + 2.0 * offset.y * dudy.y);
			grad_dot = max(dot(gradient, gradient), 1.0e-4);
			invlen = rsqrt(grad_dot);
	
			alpha *= saturate(0.5 + test * invlen);
		}
	
		// Blur
		else if (SHADER_TYPE == 6)
		{
			outColor = float4(0, 0, 0, 0);
	#if !defined(__DX9__)
			const uint stepsCount = uint(PRIM_PROPS_0.x);
			for (uint i = 0; i < stepsCount; ++i) {
	#else
			for (int i = 0; i < PRIM_PROPS_0.x; ++i) {
	#endif
				float coeff = COEFFICIENTS[i / 4][i % 4];
				float2 offset;
				offset.x = PIXEL_OFFSETS[(i*2) / 4][(i*2) % 4];
				offset.y = PIXEL_OFFSETS[(i*2 + 1) / 4][(i*2 + 1) % 4];
				
				//float coeff = COEFFICIENTS[i];
				//float2 offset = PIXEL_OFFSETS[i];
	
				outColor += coeff
					* (SAMPLE2D_LOD(TEXTURE_0, float4(input.Additional.xy + offset, 0, 0))
					+ SAMPLE2D_LOD(TEXTURE_0, float4(input.Additional.xy - offset, 0, 0)));
			}
			alpha = input.Color.a;
		}
	
		// Image with color matrix
		else if (SHADER_TYPE == 7)
		{
			float4 baseColor = SAMPLE2D(TEXTURE_0, input.Additional.xy);
			float nonZeroAlpha = max(baseColor.a, 0.00001);
			baseColor = float4(baseColor.rgb / nonZeroAlpha, nonZeroAlpha);
	
			// TODO: Rename the members of the constant buffer so they are not weird for non-blurs
			outColor.r = dot(baseColor, COEFFICIENTS[0]);
			outColor.g = dot(baseColor, COEFFICIENTS[1]);
			outColor.b = dot(baseColor, COEFFICIENTS[2]);
			outColor.a = dot(baseColor, PIXEL_OFFSETS[0]);
			outColor += PIXEL_OFFSETS[1];
	
			//outColor.r = dot(baseColor, float4(COEFFICIENTS[0], COEFFICIENTS[1], COEFFICIENTS[2], COEFFICIENTS[3]));
			//outColor.g = dot(baseColor, float4(COEFFICIENTS[4], COEFFICIENTS[5], COEFFICIENTS[6], COEFFICIENTS[7]));
			//outColor.b = dot(baseColor, float4(COEFFICIENTS[8], COEFFICIENTS[9], COEFFICIENTS[10], COEFFICIENTS[11]));
			//outColor.a = dot(baseColor, float4(PIXEL_OFFSETS[0].x, PIXEL_OFFSETS[0].y, PIXEL_OFFSETS[1].x, PIXEL_OFFSETS[1].y));
			//outColor += float4(PIXEL_OFFSETS[2].x, PIXEL_OFFSETS[2].y, PIXEL_OFFSETS[3].x, PIXEL_OFFSETS[3].y);
	
			alpha = outColor.a * input.Color.a;
			outColor.a = 1;
		}
		// YUV2RGB (9) YUVA2RGB (12)
		else if (SHADER_TYPE == 9 || SHADER_TYPE == 12)
		{
			float3 YCbCr;
			YCbCr.x = SAMPLE2D(TEXTURE_0, input.Additional.xy) COH_A8_SAMPLE_MASK;
			YCbCr.y = SAMPLE2D(TEXTURE_1, input.Additional.xy) COH_A8_SAMPLE_MASK;
			YCbCr.z = SAMPLE2D(TEXTURE_2, input.Additional.xy) COH_A8_SAMPLE_MASK;
	
			YCbCr -= float3(0.0625, 0.5, 0.5);
			float3x3 yuv2rgb = float3x3(float3(1.164, 0, 1.596), float3(1.164, -0.391, -0.813), float3(1.164, 2.018, 0));
			float3 rgb = mul(yuv2rgb, YCbCr);
	
			alpha = input.Color.a;
			outColor = float4(rgb, 1.0f);
	
			if (SHADER_TYPE == 12)
			{
				float a = SAMPLE2D(TEXTURE_3, input.Additional.xy) COH_A8_SAMPLE_MASK;
				alpha *= a;
			}
		}
		// Hairline
		else if(SHADER_TYPE == 11)
		{
			const float3 posPixels = float3(input.ScreenNormalPosition.xy, 1);
			const float distance2line = abs(dot(input.Additional.xyz, posPixels));
			alpha = 1 - saturate(distance2line);
		}
	}
	
	'''
Added file "hummingbird/CohStandardPS.hlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	#include "../ShaderConstants.fxh"
	
	struct PS_Input {
		float4 Position : SV_Position; // Why not position3
		float4 Color : TEXCOORD0;
		float4 Additional: TEXCOORD1;
		float3 ScreenNormalPosition : TEXCOORD2;
	};
	
	struct PS_Output {
		float4 color : SV_Target;
	};
	
	#include "CohShadeGeometry.ihlsl"
	
	void main(in PS_Input PSInput, out PS_Output PSOutput)
	{
		float alpha = 0.1f;
		float4 outColor = PSInput.Color;
	
		ShadeGeometry(PSInput, outColor, alpha);
		PSOutput.color = outColor * alpha;
	}
	'''
Added file "hummingbird/CohStandardVS.hlsl":
	'''
	/*
	v4lel
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	#include "../ShaderConstants.fxh"
	
	struct VS_Input {
		float3 Position : POSITION_3;
		float4 Color : COLOR_4;
		float4 Additional : ADDITIONAL;
	};
	
	struct PS_Input {
		float4 Position : SV_Position; // Why not position3
		float4 Color : TEXCOORD0;
		float4 Additional: TEXCOORD1;
		float3 ScreenNormalPosition : TEXCOORD2;
	};
	
	float4 CoherentMul(float4 vec, float4x4 mat) {
	    return mul(vec, mat);
	}
	
	float4 CoherentPosition(float3 pos) {
	    return float4(pos, 1);
	}
	
	void main(in VS_Input VSInput, out PS_Input PSInput) {
		PSInput.Position = CoherentMul(CoherentPosition(VSInput.Position),
									  TRANSFORM);
		PSInput.ScreenNormalPosition = VSInput.Position;
	
		// Translate to -1..1 with perspective correction
		float w = PSInput.Position.w;
		PSInput.Position.x = PSInput.Position.x * 2 - w;
		PSInput.Position.y = (w - PSInput.Position.y) * 2 - w;
	
		PSInput.Color = VSInput.Color;
		PSInput.Additional = VSInput.Additional;
	}
	
	'''
Added file "hummingbird/CohStencilPS.hlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	#include "../ShaderConstants.fxh"
	
	struct PS_Input {
		float4 Position : SV_Position;
		float4 Color : TEXCOORD0;
		float4 Additional: TEXCOORD1;
		float3 ScreenNormalPosition : TEXCOORD2;
	};
	
	#include "CohShadeGeometry.ihlsl"
	
	void main(in PS_Input PSInput) {
		float alpha = 1.0f;
		float4 outColor = PSInput.Color;
	
		ShadeGeometry(PSInput, outColor, alpha);
	
		// Image
		if (SHADER_TYPE == 3) {
			alpha = outColor.a;
		}
	
		if (alpha < 0.00390625f) {
			discard;
		}
	}
	'''
Added file "hummingbird/CohStencilPathPS.hlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	struct PS_Input {
		float4 Position : SV_Position;
		float2 ExtraParams : TEXCOORD0;
	};
	
	void main(in PS_Input PSInput) {
		if (PSInput.ExtraParams.y < 0.00390625f) {
			discard;
		}
	}
	'''
Added file "hummingbird/CohTextPS.hlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	#define SAMPLE2D(tex, uv) tex.Sample(TextureSampler0, uv)
	#define SAMPLE2D_LOD(tex, uv) tex.Sample(TextureSampler0, uv.xy)
	#define COH_A8_SAMPLE_MASK .r
	
	#include "../ShaderConstants.fxh"
	
	// Keep in sync w/ SDFGenerator
	#define DISTANCE_FIELD_MULTIPLIER 7.96875f
	#define DISTANCE_FIELD_MULTIPLIER_DIV2 3.984375f
	#define DISTANCE_FIELD_THRESHOLD 0.50196078431f
	
	#define SHOW_DF 0
	
	struct PS_Input {
		float4 Position : SV_Position;
		float4 Color : VS_SEMANTIC_COLOR;
		float4 Additional: TEXCOORD0;
		float3 ScreenNormalPosition : TEXCOORD1;
	};
	
	struct PS_Output {
		float4 color : SV_Target;
	};
	
	float GetLuminance(float3 color) {
		return 0.2126f * color.r + 0.7152f * color.g + 0.0722f * color.b;
	}
	
	void main(in PS_Input input, out PS_Output PSOutput) {
		float dfValue = SAMPLE2D(TEXTURE_0, input.Additional.xy) COH_A8_SAMPLE_MASK;
	#if SHOW_DF
		PSOutput.color = float4(dfValue.xxx, 1);
	#endif
		if (SHADER_TYPE == 1) {
			// Values should be in [-4, 4]
			dfValue = (dfValue * DISTANCE_FIELD_MULTIPLIER) - DISTANCE_FIELD_MULTIPLIER_DIV2;
	
			dfValue = smoothstep(-DISTANCE_FIELD_THRESHOLD / PRIM_PROPS_0.x, DISTANCE_FIELD_THRESHOLD / PRIM_PROPS_0.x, dfValue);
		} else if (SHADER_TYPE == 2) {
			const float scale = sqrt(PRIM_PROPS_0.y * 0.5);
	
			const float bias = 0.5 * scale - 0.9;
			const float outlineWidth = PRIM_PROPS_0.z / PRIM_PROPS_0.y * 0.5 * scale;
			dfValue *= scale;
	
			float4 c = lerp(PRIM_PROPS_1, input.Color, saturate(dfValue - (bias + outlineWidth)));
	
			c *= saturate(dfValue - max(0, bias - outlineWidth));
			PSOutput.color = c;
		}
	
		const float lum = GetLuminance(input.Color.xyz);
	
		// dfValue is in the [0,1] range here so warning X3571 can be safely ignored
		PSOutput.color = input.Color * pow(dfValue, 1.45f - lum);
	}
	'''
Added file "hummingbird/CohTextVS.hlsl":
	'''
	/*
	This file is part of Renoir, a modern graphics library.
	
	Copyright (c) 2012-2016 Coherent Labs AD and/or its licensors. All
	rights reserved in all media.
	
	The coded instructions, statements, computer programs, and/or related
	material (collectively the "Data") in these files contain confidential
	and unpublished information proprietary Coherent Labs and/or its
	licensors, which is protected by United States of America federal
	copyright law and by international treaties.
	
	This software or source code is supplied under the terms of a license
	agreement and nondisclosure agreement with Coherent Labs AD and may
	not be copied, disclosed, or exploited except in accordance with the
	terms of that agreement. The Data may not be disclosed or distributed to
	third parties, in whole or in part, without the prior written consent of
	Coherent Labs AD.
	
	COHERENT LABS MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS
	SOURCE CODE FOR ANY PURPOSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
	HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER, ITS AFFILIATES,
	PARENT COMPANIES, LICENSORS, SUPPLIERS, OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OR PERFORMANCE OF THIS SOFTWARE OR SOURCE CODE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	#include "../ShaderConstants.fxh"
	
	struct VS_Input {
		float3 Position : POSITION_3;
		float4 Color : COLOR_4;
		float4 Additional : ADDITIONAL;
	};
	
	struct PS_Input {
		float4 Position : SV_Position; // Why not position3
		float4 Color : VS_SEMANTIC_COLOR;
		float4 Additional: TEXCOORD0;
		float3 ScreenNormalPosition : TEXCOORD1;
	};
	
	float4 CoherentMul(float4 vec, float4x4 mat) {
	    return mul(vec, mat);
	}
	
	float4 CoherentPosition(float3 pos) {
	    return float4(pos, 1);
	}
	
	void main(in VS_Input VSInput, out PS_Input PSInput) {
		PSInput.Position = CoherentMul(CoherentPosition(VSInput.Position), TRANSFORM);
		PSInput.ScreenNormalPosition = VSInput.Position;
	
		// Translate to -1..1 with perspective correction
		float w = PSInput.Position.w;
		PSInput.Position.x = PSInput.Position.x * 2 - w;
		PSInput.Position.y = (w - PSInput.Position.y) * 2 - w;
	
		PSInput.Color = VSInput.Color;
		PSInput.Additional = VSInput.Additional;
	}
	'''
Added file "passthru.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct PS_Input
	{
	    float4 position : SV_Position;
	    float2 uv : TEXCOORD_0_FB_MSAA;
	};
	
	struct PS_Output
	{
	    float4 color : SV_Target;
	};
	
	void main(in PS_Input PSInput, out PS_Output PSOutput)
	{
	    PSOutput.color = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	}
	'''