Difference of "shaders" between "a0.15.0_realms4" (beta of "a0.15.0") and "1.2.0.2" (beta of "1.2.0").
Unable to create data files for 65 files between.

Changed file "ShaderConstants.fxh":
	Total line: 136 (+52, -42)
	          '''
	  1   1   // These [aren't but] should be grouped in a way that they require the least amount of updating (world data in one, model data in another, part of model data in another one, etc)
	  2   2   
	      3 + #if (defined(USE_STEREO_TEXTURE_ARRAY) || defined(ARRAY_TEXTURE_0)) && (VERSION >= 0xa000)
	      4 + Texture2DArray TEXTURE_0 : register (t0);
	      5 + #else
	      6 + Texture2D TEXTURE_0 : register (t0);
	      7 + #endif
	      8 + 
	      9 + Texture2D TEXTURE_1 : register (t1);
	     10 + Texture2D TEXTURE_2 : register (t2);
	     11 + 
	     12 + // Make sure this thing is actually getting bound
	     13 + sampler TextureSampler0 : register(s0);
	     14 + sampler TextureSampler1 : register(s1);
	     15 + sampler TextureSampler2 : register(s2);
	     16 + 
	     17 + #ifdef LOW_PRECISION
	     18 + #define lpfloat min16float
	     19 + #define lpfloat2 min16float2
	     20 + #define lpfloat4 min16float4
	     21 + #else
	     22 + #define lpfloat float
	     23 + #define lpfloat2 float2
	     24 + #define lpfloat4 float4
	     25 + #endif
	     26 + 
	     27 + #if defined(MSAA_FRAMEBUFFER_ENABLED)
	     28 + #define TEXCOORD_0_FB_MSAA TEXCOORD_0_centroid
	     29 + #define TEXCOORD_1_FB_MSAA TEXCOORD_1_centroid
	     30 + #else
	     31 + #define TEXCOORD_0_FB_MSAA TEXCOORD_0
	     32 + #define TEXCOORD_1_FB_MSAA TEXCOORD_1
	     33 + #endif
	     34 + 
	     35 + 
	     36 + cbuffer RenderChunkConstants {
	     37 + 	float4 CHUNK_ORIGIN_AND_SCALE;
	     38 + }
	     39 + 
	     40 + cbuffer EntityConstants {
	     41 + 	float4 OVERLAY_COLOR;
	     42 + 	float4 TILE_LIGHT_COLOR;
	     43 + 	float4 CHANGE_COLOR;
	     44 + 	float4 GLINT_COLOR;
	     45 + 	float4 UV_ANIM;
	     46 + 	float2 UV_OFFSET;
	     47 + 	float2 UV_ROTATION;
	     48 + 	float2 GLINT_UV_SCALE;
	     49 + }
	  3     - #ifdef USE_STEREO_TEXTURE_ARRAY
	  4     - Texture2DArray TEXTURE_0 : register ( t0 ); 
	  5     - #else
	  6     - Texture2D TEXTURE_0 : register ( t0 );
	  7     - #endif
	  8     - 
	  9     - Texture2D TEXTURE_1 : register ( t1 );
	 10     - Texture2D TEXTURE_2 : register ( t2 );
	 11  50   
	 12     - // Make sure this thing is actually getting bound
	 13     - sampler TextureSampler0 : register( s0 );
	 14     - sampler TextureSampler1 : register( s1 );
	     51 + cbuffer PerFrameConstants {
	 15     - sampler TextureSampler2 : register( s2 );
	 16  52   
	 17     - #ifdef LOW_PRECISION
	 18     - #define lpfloat min16float
	 19     - #define lpfloat2 min16float2
	 20     - #define lpfloat4 min16float4
	     53 + 	float3 VIEW_POS;
	     54 + 	float TIME;
	 21     - #else
	 22     - #define lpfloat float
	     55 + 
	     56 + 	float4 FOG_COLOR;
	     57 + 
	     58 + 	float2 FOG_CONTROL;
	 23     - #define lpfloat2 float2
	 24     - #define lpfloat4 float4
	 25     - #endif
	 26  59   
	 27     - #ifdef MSAA_FRAMEBUFFER_ENABLED
	 28     - #define TEXCOORD_0_FB_MSAA TEXCOORD_0_centroid
	 29     - #define TEXCOORD_1_FB_MSAA TEXCOORD_1_centroid
	     60 + 	float RENDER_DISTANCE;
	     61 + 	float FAR_CHUNKS_DISTANCE;
	     62 + }
	     63 + 
	 30     - #else
	 31     - #define TEXCOORD_0_FB_MSAA TEXCOORD_0
	 32     - #define TEXCOORD_1_FB_MSAA TEXCOORD_1
	 33     - #endif
	 34  64   
	     65 + #if !defined(INSTANCEDSTEREO)
	 35  66   
	     67 + cbuffer WorldConstants {
	 36     - cbuffer RenderChunkConstants
	     68 + 	float4x4 WORLDVIEWPROJ;
	     69 + 	float4x4 WORLD;
	     70 + 	float4x4 WORLDVIEW;
	 37     - {
	 38     - 
	     71 + 	float4x4 PROJ;
	 39     - 	float4 CHUNK_ORIGIN_AND_SCALE;
	 40  72   }
	 41  73   
	 42     - cbuffer EntityConstants
	 43     - {
	 44     - 	float4 OVERLAY_COLOR;
	     74 + #else
	     75 + 
	     76 + cbuffer WorldConstantsStereographic {
	     77 + 	float4x4 WORLDVIEWPROJ_STEREO[2];
	     78 + 	float4x4 WORLD_STEREO;
	     79 + 	float4x4 WORLDVIEW_STEREO[2];
	     80 + 	float4x4 PROJ_STEREO[2];
	 45     - 	float4 TILE_LIGHT_COLOR;
	 46     - 	float4 CHANGE_COLOR;
	 47     - 	float4 GLINT_COLOR;
	 48     - 	float2 UV_ANIM;
	 49     - 	float2 UV_OFFSET;
	 50     - 	float2 UV_ROTATION;
	 51     - 	float2 GLINT_UV_SCALE;
	 52  81   }
	 53  82   
	 54     - cbuffer PerFrameConstants
	 55     - {
	 56     - 	float3 VIEW_DIRECTION; // unneeded
	     83 + #endif
	 57     - 	float TIME; // unneeded
	 58  84   
	     85 + cbuffer ShaderConstants {
	 59     - 	float3 VIEW_POS;
	     86 + 	float4 CURRENT_COLOR;
	     87 + 	float4 DARKEN;
	 60     - 	float FAR_CHUNKS_DISTANCE;
	 61     - 	float4 FOG_COLOR;
	 62     - 
	     88 + 	float3 TEXTURE_DIMENSIONS;
	 63     - 	float2 FOG_CONTROL;
	 64     - 
	     89 + 	float4x4 UV_TRANSFORM;
	 65     - 	float RENDER_DISTANCE;
	 66     - 
	 67  90   }
	 68     - 
	 69     - 
	 70     - #if !defined(INSTANCEDSTEREO)
	 71  91   
	     92 + cbuffer WeatherConstants {
	     93 + 	float4	POSITION_OFFSET;
	     94 + 	float4	VELOCITY;
	     95 + 	float4	ALPHA;
	     96 + 	float4	VIEW_POSITION;
	     97 + 	float4	SIZE_SCALE;
	     98 + 	float4	FORWARD;
	     99 + 	float4	UV_INFO;
	    100 + 	float4  PARTICLE_BOX;
	 72     - cbuffer WorldConstants
	 73     - {
	 74     - 	float4x4 WORLDVIEWPROJ;
	 75     - 	float4x4 WORLD;
	 76     - 	float4x4 WORLDVIEW;
	 77     - 	float4x4 PROJ;
	 78 101   }
	 79     - 
	 80     - #else
	 81 102   
	 82     - cbuffer WorldConstantsStereographic
	 83     - {
	 84     - 	float4x4 WORLDVIEWPROJ_STEREO[2];
	    103 + cbuffer FlipbookTextureConstants {
	    104 + 	float1 V_OFFSET;
	    105 + 	float1 V_BLEND_OFFSET;
	 85     - 	float4x4 WORLD_STEREO;
	 86     - 	float4x4 WORLDVIEW_STEREO[2];
	 87     - 	float4x4 PROJ_STEREO[2];
	 88 106   }
	 89     - 
	 90     - #endif
	 91 107   
	 92     - cbuffer ShaderConstants
	 93     - {
	 94     - 	float4 CURRENT_COLOR;
	 95     - 	float4 DARKEN;
	    108 + cbuffer EffectsConstants {
	    109 + 	float2 EFFECT_UV_OFFSET;
	 96     - 	float2 ATLAS_FACE_SIZE;
	 97     - 	float3 TEXTURE_DIMENSIONS;
	    110 + 
	 98     - }
	 99 111   
	100     - cbuffer WeatherConstants {
	101     - 	float4	POSITION_OFFSET;
	102     - 	float4	VELOCITY;
	103     - 	float4	ALPHA;
	    112 + }
	    113 + 
	    114 + cbuffer BannerConstants {
	    115 + 	float4 BANNER_COLORS[7];
	    116 + 	float4 BANNER_UV_OFFSETS[7];
	104     - 	float4	VIEW_POSITION;
	105     - 	float4	SIZE_SCALE;
	106     - 	float4	FORWARD;
	107     - 	float4	UV_INFO;
	108     - 	float4  PARTICLE_BOX;
	109 117   }
	110 118   
	    119 + cbuffer TextConstants {
	111     - cbuffer HoloConstants
	    120 + 	float1 GLYPH_SMOOTH_RADIUS;
	    121 + 	float1 GLYPH_CUTOFF;
	    122 + 	float1 OUTLINE_CUTOFF;
	    123 + 	float4 OUTLINE_COLOR;
	112     - {
	113     - 	float4	TABLE_REVEAL_CENTER;
	114     - 	float4	TABLE_REVEAL_CONSTANTS;	// x = Radius
	115     - 
	    124 + 	float1 SHADOW_SMOOTH_RADIUS;
	116     - 	float3 GAZE_DIRECTION;
	117     - 
	    125 + 	float4 SHADOW_COLOR;
	    126 + 	float2 SHADOW_OFFSET;
	    127 + }
	    128 + cbuffer DebugConstants {
	    129 +     float TEXTURE_ARRAY_INDEX_0;
	118     - 	float4 SKIRT_UVS;
	119     - 	float4 SKIRT_UV_SCALE;
	120     - 
	121     - 	float2 CHUNK_CLIP_MIN;
	122     - 	float2 CHUNK_CLIP_MAX;
	    130 + };
	123 131   
	    132 + cbuffer InterFrameConstants {
	    133 + 	// in secs. This is reset every 2 mins. so the range is [0, 120)
	    134 + 	// make sure your shader handles the case when it transitions from 120 to 0
	    135 + 	float TOTAL_REAL_WORLD_TIME;
	    136 + };
	124     - 	float2 CLIP_MIN;
	125     - 	float2 CLIP_MAX;
	126     - }
	          '''
Added file "banner.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	#include "Util.fxh"
	
	struct PS_Input {
		float4 position : SV_Position;
	#ifdef ENABLE_LIGHT
		float4 light : LIGHT;
	#endif
	#ifdef ENABLE_FOG
		float4 fogColor : FOG_COLOR;
	#endif
	
	#ifndef DISABLE_TINTING
		float4 color : COLOR;
	#endif
	
		float2 texCoords : TEXCOORD_0_FB_MSAA;
	};
	
	struct PS_Output
	{
		float4 color : SV_Target;
	};
	
	void main( in PS_Input PSInput, out PS_Output PSOutput )
	{
		float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.texCoords);
	
	#ifndef DISABLE_TINTING
		diffuse.a = lerp(diffuse.r * diffuse.a, diffuse.a, PSInput.color.a);
		diffuse.rgb *= PSInput.color.rgb;
	#endif
	
	#ifdef ENABLE_LIGHT
		diffuse.rgb *= PSInput.light.rgb;
	#endif
	
	#ifdef ENABLE_FOG
		//apply fog
		diffuse.rgb = lerp(diffuse.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a );
	#endif
	
		//WARNING do not refactor this 
		PSOutput.color = diffuse;
	
	#ifdef VR_FEATURE
		// On Rift, the transition from 0 brightness to the lowest 8 bit value is abrupt, so clamp to 
		// the lowest 8 bit value.
		PSOutput.color = max(PSOutput.color, 1 / 255.0f);
	#endif
	}
	'''
Added file "banner.geometry.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct GeometryShaderInput
	{
		float4		pos				: SV_POSITION;
	#ifdef ENABLE_LIGHT
		float4		light			: LIGHT;
	#endif
	#ifdef ENABLE_FOG
		float4		fogColor		: FOG_COLOR;
	#endif
	#ifndef DISABLE_TINTING
		float4		color			: COLOR;
	#endif
		float2		uv				: TEXCOORD_0_FB_MSAA;
	
	#ifdef INSTANCEDSTEREO
		uint		instanceID		: SV_InstanceID;
	#endif
	};
	
	// Per-pixel color data passed through the pixel shader.
	struct GeometryShaderOutput
	{
		float4		pos				: SV_POSITION;
	#ifdef ENABLE_LIGHT
		float4		light			: LIGHT;
	#endif
	#ifdef ENABLE_FOG
		float4		fogColor		: FOG_COLOR;
	#endif
	#ifndef DISABLE_TINTING
		float4		color			: COLOR;
	#endif
		float2		uv				: TEXCOORD_0_FB_MSAA;
	
	#ifdef INSTANCEDSTEREO
		uint        renTarget_id	: SV_RenderTargetArrayIndex;
	#endif
	};
	
	// passes through the triangles, except changint the viewport id to match the instance
	[maxvertexcount(3)]
	void main(triangle GeometryShaderInput input[3], inout TriangleStream<GeometryShaderOutput> outStream)
	{
		GeometryShaderOutput output = (GeometryShaderOutput)0;
	
	#ifdef INSTANCEDSTEREO
		int i = input[0].instanceID;
	#endif
		for (int j = 0; j < 3; j++)
		{
			output.pos = input[j].pos;
			output.uv				= input[j].uv;
	#ifdef INSTANCEDSTEREO
			output.renTarget_id = i;
	#endif
	#ifdef ENABLE_LIGHT
			output.light			= input[j].light;
	#endif
	#ifdef ENABLE_FOG
			output.fogColor			= input[j].fogColor;
	#endif
	#ifndef DISABLE_TINTING
			output.color		    = input[j].color;
	#endif
			outStream.Append(output);
		}
	}
	'''
Added file "banner.vertex.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct VS_Input {
		float3 position : POSITION;
		float4 normal : NORMAL;
		float2 texCoords : TEXCOORD_0;
		float4 color : COLOR;
	
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	struct PS_Input {
		float4 position : SV_Position;
	
	#ifdef ENABLE_LIGHT
		float4 light : LIGHT;
	#endif
	#ifdef ENABLE_FOG
		float4 fogColor : FOG_COLOR;
	#endif
	
	#ifndef DISABLE_TINTING
		float4 color : COLOR;
	#endif
		float2 texCoords : TEXCOORD_0_FB_MSAA;
		
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	static const float AMBIENT = 0.45;
	
	static const float XFAC = -0.1;
	static const float ZFAC = 0.1;
	
	
	float4 TransformRGBA8_SNORM(const float4 RGBA8_SNORM) {
	#ifdef R8G8B8A8_SNORM_UNSUPPORTED
		return RGBA8_SNORM * float(2.0).xxxx - float(1.0).xxxx;
	#else
		return RGBA8_SNORM;
	#endif
	}
	
	
	float lightIntensity(const float4 position, const float4 normal) {
	#ifdef FANCY
	
	#if !defined(INSTANCEDSTEREO)
		float3 N = normalize(mul(WORLD, normal)).xyz;
	#else
		float3 N = normalize(mul(WORLD_STEREO, normal)).xyz;
	#endif
	
		N.y *= TILE_LIGHT_COLOR.a;
	
		//take care of double sided polygons on materials without culling
	#ifdef FLIP_BACKFACES
	#if !defined(INSTANCEDSTEREO)
		float3 viewDir = normalize((mul(WORLD, position)).xyz);
	#else
		float3 viewDir = normalize((mul(WORLD_STEREO, position)).xyz);
	#endif
		if (dot(N, viewDir) > 0.0) {
			N *= -1.0;
		}
	#endif
	
		float yLight = (1.0 + N.y) * 0.5;
		return yLight * (1.0 - AMBIENT) + N.x*N.x * XFAC + N.z*N.z * ZFAC + AMBIENT;
	#else
		return 1.0;
	#endif
	}
	
	void main(in VS_Input VSInput, out PS_Input PSInput) {
	#ifdef INSTANCEDSTEREO
		int i = VSInput.instanceID;
		PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], float4(VSInput.position, 1));
		PSInput.instanceID = i;
	#else
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	#endif
	
	#ifdef ENABLE_LIGHT
		float4 normal = TransformRGBA8_SNORM(VSInput.normal);
	
		float L = lightIntensity(float4(VSInput.position, 1), normal);
	
		PSInput.light = float4(L.xxx * TILE_LIGHT_COLOR.rgb, 1.0);
	#endif
	
		int frameIndex = int(VSInput.color.a * 255.0f);
		PSInput.texCoords.xy = VSInput.texCoords.xy + BANNER_UV_OFFSETS[frameIndex].xy;
	
	#ifndef DISABLE_TINTING
		PSInput.color = BANNER_COLORS[frameIndex];
		PSInput.color.a = 1.0f;
		if (frameIndex > 0) {
			PSInput.color.a = 0.0f;
		}
	#endif
	
	#ifdef ENABLE_FOG
		//fog
		PSInput.fogColor.rgb = FOG_COLOR.rgb;
		PSInput.fogColor.a = clamp(((PSInput.position.z / RENDER_DISTANCE) - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	#endif
	}
	
	'''
Added file "color_grayscale.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	// be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	
	struct PS_Input {
		float4 position : SV_Position;
		float2 uv : TEXCOORD_0;
	};
	
	struct PS_Output {
		float4 color : SV_Target;
	};
	
	void main(in PS_Input PSInput, out PS_Output PSOutput) {
		float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	
	
	#ifdef ALPHA_TEST
		if (diffuse.a < 0.5) {
			discard;
		}
	#endif
	
		float grayscale = (CURRENT_COLOR.r * diffuse.r * 0.3 + CURRENT_COLOR.g * diffuse.g * 0.59 + CURRENT_COLOR.b * diffuse.b * 0.11);
		float4 gray_color = float4(grayscale, grayscale, grayscale, CURRENT_COLOR.a * diffuse.a);
		PSOutput.color = gray_color;
	}
	
	'''
Changed file "color_texture.fragment.hlsl":
	Total line: 93 (+19, -9)
	          '''
	          ...
	 25  25   	float4 color : SV_Target;
	 26  26   };
	 27  27   
	 28  28   void main( in PS_Input PSInput, out PS_Output PSOutput )
	 29  29   {
	     30 + #ifdef EFFECTS_OFFSET
	     31 + 	float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv + EFFECT_UV_OFFSET);
	     32 + #else
	     33 + 	float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	 30     - 	float4 diffuse = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	     34 + #endif
	 31  35   
	 32  36   #ifdef ALPHA_TEST
	 33  37   
	 34  38   #ifdef ENABLE_VERTEX_TINT_MASK
	     39 + 	if( diffuse.a <= 0.0f )
	     40 + #else
	     41 + 	if (diffuse.a <= 0.5f)
	 35     - 	if( diffuse.a <= 0.0f )
	     42 + #endif
	     43 + 	{
	     44 + 		discard;
	     45 + 	}
	 36     - #else
	 37     - 	if (diffuse.a <= 0.5f)
	 38  46   #endif
	     47 + 
	     48 + #ifdef ENABLE_VERTEX_TINT_MASK
	     49 + 	diffuse.rgb = lerp(diffuse.rgb, diffuse.rgb*PSInput.color.rgb, diffuse.a);
	     50 + 	if (PSInput.color.a > 0.0f) {
	     51 + 		diffuse.a = diffuse.a > 0.0f ? 1.0f : 0.0f;
	 39     - 	{
	 40     - 		discard;
	 41  52   	}
	 42  53   #endif
	 43  54   
	 44     - #ifdef ENABLE_VERTEX_TINT_MASK
	 45     - 	diffuse.rgb = lerp(diffuse.rgb, diffuse.rgb*PSInput.color.rgb, diffuse.a);
	     55 + #ifdef GLINT
	     56 + 	float4 layer1 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layer1UV)).rgbr * GLINT_COLOR;
	     57 + 	float4 layer2 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layer2UV)).rgbr * GLINT_COLOR;
	     58 + 	float4 glint = (layer1 + layer2);
	 46     - 	if (PSInput.color.a > 0.0f) {
	 47     - 		diffuse.a = diffuse.a > 0.0f ? 1.0f : 0.0f;
	 48     - 	}
	 49     - #endif
	 50  59   
	     60 + 	#ifdef INVENTORY
	     61 + 		diffuse.rgb = glint.rgb;
	     62 + 	#else
	     63 + 		diffuse.rgb = glintBlend(diffuse, glint).rgb;
	     64 + 	#endif
	     65 + #endif
	 51     - #ifdef GLINT
	 52     - 	float4 layer1 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layer1UV)).rgbr * GLINT_COLOR;
	 53     - 	float4 layer2 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layer2UV)).rgbr * GLINT_COLOR;
	 54     - 	float4 glint = (layer1 + layer2);
	 55  66   
	     67 + #ifdef USE_OVERLAY
	 56     - 	#ifdef INVENTORY
	 57     - 		diffuse.rgb = glint.rgb;
	     68 + 		//use either the diffuse or the OVERLAY_COLOR
	     69 + 	diffuse.rgb = lerp( diffuse, OVERLAY_COLOR, OVERLAY_COLOR.a ).rgb;
	 58     - 	#else
	 59     - 		diffuse.rgb = glintBlend(diffuse, glint).rgb;
	 60     - 	#endif
	 61  70   #endif
	 62  71   
	     72 + #ifdef ENABLE_FOG
	 63     - #ifdef USE_OVERLAY
	 64     - 		//use either the diffuse or the OVERLAY_COLOR
	     73 + 	diffuse.rgb = lerp(diffuse.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a);
	 65     - 	diffuse.rgb = lerp( diffuse, OVERLAY_COLOR, OVERLAY_COLOR.a ).rgb;
	 66  74   #endif
	     75 + 
	     76 + #ifdef ENABLE_VERTEX_TINT_MASK
	 67  77   
	     78 + #ifdef ENABLE_CURRENT_ALPHA_MULTIPLY
	     79 + 	PSOutput.color = diffuse * PSInput.color.a;
	     80 + #else
	     81 + 	PSOutput.color = diffuse;
	 68     - #ifdef ENABLE_FOG
	 69     - 	diffuse.rgb = lerp(diffuse.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a);
	 70  82   #endif
	 71  83   
	 72     - #ifdef ENABLE_VERTEX_TINT_MASK
	 73     - 	PSOutput.color = diffuse;
	 74  84   #else
	 75  85   	PSOutput.color = diffuse * PSInput.color;
	 76  86   #endif
	 77  87   
	     88 + #ifdef VR_MODE
	 78     - #ifdef VR_FEATURE
	 79  89   	// On Rift, the transition from 0 brightness to the lowest 8 bit value is abrupt, so clamp to 
	 80  90   	// the lowest 8 bit value.
	 81  91   	PSOutput.color = max(PSOutput.color, 1 / 255.0f);
	 82  92   #endif
	 83  93   }
	          '''
Changed file "color_uv.geometry.hlsl":
	Total line: 72 (+6, -0)
	        '''
	        ...
	55 55   			output.color			= input[j].color;
	56 56   			output.uv0				= input[j].uv0;
	57 57   #ifdef ENABLE_FOG
	58 58   			output.fogColor			= input[j].fogColor;
	59 59   #endif
	   60 + 
	   61 + #ifdef GLINT
	   62 + 			output.layer1UV = input[j].layer1UV;
	   63 + 			output.layer2UV = input[j].layer2UV;
	   64 + #endif
	   65 + 
	60 66   #ifdef INSTANCEDSTEREO
	61 67   			output.renTarget_id = i;
	62 68   #endif
	63 69   			outStream.Append(output);
	64 70   		}
	        ...
	        '''
Changed file "color_uv.vertex.hlsl":
	Total line: 74 (+4, -0)
	        '''
	        ...
	61 61   	//fog
	62 62   	PSInput.fogColor.rgb = FOG_COLOR.rgb;
	63 63   	PSInput.fogColor.a = clamp(((PSInput.position.z / RENDER_DISTANCE) - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	64 64   #endif
	65 65   
	   66 + #ifdef USE_LIGHTING
	   67 + 	PSInput.color *= float4(TILE_LIGHT_COLOR.rgb, 1.0);
	   68 + #endif
	   69 + 
	66 70   #ifdef GLINT
	67 71   	PSInput.layer1UV = calculateLayerUV(VSInput.texCoords, UV_OFFSET.x, UV_ROTATION.x);
	68 72   	PSInput.layer2UV = calculateLayerUV(VSInput.texCoords, UV_OFFSET.y, UV_ROTATION.y);
	69 73   #endif
	70 74   }
	        '''
Added file "end_portal.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	#include "util.fxh"
	
	struct PS_Input {
		float4 position : SV_Position;
	
		#ifndef BYPASS_PIXEL_SHADER
			snorm float2 colorLookupUV : TEXCOORD_0_FB_MSAA;
			float2 parallaxUV : TEXCOORD_1_FB_MSAA;
			float4 encodedPlane : PLANE_INFO;
			#ifdef FOG
				float4 fogColor : FOG_COLOR;
			#endif
		#endif
	
		#ifdef INSTANCEDSTEREO
			uint instanceID : SV_InstanceID;
		#endif
	};
	
	struct PS_Output {
		float4 color : SV_Target;
	};
	
	static const float MAX_LAYER_DEPTH = 32.0;
	
	void main( in PS_Input PSInput, out PS_Output PSOutput ) {
		#ifdef BYPASS_PIXEL_SHADER
			PSOutput.color = float4(0.0f, 0.0f, 0.0f, 0.0f);
		#else
			///// Decode Input Values
			// Decode parallax plane data
			// Using round() because normals should all be in the standard basis
			const float planeDistance = PSInput.encodedPlane.a * MAX_LAYER_DEPTH;
	
			///// Color Assembly
			float4 colorSample = TEXTURE_1.Sample(TextureSampler1, PSInput.colorLookupUV);
			float4 textureSample = TEXTURE_0.Sample(TextureSampler0, PSInput.parallaxUV);
			const float3 brightness = textureSample.rgb * (1.0 - PSInput.encodedPlane.w);
			colorSample.rgb *= brightness;
	
			// Look for hard-coded value to clear the portal first
			#ifdef FOG
				if(planeDistance > MAX_LAYER_DEPTH - 1.0) {
					PSOutput.color = float4(PSInput.fogColor.rgb * PSInput.fogColor.a, 0.0f);
				}
				else {
					PSOutput.color = float4(colorSample.rgb * (1.0 - PSInput.fogColor.a), 1.0f);
				}
			#else
				if(planeDistance > MAX_LAYER_DEPTH - 1.0) {
					PSOutput.color = float4(0.0f, 0.0f, 0.0f, 0.0f);
				}
				else {
					PSOutput.color = float4(colorSample.rgb, 1);
				}
			#endif
		#endif
	}
	'''
Added file "end_portal.geometry.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct GeometryShaderInput
	{
		float4 pos : SV_POSITION;
		#ifndef BYPASS_PIXEL_SHADER
			snorm float2 colorLookupUV : TEXCOORD_0_FB_MSAA;
			float2 parallaxUV : TEXCOORD_1_FB_MSAA;
			float4 encodedPlane : PLANE_INFO;
			#ifdef FOG
				float4 fogColor : FOG_COLOR;
			#endif
		#endif
		#ifdef INSTANCEDSTEREO
			uint instanceID : SV_InstanceID;
		#endif
	};
	
	// Per-pixel color data passed through the pixel shader.
	struct GeometryShaderOutput
	{
		float4 pos : SV_POSITION;
		#ifndef BYPASS_PIXEL_SHADER
			snorm float2 colorLookupUV : TEXCOORD_0;
			float2 parallaxUV : TEXCOORD_1_FB_MSAA;
			float4 encodedPlane : PLANE_INFO;
			#ifdef FOG
				float4 fogColor : FOG_COLOR;
			#endif
		#endif
		#ifdef INSTANCEDSTEREO
			uint renTarget_id : SV_RenderTargetArrayIndex;
		#endif
	};
	
	// passes through the triangles, except changint the viewport id to match the instance
	[maxvertexcount(3)]
	void main(triangle GeometryShaderInput input[3], inout TriangleStream<GeometryShaderOutput> outStream)
	{
		GeometryShaderOutput output = (GeometryShaderOutput)0;
	
		#ifdef INSTANCEDSTEREO
			int i = input[0].instanceID;
		#endif
		{
			for (int j = 0; j < 3; j++)
			{
				output.pos = input[j].pos;
				#ifndef BYPASS_PIXEL_SHADER
					output.colorLookupUV = input[j].colorLookupUV;
					output.parallaxUV = input[j].parallaxUV;
					output.encodedPlane = input[j].encodedPlane;
					#ifdef FOG
						output.fogColor = input[j].fogColor;
					#endif
				#endif
	
				#ifdef INSTANCEDSTEREO
					output.renTarget_id = i;
				#endif
				outStream.Append(output);
			}
		}
	}
	'''
Added file "end_portal.vertex.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct VS_Input {
		float3 position : POSITION;
		float4 color : COLOR;
		float2 uv0 : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
		#ifdef INSTANCEDSTEREO
			uint instanceID : SV_InstanceID;
		#endif
	};
	
	
	struct PS_Input {
		float4 position : SV_Position;
	
		#ifndef BYPASS_PIXEL_SHADER
			snorm float2 colorLookupUV : TEXCOORD_0_FB_MSAA;
			float2 parallaxUV : TEXCOORD_1_FB_MSAA;
			float4 encodedPlane : PLANE_INFO;
	
			// lpfloat4 color : COLOR;
	
			// float3 eyePositionInWorld : EYE_POS;
			// float3 surfacePositionInWorld : SURFACE_POS;
	
			#ifdef FOG
				float4 fogColor : FOG_COLOR;
			#endif
		#endif
	
		#ifdef INSTANCEDSTEREO
			uint instanceID : SV_InstanceID;
		#endif
	};
	
	static const float DIST_DESATURATION = 56.0 / 255.0; //WARNING this value is also hardcoded in the water color, don'tchange
	
	static const float MAX_LAYER_DEPTH = 32.0;
	
	void main(in VS_Input VSInput, out PS_Input PSInput) {
		///// Vertex Transformation
		float3 worldPos = (VSInput.position.xyz * CHUNK_ORIGIN_AND_SCALE.w) + CHUNK_ORIGIN_AND_SCALE.xyz;
		float3 viewRay = worldPos.xyz;
	
		#ifdef INSTANCEDSTEREO
			int i = VSInput.instanceID;
	
			PSInput.position = mul(WORLDVIEW_STEREO[i], float4(worldPos, 1 ));
			PSInput.position = mul(PROJ_STEREO[i], PSInput.position);
	
			viewRay -= WORLDVIEW_STEREO[i]._m30_m31_m32;
	
			PSInput.instanceID = i;
		#else
			PSInput.position = mul(WORLDVIEW, float4( worldPos, 1 ));
			PSInput.position = mul(PROJ, PSInput.position);
		#endif
	
		#ifndef BYPASS_PIXEL_SHADER
			PSInput.encodedPlane = VSInput.color;
			PSInput.colorLookupUV = VSInput.uv0;
	
			///// Decode Input Values
			// Decode parallax plane data
			const float4 planeData = (PSInput.encodedPlane - float4(0.5, 0.5, 0.5, 0.0)) * float4(2.0, 2.0, 2.0, MAX_LAYER_DEPTH);
			const float3 planeNormal = planeData.rgb;
			const float planeDistance = planeData.a;
			
	
			///// Ray-cast for parallax-offset UV
			// Perform ray-plane intersection to find the position on the parallax plane
			float t = dot(viewRay - (planeNormal * planeDistance), planeNormal) / dot(viewRay, planeNormal);
			float3 parallaxPositionInWorld = (t * viewRay) + VIEW_POS;
	
			///// Ridiculous UV-remapping
			const float3 normalMask = abs(planeNormal);
			// Since all normals are orthonormal on <x,y,z>, mask out the correct uv result
			float2 raycastUV = parallaxPositionInWorld.yz * normalMask[0];
			raycastUV += parallaxPositionInWorld.xz * normalMask[1];
			raycastUV += parallaxPositionInWorld.xy * normalMask[2];
			// Scale the UVs to Minecraft pixel size
			raycastUV = raycastUV / 16.0;
	
			///// Color Lookup
			const float rotor = 3.1415926535897 * (5.0 / 7.0);
			float rotS = sin(planeDistance * rotor);
			float rotC = cos(planeDistance * rotor);
	
			PSInput.parallaxUV = mul(float2x2(float2(rotC, rotS), float2(-rotS, rotC)), raycastUV);
	
			///// UV Scrolling
			// Offset rotation based on a value unique to the layer
			PSInput.parallaxUV += float2(rotC, rotS) * planeDistance;
			PSInput.parallaxUV.y += TIME / 256.0;
	
			const float modVal = 64.0;
			PSInput.parallaxUV = fmod(PSInput.parallaxUV, modVal);
	
			///// Fog
			#ifdef FOG
				#ifdef FANCY
					float3 relPos = -worldPos;
					float cameraDepth = length(relPos);
				#else
					float cameraDepth = PSInput.position.z;
				#endif
				float len = cameraDepth / RENDER_DISTANCE;
				#ifdef ALLOW_FADE
					len += CURRENT_COLOR.r;
				#endif
				PSInput.fogColor.rgb = FOG_COLOR.rgb;
				PSInput.fogColor.a = clamp((len - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
			#endif
		#endif
	}
	'''
Changed file "entity.fragment.hlsl":
	Total line: 131 (+49, -24)
	          '''
	  1   1   #include "ShaderConstants.fxh"
	      2 + #include "util.fxh"
	      3 + 
	      4 + struct PS_Input {
	      5 + 	float4 position : SV_Position;
	      6 + 
	      7 + 	float4 light : LIGHT;
	      8 + 	float4 fogColor : FOG_COLOR;
	      9 + 
	     10 + #ifdef GLINT
	     11 + 	// there is some alignment issue on the Windows Phone 1320 that causes the position
	     12 + 	// to get corrupted if this is two floats and last in the struct memory wise
	     13 + 	float4 layerUV : GLINT_UVS;
	     14 + #endif
	     15 + 
	     16 + #ifdef USE_OVERLAY
	     17 + 	float4 overlayColor : OVERLAY_COLOR;
	     18 + #endif
	     19 + 
	     20 + #ifdef TINTED_ALPHA_TEST
	     21 + 	float4 alphaTestMultiplier : ALPHA_MULTIPLIER;
	     22 + #endif
	     23 + 
	     24 + 	float2 uv : TEXCOORD_0_FB_MSAA;
	  2     - #include "Util.fxh"
	  3  25   
	     26 + };
	  4     - struct PS_Input {
	  5     - 	float4 position : SV_Position;
	  6  27   
	     28 + struct PS_Output
	     29 + {
	  7     - 	float4 light : LIGHT;
	     30 + 	float4 color : SV_Target;
	  8     - 	float4 fogColor : FOG_COLOR;
	     31 + };
	  9  32   
	     33 + #ifdef USE_EMISSIVE
	     34 + #define NEEDS_DISCARD(C)	(C.a + C.r + C.g + C.b == 0.0)
	     35 + #else
	     36 + #ifndef USE_COLOR_MASK
	 10     - #ifdef GLINT
	     37 + #define NEEDS_DISCARD(C)	(C.a < 0.5)
	     38 + #else
	     39 + #define NEEDS_DISCARD(C)	(C.a == 0.0)
	     40 + #endif
	 11     - 	// there is some alignment issue on the Windows Phone 1320 that causes the position
	 12     - 	// to get corrupted if this is two floats and last in the struct memory wise
	 13     - 	float4 layerUV : GLINT_UVS;
	 14  41   #endif
	 15  42   
	     43 + float4 glintBlend(float4 dest, float4 source) {
	     44 + 	// glBlendFuncSeparate(GL_SRC_COLOR, GL_ONE, GL_ONE, GL_ZERO)
	 16     - #ifdef USE_OVERLAY
	     45 + 	return float4(source.rgb * source.rgb, source.a) + float4(dest.rgb, 0.0);
	     46 + }
	 17     - 	float4 overlayColor : OVERLAY_COLOR;
	 18     - #endif
	 19  47   
	     48 + void main( in PS_Input PSInput, out PS_Output PSOutput )
	     49 + {
	     50 + 	float4 color = float4( 1.0f, 1.0f, 1.0f, 1.0f );
	 20     - 	float2 uv : TEXCOORD_0_FB_MSAA;
	 21  51   
	     52 + #if( !defined(NO_TEXTURE) || !defined(COLOR_BASED) || defined(USE_COLOR_BLEND) )
	 22     - };
	 23  53   
	     54 + #if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE) || (VERSION < 0xa000 /*D3D_FEATURE_LEVEL_10_0*/)
	     55 + 	color = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	 24     - struct PS_Output
	     56 + #else
	     57 + 	color = texture2D_AA(TEXTURE_0, TextureSampler0, PSInput.uv);
	     58 + #endif
	 25     - {
	 26     -     float4 color : SV_Target;
	 27     - };
	 28  59   
	 29     - #ifdef USE_EMISSIVE
	 30     - #define NEEDS_DISCARD(C)	(C.a + C.r + C.g + C.b == 0.0)
	 31     - #else
	     60 + #ifdef ALPHA_TEST
	     61 + 	if( NEEDS_DISCARD( color ) )
	 32     - #ifndef USE_COLOR_MASK
	 33     - #define NEEDS_DISCARD(C)	(C.a < 0.5)
	     62 + 	{
	 34     - #else
	     63 + 		discard;
	     64 + 	}
	 35     - #define NEEDS_DISCARD(C)	(C.a <= 0.0)
	 36     - #endif
	 37  65   #endif
	 38  66   
	     67 + #ifdef TINTED_ALPHA_TEST
	     68 + 	float4 testColor = color;
	     69 + 	testColor.a = testColor.a * PSInput.alphaTestMultiplier.r;
	     70 + 	if( NEEDS_DISCARD( testColor ) )
	     71 + 	{
	     72 + 		discard;
	     73 + 	}
	 39     - float4 glintBlend(float4 dest, float4 source) {
	 40     - 	// glBlendFuncSeparate(GL_SRC_COLOR, GL_ONE, GL_ONE, GL_ZERO)
	 41     - 	return float4(source.rgb * source.rgb, source.a) + float4(dest.rgb, 0.0);
	 42     - }
	 43     - 
	 44     - void main( in PS_Input PSInput, out PS_Output PSOutput )
	 45     - {
	     74 + #endif
	 46     - 	float4 color = float4( 1.0f, 1.0f, 1.0f, 1.0f );
	 47  75   
	     76 + #endif
	 48     - #ifndef COLOR_BASED
	 49  77   
	     78 + #ifdef USE_COLOR_MASK
	 50     - #if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE) || (VERSION < 0xa000 /*D3D_FEATURE_LEVEL_10_0*/)
	 51     - 	color = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	     79 + 	color.rgb = lerp( color, color * CHANGE_COLOR, color.a ).rgb;
	     80 + 	color.a *= CHANGE_COLOR.a;
	 52     - #else
	 53     - 	color = texture2D_AA(TEXTURE_0, TextureSampler0, PSInput.uv);
	 54  81   #endif
	 55  82   
	 56     - #ifdef ALPHA_TEST
	 57     - 	if( NEEDS_DISCARD( color ) )
	 58     - 	{
	     83 + #ifdef ITEM_IN_HAND
	     84 + 	color.rgb = lerp(color, color * CHANGE_COLOR, PSInput.light.a).rgb;
	 59     - 		discard;
	 60     - 	}
	 61  85   #endif
	 62  86   
	     87 + #ifdef USE_MULTITEXTURE
	     88 + 	float4 tex1 = TEXTURE_1.Sample(TextureSampler1, PSInput.uv);
	     89 + 	float4 tex2 = TEXTURE_2.Sample(TextureSampler2, PSInput.uv);
	     90 + 	color.rgb = lerp(color.rgb, tex1, tex1.a);
	 63     - #endif
	 64     - 
	     91 + #ifdef COLOR_SECOND_TEXTURE
	 65     - #ifdef USE_COLOR_MASK
	     92 + 	if (tex2.a > 0.0f) {
	     93 + 		color.rgb = lerp(tex2.rgb, tex2 * CHANGE_COLOR, tex2.a);
	 66     - 	color.rgb = lerp( color, color * CHANGE_COLOR, color.a ).rgb;
	     94 + 	}
	     95 + #else
	     96 + 	color.rgb = lerp(color.rgb, tex2, tex2.a);
	 67     - 	color.a = 1.0;
	 68  97   #endif
	 69     - 
	 70     - #ifdef ITEM_IN_HAND
	 71     - 	color.rgb = lerp(color, color * CHANGE_COLOR, PSInput.light.a).rgb;
	 72  98   #endif
	 73     - 
	 74  99   
	 75 100   #ifdef USE_OVERLAY
	 76 101   	//use either the diffuse or the OVERLAY_COLOR
	 77 102   	color.rgb = lerp( color, PSInput.overlayColor, PSInput.overlayColor.a ).rgb;
	 78 103   #endif
	          ...
	 82 107   	color *= lerp( float( 1.0 ).xxxx, PSInput.light, color.a );
	 83 108   #else
	 84 109   	color *= PSInput.light;
	 85 110   #endif
	 86 111   
	    112 + 	//apply fog
	    113 + 	color.rgb = lerp( color.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a );
	 87     -     //apply fog
	 88     -     color.rgb = lerp( color.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a );
	 89 114   
	 90 115   #ifdef GLINT
	 91 116   	// Applies color mask to glint texture instead and blends with original color
	 92 117   	float4 layer1 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layerUV.xy)).rgbr * GLINT_COLOR;
	 93 118   	float4 layer2 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layerUV.zw)).rgbr * GLINT_COLOR;
	 94 119   	float4 glint = (layer1 + layer2) * TILE_LIGHT_COLOR;
	 95 120   	color = glintBlend(color, glint);
	 96 121   #endif
	 97 122   
	    123 + 	//WARNING do not refactor this 
	    124 + 	PSOutput.color = color;
	 98     -     //WARNING do not refactor this 
	 99     -     PSOutput.color = color;
	100 125   
	    126 + #ifdef VR_MODE
	101     - #ifdef VR_FEATURE
	102 127   	// On Rift, the transition from 0 brightness to the lowest 8 bit value is abrupt, so clamp to 
	103 128   	// the lowest 8 bit value.
	104 129   	PSOutput.color = max(PSOutput.color, 1 / 255.0f);
	105 130   #endif
	106 131   }
	          '''
Changed file "entity.geometry.hlsl":
	Total line: 83 (+15, -4)
	        '''
	        ...
	12 12   
	13 13   #ifdef USE_OVERLAY
	14 14   	float4		overlayColor	: OVERLAY_COLOR;
	15 15   #endif
	16 16   
	   17 + #ifdef TINTED_ALPHA_TEST
	   18 + 	float4 alphaTestMultiplier : ALPHA_MULTIPLIER;
	   19 + #endif
	   20 + 
	   21 + 	float2		uv				: TEXCOORD_0_FB_MSAA;
	17    - 	float2		uv0				: TEXCOORD_0;
	18 22   #ifdef INSTANCEDSTEREO
	19 23   	uint		instanceID		: SV_InstanceID;
	20 24   #endif
	21 25   };
	22 26   
	23 27   // Per-pixel color data passed through the pixel shader.
	24 28   struct GeometryShaderOutput
	25 29   {
	26 30   	float4		pos				: SV_POSITION;
	27 31   	float4		light			: LIGHT;
	   32 + 	float4		fogColor		: FOG_COLOR;
	   33 + 
	   34 + #ifdef GLINT
	   35 + 	float4		layerUV			: GLINT_UVS;
	28    - 	float4		fogColor		: FOG_COLOR;
	   36 + #endif
	29 37   
	   38 + #ifdef USE_OVERLAY
	30    - #ifdef GLINT
	   39 + 	float4		overlayColor	: OVERLAY_COLOR;
	31    - 	float4		layerUV			: GLINT_UVS;
	32 40   #endif
	33 41   
	   42 + #ifdef TINTED_ALPHA_TEST
	34    - #ifdef USE_OVERLAY
	   43 + 	float4 alphaTestMultiplier : ALPHA_MULTIPLIER;
	35    - 	float4		overlayColor	: OVERLAY_COLOR;
	36 44   #endif
	37 45   
	   46 + 	float2		uv				: TEXCOORD_0_FB_MSAA;
	38    - 	float2		uv0				: TEXCOORD_0;
	39 47   #ifdef INSTANCEDSTEREO
	40 48   	uint        renTarget_id	: SV_RenderTargetArrayIndex;
	41 49   #endif
	42 50   };
	43 51   
	        ...
	50 58   #ifdef INSTANCEDSTEREO
	51 59   	int i = input[0].instanceID;
	52 60   #endif
	53 61   	for (int j = 0; j < 3; j++)
	54 62   	{
	   63 + 		output.pos = input[j].pos;
	   64 + #ifndef NO_TEXTURE
	   65 + 		output.uv				= input[j].uv;
	55    - 		output.pos = input[j].pos;
	   66 + #endif
	   67 + #ifdef INSTANCEDSTEREO
	   68 + 		output.renTarget_id = i;
	56    - #ifndef COLOR_BASED
	57    - 		output.uv0				= input[j].uv0;
	58 69   #endif
	   70 + 		output.light			= input[j].light;
	   71 + 		output.fogColor			= input[j].fogColor;
	   72 + #ifdef USE_OVERLAY
	   73 + 		output.overlayColor		= input[j].overlayColor;
	59    - #ifdef INSTANCEDSTEREO
	60    - 		output.renTarget_id = i;
	61 74   #endif
	62    - 		output.light			= input[j].light;
	63    - 		output.fogColor			= input[j].fogColor;
	   75 + #ifdef TINTED_ALPHA_TEST
	   76 + 		output.alphaTestMultiplier = input[j].alphaTestMultiplier;
	64    - #ifdef USE_OVERLAY
	65    - 		output.overlayColor		= input[j].overlayColor;
	66 77   #endif
	67 78   #ifdef GLINT
	68 79   		output.layerUV			= input[j].layerUV;
	69 80   #endif
	70 81   		outStream.Append(output);
	        ...
	        '''
Changed file "entity.vertex.hlsl":
	Total line: 148 (+43, -31)
	          '''
	          ...
	 27  27   
	 28  28   #ifdef USE_OVERLAY
	 29  29   	float4 overlayColor : OVERLAY_COLOR;
	 30  30   #endif
	 31  31   
	     32 + #ifdef TINTED_ALPHA_TEST
	     33 + 	// With MSAA Enabled, making this field a float results in a DX11 internal compiler error
	     34 + 	// We assume it is trying to pack the single float with the centroid-interpolated UV coordinates, which it can't do
	     35 + 	float4 alphaTestMultiplier : ALPHA_MULTIPLIER;
	     36 + #endif
	     37 + 
	     38 + 	float2 uv : TEXCOORD_0_FB_MSAA;
	     39 + 	
	     40 + #ifdef INSTANCEDSTEREO
	     41 + 	uint instanceID : SV_InstanceID;
	     42 + #endif
	     43 + };
	     44 + 
	     45 + static const float AMBIENT = 0.45;
	     46 + 
	     47 + static const float XFAC = -0.1;
	     48 + static const float ZFAC = 0.1;
	     49 + 
	 32     - 	float2 uv : TEXCOORD_0_FB_MSAA;
	 33  50   
	     51 + float4 TransformRGBA8_SNORM(const float4 RGBA8_SNORM) {
	     52 + #ifdef R8G8B8A8_SNORM_UNSUPPORTED
	     53 + 	return RGBA8_SNORM * float(2.0).xxxx - float(1.0).xxxx;
	     54 + #else
	     55 + 	return RGBA8_SNORM;
	 34     - #ifdef INSTANCEDSTEREO
	 35     - 	uint instanceID : SV_InstanceID;
	 36  56   #endif
	     57 + }
	     58 + 
	 37     - };
	 38  59   
	     60 + float lightIntensity(const float4 position, const float4 normal) {
	     61 + #ifdef FANCY
	 39     - static const float AMBIENT = 0.45;
	 40  62   
	     63 + #if !defined(INSTANCEDSTEREO)
	     64 + 	float3 N = normalize(mul(WORLD, normal)).xyz;
	     65 + #else
	     66 + 	float3 N = normalize(mul(WORLD_STEREO, normal)).xyz;
	     67 + #endif
	 41     - static const float XFAC = -0.1;
	 42     - static const float ZFAC = 0.1;
	 43  68   
	     69 + 	N.y *= TILE_LIGHT_COLOR.a;
	 44  70   
	     71 + 	//take care of double sided polygons on materials without culling
	     72 + #ifdef FLIP_BACKFACES
	 45     - float4 TransformRGBA8_SNORM(const float4 RGBA8_SNORM) {
	     73 + #if !defined(INSTANCEDSTEREO)
	     74 + 	float3 viewDir = normalize((mul(WORLD, position)).xyz);
	 46     - #ifdef R8G8B8A8_SNORM_UNSUPPORTED
	 47     - 	return RGBA8_SNORM * float(2.0).xxxx - float(1.0).xxxx;
	 48  75   #else
	     76 + 	float3 viewDir = normalize((mul(WORLD_STEREO, position)).xyz);
	 49     - 	return RGBA8_SNORM;
	 50  77   #endif
	     78 + 	if (dot(N, viewDir) > 0.0) {
	 51     - }
	 52     - 
	     79 + 		N *= -1.0;
	     80 + 	}
	     81 + #endif
	 53     - 
	 54     - float lightIntensity(const float4 position, const float4 normal) {
	 55     - #ifdef FANCY
	 56  82   
	     83 + 	float yLight = (1.0 + N.y) * 0.5;
	 57     - #if !defined(INSTANCEDSTEREO)
	     84 + 	return yLight * (1.0 - AMBIENT) + N.x*N.x * XFAC + N.z*N.z * ZFAC + AMBIENT;
	 58     - 	float3 N = normalize(mul(WORLD, normal)).xyz;
	 59  85   #else
	     86 + 	return 1.0;
	 60     - 	float3 N = normalize(mul(WORLD_STEREO, normal)).xyz;
	 61  87   #endif
	     88 + }
	 62     - 
	 63     - 	N.y *= TILE_LIGHT_COLOR.a;
	 64  89   
	 65     - 	//take care of double sided polygons on materials without culling
	 66     - #ifdef FLIP_BACKFACES
	 67     - #if !defined(INSTANCEDSTEREO)
	 68     - 	float3 viewDir = normalize((mul(WORLD, position)).xyz);
	 69     - #else
	     90 + #ifdef GLINT
	     91 + float2 calculateLayerUV(float2 origUV, float offset, float rotation) {
	     92 + 	float2 uv = origUV;
	     93 + 	uv -= 0.5;
	 70     - 	float3 viewDir = normalize((mul(WORLD_STEREO, position)).xyz);
	 71     - #endif
	 72     - 	if (dot(N, viewDir) > 0.0) {
	 73     - 		N *= -1.0;
	 74     - 	}
	 75     - #endif
	 76     - 
	     94 + 	float rsin = sin(rotation);
	 77     - 	float yLight = (1.0 + N.y) * 0.5;
	 78     - 	return yLight * (1.0 - AMBIENT) + N.x*N.x * XFAC + N.z*N.z * ZFAC + AMBIENT;
	     95 + 	float rcos = cos(rotation);
	     96 + 	uv = mul(uv, float2x2(rcos, -rsin, rsin, rcos));
	     97 + 	uv.x += offset;
	     98 + 	uv += 0.5;
	 79     - #else
	 80     - 	return 1.0;
	 81     - #endif
	 82     - }
	 83  99   
	 84     - #ifdef GLINT
	 85     - float2 calculateLayerUV(float2 origUV, float offset, float rotation) {
	    100 + 	return uv * GLINT_UV_SCALE;
	 86     - 	float2 uv = origUV;
	    101 + }
	    102 + #endif
	    103 + 
	    104 + void main(in VS_Input VSInput, out PS_Input PSInput) {
	    105 + #ifdef INSTANCEDSTEREO
	    106 + 	int i = VSInput.instanceID;
	    107 + 	PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], float4(VSInput.position, 1));
	    108 + 	PSInput.instanceID = i;
	    109 + #else
	    110 + 	PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	 87     - 	uv -= 0.5;
	 88     - 	float rsin = sin(rotation);
	 89     - 	float rcos = cos(rotation);
	 90     - 	uv = mul(uv, float2x2(rcos, -rsin, rsin, rcos));
	 91     - 	uv.x += offset;
	 92     - 	uv += 0.5;
	 93     - 
	 94     - 	return uv * GLINT_UV_SCALE;
	 95     - }
	 96 111   #endif
	    112 + 	float4 normal = TransformRGBA8_SNORM(VSInput.normal);
	    113 + 
	    114 + 	float L = lightIntensity(float4(VSInput.position, 1), normal);
	 97 115   
	 98     - void main(in VS_Input VSInput, out PS_Input PSInput) {
	    116 + #ifdef USE_OVERLAY
	 99     - #ifdef INSTANCEDSTEREO
	    117 + 	L += OVERLAY_COLOR.a * 0.35;
	    118 + 	PSInput.overlayColor = OVERLAY_COLOR;
	    119 + #endif
	    120 + 
	    121 + #ifdef TINTED_ALPHA_TEST
	    122 + 	PSInput.alphaTestMultiplier = OVERLAY_COLOR.aaaa;
	100     - 	int i = VSInput.instanceID;
	101     - 	PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], float4(VSInput.position, 1));
	102     - 	PSInput.instanceID = i;
	103     - #else
	104     - 	PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	105 123   #endif
	106     - 	float4 normal = TransformRGBA8_SNORM(VSInput.normal);
	107 124   
	    125 + 	PSInput.light = float4(L.xxx * TILE_LIGHT_COLOR.rgb, 1.0);
	108     - 	float L = lightIntensity(float4(VSInput.position, 1), normal);
	109 126   
	    127 + #ifdef COLOR_BASED
	110     - #ifdef USE_OVERLAY
	111     - 	L += OVERLAY_COLOR.a * 0.35;
	    128 + 	PSInput.light *= VSInput.color;
	112     - 	PSInput.overlayColor = OVERLAY_COLOR;
	113 129   #endif
	114     - 
	115     - 	PSInput.light = float4(L.xxx * TILE_LIGHT_COLOR.rgb, 1.0);
	116 130   
	117     - #ifdef COLOR_BASED
	118     - 	PSInput.light *= VSInput.color;
	    131 + #if( !defined(NO_TEXTURE) || !defined(COLOR_BASED) || defined(USE_COLOR_BLEND) )
	119     - #else
	120 132   	PSInput.uv = VSInput.texCoords;
	121 133   #endif
	122 134   
	123 135   #ifdef USE_UV_ANIM
	    136 + 	PSInput.uv.xy = UV_ANIM.xy + (PSInput.uv.xy * UV_ANIM.zw);
	124     - 	PSInput.uv.xy += UV_ANIM.xy;
	125 137   #endif
	126 138   
	127 139   #ifdef GLINT
	128 140   	PSInput.layerUV.xy = calculateLayerUV(VSInput.texCoords, UV_OFFSET.x, UV_ROTATION.x);
	129 141   	PSInput.layerUV.zw = calculateLayerUV(VSInput.texCoords, UV_OFFSET.y, UV_ROTATION.y);
	          ...
	          '''
Removed file "hologram_sr.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct PS_Input
	{
	    float4 position : SV_Position;
	    float4 color : COLOR;
	};
	
	struct PS_Output
	{
	    float4 color : SV_Target;
	};
	
	void main( in PS_Input PSInput, out PS_Output PSOutput )
	{
	    PSOutput.color = PSInput.color;
	}
	'''
Removed file "hologram_sr.geometry.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct GeometryShaderInput
	{
		float4	pos				: SV_POSITION;
		float4	color			: COLOR;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	// Per-pixel color data passed through the pixel shader.
	struct GeometryShaderOutput
	{
		float4	pos				: SV_POSITION;
		float4	color			: COLOR;
	#ifdef INSTANCEDSTEREO
		uint        renTarget_id : SV_RenderTargetArrayIndex;
	#endif
	};
	
	// passes through the triangles, except changint the viewport id to match the instance
	[maxvertexcount(3)]
	void main(triangle GeometryShaderInput input[3], inout TriangleStream<GeometryShaderOutput> outStream)
	{
		GeometryShaderOutput output = (GeometryShaderOutput)0;
	
	#ifdef INSTANCEDSTEREO
		int i = input[0].instanceID;
	#endif
		for (int j = 0; j < 3; j++)
		{
			output.pos = input[j].pos;
			output.color			= input[j].color;
	#ifdef INSTANCEDSTEREO
			output.renTarget_id = i;
	#endif
			outStream.Append(output);
		}
	}
	'''
Removed file "hologram_sr.vertex.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct VS_Input
	{
		float3 position : POSITION;
		float4 normal : NORMAL;
		float4 color : COLOR;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	struct PS_Input
	{
		float4 position : SV_Position;
		float4 color : COLOR;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	void main( in VS_Input VSInput, out PS_Input PSInput )
	{
		PSInput.color = VSInput.color * 0.5f + -0.5f * dot(VSInput.normal, float4(GAZE_DIRECTION, 0.0f));
	#ifdef INSTANCEDSTEREO
		int i = VSInput.instanceID;
		PSInput.position = mul( WORLDVIEWPROJ_STEREO[i], float4( VSInput.position, 1.0f ) );
		PSInput.instanceID = i;
	#else
		PSInput.position = mul( WORLDVIEWPROJ, float4( VSInput.position, 1.0f ) );
	#endif
	}
	'''
Removed file "holoroom_inner_skirt.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct PS_Input
	{
		float4 position : SV_Position;
		float4 color : COLOR;
		float2 uv : TEXCOORD_0;
	};
	
	struct PS_Output
	{
		float4 color : SV_Target;
	};
	
	void main( in PS_Input PSInput, out PS_Output PSOutput )
	{
		float2 uv = PSInput.uv * SKIRT_UV_SCALE.xy;
		uv = frac(uv);
		uv = uv * SKIRT_UVS.zw + SKIRT_UVS.xy;
		PSOutput.color = TEXTURE_0.Sample( TextureSampler0, uv ) * PSInput.color.r;
		PSOutput.color.rgb *= TEXTURE_1.Sample(TextureSampler1, PSInput.color.gr).rgb;
	}
	'''
Removed file "holoroom_inner_skirt.geometry.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct GeometryShaderInput
	{
		float4		pos				: SV_POSITION;
		float4		color			: COLOR;
		float2		uv0				: TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	// Per-pixel color data passed through the pixel shader.
	struct GeometryShaderOutput
	{
		float4		pos				: SV_POSITION;
		float4		color			: COLOR;
		float2		uv0				: TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
		uint        renTarget_id	: SV_RenderTargetArrayIndex;
	#endif
	};
	
	// Takes verts in world space and transforms them by two different view 
	// proj matrices, on two different viewports.
	[maxvertexcount(6)]
	void main(triangle GeometryShaderInput input[3], inout TriangleStream<GeometryShaderOutput> outStream)
	{
		GeometryShaderOutput output = (GeometryShaderOutput)0;
	
	#ifdef INSTANCEDSTEREO
		int i = input[0].instanceID;
	#endif
		{
			for (int j = 0; j < 3; j++)
			{
				output.pos = input[j].pos;
				output.color			= input[j].color;
				output.uv0				= input[j].uv0;
	#ifdef INSTANCEDSTEREO
				output.renTarget_id = i;
	#endif
				outStream.Append(output);
			}
		}
	}
	'''
Removed file "holoroom_inner_skirt.vertex.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct VS_Input
	{
		float3 position : POSITION;
		float4 color : COLOR;
		float2 texCoords : TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	struct PS_Input
	{
		float4 position : SV_Position;
		float4 color : COLOR;
		float2 texCoords : TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	void main( in VS_Input VSInput, out PS_Input PSInput )
	{
		PSInput.color = VSInput.color;
	
	#ifdef INSTANCEDSTEREO
		int i = VSInput.instanceID;
		PSInput.position = mul( WORLDVIEWPROJ_STEREO[i], float4( VSInput.position, 1 ) );
		PSInput.instanceID = i;
	#else
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	#endif
		PSInput.texCoords = VSInput.texCoords;
	
	}
	'''
Removed file "holoroom_tableSurface.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct PS_Input
	{
		float4 position : SV_Position;
		float3 color : COLOR;
		float2 uv : TEXCOORD_0;
	
	};
	
	struct PS_Output
	{
		float4 color : SV_Target;
	};
	
	void main( in PS_Input PSInput, out PS_Output PSOutput )
	{
		float4 diffuse = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
		//diffuse.rgb *= TEXTURE_1.Sample(TextureSampler1, float2(0, PSInput.color.a)).rgb;
		//diffuse.rgb *= float3(151.0f/255.0f, 59.0f/255.0f, 224.0f/255.0f);
		diffuse.rgb *= PSInput.color.rgb;
	
		PSOutput.color = diffuse;
	}
	'''
Removed file "holoroom_tableSurface.geometry.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct GeometryShaderInput
	{
		float4		pos				: SV_POSITION;
		float4		color			: COLOR;
		float2		uv0				: TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	// Per-pixel color data passed through the pixel shader.
	struct GeometryShaderOutput
	{
		float4		pos				: SV_POSITION;
		float4		color			: COLOR;
		float2		uv0				: TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
		uint        renTarget_id : SV_RenderTargetArrayIndex;
	#endif
	};
	
	// passes through the triangles, except changint the viewport id to match the instance
	[maxvertexcount(3)]
	void main(triangle GeometryShaderInput input[3], inout TriangleStream<GeometryShaderOutput> outStream)
	{
		GeometryShaderOutput output = (GeometryShaderOutput)0;
	
	#ifdef INSTANCEDSTEREO
		int i = input[0].instanceID;
	#endif
		{
			for (int j = 0; j < 3; j++)
			{
				output.pos = input[j].pos;
				output.color			= input[j].color;
				output.uv0				= input[j].uv0;
	#ifdef INSTANCEDSTEREO
				output.renTarget_id = i;
	#endif
				outStream.Append(output);
			}
		}
	}
	'''
Removed file "holoroom_tableSurface.vertex.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct VS_Input
	{
		float3 position : POSITION;
		float3 normal : NORMAL;
		float4 color : COLOR;
		float2 texCoords : TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	struct PS_Input
	{
		float4 position : SV_Position;
		float4 color : COLOR;
		float2 texCoords : TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	void main( in VS_Input VSInput, out PS_Input PSInput )
	{
		PSInput.color = VSInput.color;
		float3 position = VSInput.position;
		float3 voxelCenter = VSInput.normal * 80.0f - float3(40.0f, 40.0f, 40.0f);
		voxelCenter.y = -0.5f;
		float2 delta = voxelCenter.xz - TABLE_REVEAL_CENTER.xz;
		float lengthSq = dot(delta, delta);
	
		if (lengthSq > (TABLE_REVEAL_CONSTANTS.x * TABLE_REVEAL_CONSTANTS.x)) {
			position = float3(0.0f, 0.0f, 0.0f);
		}
		else if (TABLE_REVEAL_CONSTANTS.y > 0.0f && VSInput.normal.y > 0.0f && lengthSq < (TABLE_REVEAL_CONSTANTS.y * TABLE_REVEAL_CONSTANTS.y)) {
			float fallAmount = TABLE_REVEAL_CONSTANTS.y*TABLE_REVEAL_CONSTANTS.y - lengthSq;
			position.y -= fallAmount * 0.1f;
		}
	
	#ifdef INSTANCEDSTEREO
		int i = VSInput.instanceID;
		PSInput.position = mul( WORLDVIEWPROJ_STEREO[i], float4( position, 1 ) );
		PSInput.instanceID = i;
	#else
		PSInput.position = mul(WORLDVIEWPROJ, float4(position, 1));
	#endif
		PSInput.texCoords = VSInput.texCoords;
	}
	'''
Removed file "holoroom_terrain_endcap.fragment.hlsl":
	'''
	//$ANTCOLONY
	
	#include "ShaderConstants.fxh"
	
	struct PS_Input
	{
		float4 position : SV_Position;
		float4	color			: COLOR;
		float2 uv0 : TEXCOORD_0;
		float4 uv1 : TEXCOORD_1;
	};
	
	struct PS_Output
	{
		float4 color : SV_Target;
	};
	
	void main(in PS_Input PSInput, out PS_Output PSOutput)
	{
		float2 uv = PSInput.uv1.xy + (PSInput.uv0 - floor(PSInput.uv0)) * PSInput.uv1.zw;
		float4 diffuse = TEXTURE_0.Sample(TextureSampler0, uv);
		float2 lightingUVs = float2(0.0f, 0.9f);
		diffuse.rgb *= TEXTURE_1.Sample(TextureSampler1, lightingUVs).rgb;
	
		if (diffuse.a < 0.5f)
		{
			discard;
		}
	
		diffuse *= PSInput.color;
		PSOutput.color = diffuse;
	}
	'''
Removed file "holoroom_terrain_endcap.geometry.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct GeometryShaderInput
	{
		float4	pos				: SV_POSITION;
		float4		color			: COLOR;
		float2		uv0				: TEXCOORD_0;
		float4		uv1				: TEXCOORD_1;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	// Per-pixel color data passed through the pixel shader.
	struct GeometryShaderOutput
	{
		float4		pos				: SV_POSITION;
		float4		color			: COLOR;
		float2		uv0				: TEXCOORD_0;
		float4		uv1				: TEXCOORD_1;
	#ifdef INSTANCEDSTEREO
		uint			renTarget_id	: SV_RenderTargetArrayIndex;
	#endif
	};
	
	// Takes verts in world space and transforms them by two different view 
	// proj matrices, on two different viewports.
	[maxvertexcount(6)]
	void main(triangle GeometryShaderInput input[3], inout TriangleStream<GeometryShaderOutput> outStream)
	{
		GeometryShaderOutput output = (GeometryShaderOutput)0;
	
	#ifdef INSTANCEDSTEREO
		int i = input[0].instanceID;
	#endif
		{
			for (int j = 0; j < 3; j++)
			{
				output.pos = input[j].pos;
				output.color			= input[j].color;
				output.uv0				= input[j].uv0;
				output.uv1				= input[j].uv1;
	#ifdef INSTANCEDSTEREO
				output.renTarget_id = i;
	#endif
				outStream.Append(output);
			}
			//outStream.RestartStrip();
		}
	}
	'''
Removed file "holoroom_terrain_endcap.vertex.hlsl":
	'''
	//$ANTCOLONY
	#include "ShaderConstants.fxh"
	
	struct VS_Input
	{
		float3 position : POSITION;
		float2 uv0 : TEXCOORD_0;	// x,y 0-1 based off if voxel texture wasn't in atlas. Can multiply against atlas UV's to get atlas uv's
		float2 uv1 : TEXCOORD_1;	// x = voxel coord x, y = voxel coord y
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	struct PS_Input
	{
		float4 position : SV_Position;
		float4	color			: COLOR;
		float2 uv0 : TEXCOORD_0;
		float4 uvRect : TEXCOORD_1;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	Texture2D<float4> TILE_UV_MAP : register (t1);
	
	void main( in VS_Input VSInput, out PS_Input PSInput )
	{
		float3 position = VSInput.position.xyz;
	
		int2 tileUVs = int2(0, VSInput.uv1.x * 255.0f);
		float4 uvCoords = TEXTURE_1[tileUVs];
	
		tileUVs.x = 4.0f;
		float4 colorVal = TEXTURE_1[tileUVs];
	
		PSInput.uv0 = VSInput.uv0 * float2(1.0f, 127.0f);
		PSInput.uvRect = uvCoords;
	
	#ifdef INSTANCEDSTEREO
		int i = VSInput.instanceID;
		PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], float4(position.xyz, 1));
		PSInput.instanceID = i;
	#else
		PSInput.position = mul(WORLDVIEWPROJ, float4(position.xyz, 1));
	#endif
		PSInput.color = colorVal;
	}
	'''
Added file "levelstage_copy_vr.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct PS_Input
	{
	    float4 position : SV_Position;
	    float2 uv : TEXCOORD_0;
	};
	
	struct PS_Output
	{
	    float4 color : SV_Target;
	};
	
	void main( in PS_Input PSInput, out PS_Output PSOutput )
	{
		// when copying the levelstage texture for the rift overlay, we need to ensure alpha is 1, and
		// convert from linear space to SRGB
	
	    PSOutput.color = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
		PSOutput.color.a = 1.0;
		PSOutput.color = pow(PSOutput.color, 2.2); // conversion to srgb
	
	}
	'''
Changed file "position.vertex.hlsl":
	Total line: 30 (+0, -0)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3  3   struct VS_Input
	 4  4   {
	    5 + 	float3 position : POSITION;
	 5    -     float3 position : POSITION;
	 6  6   #ifdef INSTANCEDSTEREO
	 7  7   	uint instanceID : SV_InstanceID;
	 8  8   #endif
	 9  9   };
	10 10   
	11 11   
	12 12   struct PS_Input
	13 13   {
	   14 + 	float4 position : SV_Position;
	14    -     float4 position : SV_Position;
	15 15   #ifdef INSTANCEDSTEREO
	16 16   	uint instanceID : SV_InstanceID;
	17 17   #endif
	18 18   };
	19 19   
	        ...
	        '''
Changed file "rain_snow.fragment.hlsl":
	Total line: 56 (+19, -2)
	        '''
	        ...
	19 19   	PSOutput.color.a *= PSInput.color.a;
	20 20   
	21 21   	float2 uv = PSInput.worldPosition.xz;
	22 22   	float4 occlusionTexture = TEXTURE_1.Sample(TextureSampler1, uv);
	23 23   
	   24 + #ifndef FLIP_OCCLUSION
	   25 + #define OCCLUSION_OPERATOR <
	   26 + #else
	   27 + #define OCCLUSION_OPERATOR >
	   28 + #endif
	   29 + 
	   30 + #ifdef SNOW
	   31 + #define OCCLUSION_HEIGHT occlusionTexture.g
	   32 + #define OCCLUSION_LUMINANCE occlusionTexture.r
	   33 + #else
	   34 + #define OCCLUSION_HEIGHT occlusionTexture.a
	   35 + #define OCCLUSION_LUMINANCE occlusionTexture.b
	   36 + #endif
	   37 + 
	   38 + 	// clamp the uvs
	   39 + 	if (uv.x >= 0.0f && uv.x <= 1.0f && 
	   40 + 		uv.y >= 0.0f && uv.y <= 1.0f && 
	   41 + 		PSInput.worldPosition.y OCCLUSION_OPERATOR OCCLUSION_HEIGHT) {
	   42 + 		PSOutput.color.a = 0.0f;
	   43 + 	}
	   44 + 
	24    - 	// clamp the uvs
	25    - 	if (uv.x >= 0.0f && uv.x <= 1.0f && 
	26    - 		uv.y >= 0.0f && uv.y <= 1.0f && 
	   45 + 	float mixAmount = (PSInput.worldPosition.y - OCCLUSION_HEIGHT)*25.0f;
	   46 + 	float2 lightingUVs = float2(OCCLUSION_LUMINANCE, 1.0f);
	   47 + 	lightingUVs.x = lerp(lightingUVs.x, 0.0f, mixAmount);
	27    - 		PSInput.worldPosition.y < occlusionTexture.a) {
	28    - 		PSOutput.color.a = 0.0f;
	29    - 	}
	30 48   
	31    - 	float mixAmount = saturate((PSInput.worldPosition.y - occlusionTexture.a)*10.0f);
	   49 + 	float3 lighting = TEXTURE_2.Sample(TextureSampler2, lightingUVs);
	32    - 	float3 lighting = lerp(occlusionTexture.rgb, PSInput.color.rgb, mixAmount);
	33 50   	PSOutput.color.rgb *= lighting.rgb;
	34 51   
	35 52   	//apply fog
	36 53   	PSOutput.color.rgb = lerp(PSOutput.color.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a);
	37 54   }
	        ...
	        '''
Changed file "rain_snow.geometry.hlsl":
	Total line: 52 (+0, -16)
	        '''
	        ...
	25 25   #ifdef INSTANCEDSTEREO
	26 26   	uint renTarget_id : SV_RenderTargetArrayIndex;
	27 27   #endif
	28 28   };
	29 29   
	30    - bool inBounds(float3 worldPos)
	31    - {
	32    - 	bool inBounds = true;
	33    - 	if (worldPos.x < CLIP_MIN.x ||
	34    - 		worldPos.x > CLIP_MAX.x ||
	35    - 		worldPos.z < CLIP_MIN.y ||
	36    - 		worldPos.z > CLIP_MAX.y)
	37    - 	{
	38    - 		inBounds = false;
	39    - 	}
	40    - 
	41    - 	return inBounds;
	42    - }
	43    - 
	44 30   // passes through the triangles, except changint the viewport id to match the instance
	45 31   [maxvertexcount(3)]
	46 32   void main(triangle GeometryShaderInput input[3], inout TriangleStream<GeometryShaderOutput> outStream)
	47 33   {
	48 34   	GeometryShaderOutput output = (GeometryShaderOutput)0;
	49 35   
	50 36   #ifdef INSTANCEDSTEREO
	51 37   	int i = input[0].instanceID;
	52 38   #endif
	53    - //	if (inBounds(input[0].worldPositionActual) || inBounds(input[1].worldPositionActual) || inBounds(input[2].worldPositionActual)) {
	54    - 
	55 39   		for (int j = 0; j < 3; j++)	{
	56 40   			output.position = input[j].position;
	57 41   			output.uv = input[j].uv;
	58 42   			output.color = input[j].color;
	59 43   			output.worldPosition = input[j].worldPosition;
	        ...
	        '''
Changed file "rain_snow.vertex.hlsl":
	Total line: 89 (+14, -6)
	        '''
	        ...
	22 22   
	23 23   void main(in VS_Input VSInput, out PS_Input PSInput)
	24 24   {
	25 25   	float spriteSelector = VSInput.color.x*255.0f;
	26 26   	PSInput.uv = UV_INFO.xy + (VSInput.uv0 * UV_INFO.zw);
	   27 + #ifndef NO_VARIETY
	   28 + 	PSInput.uv.x += spriteSelector * UV_INFO.z;
	   29 + #endif
	   30 + 
	   31 + 	float3 position = VSInput.position.xyz;
	   32 + 		
	   33 + 	// subtract the offset then fmod into (0.0f, PARTICLE_BOX)
	   34 + 	position.xyz += POSITION_OFFSET.xyz;
	   35 + 	position.xyz = fmod(position.xyz, PARTICLE_BOX.xxx);
	   36 + 	
	   37 + 	// centre box on origin
	   38 + 	position.xyz -= PARTICLE_BOX.xxx * 0.5f;
	   39 + 	
	27    - 	PSInput.uv.x += spriteSelector * UV_INFO.z;
	28    - 
	29    - 	float3 position = VSInput.position.xyz;
	30    - 		
	31    - 	// subtract the offset then fmod into (0.0f, PARTICLE_BOX)
	   40 + 	// push along view vector so box is positioned more infront of camera
	   41 + 	position.xyz += FORWARD.xyz;
	32    - 	position.xyz += POSITION_OFFSET.xyz;
	33    - 	position.xyz = fmod(position.xyz, PARTICLE_BOX.xxx);
	34 42   	
	   43 + 	// get world position
	   44 + 	float4 worldPositionBottom = float4(position.xyz, 1.0f);
	   45 + 	float4 worldPositionTop = float4(worldPositionBottom.xyz + (VELOCITY.xyz * SIZE_SCALE.y), 1.0f);
	   46 + 
	   47 + 	// get projected positions of top and bottom of particle, and top of particle in previous frame
	   48 + #ifdef INSTANCEDSTEREO
	   49 + 	int i = VSInput.instanceID;
	   50 + 	float4 bottom = mul(WORLDVIEWPROJ_STEREO[i], worldPositionBottom);
	   51 + 	float4 top = mul(WORLDVIEWPROJ_STEREO[i], worldPositionTop);
	   52 + 	PSInput.instanceID = i;
	   53 + #else
	   54 + 	float4 bottom = mul(WORLDVIEWPROJ, worldPositionBottom);
	35    - 	// centre box on origin
	36    - 	position.xyz -= PARTICLE_BOX.xxx * 0.5f;
	37    - 	
	38    - 	// push along view vector so box is positioned more infront of camera
	39    - 	position.xyz += FORWARD.xyz;
	40    - 	
	41    - 	// get world position
	42    - 	float4 worldPositionBottom = float4(position.xyz, 1.0f);
	43    - 	float4 worldPositionTop = float4(worldPositionBottom.xyz + (VELOCITY.xyz * SIZE_SCALE.y), 1.0f);
	44    - 
	   55 + 	float4 top = mul(WORLDVIEWPROJ, worldPositionTop);
	   56 + #endif
	   57 + 	// get 2d vector in screenspace between top and bottom of particle
	   58 + 	float2 dir = (top.xy/top.w) - (bottom.xy/bottom.w);
	45    - 	// get projected positions of top and bottom of particle, and top of particle in previous frame
	46    - #ifdef INSTANCEDSTEREO
	47    - 	int i = VSInput.instanceID;
	48    - 	float4 bottom = mul(WORLDVIEWPROJ_STEREO[i], worldPositionBottom);
	   59 + 	
	   60 + 	// get 2d vector perpendicular to velocity
	   61 + 	float2 dirPerp = normalize(float2(-dir.y, dir.x));
	   62 + 
	   63 + 	// choose either the top or bottom projected position using uv.y
	   64 + 	PSInput.position = lerp(top, bottom, VSInput.uv0.y);
	   65 + 	 	
	   66 + 	// offset the position of each side of the particle using uv.x 
	   67 + 	PSInput.position.xy += (0.5f - VSInput.uv0.x) * dirPerp * SIZE_SCALE.x;
	49    - 	float4 top = mul(WORLDVIEWPROJ_STEREO[i], worldPositionTop);
	50    - 	PSInput.instanceID = i;
	51    - #else
	52    - 	float4 bottom = mul(WORLDVIEWPROJ, worldPositionBottom);
	53    - 	float4 top = mul(WORLDVIEWPROJ, worldPositionTop);
	54    - #endif
	55    - 	// get 2d vector in screenspace between top and bottom of particle
	56    - 	float2 dir = (top.xy/top.w) - (bottom.xy/bottom.w);
	57 68   	
	   69 + 	// get the final colour including the lighting, distance and length scales, and per instance alpha
	58    - 	// get 2d vector perpendicular to velocity
	   70 + 	PSInput.color = ALPHA;
	59    - 	float2 dirPerp = normalize(float2(-dir.y, dir.x));
	60 71   
	61    - 	// choose either the top or bottom projected position using uv.y
	62    - 	PSInput.position = lerp(top, bottom, VSInput.uv0.y);
	   72 + #if defined(COMFORT_MODE) && defined(VR_MODE)
	   73 + 	if (PSInput.position.z < 2.0f) {
	   74 + 		PSInput.color.a = clamp((PSInput.position.z - 1.2f)/0.8f, 0.0f, 1.0f);
	   75 + 	}
	63    - 	 	
	64    - 	// offset the position of each side of the particle using uv.x 
	65    - 	PSInput.position.xy += (0.5f - VSInput.uv0.x) * dirPerp * SIZE_SCALE.x;
	66    - 	
	67    - 	// get the final colour including the lighting, distance and length scales, and per instance alpha
	   76 + #endif
	68    - 	PSInput.color = ALPHA;
	69 77   
	70 78   	//fog
	71 79   	PSInput.fogColor.rgb = FOG_COLOR.rgb;
	72 80   	PSInput.fogColor.a = clamp(((PSInput.position.z / RENDER_DISTANCE) - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	73 81   
	        ...
	        '''
Changed file "renderchunk.fragment.hlsl":
	Total line: 95 (+29, -13)
	          '''
	  1   1   #include "ShaderConstants.fxh"
	      2 + #include "util.fxh"
	      3 + 
	      4 + struct PS_Input
	      5 + {
	      6 + 	float4 position : SV_Position;
	      7 + 
	      8 + #ifndef BYPASS_PIXEL_SHADER
	      9 + 	lpfloat4 color : COLOR;
	     10 + 	snorm float2 uv0 : TEXCOORD_0_FB_MSAA;
	     11 + 	snorm float2 uv1 : TEXCOORD_1_FB_MSAA;
	     12 + #endif
	     13 + 
	     14 + #ifdef NEAR_WATER
	     15 + 	float cameraDist : TEXCOORD_2;
	     16 + #endif
	  2     - #include "Util.fxh"
	  3  17   
	  4     - struct PS_Input
	  5     - {
	     18 + #ifdef FOG
	     19 + 	float4 fogColor : FOG_COLOR;
	  6     - 	float4 position : SV_Position;
	  7     - 	lpfloat4 color : COLOR;
	     20 + #endif
	     21 + };
	     22 + 
	     23 + struct PS_Output
	     24 + {
	     25 + 	float4 color : SV_Target;
	     26 + };
	  8     - 	snorm float2 uv0 : TEXCOORD_0_FB_MSAA;
	  9     - 	snorm float2 uv1 : TEXCOORD_1_FB_MSAA;
	 10     - #ifdef NEAR_WATER
	 11     - 	float cameraDist : TEXCOORD_2;
	 12     - #endif
	 13  27   
	     28 + void main( in PS_Input PSInput, out PS_Output PSOutput )
	     29 + {
	     30 + #ifdef BYPASS_PIXEL_SHADER
	     31 +     PSOutput.color = float4(0.0f, 0.0f, 0.0f, 0.0f);
	     32 +     return;
	     33 + #else
	 14     - #ifdef FOG
	 15     - 	float4 fogColor : FOG_COLOR;
	 16     - #endif
	 17     - };
	 18  34   
	     35 + #if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE) || (VERSION < 0xa000 /*D3D_FEATURE_LEVEL_10_0*/) 
	     36 + 	float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv0);
	 19     - struct PS_Output
	     37 + #else
	     38 + 	float4 diffuse = texture2D_AA(TEXTURE_0, TextureSampler0, PSInput.uv0 );
	     39 + #endif
	 20     - {
	 21     - 	float4 color : SV_Target;
	 22     - };
	 23  40   
	 24     - void main( in PS_Input PSInput, out PS_Output PSOutput )
	 25     - {
	 26     - #if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE) || (VERSION < 0xa000 /*D3D_FEATURE_LEVEL_10_0*/) 
	     41 + #ifdef SEASONS_FAR
	     42 + 	diffuse.a = 1.0f;
	     43 + 	PSInput.color.b = 1.0f;
	 27     - 	float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv0);
	 28     - #else
	 29     - 	float4 diffuse = texture2D_AA(TEXTURE_0, TextureSampler0, PSInput.uv0 );
	 30  44   #endif
	 31  45   
	     46 + #ifdef ALPHA_TEST
	     47 + //If we know that all the verts in a triangle will have the same alpha, we should cull there first.
	     48 + 	#ifdef ALPHA_TO_COVERAGE
	 32     - #ifdef SEASONS_FAR
	     49 + 		float alphaThreshold = .05f;
	     50 + 	#else
	     51 + 		float alphaThreshold = .5f;
	     52 + 	#endif
	 33     - 	diffuse.a = 1.0f;
	 34     - 	PSInput.color.b = 1.0f;
	 35     - #endif
	 36     - 
	 37     - #ifdef ALPHA_TEST
	 38     - //If we know that all the verts in a triangle will have the same alpha, we should cull there first.
	     53 + 	if(diffuse.a < alphaThreshold)
	 39     - 	if( diffuse.a < 0.5 )
	 40     - 	{
	 41  54   		discard;
	 42     - 	}
	 43  55   #endif
	 44  56   
	     57 + #if !defined(ALWAYS_LIT)
	 45  58   	diffuse = diffuse * TEXTURE_1.Sample(TextureSampler1, PSInput.uv1);
	     59 + #endif
	 46  60   
	 47  61   #ifndef SEASONS
	 48  62   
	 49  63   #if !defined(ALPHA_TEST) && !defined(BLEND)
	 50  64   	diffuse.a = PSInput.color.a;
	 51  65   #elif defined(BLEND)
	     66 + #ifdef NEAR_WATER	
	 52  67   	diffuse.a *= PSInput.color.a;
	 53  68   
	 54     - #ifdef NEAR_WATER
	 55  69   	float alphaFadeOut = saturate(PSInput.cameraDist.x);
	 56  70   	diffuse.a = lerp(diffuse.a, 1.0f, alphaFadeOut);
	 57  71   #endif
	 58  72   
	 59  73   #endif	
	          ...
	 69  83   	diffuse.rgb = lerp( diffuse.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a );
	 70  84   #endif
	 71  85   
	 72  86   	PSOutput.color = diffuse;
	 73  87   
	     88 + #ifdef VR_MODE
	 74     - #ifdef VR_FEATURE
	 75  89   	// On Rift, the transition from 0 brightness to the lowest 8 bit value is abrupt, so clamp to 
	 76  90   	// the lowest 8 bit value.
	 77  91   	PSOutput.color = max(PSOutput.color, 1 / 255.0f);
	 78  92   #endif
	     93 + 
	     94 + #endif // BYPASS_PIXEL_SHADER
	 79  95   }
	          '''
Changed file "renderchunk.geometry.hlsl":
	Total line: 74 (+17, -15)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3  3   struct GeometryShaderInput
	 4  4   {
	 5    - 	float4				pos				: SV_POSITION;
	 6    - 	lpfloat4			color			: COLOR;
	 7    - 	snorm float2		uv0				: TEXCOORD_0;
	 8    - 	snorm float2		uv1				: TEXCOORD_1;
	 9    - #ifdef FOG
	10    - 	float4				fogColor		: FOG_COLOR;
	11    - #endif
	12    - #ifdef INSTANCEDSTEREO
	13    - 	uint				instanceID		: SV_InstanceID;
	14    - #endif
	15    - };
	16    - 
	17    - // Per-pixel color data passed through the pixel shader.
	18    - struct GeometryShaderOutput
	19    - {
	    5 + 	float4			pos				: SV_POSITION;
	20    - 	float4				pos				: SV_POSITION;
	    6 + #ifndef BYPASS_PIXEL_SHADER
	    7 + 	lpfloat4		color				: COLOR;
	21    - 	lpfloat4			color			: COLOR;
	    8 + 	snorm float2		uv0				: TEXCOORD_0;
	    9 + 	snorm float2		uv1				: TEXCOORD_1;
	22    - 	snorm float2		uv0				: TEXCOORD_0;
	   10 + #endif
	   11 + #ifdef NEAR_WATER
	   12 + 	float 			cameraDist 			: TEXCOORD_2;
	23    - 	snorm float2		uv1				: TEXCOORD_1;
	   13 + #endif
	24 14   #ifdef FOG
	25 15   	float4				fogColor		: FOG_COLOR;
	   16 + #endif
	   17 + #ifdef INSTANCEDSTEREO
	   18 + 	uint				instanceID		: SV_InstanceID;
	26 19   #endif
	   20 + };
	   21 + 
	   22 + // Per-pixel color data passed through the pixel shader.
	   23 + struct GeometryShaderOutput
	   24 + {
	   25 + 	float4				pos				: SV_POSITION;
	   26 + #ifndef BYPASS_PIXEL_SHADER
	   27 + 	lpfloat4			color			: COLOR;
	   28 + 	snorm float2		uv0				: TEXCOORD_0;
	   29 + 	snorm float2		uv1				: TEXCOORD_1;
	   30 + #endif
	   31 + #ifdef NEAR_WATER
	   32 + 	float 			cameraDist 			: TEXCOORD_2;
	   33 + #endif
	   34 + #ifdef FOG
	   35 + 	float4				fogColor		: FOG_COLOR;
	   36 + #endif
	   37 + #ifdef INSTANCEDSTEREO
	   38 + 	uint				renTarget_id : SV_RenderTargetArrayIndex;
	   39 + #endif
	   40 + };
	27    - #ifdef INSTANCEDSTEREO
	28    - 	uint				renTarget_id : SV_RenderTargetArrayIndex;
	29    - #endif
	30    - };
	31    - 
	32    - bool inBounds(float3 worldPos)
	33    - {
	34    - 	bool inBounds = true;
	35    - 	if (worldPos.x < CHUNK_CLIP_MIN.x ||
	36    - 		worldPos.x > CHUNK_CLIP_MAX.x ||
	37    - 		worldPos.z < CHUNK_CLIP_MIN.y ||
	38    - 		worldPos.z > CHUNK_CLIP_MAX.y)
	39    - 	{
	40    - 		inBounds = false;
	41    - 	}
	42    - 
	43    - 	return inBounds;
	44    - }
	45 41   
	46 42   // passes through the triangles, except changint the viewport id to match the instance
	47 43   [maxvertexcount(3)]
	48 44   void main(triangle GeometryShaderInput input[3], inout TriangleStream<GeometryShaderOutput> outStream)
	49 45   {
	        ...
	54 50   #endif
	55 51   	{
	56 52   		for (int j = 0; j < 3; j++)
	57 53   		{
	58 54   			output.pos = input[j].pos;
	   55 + #ifndef BYPASS_PIXEL_SHADER
	59 56   			output.color			= input[j].color;
	   57 + 			output.uv0				= input[j].uv0;
	   58 + 			output.uv1				= input[j].uv1;
	60    - 			output.uv0				= input[j].uv0;
	   59 + #endif
	   60 + #ifdef NEAR_WATER
	   61 + 			output.cameraDist		= input[j].cameraDist;
	61    - 			output.uv1				= input[j].uv1;
	   62 + #endif
	   63 + 
	62 64   #ifdef INSTANCEDSTEREO
	63 65   			output.renTarget_id = i;
	64 66   #endif
	65 67   
	66 68   #ifdef FOG
	        ...
	        '''
Changed file "renderchunk.vertex.hlsl":
	Total line: 130 (+32, -13)
	          '''
	          ...
	 11  11   };
	 12  12   
	 13  13   
	 14  14   struct PS_Input {
	 15  15   	float4 position : SV_Position;
	     16 + 
	     17 + #ifndef BYPASS_PIXEL_SHADER
	     18 + 	lpfloat4 color : COLOR;
	     19 + 	snorm float2 uv0 : TEXCOORD_0_FB_MSAA;
	     20 + 	snorm float2 uv1 : TEXCOORD_1_FB_MSAA;
	     21 + #endif
	     22 + 
	     23 + #ifdef NEAR_WATER
	     24 + 	float cameraDist : TEXCOORD_2;
	     25 + #endif
	     26 + 
	     27 + #ifdef FOG
	     28 + 	float4 fogColor : FOG_COLOR;
	     29 + #endif
	     30 + #ifdef INSTANCEDSTEREO
	     31 + 	uint instanceID : SV_InstanceID;
	     32 + #endif
	     33 + };
	     34 + 
	     35 + 
	     36 + static const float rA = 1.0;
	     37 + static const float rB = 1.0;
	     38 + static const float3 UNIT_Y = float3(0, 1, 0);
	     39 + static const float DIST_DESATURATION = 56.0 / 255.0; //WARNING this value is also hardcoded in the water color, don'tchange
	     40 + 
	 16     - 	lpfloat4 color : COLOR;
	 17     - 	snorm float2 uv0 : TEXCOORD_0_FB_MSAA;
	 18     - 	snorm float2 uv1 : TEXCOORD_1_FB_MSAA;
	 19  41   
	 20     - #ifdef NEAR_WATER
	 21     - 	float cameraDist : TEXCOORD_2;
	     42 + void main(in VS_Input VSInput, out PS_Input PSInput) {
	 22     - #endif
	 23  43   
	     44 + #ifndef BYPASS_PIXEL_SHADER
	 24     - #ifdef FOG
	 25     - 	float4 fogColor : FOG_COLOR;
	     45 + 	PSInput.uv0 = VSInput.uv0;
	     46 + 	PSInput.uv1 = VSInput.uv1;
	     47 + 	PSInput.color = VSInput.color;
	 26     - #endif
	 27     - #ifdef INSTANCEDSTEREO
	 28     - 	uint instanceID : SV_InstanceID;
	 29  48   #endif
	 30     - };
	 31     - 
	 32  49   
	     50 + #ifdef AS_ENTITY_RENDERER
	 33     - static const float rA = 1.0;
	     51 + 	#ifdef INSTANCEDSTEREO
	     52 + 		int i = VSInput.instanceID;
	     53 + 		PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], float4(VSInput.position, 1));
	 34     - static const float rB = 1.0;
	 35     - static const float3 UNIT_Y = float3(0, 1, 0);
	 36     - static const float DIST_DESATURATION = 56.0 / 255.0; //WARNING this value is also hardcoded in the water color, don'tchange
	 37     - 
	     54 + 		PSInput.instanceID = i;
	     55 + 	#else
	     56 + 		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	     57 + 	#endif
	     58 + 		float3 worldPos = PSInput.position;
	     59 + #else
	     60 + 		float3 worldPos = (VSInput.position.xyz * CHUNK_ORIGIN_AND_SCALE.w) + CHUNK_ORIGIN_AND_SCALE.xyz;
	 38     - 
	 39     - void main(in VS_Input VSInput, out PS_Input PSInput) {
	 40     - 	PSInput.uv0 = VSInput.uv0;
	 41     - 	PSInput.uv1 = VSInput.uv1;
	 42     - 	PSInput.color = VSInput.color;
	 43     - 
	 44     - 	float3 worldPos = (VSInput.position.xyz * CHUNK_ORIGIN_AND_SCALE.w) + CHUNK_ORIGIN_AND_SCALE.xyz;
	     61 + 	
	 45     - 
	     62 + 		// Transform to view space before projection instead of all at once to avoid floating point errors
	     63 + 		// Not required for entities because they are already offset by camera translation before rendering
	     64 + 		// World position here is calculated above and can get huge
	     65 + 	#ifdef INSTANCEDSTEREO
	     66 + 		int i = VSInput.instanceID;
	 46     - 	// Transform to view space before projection instead of all at once to avoid floating point errors
	 47     - 	// Not required for entities because they are already offset by camera translation before rendering
	 48     - 	// World position here is calculated above and can get huge
	 49     - #ifdef INSTANCEDSTEREO
	 50     - 	int i = VSInput.instanceID;
	     67 + 	
	 51     - 
	     68 + 		PSInput.position = mul(WORLDVIEW_STEREO[i], float4(worldPos, 1 ));
	     69 + 		PSInput.position = mul(PROJ_STEREO[i], PSInput.position);
	 52     - 	PSInput.position = mul(WORLDVIEW_STEREO[i], float4(worldPos, 1 ));
	 53     - 	PSInput.position = mul(PROJ_STEREO[i], PSInput.position);
	     70 + 	
	 54     - 
	     71 + 		PSInput.instanceID = i;
	     72 + 	#else
	     73 + 		PSInput.position = mul(WORLDVIEW, float4( worldPos, 1 ));
	     74 + 		PSInput.position = mul(PROJ, PSInput.position);
	 55     - 	PSInput.instanceID = i;
	 56     - #else
	 57     - 	PSInput.position = mul(WORLDVIEW, float4( worldPos, 1 ));
	 58     - 	PSInput.position = mul(PROJ, PSInput.position);
	     75 + 	#endif
	 59  76   #endif
	     77 + 
	     78 + ///// find distance from the camera
	 60  79   
	 61  80   #if defined(FOG) || defined(NEAR_WATER)
	     81 + 	#ifdef FANCY
	     82 + 		float3 relPos = -worldPos;
	     83 + 		float cameraDepth = length(relPos);
	     84 + 		#ifdef NEAR_WATER
	     85 + 			PSInput.cameraDist = cameraDepth / FAR_CHUNKS_DISTANCE;
	     86 + 		#endif
	 62     - #ifdef FANCY
	 63     - 	float3 relPos = VIEW_POS - worldPos;
	 64     - 	float cameraDepth = length(relPos);
	 65     - #ifdef NEAR_WATER
	 66     - 	PSInput.cameraDist = cameraDepth / FAR_CHUNKS_DISTANCE;
	 67     - #endif
	 68     - 
	     87 + 	#else
	 69     - #else
	     88 + 		float cameraDepth = PSInput.position.z;
	     89 + 		#ifdef NEAR_WATER
	     90 + 			float3 relPos = -worldPos;
	     91 + 			float cameraDist = length(relPos);
	     92 + 			PSInput.cameraDist = cameraDist / FAR_CHUNKS_DISTANCE;
	     93 + 		#endif
	 70     - #ifdef NEAR_WATER
	 71     - 	float3 relPos = VIEW_POS - worldPos;
	 72     - 	float cameraDist = length(relPos);
	 73     - 	PSInput.cameraDist = cameraDist / FAR_CHUNKS_DISTANCE;
	 74     - #endif
	 75     - 	float cameraDepth = PSInput.position.z;
	     94 + 	#endif
	 76     - #endif
	 77  95   #endif
	 78  96   
	 79  97   	///// apply fog
	 80  98   
	 81  99   #ifdef FOG
	          ...
	 84 102   	len += CURRENT_COLOR.r;
	 85 103   #endif
	 86 104   
	 87 105   	PSInput.fogColor.rgb = FOG_COLOR.rgb;
	 88 106   	PSInput.fogColor.a = clamp((len - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	    107 + 
	 89 108   #endif
	 90 109   
	 91 110   	///// water magic
	 92 111   #ifdef NEAR_WATER
	 93 112   #ifdef FANCY  /////enhance water
	          ...
	          '''
Added file "selection_box.vertex.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct VS_Input
	{
		float3 position : POSITION;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	struct PS_Input
	{
		float4 position : SV_Position;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	void main( in VS_Input VSInput, out PS_Input PSInput )
	{
	#ifdef INSTANCEDSTEREO
		int i = VSInput.instanceID;
		PSInput.position = mul( WORLDVIEWPROJ_STEREO[i], float4( VSInput.position, 1 ) );
		PSInput.instanceID = i;
	#else
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	#endif
	
	    //this is to make it come closer to the camera and avoid z-fighting
	    PSInput.position.z -= 0.0001;
	}
	'''
Added file "shadow_stencil_overlay.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	
	struct PS_Input
	{
	    float4 position : SV_Position;
	    float4 color : COLOR;
	};
	
	struct PS_Output
	{
	    float4 color : SV_Target;
	};
	
	void main( in PS_Input PSInput, out PS_Output PSOutput )
	{
	  PSOutput.color.rgb = lerp(PSInput.color.rgb, CURRENT_COLOR.rgb, PSInput.color.a);
	  PSOutput.color.a = 1;
	}
	'''
Added file "simple.vertex.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	struct PS_Input
	{
	    float4 position : SV_Position;
	    float4 color : COLOR;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	void main( in VS_Input VSInput, out PS_Input PSInput )
	{
	    PSInput.color = CURRENT_COLOR;
	#ifdef INSTANCEDSTEREO
		int i = VSInput.instanceID;
		PSInput.position = mul( WORLDVIEWPROJ_STEREO[i], float4( VSInput.position, 1 ) );
		PSInput.instanceID = i;
	#else
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	#endif
	}
	'''
Changed file "text.fragment.hlsl":
	Total line: 67 (+45, -6)
	        '''
	        ...
	 2  2   
	 3  3   struct PS_Input
	 4  4   {
	 5  5       float4 position : SV_Position;
	 6  6       float4 color : COLOR;
	    7 +     float2 uv : TEXCOORD_0_FB_MSAA;
	    8 + };
	    9 + 
	   10 + struct PS_Output
	   11 + {
	   12 +     float4 color : SV_Target;
	   13 + };
	   14 + 
	   15 + float median(float a, float b, float c) {
	   16 +     return max(min(a, b), min(max(a, b), c));
	   17 + }
	   18 + 
	   19 + static const float GLYPH_UV_SIZE = 1.0 / 16.0;
	   20 + 
	   21 + void main(in PS_Input PSInput, out PS_Output PSOutput)
	   22 + {
	   23 +     float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	   24 + 
	   25 + #ifdef SMOOTH
	   26 +     const float center = 0.4f;
	   27 +     const float radius = 0.1f;
	   28 + 
	   29 +     diffuse = smoothstep(center - radius, center + radius, diffuse);
	   30 + #endif
	   31 + 
	   32 + #ifdef ALPHA_TEST
	   33 +     if (diffuse.a < 0.5)
	   34 +     {
	   35 +         discard;
	   36 +     }
	   37 + #endif
	   38 + 
	   39 + #ifdef MSDF
	   40 +     float4 resultColor = PSInput.color;
	   41 + 
	   42 +     const float sampleDistance = median(diffuse.r, diffuse.g, diffuse.b);
	   43 + 
	   44 +     const float innerEdgeAlpha = smoothstep(max(0.0, GLYPH_CUTOFF - GLYPH_SMOOTH_RADIUS), min(1.0, GLYPH_CUTOFF + GLYPH_SMOOTH_RADIUS), sampleDistance);
	   45 +     // Apply fill cutoff
	   46 +     resultColor = lerp(OUTLINE_COLOR, resultColor, innerEdgeAlpha);
	   47 + 
	   48 +     const float outerEdgeAlpha = smoothstep(max(0.0, OUTLINE_CUTOFF - GLYPH_SMOOTH_RADIUS), min(1.0, OUTLINE_CUTOFF + GLYPH_SMOOTH_RADIUS), sampleDistance);
	   49 +     // Apply stroke (outline) cutoff
	   50 +     resultColor = float4(resultColor.rgb, resultColor.a * outerEdgeAlpha);
	 7    -     float2 uv : TEXCOORD_0;
	 8    - };
	 9 51   
	   52 +     const float2 topLeft = floor(PSInput.uv);
	10    - struct PS_Output
	11    - {
	   53 +     const float2 bottomRight = floor(PSInput.uv + GLYPH_UV_SIZE);
	12    -     float4 color : SV_Target;
	13    - };
	14 54   
	   55 +     const float4 shadowSample = TEXTURE_0.Sample(TextureSampler0, clamp(PSInput.uv - SHADOW_OFFSET, topLeft, bottomRight));
	   56 +     const float shadowDistance = shadowSample.a;
	   57 +     const float shadowAlpha = smoothstep(max(0.0, OUTLINE_CUTOFF - SHADOW_SMOOTH_RADIUS), min(1.0, OUTLINE_CUTOFF + SHADOW_SMOOTH_RADIUS), shadowDistance);
	   58 +     // Apply shadow past the stroke
	   59 +     resultColor = lerp(float4(SHADOW_COLOR.rgb, SHADOW_COLOR.a * shadowAlpha), resultColor, outerEdgeAlpha);
	15    - void main( in PS_Input PSInput, out PS_Output PSOutput )
	16    - {
	17    -     const float4 diffuse = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	18 60   
	19    - #ifdef ALPHA_TEST
	20    -     if( diffuse.a < 0.5 )
	   61 +     diffuse = resultColor;
	   62 + #else
	   63 +     diffuse *= PSInput.color;
	21    -     {
	22    -         discard;
	23    -     }
	24 64   #endif
	25 65   
	   66 +     PSOutput.color = diffuse * DARKEN;
	26    -     PSOutput.color = diffuse * PSInput.color * DARKEN;
	27 67   }
	28    - 
	        '''
Changed file "texture.fragment.hlsl":
	Total line: 43 (+20, -1)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3  3   struct PS_Input
	 4  4   {
	 5  5       float4 position : SV_Position;
	    6 +     float2 uv : TEXCOORD_0_FB_MSAA;
	    7 + };
	    8 + 
	    9 + struct PS_Output
	   10 + {
	   11 +     float4 color : SV_Target;
	   12 + };
	   13 + 
	   14 + void main(in PS_Input PSInput, out PS_Output PSOutput)
	   15 + {
	   16 + #ifdef STEREO_LEFT_EYE_ONLY
	   17 +     PSOutput.color = TEXTURE_0.Sample(TextureSampler0, float3(PSInput.uv, 0.0f));
	   18 + #elif defined(DEPTH_TEXTURE)
	   19 + 	PSOutput.color.a = 1.0;
	   20 + #if defined(ARRAY_TEXTURE_0)
	 6    -     float2 uv : TEXCOORD_0;
	 7    - };
	   21 + 	PSOutput.color.rgb = TEXTURE_0.Sample(TextureSampler0, float3(PSInput.uv, TEXTURE_ARRAY_INDEX_0)).r;
	   22 + #else
	   23 +     PSOutput.color.rgb = TEXTURE_0.Sample(TextureSampler0, PSInput.uv).r;
	   24 + #endif
	   25 + #else
	   26 + #if defined(ARRAY_TEXTURE_0)
	   27 + 	PSOutput.color = TEXTURE_0.Sample(TextureSampler0, float3(PSInput.uv, TEXTURE_ARRAY_INDEX_0));
	   28 + #else
	   29 +     PSOutput.color = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	 8    - 
	 9    - struct PS_Output
	10    - {
	11    -     float4 color : SV_Target;
	12    - };
	13    - 
	14    - void main( in PS_Input PSInput, out PS_Output PSOutput )
	15    - {
	16    -     PSOutput.color = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	   30 + #endif
	   31 + #endif
	17 32   
	18 33   #ifdef ALPHA_TEST
	19 34       if( PSOutput.color.a < 0.5 )
	   35 +     {
	   36 +         discard;
	   37 +     }
	20    -     {
	   38 + #endif
	   39 + 
	   40 + #ifdef NO_ALPHA
	   41 + 	PSOutput.color.a = 1.f;
	21    -         discard;
	22    -     }
	23 42   #endif
	24 43   }
	        '''
Changed file "texture_ccolor.fragment.hlsl":
	Total line: 31 (+5, -1)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	    2 + #include "util.fxh"
	 2  3   
	 3  4   struct PS_Input
	 4  5   {
	 5  6       float4 position : SV_Position;
	    7 +     float2 uv : TEXCOORD_0_FB_MSAA;
	 6    -     float2 uv : TEXCOORD_0;
	 7  8   };
	 8  9   
	 9 10   struct PS_Output
	10 11   {
	11 12       float4 color : SV_Target;
	12 13   };
	13 14   
	14 15   void main( in PS_Input PSInput, out PS_Output PSOutput )
	15 16   {
	   17 + #if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE) || (VERSION < 0xa000 /*D3D_FEATURE_LEVEL_10_0*/) 
	   18 + 	float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	   19 + #else
	   20 + 	float4 diffuse = texture2D_AA(TEXTURE_0, TextureSampler0, PSInput.uv);
	16    -     float4 diffuse = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	   21 + #endif
	17    - 
	18 22   
	19 23   #ifdef ALPHA_TEST
	20 24       if( diffuse.a < 0.5 )
	21 25       {
	22 26           discard;
	        ...
	        '''
Added file "texture_raw_alphatest.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	#include "util.fxh"
	
	struct PS_Input
	{
	    float4 position : SV_Position;
	    float2 uv : TEXCOORD_0_FB_MSAA;
	};
	
	struct PS_Output
	{
	    float4 color : SV_Target;
	};
	
	void main( in PS_Input PSInput, out PS_Output PSOutput )
	{
	#if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE) || (VERSION < 0xa000 /*D3D_FEATURE_LEVEL_10_0*/) 
		float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	#else
		float4 diffuse = texture2D_AA(TEXTURE_0, TextureSampler0, PSInput.uv);
	#endif
	
	#ifdef ALPHA_TEST
	    if( diffuse.a < 0.0625 )
	    {
	        discard;
	    }
	#endif
	
	    PSOutput.color = diffuse;
	}
	'''
Changed file "util.fxh":
	Total line: 54 (+9, -40)
	        '''
	 1    - float2 clampUVsForMipLevel(in float2 uv, in float mipLevel, in float textureWidth, in float textureHeight)
	 2    - {
	 3    - 	float2 uvClamped;
	 4    - 
	 5    - 	// Clamp UVs to atlas face so that neighboring faces don't bleed across
	 6    - 	float2 numAtlasFaces = float2(textureWidth, textureHeight) / ATLAS_FACE_SIZE;
	 7    - 	float2 faceUV = frac(uv * numAtlasFaces);
	 8    - 	uvClamped = (uv * numAtlasFaces) - faceUV;
	 9    - 	float2 halfTexel = float2(.5f, .5f) / (ATLAS_FACE_SIZE / pow(2, mipLevel));
	10    - 	faceUV = clamp(faceUV, halfTexel, 1 - halfTexel);
	11    - 	uvClamped += faceUV;
	12    - 	uvClamped /= numAtlasFaces;
	13    - 
	14    - 	return uvClamped;
	15    - }
	16    - 
	17    - float4 texture2D_AA(in Texture2D tex, in sampler texSampler, in float2 uv)
	18    - {
	19    - 	// Texture antialiasing
	20    - 	//
	21    - 	// The texture coordinates are modified so that the bilinear filter will be one pixel width wide instead of one texel width. 
	22    - 
	23    - 	// Get the UV deltas
	24    - 	float2 dUVdx = ddx(uv) * TEXTURE_DIMENSIONS.xy;
	25    - 	float2 dUVdy = ddy(uv) * TEXTURE_DIMENSIONS.xy;
	26    - 	float2 dU = float2(dUVdx.x, dUVdy.x);
	27    - 	float2 dV = float2(dUVdx.y, dUVdy.y);
	28    - 
	29    - 	float duUV = sqrt(dot(dU, dU));
	30    - 	float dvUV = sqrt(dot(dV, dV));
	31  1   
	    2 + float4 texture2D_AA(in Texture2D tex, in sampler texSampler, in float2 uv)
	    3 + {
	32    - 	// Determine mip map LOD
	33    -     float d = max(dot(dUVdx, dUVdx), dot(dUVdy, dUVdy));
	    4 + 	// Texture antialiasing
	    5 + 	//
	    6 + 	// The texture coordinates are modified so that the bilinear filter will be one pixel width wide instead of one texel width. 
	34    - 	float mipLevel = .5f * log2(d);
	35    - 	mipLevel = mipLevel + .5f;	// Mip bias to reduce aliasing
	36    - 	mipLevel = clamp(mipLevel, 0.0f, TEXTURE_DIMENSIONS.z);
	37  7   
	    8 + 	// Get the UV deltas
	38    - 	float2 uvModified; 
	39    - 	if( mipLevel >= 1.0f)
	    9 + 	float2 dUVdx = ddx(uv) * TEXTURE_DIMENSIONS.xy;
	   10 + 	float2 dUVdy = ddy(uv) * TEXTURE_DIMENSIONS.xy;
	   11 + 	float2 dU = float2(dUVdx.x, dUVdy.x);
	   12 + 	float2 dV = float2(dUVdx.y, dUVdy.y);
	   13 + 
	   14 + 	float duUV = sqrt(dot(dU, dU));
	   15 + 	float dvUV = sqrt(dot(dV, dV));
	40    - 	{
	41    - 		uvModified = uv;
	42    - 	}
	43    - 	else
	44    - 	{
	45    - 		// First scale the uv so that each texel has a uv range of [0,1]
	46    - 		float2 texelUV = frac(uv * TEXTURE_DIMENSIONS.xy);
	47 16   
	   17 + 	// Determine mip map LOD
	   18 +     float d = max(dot(dUVdx, dUVdx), dot(dUVdy, dUVdy));
	   19 + 	float mipLevel = .5f * log2(d);
	   20 + 	mipLevel = mipLevel + .5f;	// Mip bias to reduce aliasing
	   21 + 	mipLevel = clamp(mipLevel, 0.0f, TEXTURE_DIMENSIONS.z);
	48    - 		// Initially set uvModified to the floor of the texel position
	49    - 		uvModified = (uv * TEXTURE_DIMENSIONS.xy) - texelUV;
	50 22   
	51    - 		// Modify the texelUV to push the uvs toward the edges.
	52    - 		//          |                 |       |                   |
	53    - 		//          |         _/      |       |           /       |
	54    - 		//  Change  | U     _/        |  to   | U     ___/        |
	   23 + 	float2 uvModified; 
	   24 + 	if( mipLevel >= 1.0f)
	   25 + 	{
	   26 + 		uvModified = uv;
	   27 + 	}
	   28 + 	else
	   29 + 	{
	   30 + 		// First scale the uv so that each texel has a uv range of [0,1]
	   31 + 		float2 texelUV = frac(uv * TEXTURE_DIMENSIONS.xy);
	55    - 		//          |     _/          |       |     /             |
	56    - 		//          |    /            |       |    /              |
	57    - 		//          |         X       |       |         X         |
	58    - 		float scalerU = 1.0f / (duUV);
	59    - 		float scalerV = 1.0f / (dvUV);
	60    - 		float2 scaler = max(float2(scalerU, scalerV), 1.0f);
	61    - 		texelUV = clamp(texelUV * scaler, 0.0f, .5f) + clamp(texelUV*scaler - (scaler - .5f), 0.0f, .5f);
	62    - 		uvModified += texelUV;
	63    - 		uvModified /= TEXTURE_DIMENSIONS.xy;
	   32 + 
	64    - 	}
	   33 + 		// Initially set uvModified to the floor of the texel position
	   34 + 		uvModified = (uv * TEXTURE_DIMENSIONS.xy) - texelUV;
	65    - #ifdef ATLAS_TEXTURE
	66    - 	//Clamp UVs to atlas face
	67 35   
	   36 + 		// Modify the texelUV to push the uvs toward the edges.
	   37 + 		//          |                 |       |                   |
	   38 + 		//          |         _/      |       |           /       |
	   39 + 		//  Change  | U     _/        |  to   | U     ___/        |
	   40 + 		//          |     _/          |       |     /             |
	   41 + 		//          |    /            |       |    /              |
	   42 + 		//          |         X       |       |         X         |
	   43 + 		float scalerU = 1.0f / (duUV);
	   44 + 		float scalerV = 1.0f / (dvUV);
	   45 + 		float2 scaler = max(float2(scalerU, scalerV), 1.0f);
	   46 + 		texelUV = clamp(texelUV * scaler, 0.0f, .5f) + clamp(texelUV*scaler - (scaler - .5f), 0.0f, .5f);
	   47 + 		uvModified += texelUV;
	   48 + 		uvModified /= TEXTURE_DIMENSIONS.xy;
	   49 + 	}
	68    - 	float mipLevel0 = clamp(floor(mipLevel), 0.0f, TEXTURE_DIMENSIONS.z);
	69    - 	float mipLevel1 = clamp(floor(mipLevel+1.0f), 0.0f, TEXTURE_DIMENSIONS.z);
	70    - 
	71    - 	float2 uvLOD0 = clampUVsForMipLevel(uvModified, mipLevel0, TEXTURE_DIMENSIONS.x, TEXTURE_DIMENSIONS.y);
	72    - 	float2 uvLOD1 = clampUVsForMipLevel(uvModified, mipLevel1, TEXTURE_DIMENSIONS.x, TEXTURE_DIMENSIONS.y);
	73    - 
	74    - 	float4 diffuse0 = tex.SampleLevel(texSampler, uvLOD0, mipLevel0);
	75    - 	float4 diffuse1 = tex.SampleLevel(texSampler, uvLOD1, mipLevel1);
	76    - 
	77    - 	float4 diffuse = lerp(diffuse0, diffuse1, frac(mipLevel));
	78    - 
	79    - #else
	80 50   	float4 diffuse = tex.Sample(TextureSampler0, uvModified);
	81    - #endif
	82 51   	return diffuse;
	83 52   
	84 53   }
	85 54   
	        '''
Added file "uv_blend_flipbook.vertex.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct VS_Input {
		float3 position : POSITION;
		float2 uv : TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	struct PS_Input {
		float4 position : SV_Position;
		float2 uv : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	void main(in VS_Input VSInput, out PS_Input PSInput) {
		PSInput.uv = VSInput.uv;
		PSInput.uv.y += V_OFFSET;
		PSInput.uv1 = VSInput.uv;
		PSInput.uv1.y += V_BLEND_OFFSET;
	
	#ifdef INSTANCEDSTEREO
		int i = VSInput.instanceID;
		PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], float4(VSInput.position, 1));
		PSInput.instanceID = i;
	#else
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	#endif
	}
	'''
Added file "uv_repeat.vertex.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	    float2 uv : TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
	    uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	struct PS_Input
	{
	    float4 position : SV_Position;
	    float2 uv : TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
	    uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	void main( in VS_Input VSInput, out PS_Input PSInput )
	{
	    float4 transformedUV = mul(UV_TRANSFORM, float4(VSInput.uv, 0, 1));
	    PSInput.uv = transformedUV.xy;
	
	#ifdef INSTANCEDSTEREO
	    int i = VSInput.instanceID;
	    PSInput.position = mul( WORLDVIEWPROJ_STEREO[i], float4( VSInput.position, 1 ) );
	    PSInput.instanceID = i;
	#else
	    PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	#endif
	}
	'''
Added file "uv_selection_overlay.vertex.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	    float2 uv : TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	struct PS_Input
	{
	    float4 position : SV_Position;
	    float2 uv : TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	void main( in VS_Input VSInput, out PS_Input PSInput )
	{
	    PSInput.uv = VSInput.uv;
	#ifdef INSTANCEDSTEREO
		int i = VSInput.instanceID;
		float4 pos = mul(WORLDVIEW_STEREO[i], float4(VSInput.position, 1));
		PSInput.position = mul(PROJ_STEREO[i], pos);
		PSInput.instanceID = i;
	#else
		float4 pos = mul(WORLDVIEW, float4(VSInput.position, 1));
		PSInput.position = mul(PROJ, pos);
	#endif
	}
	'''
Added file "uv_time_rotate.vertex.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	    float2 uv : TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
	    uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	struct PS_Input
	{
	    float4 position : SV_Position;
	    float2 uv : TEXCOORD_0;
	#ifdef INSTANCEDSTEREO
	    uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	void main( in VS_Input VSInput, out PS_Input PSInput )
	{
	#if defined(VR_MODE)
	 	const float ROTATION_Y_SPEED = 0.0f;
		const float ROTATION_X_SPEED = 0.0f;
		const float ROTATION_X_SCALE = 0.0f;
		const float ROTATION_X_ADDITION = 0.0f;
	#else
		const float ROTATION_Y_SPEED = 1.5f;
		const float ROTATION_X_SPEED = 0.1f;
		const float ROTATION_X_SCALE = 7.0f;
		const float ROTATION_X_ADDITION = 20.0f;
	#endif	
	    float s;
	    float c;
	    sincos(radians(-TOTAL_REAL_WORLD_TIME * ROTATION_Y_SPEED), s, c);
	
	    float4x4 rotationY = {
	        float4(c, 0, s, 0),
	        float4(0, 1, 0, 0),
	        float4(-s, 0, c, 0),
	        float4(0, 0, 0, 1)
		};
		
	    sincos(radians(sin(TOTAL_REAL_WORLD_TIME * ROTATION_X_SPEED) * ROTATION_X_SCALE + ROTATION_X_ADDITION), s, c);
	    float4x4 rotationX = {
	        float4(1, 0, 0, 0),
	        float4(0, c, -s, 0),
	        float4(0, s, c, 0),
	        float4(0, 0, 0, 1)
		};
		
	    PSInput.uv = VSInput.uv;
	#ifdef INSTANCEDSTEREO
	    int i = VSInput.instanceID;
	    PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], mul(rotationX, mul(rotationY, float4( VSInput.position, 1 ))));
	    PSInput.instanceID = i;
	#else
	    PSInput.position = mul(WORLDVIEWPROJ, mul(rotationX, mul(rotationY, float4(VSInput.position, 1))));
	#endif
	}
	'''
Removed file "weather.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct PS_Input {
		float4 position : SV_Position;
		float4 color : COLOR;
		float2 uv0 : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	};
	
	struct PS_Output {
		float4 color : SV_Target;
	};
	
	void main(in PS_Input PSInput, out PS_Output PSOutput) 
	{
		float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv0) * TEXTURE_1.Sample(TextureSampler1, PSInput.uv1);
	
	#ifdef ALPHA_TEST
		if(diffuse.a < 0.5)
		 	discard;
	#endif
		diffuse *= PSInput.color;
	
		PSOutput.color = diffuse;
	}
	'''
Removed file "weather.geometry.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct GeometryShaderInput
	{
		float4 position : SV_Position;
		float4 color : COLOR;
		float2 uv0 : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	// Per-pixel color data passed through the pixel shader.
	struct GeometryShaderOutput
	{
		float4 position : SV_Position;
		float4 color : COLOR;
		float2 uv0 : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	
	#ifdef INSTANCEDSTEREO
		uint        renTarget_id : SV_RenderTargetArrayIndex;
	#endif
	};
	
	// passes through the triangles, except changint the viewport id to match the instance
	[maxvertexcount(3)]
	void main(triangle GeometryShaderInput input[3], inout TriangleStream<GeometryShaderOutput> outStream)
	{
		GeometryShaderOutput output = (GeometryShaderOutput)0;
	
	#ifdef INSTANCEDSTEREO
		int i = input[0].instanceID;
	#endif
	
		for (int j = 0; j < 3; j++)
		{
			output.position = input[j].position;
			output.color = input[j].color;
			output.uv0 = input[j].uv0;
			output.uv1 = input[j].uv1;
	
	#ifdef INSTANCEDSTEREO
			output.renTarget_id = i;
	#endif
			outStream.Append(output);
		}
	}
	'''
Removed file "weather.vertex.hlsl":
	'''
	
	#include "ShaderConstants.fxh"
	
	struct VS_Input {
		float3 position : POSITION;
		float4 color : COLOR;
		float2 uv0 : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	struct PS_Input {
		float4 position : SV_Position;
		float4 color : COLOR;
		float2 uv0 : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	void main(in VS_Input VSInput, out PS_Input PSInput)
	{
	#ifdef INSTANCEDSTEREO
		int i = VSInput.instanceID;
		PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], float4(VSInput.position, 1));
		PSInput.instanceID = i;
	#else
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	#endif
		PSInput.color = VSInput.color;
		PSInput.uv0.x = VSInput.uv0.x*2.0f;
		PSInput.uv0.y = VSInput.uv0.y*10.0f;
		PSInput.uv1 = VSInput.uv1;
	}
	'''