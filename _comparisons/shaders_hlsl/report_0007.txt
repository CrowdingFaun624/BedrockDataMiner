Difference of "shaders" between "a0.13.2-3" and "a0.15.0_realms2" (beta of "a0.15.0").
Unable to create data files for 13 files between.

Changed file "ShaderConstants.fxh":
	Total line: 126 (+15, -1)
	          '''
	          ...
	 22  22   #define lpfloat float
	 23  23   #define lpfloat2 float2
	 24  24   #define lpfloat4 float4
	 25  25   #endif
	 26  26   
	     27 + #ifdef MSAA_FRAMEBUFFER_ENABLED
	     28 + #define TEXCOORD_0_FB_MSAA TEXCOORD_0_centroid
	     29 + #define TEXCOORD_1_FB_MSAA TEXCOORD_1_centroid
	     30 + #else
	     31 + #define TEXCOORD_0_FB_MSAA TEXCOORD_0
	     32 + #define TEXCOORD_1_FB_MSAA TEXCOORD_1
	     33 + #endif
	     34 + 
	 27  35   
	 28  36   cbuffer RenderChunkConstants
	 29  37   {
	 30  38   
	     39 + 	float4 CHUNK_ORIGIN_AND_SCALE;
	 31     - 	float3 CHUNK_ORIGIN;
	 32  40   }
	 33  41   
	 34  42   cbuffer EntityConstants
	 35  43   {
	 36  44   	float4 OVERLAY_COLOR;
	 37  45   	float4 TILE_LIGHT_COLOR;
	     46 + 	float4 CHANGE_COLOR;
	     47 + 	float4 GLINT_COLOR;
	 38     - 	float4 CHANGE_COLOR;
	 39  48   	float2 UV_ANIM;
	 40  49   	float2 UV_OFFSET;
	 41  50   	float2 UV_ROTATION;
	 42  51   	float2 GLINT_UV_SCALE;
	 43  52   }
	          ...
	 60  69   
	 61  70   #if !defined(INSTANCEDSTEREO)
	 62  71   
	 63  72   cbuffer WorldConstants
	 64  73   {
	     74 + 	float4x4 WORLDVIEWPROJ;
	     75 + 	float4x4 WORLD;
	     76 + 	float4x4 WORLDVIEW;
	     77 + 	float4x4 PROJ;
	 65     - 	float4x4 WORLDVIEWPROJ;
	 66     - 	float4x4 WORLD;
	 67  78   }
	 68  79   
	 69  80   #else
	 70  81   
	 71  82   cbuffer WorldConstantsStereographic
	 72  83   {
	     84 + 	float4x4 WORLDVIEWPROJ_STEREO[2];
	     85 + 	float4x4 WORLD_STEREO;
	     86 + 	float4x4 WORLDVIEW_STEREO[2];
	     87 + 	float4x4 PROJ_STEREO[2];
	 73     - 	float4x4 WORLDVIEWPROJ_STEREO[2];
	 74     - 	float4x4 WORLD_STEREO;
	 75  88   }
	 76  89   
	 77  90   #endif
	 78  91   
	 79  92   cbuffer ShaderConstants
	 80  93   {
	 81  94   	float4 CURRENT_COLOR;
	 82  95   	float4 DARKEN;
	     96 + 	float2 ATLAS_FACE_SIZE;
	     97 + 	float3 TEXTURE_DIMENSIONS;
	 83  98   }
	 84  99   
	 85 100   cbuffer WeatherConstants {
	 86 101   	float4	POSITION_OFFSET;
	 87 102   	float4	VELOCITY;
	          ...
	 93 108   	float4  PARTICLE_BOX;
	 94 109   }
	 95 110   
	 96 111   cbuffer HoloConstants
	 97 112   {
	 98     - 	float4x4 ONETOONE_CLIPMAT;
	 99 113   	float4	TABLE_REVEAL_CENTER;
	100 114   	float4	TABLE_REVEAL_CONSTANTS;	// x = Radius
	101 115   
	102 116   	float3 GAZE_DIRECTION;
	103 117   
	          ...
	          '''
Changed file "Template.fragment.hlsl":
	Total line: 17 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 4    - 
	 5  3   struct PS_Input
	 6  4   {
	 7  5       float4 position : SV_Position;
	 8  6       float4 color : COLOR;
	 9  7   };
	        ...
	        '''
Changed file "cloud.vertex.hlsl":
	Total line: 46 (+5, -2)
	        '''
	        ...
	28 28   {
	29 29   #ifdef INSTANCEDSTEREO
	30 30   	int i = VSInput.instanceID;
	31 31   	PSInput.position = mul( WORLDVIEWPROJ_STEREO[i], float4( VSInput.position, 1 ) );
	32 32   	PSInput.instanceID = i;
	   33 + 	float3 worldPos = mul(WORLD_STEREO, float4(VSInput.position, 1));
	33 34   #else
	34 35   	PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	   36 + 	float3 worldPos = mul(WORLD, float4(VSInput.position, 1));
	35 37   #endif
	   38 + 
	   39 +     PSInput.color = VSInput.color * CURRENT_COLOR;
	36 40   
	   41 + 	float depth = length(worldPos) / RENDER_DISTANCE;
	37    -     PSInput.color = VSInput.color * CURRENT_COLOR;
	38 42   
	39    -     float depth = PSInput.position.z / RENDER_DISTANCE;
	40 43       float fog = max( depth - fogNear, 0.0 );
	41 44   
	42 45       PSInput.color.a *= 1.0 - fog;
	43 46   }
	        '''
Changed file "color.fragment.hlsl":
	Total line: 17 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 4    - 
	 5  3   struct PS_Input
	 6  4   {
	 7  5       float4 position : SV_Position;
	 8  6       float4 color : COLOR;
	 9  7   };
	        ...
	        '''
Changed file "color_texture.fragment.hlsl":
	Total line: 83 (+37, -17)
	          '''
	  1   1   #include "ShaderConstants.fxh"
	  2   2   
	      3 + float4 glintBlend(float4 dest, float4 source) {
	      4 + 	return float4(source.rgb * source.rgb, 0.0) + dest;
	      5 + }
	      6 + 
	      7 + struct PS_Input
	      8 + {
	      9 + 	float4 position : SV_Position;
	     10 + 	float4 color : COLOR;
	     11 + 	float2 uv : TEXCOORD_0;
	     12 + 
	     13 + #ifdef ENABLE_FOG
	     14 + 	float4 fogColor : FOG_COLOR;
	     15 + #endif
	     16 + 
	     17 + #ifdef GLINT
	     18 + 	float2 layer1UV : UV_1;
	     19 + 	float2 layer2UV : UV_2;
	     20 + #endif
	     21 + };
	  3     - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	  4  22   
	     23 + struct PS_Output
	     24 + {
	  5     - float4 glintBlend(float4 dest, float4 source) {
	     25 + 	float4 color : SV_Target;
	     26 + };
	  6     - 	return float4(source.rgb * source.rgb, 0.0) + dest;
	  7     - }
	  8  27   
	     28 + void main( in PS_Input PSInput, out PS_Output PSOutput )
	  9     - struct PS_Input
	 10  29   {
	 11     -     float4 position : SV_Position;
	 12     -     float4 color : COLOR;
	     30 + 	float4 diffuse = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	 13     -     float2 uv : TEXCOORD_0;
	 14  31   
	 15     - #ifdef ENABLE_FOG
	 16     - 	float4 fogColor : FOG_COLOR;
	     32 + #ifdef ALPHA_TEST
	 17     - #endif
	 18  33   
	     34 + #ifdef ENABLE_VERTEX_TINT_MASK
	     35 + 	if( diffuse.a <= 0.0f )
	 19     - #ifdef GLINT
	     36 + #else
	     37 + 	if (diffuse.a <= 0.5f)
	 20     - 	float2 layer1UV : UV_1;
	 21     - 	float2 layer2UV : UV_2;
	 22  38   #endif
	 23     - };
	 24     - 
	 25     - struct PS_Output
	     39 + 	{
	 26     - {
	     40 + 		discard;
	     41 + 	}
	     42 + #endif
	 27     -     float4 color : SV_Target;
	 28     - };
	 29  43   
	     44 + #ifdef ENABLE_VERTEX_TINT_MASK
	     45 + 	diffuse.rgb = lerp(diffuse.rgb, diffuse.rgb*PSInput.color.rgb, diffuse.a);
	     46 + 	if (PSInput.color.a > 0.0f) {
	     47 + 		diffuse.a = diffuse.a > 0.0f ? 1.0f : 0.0f;
	     48 + 	}
	     49 + #endif
	 30     - void main( in PS_Input PSInput, out PS_Output PSOutput )
	 31     - {
	 32     -     float4 diffuse = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	 33  50   
	 34     - #ifdef ALPHA_TEST
	 35     -     if( diffuse.a < 0.5 )
	     51 + #ifdef GLINT
	     52 + 	float4 layer1 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layer1UV)).rgbr * GLINT_COLOR;
	     53 + 	float4 layer2 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layer2UV)).rgbr * GLINT_COLOR;
	     54 + 	float4 glint = (layer1 + layer2);
	 36     -     {
	 37     -         discard;
	 38     -     }
	 39     - #endif
	 40  55   
	     56 + 	#ifdef INVENTORY
	     57 + 		diffuse.rgb = glint.rgb;
	     58 + 	#else
	     59 + 		diffuse.rgb = glintBlend(diffuse, glint).rgb;
	     60 + 	#endif
	     61 + #endif
	 41     - #ifdef GLINT
	 42     - 	float4 layer1 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layer1UV)).rgbr * CHANGE_COLOR;
	 43     - 	float4 layer2 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layer2UV)).rgbr * CHANGE_COLOR;
	 44     - 	float4 glint = (layer1 + layer2);
	 45  62   
	     63 + #ifdef USE_OVERLAY
	 46     - 	#ifdef INVENTORY
	 47     - 		diffuse = glint;
	     64 + 		//use either the diffuse or the OVERLAY_COLOR
	     65 + 	diffuse.rgb = lerp( diffuse, OVERLAY_COLOR, OVERLAY_COLOR.a ).rgb;
	     66 + #endif
	 48     - 	#else
	 49     - 		diffuse = glintBlend(diffuse, glint);
	 50     - 	#endif
	     67 + 
	     68 + #ifdef ENABLE_FOG
	     69 + 	diffuse.rgb = lerp(diffuse.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a);
	 51  70   #endif
	 52  71   
	     72 + #ifdef ENABLE_VERTEX_TINT_MASK
	     73 + 	PSOutput.color = diffuse;
	 53     - #ifdef USE_OVERLAY
	     74 + #else
	     75 + 	PSOutput.color = diffuse * PSInput.color;
	 54     -         //use either the diffuse or the OVERLAY_COLOR
	 55     -     diffuse.rgb = lerp( diffuse, OVERLAY_COLOR, OVERLAY_COLOR.a ).rgb;
	 56  76   #endif
	 57  77   
	     78 + #ifdef VR_FEATURE
	     79 + 	// On Rift, the transition from 0 brightness to the lowest 8 bit value is abrupt, so clamp to 
	     80 + 	// the lowest 8 bit value.
	     81 + 	PSOutput.color = max(PSOutput.color, 1 / 255.0f);
	 58     - #ifdef ENABLE_FOG
	 59     - 	diffuse.rgb = lerp(diffuse.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a);
	 60  82   #endif
	 61     - 
	 62     -     PSOutput.color = diffuse * PSInput.color;
	 63  83   }
	          '''
Changed file "color_uv.geometry.hlsl":
	Total line: 66 (+8, -8)
	        '''
	        ...
	 8  8   
	 9  9   #ifdef ENABLE_FOG
	10 10   	float4 fogColor : FOG_COLOR;
	11 11   #endif
	12 12   
	13    - #ifdef INSTANCEDSTEREO
	14    - 	uint instanceID : SV_InstanceID;
	15    - #endif
	16 13   #ifdef GLINT
	17 14   	float2 layer1UV : UV_1;
	18 15   	float2 layer2UV : UV_2;
	   16 + #endif
	   17 + #ifdef INSTANCEDSTEREO
	   18 + 	uint instanceID : SV_InstanceID;
	19 19   #endif
	20 20   };
	21 21   
	22 22   // Per-pixel color data passed through the pixel shader.
	23 23   struct GeometryShaderOutput
	24 24   {
	25 25   	float4		pos				: SV_POSITION;
	26 26   	float4		color			: COLOR;
	27    - 	float2		uv0				: TEXCOORD_0;
	28    - 
	29    - #ifdef ENABLE_FOG
	   27 + 	float2		uv0				: TEXCOORD_0;
	30    - 	float4 fogColor : FOG_COLOR;
	31    - #endif
	32 28   
	   29 + #ifdef ENABLE_FOG
	33    - #ifdef INSTANCEDSTEREO
	   30 + 	float4 fogColor : FOG_COLOR;
	34    - 	uint        renTarget_id : SV_RenderTargetArrayIndex;
	35 31   #endif
	   32 + 
	36 33   #ifdef GLINT
	37 34   	float2 layer1UV : UV_1;
	38 35   	float2 layer2UV : UV_2;
	   36 + #endif
	   37 + #ifdef INSTANCEDSTEREO
	   38 + 	uint        renTarget_id : SV_RenderTargetArrayIndex;
	39 39   #endif
	40 40   };
	41 41   
	42 42   // passes through the triangles, except changint the viewport id to match the instance
	43 43   [maxvertexcount(3)]
	        ...
	53 53   		{
	54 54   			output.pos = input[j].pos;
	55 55   			output.color			= input[j].color;
	56 56   			output.uv0				= input[j].uv0;
	57 57   #ifdef ENABLE_FOG
	   58 + 			output.fogColor			= input[j].fogColor;
	58    - 			float4 output.fogColor  = input[j].fogColor;
	59 59   #endif
	60 60   #ifdef INSTANCEDSTEREO
	61 61   			output.renTarget_id = i;
	62 62   #endif
	63 63   			outStream.Append(output);
	        ...
	        '''
Changed file "color_uv.vertex.hlsl":
	Total line: 70 (+3, -3)
	        '''
	        ...
	19 19   
	20 20   #ifdef ENABLE_FOG
	21 21   	float4 fogColor : FOG_COLOR;
	22 22   #endif
	23 23   
	24    - #ifdef INSTANCEDSTEREO
	25    - 	uint instanceID : SV_InstanceID;
	26    - #endif
	27 24   #ifdef GLINT
	28 25   	float2 layer1UV : UV_1;
	29 26   	float2 layer2UV : UV_2;
	   27 + #endif
	   28 + #ifdef INSTANCEDSTEREO
	   29 + 	uint instanceID : SV_InstanceID;
	30 30   #endif
	31 31   };
	32 32   
	33 33   #ifdef GLINT
	34 34   float2 calculateLayerUV(float2 origUV, float offset, float rotation) {
	        ...
	        '''
Changed file "current_color.fragment.hlsl":
	Total line: 25 (+15, -8)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	    3 + struct PS_Input
	    4 + {
	    5 + 	float4 position : SV_Position;
	    6 + };
	    7 + 
	    8 + struct PS_Output
	    9 + {
	   10 + 	float4 color : SV_Target;
	   11 + 
	   12 + #ifdef FORCE_DEPTH_ZERO
	   13 + 	float depth : SV_Depth;
	   14 + #endif
	 3    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 4 15   
	 5    - struct PS_Input
	 6    - {
	 7    -     float4 position : SV_Position;
	 8 16   };
	 9 17   
	   18 + void main( in PS_Input PSInput, out PS_Output PSOutput )
	10    - struct PS_Output
	11 19   {
	   20 + 	PSOutput.color = CURRENT_COLOR;
	12    -     float4 color : SV_Target;
	13    - };
	14 21   
	   22 + #ifdef FORCE_DEPTH_ZERO
	15    - void main( in PS_Input PSInput, out PS_Output PSOutput )
	16    - {
	   23 + 	PSOutput.depth = 0.0;
	17    -     PSOutput.color = CURRENT_COLOR;
	   24 + #endif
	18 25   }
	        '''
Changed file "entity.fragment.hlsl":
	Total line: 106 (+51, -34)
	          '''
	  1   1   #include "ShaderConstants.fxh"
	      2 + #include "Util.fxh"
	      3 + 
	      4 + struct PS_Input {
	      5 + 	float4 position : SV_Position;
	      6 + 
	      7 + 	float4 light : LIGHT;
	      8 + 	float4 fogColor : FOG_COLOR;
	      9 + 
	     10 + #ifdef GLINT
	     11 + 	// there is some alignment issue on the Windows Phone 1320 that causes the position
	     12 + 	// to get corrupted if this is two floats and last in the struct memory wise
	     13 + 	float4 layerUV : GLINT_UVS;
	     14 + #endif
	     15 + 
	     16 + #ifdef USE_OVERLAY
	     17 + 	float4 overlayColor : OVERLAY_COLOR;
	     18 + #endif
	     19 + 
	     20 + 	float2 uv : TEXCOORD_0_FB_MSAA;
	     21 + 
	     22 + };
	     23 + 
	     24 + struct PS_Output
	     25 + {
	     26 +     float4 color : SV_Target;
	     27 + };
	     28 + 
	     29 + #ifdef USE_EMISSIVE
	     30 + #define NEEDS_DISCARD(C)	(C.a + C.r + C.g + C.b == 0.0)
	     31 + #else
	     32 + #ifndef USE_COLOR_MASK
	     33 + #define NEEDS_DISCARD(C)	(C.a < 0.5)
	     34 + #else
	     35 + #define NEEDS_DISCARD(C)	(C.a <= 0.0)
	     36 + #endif
	     37 + #endif
	  2     - 
	  3     - struct PS_Input {
	  4     - 	float4 position : SV_Position;
	  5  38   
	     39 + float4 glintBlend(float4 dest, float4 source) {
	     40 + 	// glBlendFuncSeparate(GL_SRC_COLOR, GL_ONE, GL_ONE, GL_ZERO)
	     41 + 	return float4(source.rgb * source.rgb, source.a) + float4(dest.rgb, 0.0);
	     42 + }
	  6     - 	float4 light : LIGHT;
	  7     - 	float4 fogColor : FOG_COLOR;
	  8  43   
	     44 + void main( in PS_Input PSInput, out PS_Output PSOutput )
	  9     - #ifdef GLINT
	 10     - 	// there is some alignment issue on the Windows Phone 1320 that causes the position
	     45 + {
	     46 + 	float4 color = float4( 1.0f, 1.0f, 1.0f, 1.0f );
	 11     - 	// to get corrupted if this is two floats and last in the struct memory wise
	 12     - 	float4 layerUV : GLINT_UVS;
	     47 + 
	     48 + #ifndef COLOR_BASED
	 13     - #endif
	 14  49   
	     50 + #if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE) || (VERSION < 0xa000 /*D3D_FEATURE_LEVEL_10_0*/)
	     51 + 	color = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	     52 + #else
	     53 + 	color = texture2D_AA(TEXTURE_0, TextureSampler0, PSInput.uv);
	 15     - #ifdef USE_OVERLAY
	 16     - 	float4 overlayColor : OVERLAY_COLOR;
	 17  54   #endif
	 18     - 
	 19     - 	float2 uv : TEXCOORD_0;
	 20     - 
	 21     - };
	 22  55   
	     56 + #ifdef ALPHA_TEST
	     57 + 	if( NEEDS_DISCARD( color ) )
	 23     - struct PS_Output
	     58 + 	{
	 24     - {
	     59 + 		discard;
	     60 + 	}
	     61 + #endif
	 25     -     float4 color : SV_Target;
	 26     - };
	 27  62   
	 28     - #ifdef USE_EMISSIVE
	 29     - #define NEEDS_DISCARD(C)	(C.a + C.r + C.g + C.b == 0.0)
	 30     - #else
	 31     - #define NEEDS_DISCARD(C)	(C.a < 0.5)
	 32  63   #endif
	 33  64   
	     65 + #ifdef USE_COLOR_MASK
	 34     - float4 glintBlend(float4 dest, float4 source) {
	     66 + 	color.rgb = lerp( color, color * CHANGE_COLOR, color.a ).rgb;
	     67 + 	color.a = 1.0;
	     68 + #endif
	 35     - 	// glBlendFuncSeparate(GL_SRC_COLOR, GL_ONE, GL_ONE, GL_ZERO)
	 36     - 	return float4(source.rgb * source.rgb, source.a) + float4(dest.rgb, 0.0);
	 37     - }
	 38  69   
	     70 + #ifdef ITEM_IN_HAND
	     71 + 	color.rgb = lerp(color, color * CHANGE_COLOR, PSInput.light.a).rgb;
	 39     - void main( in PS_Input PSInput, out PS_Output PSOutput )
	 40     - {
	     72 + #endif
	 41     -     float4 color = float4( 1.0f, 1.0f, 1.0f, 1.0f );
	 42  73   
	 43     - #ifndef COLOR_BASED
	 44     -         color = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	 45  74   
	 46     - #ifdef ALPHA_TEST
	 47     -         if( NEEDS_DISCARD( color ) )
	 48     -         {
	     75 + #ifdef USE_OVERLAY
	     76 + 	//use either the diffuse or the OVERLAY_COLOR
	     77 + 	color.rgb = lerp( color, PSInput.overlayColor, PSInput.overlayColor.a ).rgb;
	 49     -             discard;
	 50     -         }
	 51     - #endif
	 52  78   #endif
	 53  79   
	 54     - #ifdef USE_COLOR_MASK
	 55     - 	#ifdef GLINT
	 56     - 		// Applies color mask to glint texture instead and blends with original color
	     80 + #ifdef USE_EMISSIVE
	     81 + 	//make glowy stuff
	     82 + 	color *= lerp( float( 1.0 ).xxxx, PSInput.light, color.a );
	     83 + #else
	 57     - 		float4 layer1 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layerUV.xy)).rgbr * CHANGE_COLOR;
	 58     - 		float4 layer2 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layerUV.zw)).rgbr * CHANGE_COLOR;
	 59     - 		float4 glint = (layer1 + layer2) * TILE_LIGHT_COLOR;
	 60     - 	#else
	 61     - 		color.rgb = lerp( color, color * CHANGE_COLOR, color.a ).rgb;
	 62     - 		color.a = 1.0;
	     84 + 	color *= PSInput.light;
	 63     - 	#endif
	 64  85   #endif
	 65  86   
	     87 +     //apply fog
	 66     - #ifdef USE_OVERLAY
	 67     -         //use either the diffuse or the OVERLAY_COLOR
	     88 +     color.rgb = lerp( color.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a );
	 68     -         color.rgb = lerp( color, PSInput.overlayColor, PSInput.overlayColor.a ).rgb;
	 69     - #endif
	 70  89   
	     90 + #ifdef GLINT
	     91 + 	// Applies color mask to glint texture instead and blends with original color
	 71     - #ifdef USE_EMISSIVE
	     92 + 	float4 layer1 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layerUV.xy)).rgbr * GLINT_COLOR;
	     93 + 	float4 layer2 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layerUV.zw)).rgbr * GLINT_COLOR;
	     94 + 	float4 glint = (layer1 + layer2) * TILE_LIGHT_COLOR;
	     95 + 	color = glintBlend(color, glint);
	 72     -         //make glowy stuff
	 73     -         color *= lerp( float( 1.0 ).xxxx, PSInput.light, color.a );
	 74     - #else
	 75     -         color *= PSInput.light;
	 76  96   #endif
	 77  97   
	     98 +     //WARNING do not refactor this 
	 78     -     //apply fog
	     99 +     PSOutput.color = color;
	 79     -     color.rgb = lerp( color.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a );
	 80 100   
	    101 + #ifdef VR_FEATURE
	    102 + 	// On Rift, the transition from 0 brightness to the lowest 8 bit value is abrupt, so clamp to 
	 81     - #ifdef USE_COLOR_MASK
	    103 + 	// the lowest 8 bit value.
	    104 + 	PSOutput.color = max(PSOutput.color, 1 / 255.0f);
	 82     - 	#ifdef GLINT
	 83     - 		color = glintBlend(color, glint);
	 84     - 	#endif
	 85 105   #endif
	 86     - 
	 87     -     //WARNING do not refactor this 
	 88     -     PSOutput.color = color;
	 89 106   }
	          '''
Changed file "entity.vertex.hlsl":
	Total line: 136 (+1, -0)
	          '''
	          ...
	 27  27   
	 28  28   #ifdef USE_OVERLAY
	 29  29   	float4 overlayColor : OVERLAY_COLOR;
	 30  30   #endif
	 31  31   
	     32 + 	float2 uv : TEXCOORD_0_FB_MSAA;
	 32     - 	float2 uv : TEXCOORD_0;
	     33 + 
	 33  34   #ifdef INSTANCEDSTEREO
	 34  35   	uint instanceID : SV_InstanceID;
	 35  36   #endif
	 36  37   };
	 37  38   
	          ...
	          '''
Changed file "flat_white.fragment.hlsl":
	Total line: 16 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 4    - 
	 5  3   struct PS_Input
	 6  4   {
	 7  5       float4 position : SV_Position;
	 8  6   };
	 9  7   
	        ...
	        '''
Changed file "hologram_sr.fragment.hlsl":
	Total line: 17 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 4    - 
	 5  3   struct PS_Input
	 6  4   {
	 7  5       float4 position : SV_Position;
	 8  6       float4 color : COLOR;
	 9  7   };
	        ...
	        '''
Changed file "hologram_sr.vertex.hlsl":
	Total line: 34 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to vertex shader and shader model to vs_40 (in visual studio)
	 4    - 
	 5  3   struct VS_Input
	 6  4   {
	    5 + 	float3 position : POSITION;
	 7    -     float3 position : POSITION;
	 8  6   	float4 normal : NORMAL;
	 9  7   	float4 color : COLOR;
	10  8   #ifdef INSTANCEDSTEREO
	11  9   	uint instanceID : SV_InstanceID;
	12 10   #endif
	13 11   };
	14 12   
	15 13   
	16 14   struct PS_Input
	17 15   {
	   16 + 	float4 position : SV_Position;
	   17 + 	float4 color : COLOR;
	18    -     float4 position : SV_Position;
	19    -     float4 color : COLOR;
	20 18   #ifdef INSTANCEDSTEREO
	21 19   	uint instanceID : SV_InstanceID;
	22 20   #endif
	23 21   };
	24 22   
	25 23   
	26 24   void main( in VS_Input VSInput, out PS_Input PSInput )
	27 25   {
	   26 + 	PSInput.color = VSInput.color * 0.5f + -0.5f * dot(VSInput.normal, float4(GAZE_DIRECTION, 0.0f));
	28    -     PSInput.color = VSInput.color * 0.5f + -0.5f * dot(VSInput.normal, float4(GAZE_DIRECTION, 0.0f));
	29 27   #ifdef INSTANCEDSTEREO
	30 28   	int i = VSInput.instanceID;
	31 29   	PSInput.position = mul( WORLDVIEWPROJ_STEREO[i], float4( VSInput.position, 1.0f ) );
	32 30   	PSInput.instanceID = i;
	33 31   #else
	        ...
	        '''
Changed file "hologram_texture_stereo.fragment.hlsl":
	Total line: 27 (+0, -2)
	        '''
	 1  1   // DO NOT HAVE THIS INCLUDE BE THE FIRST LINE!  we need a #define to be respected in the .fxh file
	 2  2   #include "ShaderConstants.fxh"
	 3  3   
	 4    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 5    - 
	 6  4   struct PS_Input
	 7  5   {
	    6 + 	float4	position		: SV_Position;
	 8    -     float4	position		: SV_Position;
	 9  7   	float2	uv				: TEXCOORD_0; // the stereo texture uses a texture array
	10  8   #ifdef INSTANCEDSTEREO
	11  9   	uint	instanceID		: SV_InstanceID;
	12 10   #endif
	13 11   };
	14 12   
	15 13   struct PS_Output
	16 14   {
	   15 + 	float4 color : SV_Target;
	17    -     float4 color : SV_Target;
	18 16   };
	19 17   
	20 18   void main( in PS_Input PSInput, out PS_Output PSOutput )
	21 19   {
	22 20   #ifdef INSTANCEDSTEREO
	        ...
	        '''
Changed file "holoroom_inner_skirt.fragment.hlsl":
	Total line: 22 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 4    - 
	 5  3   struct PS_Input
	 6  4   {
	    5 + 	float4 position : SV_Position;
	 7    -     float4 position : SV_Position;
	 8  6   	float4 color : COLOR;
	 9  7   	float2 uv : TEXCOORD_0;
	10  8   };
	11  9   
	12 10   struct PS_Output
	13 11   {
	   12 + 	float4 color : SV_Target;
	14    -     float4 color : SV_Target;
	15 13   };
	16 14   
	17 15   void main( in PS_Input PSInput, out PS_Output PSOutput )
	18 16   {
	19 17   	float2 uv = PSInput.uv * SKIRT_UV_SCALE.xy;
	        ...
	        '''
Changed file "holoroom_inner_skirt.vertex.hlsl":
	Total line: 38 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to vertex shader and shader model to vs_40 (in visual studio)
	 4    - 
	 5  3   struct VS_Input
	 6  4   {
	    5 + 	float3 position : POSITION;
	    6 + 	float4 color : COLOR;
	    7 + 	float2 texCoords : TEXCOORD_0;
	 7    -     float3 position : POSITION;
	 8    -     float4 color : COLOR;
	 9    -     float2 texCoords : TEXCOORD_0;
	10  8   #ifdef INSTANCEDSTEREO
	11  9   	uint instanceID : SV_InstanceID;
	12 10   #endif
	13 11   };
	14 12   
	15 13   
	16 14   struct PS_Input
	17 15   {
	   16 + 	float4 position : SV_Position;
	   17 + 	float4 color : COLOR;
	   18 + 	float2 texCoords : TEXCOORD_0;
	18    -     float4 position : SV_Position;
	19    -     float4 color : COLOR;
	20    -     float2 texCoords : TEXCOORD_0;
	21 19   #ifdef INSTANCEDSTEREO
	22 20   	uint instanceID : SV_InstanceID;
	23 21   #endif
	24 22   };
	25 23   
	26 24   
	27 25   void main( in VS_Input VSInput, out PS_Input PSInput )
	28 26   {
	   27 + 	PSInput.color = VSInput.color;
	29    -     PSInput.color = VSInput.color;
	30 28   
	31 29   #ifdef INSTANCEDSTEREO
	32 30   	int i = VSInput.instanceID;
	33 31   	PSInput.position = mul( WORLDVIEWPROJ_STEREO[i], float4( VSInput.position, 1 ) );
	34 32   	PSInput.instanceID = i;
	35 33   #else
	36 34   	PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	37 35   #endif
	   36 + 	PSInput.texCoords = VSInput.texCoords;
	38    -     PSInput.texCoords = VSInput.texCoords;
	39 37   
	40 38   }
	        '''
Changed file "holoroom_tableSurface.fragment.hlsl":
	Total line: 24 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 4    - 
	 5  3   struct PS_Input
	 6  4   {
	    5 + 	float4 position : SV_Position;
	 7    -     float4 position : SV_Position;
	 8  6   	float3 color : COLOR;
	    7 + 	float2 uv : TEXCOORD_0;
	 9    -     float2 uv : TEXCOORD_0;
	10  8   
	11  9   };
	12 10   
	13 11   struct PS_Output
	14 12   {
	   13 + 	float4 color : SV_Target;
	15    -     float4 color : SV_Target;
	16 14   };
	17 15   
	18 16   void main( in PS_Input PSInput, out PS_Output PSOutput )
	19 17   {
	   18 + 	float4 diffuse = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	   19 + 	//diffuse.rgb *= TEXTURE_1.Sample(TextureSampler1, float2(0, PSInput.color.a)).rgb;
	20    -     float4 diffuse = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	21    -     //diffuse.rgb *= TEXTURE_1.Sample(TextureSampler1, float2(0, PSInput.color.a)).rgb;
	22 20   	//diffuse.rgb *= float3(151.0f/255.0f, 59.0f/255.0f, 224.0f/255.0f);
	23 21   	diffuse.rgb *= PSInput.color.rgb;
	24 22   
	   23 + 	PSOutput.color = diffuse;
	25    -     PSOutput.color = diffuse;
	26 24   }
	        '''
Changed file "holoroom_tableSurface.vertex.hlsl":
	Total line: 51 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to vertex shader and shader model to vs_40 (in visual studio)
	 4    - 
	 5  3   struct VS_Input
	 6  4   {
	    5 + 	float3 position : POSITION;
	 7    -     float3 position : POSITION;
	 8  6   	float3 normal : NORMAL;
	    7 + 	float4 color : COLOR;
	    8 + 	float2 texCoords : TEXCOORD_0;
	 9    -     float4 color : COLOR;
	10    -     float2 texCoords : TEXCOORD_0;
	11  9   #ifdef INSTANCEDSTEREO
	12 10   	uint instanceID : SV_InstanceID;
	13 11   #endif
	14 12   };
	15 13   
	16 14   
	17 15   struct PS_Input
	18 16   {
	   17 + 	float4 position : SV_Position;
	   18 + 	float4 color : COLOR;
	   19 + 	float2 texCoords : TEXCOORD_0;
	19    -     float4 position : SV_Position;
	20    -     float4 color : COLOR;
	21    -     float2 texCoords : TEXCOORD_0;
	22 20   #ifdef INSTANCEDSTEREO
	23 21   	uint instanceID : SV_InstanceID;
	24 22   #endif
	25 23   };
	26 24   
	27 25   
	28 26   void main( in VS_Input VSInput, out PS_Input PSInput )
	29 27   {
	   28 + 	PSInput.color = VSInput.color;
	30    -     PSInput.color = VSInput.color;
	31 29   	float3 position = VSInput.position;
	32 30   	float3 voxelCenter = VSInput.normal * 80.0f - float3(40.0f, 40.0f, 40.0f);
	33 31   	voxelCenter.y = -0.5f;
	34 32   	float2 delta = voxelCenter.xz - TABLE_REVEAL_CENTER.xz;
	35 33   	float lengthSq = dot(delta, delta);
	        ...
	        '''
Changed file "holoroom_terrain_endcap.fragment.hlsl":
	Total line: 32 (+1, -3)
	        '''
	 1  1   //$ANTCOLONY
	 2  2   
	 3  3   #include "ShaderConstants.fxh"
	 4  4   
	 5    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 6    - 
	 7  5   struct PS_Input
	 8  6   {
	 9  7   	float4 position : SV_Position;
	10  8   	float4	color			: COLOR;
	    9 + 	float2 uv0 : TEXCOORD_0;
	   10 + 	float4 uv1 : TEXCOORD_1;
	11    -     float2 uv0 : TEXCOORD_0;
	12    -     float4 uv1 : TEXCOORD_1;
	13 11   };
	14 12   
	15 13   struct PS_Output
	16 14   {
	17 15   	float4 color : SV_Target;
	18 16   };
	19 17   
	20 18   void main(in PS_Input PSInput, out PS_Output PSOutput)
	21 19   {
	22 20   	float2 uv = PSInput.uv1.xy + (PSInput.uv0 - floor(PSInput.uv0)) * PSInput.uv1.zw;
	   21 + 	float4 diffuse = TEXTURE_0.Sample(TextureSampler0, uv);
	23    -     float4 diffuse = TEXTURE_0.Sample(TextureSampler0, uv);
	24 22   	float2 lightingUVs = float2(0.0f, 0.9f);
	25 23   	diffuse.rgb *= TEXTURE_1.Sample(TextureSampler1, lightingUVs).rgb;
	26 24   
	   25 + 	if (diffuse.a < 0.5f)
	27    -     if (diffuse.a < 0.5f)
	   26 + 	{
	28    -     {
	   27 + 		discard;
	   28 + 	}
	29    -         discard;
	30    -     }
	31 29   
	   30 + 	diffuse *= PSInput.color;
	32    -     diffuse *= PSInput.color;
	33 31   	PSOutput.color = diffuse;
	34 32   }
	        '''
Changed file "holoroom_terrain_endcap.vertex.hlsl":
	Total line: 48 (+0, -2)
	        '''
	 1  1   //$ANTCOLONY
	 2  2   #include "ShaderConstants.fxh"
	 3  3   
	 4    - // be sure to change the shader type to vertex shader and shader model to vs_40 (in visual studio)
	 5    - 
	 6  4   struct VS_Input
	 7  5   {
	 8  6   	float3 position : POSITION;
	 9  7   	float2 uv0 : TEXCOORD_0;	// x,y 0-1 based off if voxel texture wasn't in atlas. Can multiply against atlas UV's to get atlas uv's
	10  8   	float2 uv1 : TEXCOORD_1;	// x = voxel coord x, y = voxel coord y
	        ...
	16 14   struct PS_Input
	17 15   {
	18 16   	float4 position : SV_Position;
	19 17   	float4	color			: COLOR;
	20 18   	float2 uv0 : TEXCOORD_0;
	   19 + 	float4 uvRect : TEXCOORD_1;
	21    -     float4 uvRect : TEXCOORD_1;
	22 20   #ifdef INSTANCEDSTEREO
	23 21   	uint instanceID : SV_InstanceID;
	24 22   #endif
	25 23   };
	26 24   
	        ...
	34 32   	float4 uvCoords = TEXTURE_1[tileUVs];
	35 33   
	36 34   	tileUVs.x = 4.0f;
	37 35   	float4 colorVal = TEXTURE_1[tileUVs];
	38 36   
	   37 + 	PSInput.uv0 = VSInput.uv0 * float2(1.0f, 127.0f);
	   38 + 	PSInput.uvRect = uvCoords;
	39    -     PSInput.uv0 = VSInput.uv0 * float2(1.0f, 127.0f);
	40    -     PSInput.uvRect = uvCoords;
	41 39   
	42 40   #ifdef INSTANCEDSTEREO
	43 41   	int i = VSInput.instanceID;
	44 42   	PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], float4(position.xyz, 1));
	45 43   	PSInput.instanceID = i;
	        ...
	        '''
Changed file "iteminhand.fragment.hlsl":
	Total line: 21 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 4    - 
	 5  3   struct PS_Input
	 6  4   {
	 7  5       float4 position : SV_Position;
	 8  6       float4 light : LIGHT;
	 9  7   };
	        ...
	        '''
Changed file "position.geometry.hlsl":
	Total line: 46 (+10, -1)
	        '''
	        ...
	16 16   	uint        renTarget_id : SV_RenderTargetArrayIndex;
	17 17   #endif
	18 18   };
	19 19   
	20 20   // passes through the triangles, except changint the viewport id to match the instance
	   21 + #ifdef LINE_STRIP
	   22 + [maxvertexcount(2)]
	   23 + void main(line GeometryShaderInput input[2], inout LineStream<GeometryShaderOutput> outStream)
	   24 + #else
	   25 + [maxvertexcount(3)]
	   26 + void main(triangle GeometryShaderInput input[3], inout TriangleStream<GeometryShaderOutput> outStream)
	   27 + #endif
	   28 + {
	   29 + 	GeometryShaderOutput output = (GeometryShaderOutput)0;
	   30 + 
	   31 + #ifdef INSTANCEDSTEREO
	   32 + 	int i = input[0].instanceID;
	   33 + #endif
	   34 + #ifdef LINE_STRIP
	   35 + 	for (int j = 0; j < 2; j++)
	   36 + #else
	   37 + 	for (int j = 0; j < 3; j++)
	21    - [maxvertexcount(3)]
	22    - void main(triangle GeometryShaderInput input[3], inout TriangleStream<GeometryShaderOutput> outStream)
	23    - {
	24    - 	GeometryShaderOutput output = (GeometryShaderOutput)0;
	25    - 
	26    - #ifdef INSTANCEDSTEREO
	27    - 	int i = input[0].instanceID;
	28 38   #endif
	29    - 	for (int j = 0; j < 3; j++)
	30 39   	{
	31 40   		output.pos = input[j].pos;
	32 41   #ifdef INSTANCEDSTEREO
	33 42   		output.renTarget_id = i;
	34 43   #endif
	        ...
	        '''
Changed file "rain_snow.fragment.hlsl":
	Total line: 39 (+2, -3)
	        '''
	        ...
	19 19   	PSOutput.color.a *= PSInput.color.a;
	20 20   
	21 21   	float2 uv = PSInput.worldPosition.xz;
	22 22   	float4 occlusionTexture = TEXTURE_1.Sample(TextureSampler1, uv);
	23 23   
	24    - 	occlusionTexture.a *= 255.0f;	// Alpha stores height of world
	25    - 
	26 24   	// clamp the uvs
	   25 + 	if (uv.x >= 0.0f && uv.x <= 1.0f && 
	   26 + 		uv.y >= 0.0f && uv.y <= 1.0f && 
	27    - 	float2 uvclamp = saturate(uv);
	   27 + 		PSInput.worldPosition.y < occlusionTexture.a) {
	28    - 	if (uvclamp.x == uv.x && uvclamp.y == uv.y && PSInput.worldPosition.y < occlusionTexture.a) {
	29 28   		PSOutput.color.a = 0.0f;
	30 29   	}
	31 30   
	   31 + 	float mixAmount = saturate((PSInput.worldPosition.y - occlusionTexture.a)*10.0f);
	32    - 	float mixAmount = saturate((PSInput.worldPosition.y - occlusionTexture.a)*0.1f);
	33 32   	float3 lighting = lerp(occlusionTexture.rgb, PSInput.color.rgb, mixAmount);
	34 33   	PSOutput.color.rgb *= lighting.rgb;
	35 34   
	36 35   	//apply fog
	37 36   	PSOutput.color.rgb = lerp(PSOutput.color.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a);
	        ...
	        '''
Changed file "rain_snow.vertex.hlsl":
	Total line: 81 (+1, -0)
	        '''
	        ...
	72 72   	PSInput.fogColor.a = clamp(((PSInput.position.z / RENDER_DISTANCE) - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	73 73   
	74 74   	worldPositionBottom.xz *= 1.0f / 64.0f;	// Scale by 1/TextureDimensions to get values between
	75 75   	worldPositionBottom.xz += 0.5f;			// Offset so that center of view is in the center of occlusion texture
	76 76   	worldPositionBottom.y += VIEW_POSITION.y - 0.5f;
	   77 + 	worldPositionBottom.y *= 1.0f / 255.0f;
	77 78   	PSInput.worldPosition = worldPositionBottom;
	78 79   }
	79 80   
	80 81   
	        '''
Changed file "renderchunk.fragment.hlsl":
	Total line: 79 (+20, -14)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	    2 + #include "Util.fxh"
	 2  3   
	 3  4   struct PS_Input
	 4  5   {
	    6 + 	float4 position : SV_Position;
	    7 + 	lpfloat4 color : COLOR;
	    8 + 	snorm float2 uv0 : TEXCOORD_0_FB_MSAA;
	    9 + 	snorm float2 uv1 : TEXCOORD_1_FB_MSAA;
	   10 + #ifdef NEAR_WATER
	   11 + 	float cameraDist : TEXCOORD_2;
	 5    -     float4 position : SV_Position;
	 6    -     lpfloat4 color : COLOR;
	 7    -     snorm float2 uv0 : TEXCOORD_0;
	 8    -     snorm float2 uv1 : TEXCOORD_1;
	 9    - #ifdef HOLOGRAPHIC
	10    - 	float4 worldPosition : TEXCOORD_2;
	11 12   #endif
	   13 + 
	12 14   #ifdef FOG
	   15 + 	float4 fogColor : FOG_COLOR;
	13    -     float4 fogColor : FOG_COLOR;
	14 16   #endif
	15 17   };
	16 18   
	17 19   struct PS_Output
	18 20   {
	   21 + 	float4 color : SV_Target;
	19    -     float4 color : SV_Target;
	20 22   };
	21 23   
	22 24   void main( in PS_Input PSInput, out PS_Output PSOutput )
	23 25   {
	   26 + #if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE) || (VERSION < 0xa000 /*D3D_FEATURE_LEVEL_10_0*/) 
	   27 + 	float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv0);
	   28 + #else
	   29 + 	float4 diffuse = texture2D_AA(TEXTURE_0, TextureSampler0, PSInput.uv0 );
	24    - 	float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv0);
	   30 + #endif
	25 31   
	26 32   #ifdef SEASONS_FAR
	27 33   	diffuse.a = 1.0f;
	28 34   	PSInput.color.b = 1.0f;
	29 35   #endif
	30 36   
	31    - #ifdef HOLOGRAPHIC
	32    - 	if (PSInput.worldPosition.x < CHUNK_CLIP_MIN.x ||
	   37 + #ifdef ALPHA_TEST
	   38 + //If we know that all the verts in a triangle will have the same alpha, we should cull there first.
	   39 + 	if( diffuse.a < 0.5 )
	33    - 		PSInput.worldPosition.x > CHUNK_CLIP_MAX.x ||
	34    - 		PSInput.worldPosition.z < CHUNK_CLIP_MIN.y ||
	35    - 		PSInput.worldPosition.z > CHUNK_CLIP_MAX.y)
	36 40   	{
	37 41   		discard;
	38 42   	}
	39 43   #endif
	40    - 
	41 44   
	42    - #ifdef ALPHA_TEST
	43    - //If we know that all the verts in a triangle will have the same alpha, we should cull there first.
	44    -     if( diffuse.a < 0.5 )
	45    -     {
	   45 + 	diffuse = diffuse * TEXTURE_1.Sample(TextureSampler1, PSInput.uv1);
	   46 + 
	   47 + #ifndef SEASONS
	46    -         discard;
	47    -     }
	48    - #endif
	49 48   
	   49 + #if !defined(ALPHA_TEST) && !defined(BLEND)
	   50 + 	diffuse.a = PSInput.color.a;
	   51 + #elif defined(BLEND)
	   52 + 	diffuse.a *= PSInput.color.a;
	50    - 	diffuse = diffuse * TEXTURE_1.Sample(TextureSampler1, PSInput.uv1);
	51 53   
	   54 + #ifdef NEAR_WATER
	   55 + 	float alphaFadeOut = saturate(PSInput.cameraDist.x);
	   56 + 	diffuse.a = lerp(diffuse.a, 1.0f, alphaFadeOut);
	   57 + #endif
	52    - #ifndef SEASONS
	53 58   
	   59 + #endif	
	   60 + 	diffuse.rgb *= PSInput.color.rgb;
	   61 + #else
	   62 + 	float2 uv = PSInput.color.xy;
	54    - #if !defined(ALPHA_TEST) && !defined(BLEND)
	55    - 	diffuse.a = PSInput.color.a;
	   63 + 	diffuse.rgb *= lerp(1.0f, TEXTURE_2.Sample(TextureSampler2, uv).rgb*2.0f, PSInput.color.b);
	56    - #elif defined(BLEND)
	   64 + 	diffuse.rgb *= PSInput.color.aaa;
	57    - 	diffuse.a *= PSInput.color.a;
	   65 + 	diffuse.a = 1.0f;
	   66 + #endif
	58    - #endif	
	59    - 	diffuse.rgb *= PSInput.color.rgb;
	60    - #else
	61    - 	float2 uv = PSInput.color.xy;
	   67 + 
	62    - 	uv.y += 1.0f / 512.0f;
	63    - 	diffuse.rgb *= lerp(1.0f, TEXTURE_2.Sample(TextureSampler2, uv).rgb*2.0f, PSInput.color.b);
	   68 + #ifdef FOG
	   69 + 	diffuse.rgb = lerp( diffuse.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a );
	64    - 	diffuse.rgb *= PSInput.color.aaa;
	65    - 	diffuse.a = 1.0f;
	66 70   #endif
	   71 + 
	   72 + 	PSOutput.color = diffuse;
	67 73   
	   74 + #ifdef VR_FEATURE
	   75 + 	// On Rift, the transition from 0 brightness to the lowest 8 bit value is abrupt, so clamp to 
	   76 + 	// the lowest 8 bit value.
	   77 + 	PSOutput.color = max(PSOutput.color, 1 / 255.0f);
	68    - #ifdef FOG
	69    -     diffuse.rgb = lerp( diffuse.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a );
	70 78   #endif
	71    - 
	72    -     PSOutput.color = diffuse;
	73 79   }
	        '''
Changed file "renderchunk.geometry.hlsl":
	Total line: 72 (+3, -21)
	        '''
	        ...
	 4  4   {
	 5  5   	float4				pos				: SV_POSITION;
	 6  6   	lpfloat4			color			: COLOR;
	 7  7   	snorm float2		uv0				: TEXCOORD_0;
	 8  8   	snorm float2		uv1				: TEXCOORD_1;
	 9    - 	float4 worldPosition : TEXCOORD_2;
	10  9   #ifdef FOG
	11 10   	float4				fogColor		: FOG_COLOR;
	12    - #endif
	13    - #ifdef INSTANCEDSTEREO
	14    - 	uint				instanceID		: SV_InstanceID;
	15 11   #endif
	   12 + #ifdef INSTANCEDSTEREO
	16    - #ifdef HOLOGRAPHIC
	17    - 	float clipDist0 : SV_ClipDistance0;
	   13 + 	uint				instanceID		: SV_InstanceID;
	18    - 	float cullDist0 : SV_CullDistance0;
	19 14   #endif
	20 15   };
	21 16   
	22 17   // Per-pixel color data passed through the pixel shader.
	23 18   struct GeometryShaderOutput
	24 19   {
	25 20   	float4				pos				: SV_POSITION;
	26 21   	lpfloat4			color			: COLOR;
	27 22   	snorm float2		uv0				: TEXCOORD_0;
	28 23   	snorm float2		uv1				: TEXCOORD_1;
	29    - 	float4 worldPosition : TEXCOORD_2;
	30 24   #ifdef FOG
	31 25   	float4				fogColor		: FOG_COLOR;
	32    - #endif
	33    - #ifdef INSTANCEDSTEREO
	34    - 	uint				renTarget_id : SV_RenderTargetArrayIndex;
	35 26   #endif
	   27 + #ifdef INSTANCEDSTEREO
	36    - #ifdef HOLOGRAPHIC
	37    - 	float clipDist0 : SV_ClipDistance0;
	   28 + 	uint				renTarget_id : SV_RenderTargetArrayIndex;
	38    - 	float cullDist0 : SV_CullDistance0;
	39 29   #endif
	40 30   };
	41 31   
	42 32   bool inBounds(float3 worldPos)
	43 33   {
	        ...
	59 49   {
	60 50   	GeometryShaderOutput output = (GeometryShaderOutput)0;
	61 51   
	62 52   #ifdef INSTANCEDSTEREO
	63 53   	int i = input[0].instanceID;
	64    - #endif
	65    - #ifdef HOLOGRAPHIC
	66    - 	if (inBounds(input[0].worldPosition) || inBounds(input[1].worldPosition) || inBounds(input[2].worldPosition))
	67 54   #endif
	68    - 	{
	69    - 		for (int j = 0; j < 3; j++)
	   55 + 	{
	70    - 		{
	71    - 			output.pos = input[j].pos;
	72    - 			output.color			= input[j].color;
	   56 + 		for (int j = 0; j < 3; j++)
	   57 + 		{
	   58 + 			output.pos = input[j].pos;
	73    - 			output.uv0				= input[j].uv0;
	74    - 			output.uv1				= input[j].uv1;
	75    - 			output.worldPosition	= input[j].worldPosition;
	76    - #ifdef INSTANCEDSTEREO
	   59 + 			output.color			= input[j].color;
	77    - 			output.renTarget_id = i;
	78    - #endif
	   60 + 			output.uv0				= input[j].uv0;
	   61 + 			output.uv1				= input[j].uv1;
	79    - #ifdef HOLOGRAPHIC
	80    - 			output.clipDist0 = input[j].clipDist0;
	   62 + #ifdef INSTANCEDSTEREO
	   63 + 			output.renTarget_id = i;
	81    - 			output.cullDist0 = input[j].cullDist0;
	82 64   #endif
	83 65   
	84 66   #ifdef FOG
	85 67   			output.fogColor			= input[j].fogColor;
	86 68   #endif
	        ...
	        '''
Changed file "renderchunk.vertex.hlsl":
	Total line: 111 (+13, -20)
	          '''
	  1   1   #include "ShaderConstants.fxh"
	  2   2   
	      3 + struct VS_Input {
	  3     - struct VS_Input
	  4     - {
	      4 + 	float3 position : POSITION;
	      5 + 	float4 color : COLOR;
	      6 + 	float2 uv0 : TEXCOORD_0;
	      7 + 	float2 uv1 : TEXCOORD_1;
	  5     -     float3 position : POSITION;
	  6     -     float4 color : COLOR;
	  7     -     float2 uv0 : TEXCOORD_0;
	  8     -     float2 uv1 : TEXCOORD_1;
	  9   8   #ifdef INSTANCEDSTEREO
	 10   9   	uint instanceID : SV_InstanceID;
	 11  10   #endif
	 12  11   };
	 13  12   
	 14  13   
	     14 + struct PS_Input {
	 15     - struct PS_Input
	 16     - {
	     15 + 	float4 position : SV_Position;
	     16 + 	lpfloat4 color : COLOR;
	 17     -     float4 position : SV_Position;
	 18     -     lpfloat4 color : COLOR;
	 19     -     snorm float2 uv0 : TEXCOORD_0;
	 20     -     snorm float2 uv1 : TEXCOORD_1;
	 21     - #ifdef HOLOGRAPHIC
	     17 + 	snorm float2 uv0 : TEXCOORD_0_FB_MSAA;
	     18 + 	snorm float2 uv1 : TEXCOORD_1_FB_MSAA;
	 22     -         float4 worldPosition : TEXCOORD_2;
	 23     - #endif
	 24  19   
	     20 + #ifdef NEAR_WATER
	 25     - #ifdef FOG
	     21 + 	float cameraDist : TEXCOORD_2;
	 26     -     float4 fogColor : FOG_COLOR;
	 27  22   #endif
	     23 + 
	     24 + #ifdef FOG
	     25 + 	float4 fogColor : FOG_COLOR;
	 28     - #ifdef INSTANCEDSTEREO
	 29     - 	uint instanceID : SV_InstanceID;
	 30  26   #endif
	     27 + #ifdef INSTANCEDSTEREO
	 31     - #ifdef HOLOGRAPHIC
	 32     - 	float clipDist0 : SV_ClipDistance0;
	     28 + 	uint instanceID : SV_InstanceID;
	 33     - 	float cullDist0 : SV_CullDistance0;
	 34  29   #endif
	 35  30   };
	 36  31   
	 37  32   
	 38  33   static const float rA = 1.0;
	 39  34   static const float rB = 1.0;
	     35 + static const float3 UNIT_Y = float3(0, 1, 0);
	 40     - static const float3 UNIT_Y = float3( 0, 1, 0 );
	 41  36   static const float DIST_DESATURATION = 56.0 / 255.0; //WARNING this value is also hardcoded in the water color, don'tchange
	 42  37   
	 43  38   
	     39 + void main(in VS_Input VSInput, out PS_Input PSInput) {
	 44     - void main( in VS_Input VSInput, out PS_Input PSInput )
	 45     - {
	     40 + 	PSInput.uv0 = VSInput.uv0;
	     41 + 	PSInput.uv1 = VSInput.uv1;
	     42 + 	PSInput.color = VSInput.color;
	 46     -     PSInput.uv0 = VSInput.uv0;
	 47     -     PSInput.uv1 = VSInput.uv1;
	 48     -     PSInput.color = VSInput.color;
	     43 + 
	     44 + 	float3 worldPos = (VSInput.position.xyz * CHUNK_ORIGIN_AND_SCALE.w) + CHUNK_ORIGIN_AND_SCALE.xyz;
	 49  45   
	     46 + 	// Transform to view space before projection instead of all at once to avoid floating point errors
	     47 + 	// Not required for entities because they are already offset by camera translation before rendering
	     48 + 	// World position here is calculated above and can get huge
	 50  49   #ifdef INSTANCEDSTEREO
	 51  50   	int i = VSInput.instanceID;
	     51 + 
	     52 + 	PSInput.position = mul(WORLDVIEW_STEREO[i], float4(worldPos, 1 ));
	 52     - 	PSInput.position = mul( WORLDVIEWPROJ_STEREO[i], float4( VSInput.position.xyz, 1 ) );
	 53     - 	PSInput.instanceID = i;
	 54     - #else
	     53 + 	PSInput.position = mul(PROJ_STEREO[i], PSInput.position);
	 55     - 	PSInput.position = mul(WORLDVIEWPROJ, float4( VSInput.position.xyz, 1 ) );
	 56     - #endif
	 57  54   
	     55 + 	PSInput.instanceID = i;
	     56 + #else
	 58     - 	float3 worldPos = VSInput.position.xyz + CHUNK_ORIGIN;
	     57 + 	PSInput.position = mul(WORLDVIEW, float4( worldPos, 1 ));
	     58 + 	PSInput.position = mul(PROJ, PSInput.position);
	     59 + #endif
	 59     - #ifdef HOLOGRAPHIC
	 60     - 	PSInput.worldPosition = float4(worldPos, 1);
	 61     - 
	 62  60   
	 63     - 	// check for clipping distance for the 4 sides in cutaway mode
	 64     - 	// one-to-one clipping
	 65     - #ifdef INSTANCEDSTEREO
	 66     - 	float4 posOneToOneSpace = mul(WORLD_STEREO, float4(VSInput.position.xyz, 1));
	     61 + #if defined(FOG) || defined(NEAR_WATER)
	     62 + #ifdef FANCY
	     63 + 	float3 relPos = VIEW_POS - worldPos;
	     64 + 	float cameraDepth = length(relPos);
	 67     - #else
	 68     - 	float4 posOneToOneSpace = mul(WORLD, float4(VSInput.position.xyz, 1));
	 69     - #endif
	 70     - 	posOneToOneSpace = -mul(ONETOONE_CLIPMAT, posOneToOneSpace);
	 71     - 
	     65 + #ifdef NEAR_WATER
	     66 + 	PSInput.cameraDist = cameraDepth / FAR_CHUNKS_DISTANCE;
	 72     - 	PSInput.clipDist0 = posOneToOneSpace.z;
	 73     - 	PSInput.cullDist0 = posOneToOneSpace.z;
	 74  67   #endif
	 75     - 
	 76  68   
	     69 + #else
	 77     - #if defined(FOG) || defined(NEAR_WATER)
	     70 + #ifdef NEAR_WATER
	     71 + 	float3 relPos = VIEW_POS - worldPos;
	     72 + 	float cameraDist = length(relPos);
	 78     - #ifdef FANCY
	 79     -     float3 relPos = VIEW_POS - worldPos;
	 80     -     float cameraDepth = length( relPos );
	     73 + 	PSInput.cameraDist = cameraDist / FAR_CHUNKS_DISTANCE;
	     74 + #endif
	     75 + 	float cameraDepth = PSInput.position.z;
	 81     - #else
	 82     -     float cameraDepth = PSInput.position.z;
	 83  76   #endif
	 84  77   #endif
	 85  78   
	     79 + 	///// apply fog
	 86     -     ///// apply fog
	 87  80   
	 88  81   #ifdef FOG
	     82 + 	float len = cameraDepth / RENDER_DISTANCE;
	 89     -     float len = cameraDepth / RENDER_DISTANCE;
	 90  83   #ifdef ALLOW_FADE
	     84 + 	len += CURRENT_COLOR.r;
	 91     -     len += CURRENT_COLOR.r;
	 92  85   #endif
	 93  86   
	     87 + 	PSInput.fogColor.rgb = FOG_COLOR.rgb;
	     88 + 	PSInput.fogColor.a = clamp((len - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	 94     -     PSInput.fogColor.rgb = FOG_COLOR.rgb;
	 95     -     PSInput.fogColor.a = clamp( ( len - FOG_CONTROL.x ) / ( FOG_CONTROL.y - FOG_CONTROL.x ), 0.0, 1.0 );
	 96  89   #endif
	 97  90   
	     91 + 	///// water magic
	 98     -     ///// water magic
	 99  92   #ifdef NEAR_WATER
	100  93   #ifdef FANCY  /////enhance water
	     94 + 	float F = dot(normalize(relPos), UNIT_Y);
	     95 + 	F = 1.0 - max(F, 0.1);
	     96 + 	F = 1.0 - lerp(F*F*F*F, 1.0, min(1.0, cameraDepth / FAR_CHUNKS_DISTANCE));
	101     -     float F = dot( normalize( relPos ), UNIT_Y );
	102     -     F = 1.0 - max( F, 0.1 );
	103     -     F = 1.0 - lerp( F*F*F*F, 1.0, min( 1.0, cameraDepth / FAR_CHUNKS_DISTANCE ) );
	104  97   
	     98 + 	PSInput.color.rg -= float2(float(F * DIST_DESATURATION).xx);
	105     -     PSInput.color.rg -= float2( float( F * DIST_DESATURATION ).xx );
	106  99   
	    100 + 	float4 depthColor = float4(PSInput.color.rgb * 0.5, 1.0);
	    101 + 	float4 traspColor = float4(PSInput.color.rgb * 0.45, 0.8);
	    102 + 	float4 surfColor = float4(PSInput.color.rgb, 1.0);
	107     -     float4 depthColor = float4( PSInput.color.rgb * 0.5, 1.0 );
	108     -     float4 traspColor = float4( PSInput.color.rgb * 0.45, 0.8 );
	109     -     float4 surfColor = float4( PSInput.color.rgb, 1.0 );
	110 103   
	    104 + 	float4 nearColor = lerp(traspColor, depthColor, PSInput.color.a);
	    105 + 	PSInput.color = lerp(surfColor, nearColor, F);
	111     -     float4 nearColor = lerp( traspColor, depthColor, PSInput.color.a );
	112     -     PSInput.color = lerp( surfColor, nearColor, F );
	113 106   #else
	    107 + 	PSInput.color.a = PSInput.position.z / FAR_CHUNKS_DISTANCE + 0.5;
	114     -     PSInput.color.a = PSInput.position.z / FAR_CHUNKS_DISTANCE + 0.5;
	115 108   #endif //FANCY
	116 109   #endif
	117 110   
	118 111   }
	          '''
Added file "stars.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct PS_Input
	{
	    float4 position : SV_Position;
	    float4 color : COLOR;
	};
	
	struct PS_Output
	{
	    float4 color : SV_Target;
	};
	
	void main( in PS_Input PSInput, out PS_Output PSOutput )
	{
	    PSOutput.color = PSInput.color;
	    PSOutput.color.rgb *= CURRENT_COLOR.rgb * PSInput.color.a;
	}
	'''
Changed file "text.fragment.hlsl":
	Total line: 28 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 4    - 
	 5  3   struct PS_Input
	 6  4   {
	 7  5       float4 position : SV_Position;
	 8  6       float4 color : COLOR;
	 9  7       float2 uv : TEXCOORD_0;
	        ...
	        '''
Changed file "texture.fragment.hlsl":
	Total line: 24 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 4    - 
	 5  3   struct PS_Input
	 6  4   {
	 7  5       float4 position : SV_Position;
	 8  6       float2 uv : TEXCOORD_0;
	 9  7   };
	        ...
	        '''
Added file "texture_blend.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct PS_Input
	{
		float4 position : SV_Position;
		float2 uv : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	};
	
	struct PS_Output
	{
		float4 color : SV_Target;
	};
	
	void main(in PS_Input PSInput, out PS_Output PSOutput)
	{
		float4 color = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
		float4 color1 = TEXTURE_0.Sample(TextureSampler0, PSInput.uv1);
	
		if (color.a < 0.01f)
		{
			color = color1;
		}
		else if (color.b > 0.01f) {
			color = lerp(color, color1, CURRENT_COLOR.a);
		}
	
		PSOutput.color = color;
	}
	'''
Changed file "texture_ccolor.fragment.hlsl":
	Total line: 27 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 4    - 
	 5  3   struct PS_Input
	 6  4   {
	 7  5       float4 position : SV_Position;
	 8  6       float2 uv : TEXCOORD_0;
	 9  7   };
	        ...
	        '''
Changed file "texture_cutout.fragment.hlsl":
	Total line: 25 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 4    - 
	 5  3   struct PS_Input
	 6  4   {
	 7  5       float4 position : SV_Position;
	 8  6       float2 uv : TEXCOORD_0;
	 9  7   };
	        ...
	        '''
Added file "util.fxh":
	'''
	float2 clampUVsForMipLevel(in float2 uv, in float mipLevel, in float textureWidth, in float textureHeight)
	{
		float2 uvClamped;
	
		// Clamp UVs to atlas face so that neighboring faces don't bleed across
		float2 numAtlasFaces = float2(textureWidth, textureHeight) / ATLAS_FACE_SIZE;
		float2 faceUV = frac(uv * numAtlasFaces);
		uvClamped = (uv * numAtlasFaces) - faceUV;
		float2 halfTexel = float2(.5f, .5f) / (ATLAS_FACE_SIZE / pow(2, mipLevel));
		faceUV = clamp(faceUV, halfTexel, 1 - halfTexel);
		uvClamped += faceUV;
		uvClamped /= numAtlasFaces;
	
		return uvClamped;
	}
	
	float4 texture2D_AA(in Texture2D tex, in sampler texSampler, in float2 uv)
	{
		// Texture antialiasing
		//
		// The texture coordinates are modified so that the bilinear filter will be one pixel width wide instead of one texel width. 
	
		// Get the UV deltas
		float2 dUVdx = ddx(uv) * TEXTURE_DIMENSIONS.xy;
		float2 dUVdy = ddy(uv) * TEXTURE_DIMENSIONS.xy;
		float2 dU = float2(dUVdx.x, dUVdy.x);
		float2 dV = float2(dUVdx.y, dUVdy.y);
	
		float duUV = sqrt(dot(dU, dU));
		float dvUV = sqrt(dot(dV, dV));
	
		// Determine mip map LOD
	    float d = max(dot(dUVdx, dUVdx), dot(dUVdy, dUVdy));
		float mipLevel = .5f * log2(d);
		mipLevel = mipLevel + .5f;	// Mip bias to reduce aliasing
		mipLevel = clamp(mipLevel, 0.0f, TEXTURE_DIMENSIONS.z);
	
		float2 uvModified; 
		if( mipLevel >= 1.0f)
		{
			uvModified = uv;
		}
		else
		{
			// First scale the uv so that each texel has a uv range of [0,1]
			float2 texelUV = frac(uv * TEXTURE_DIMENSIONS.xy);
	
			// Initially set uvModified to the floor of the texel position
			uvModified = (uv * TEXTURE_DIMENSIONS.xy) - texelUV;
	
			// Modify the texelUV to push the uvs toward the edges.
			//          |                 |       |                   |
			//          |         _/      |       |           /       |
			//  Change  | U     _/        |  to   | U     ___/        |
			//          |     _/          |       |     /             |
			//          |    /            |       |    /              |
			//          |         X       |       |         X         |
			float scalerU = 1.0f / (duUV);
			float scalerV = 1.0f / (dvUV);
			float2 scaler = max(float2(scalerU, scalerV), 1.0f);
			texelUV = clamp(texelUV * scaler, 0.0f, .5f) + clamp(texelUV*scaler - (scaler - .5f), 0.0f, .5f);
			uvModified += texelUV;
			uvModified /= TEXTURE_DIMENSIONS.xy;
		}
	#ifdef ATLAS_TEXTURE
		//Clamp UVs to atlas face
	
		float mipLevel0 = clamp(floor(mipLevel), 0.0f, TEXTURE_DIMENSIONS.z);
		float mipLevel1 = clamp(floor(mipLevel+1.0f), 0.0f, TEXTURE_DIMENSIONS.z);
	
		float2 uvLOD0 = clampUVsForMipLevel(uvModified, mipLevel0, TEXTURE_DIMENSIONS.x, TEXTURE_DIMENSIONS.y);
		float2 uvLOD1 = clampUVsForMipLevel(uvModified, mipLevel1, TEXTURE_DIMENSIONS.x, TEXTURE_DIMENSIONS.y);
	
		float4 diffuse0 = tex.SampleLevel(texSampler, uvLOD0, mipLevel0);
		float4 diffuse1 = tex.SampleLevel(texSampler, uvLOD1, mipLevel1);
	
		float4 diffuse = lerp(diffuse0, diffuse1, frac(mipLevel));
	
	#else
		float4 diffuse = tex.Sample(TextureSampler0, uvModified);
	#endif
		return diffuse;
	
	}
	
	'''
Changed file "uv_as_color.fragment.hlsl":
	Total line: 17 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	 3    - // be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	 4    - 
	 5  3   struct PS_Input
	 6  4   {
	 7  5       float4 position : SV_Position;
	 8  6       float2 uv : TEXCOORD_0;
	 9  7   };
	        ...
	        '''
Added file "uv_blend.geometry.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct GeometryShaderInput
	{
		float4		pos				: SV_POSITION;
		float2		uv0				: TEXCOORD_0;
		float2		uv1				: TEXCOORD_1;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	// Per-pixel color data passed through the pixel shader.
	struct GeometryShaderOutput
	{
		float4		pos				: SV_POSITION;
		float2		uv0				: TEXCOORD_0;
		float2		uv1				: TEXCOORD_1;
	#ifdef INSTANCEDSTEREO
		uint        renTarget_id : SV_RenderTargetArrayIndex;
	#endif
	};
	
	// passes through the triangles, except changint the viewport id to match the instance
	[maxvertexcount(3)]
	void main(triangle GeometryShaderInput input[3], inout TriangleStream<GeometryShaderOutput> outStream)
	{
		GeometryShaderOutput output = (GeometryShaderOutput)0;
	
	#ifdef INSTANCEDSTEREO
		int i = input[0].instanceID;
	#endif	
		{
			for (int j = 0; j < 3; j++)
			{
				output.pos = input[j].pos;
				output.uv0				= input[j].uv0;
				output.uv1				= input[j].uv1;
	#ifdef INSTANCEDSTEREO
				output.renTarget_id = i;
	#endif
				outStream.Append(output);
			}
			//outStream.RestartStrip();
		}
	}
	'''
Added file "uv_blend.vertex.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct VS_Input
	{
		float3 position : POSITION;
		float2 uv : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	struct PS_Input
	{
		float4 position : SV_Position;
		float2 uv : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	#ifdef INSTANCEDSTEREO
		uint instanceID : SV_InstanceID;
	#endif
	};
	
	
	void main(in VS_Input VSInput, out PS_Input PSInput)
	{
		PSInput.uv = VSInput.uv;
		PSInput.uv1 = VSInput.uv1;
	#ifdef INSTANCEDSTEREO
		int i = VSInput.instanceID;
		PSInput.position = mul(WORLDVIEWPROJ_STEREO[i], float4(VSInput.position, 1));
		PSInput.instanceID = i;
	#else
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	#endif
	}
	'''