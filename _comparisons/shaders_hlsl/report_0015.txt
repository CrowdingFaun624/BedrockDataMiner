Difference of "shaders" between "1.2.11" and "1.2.13.5" (beta of "1.2.13").

Changed file "ShaderConstants.fxh":
	Total line: 171 (+64, -31)
	          '''
	  1   1   // These [aren't but] should be grouped in a way that they require the least amount of updating (world data in one, model data in another, part of model data in another one, etc)
	  2   2   
	  3   3   #if (defined(USE_STEREO_TEXTURE_ARRAY) || defined(ARRAY_TEXTURE_0)) && (VERSION >= 0xa000)
	  4   4   Texture2DArray TEXTURE_0 : register (t0);
	  5   5   #else
	      6 + Texture2DMS<float4> TEXTURE_0_MS : register(t0);
	      7 + Texture2D TEXTURE_0 : register(t0);
	      8 + #endif
	      9 + 
	     10 + Texture2DMS<float4> TEXTURE_1_MS : register(t1);
	     11 + Texture2D TEXTURE_1 : register(t1);
	     12 + Texture2D TEXTURE_2 : register(t2);
	     13 + #ifndef NO_TEX_3
	     14 + Texture2D TEXTURE_3 : register(t3);
	     15 + sampler TextureSampler3 : register(s3);
	     16 + #endif
	     17 + 
	     18 + // Make sure this thing is actually getting bound
	     19 + sampler TextureSampler0 : register(s0);
	     20 + sampler TextureSampler1 : register(s1);
	     21 + sampler TextureSampler2 : register(s2);
	     22 + 
	     23 + #ifdef LOW_PRECISION
	     24 + #define lpfloat min16float
	     25 + #define lpfloat2 min16float2
	     26 + #define lpfloat4 min16float4
	     27 + #else
	     28 + #define lpfloat float
	     29 + #define lpfloat2 float2
	     30 + #define lpfloat4 float4
	     31 + #endif
	     32 + 
	     33 + #if defined(MSAA_FRAMEBUFFER_ENABLED)
	     34 + #define TEXCOORD_0_FB_MSAA TEXCOORD_0_centroid
	     35 + #define TEXCOORD_1_FB_MSAA TEXCOORD_1_centroid
	     36 + #define TEXCOORD_2_FB_MSAA TEXCOORD_2_centroid
	     37 + #define TEXCOORD_3_FB_MSAA TEXCOORD_3_centroid
	     38 + #else
	     39 + #define TEXCOORD_0_FB_MSAA TEXCOORD_0
	     40 + #define TEXCOORD_1_FB_MSAA TEXCOORD_1
	     41 + #define TEXCOORD_2_FB_MSAA TEXCOORD_2
	     42 + #define TEXCOORD_3_FB_MSAA TEXCOORD_3
	  6     - Texture2D TEXTURE_0 : register (t0);
	  7  43   #endif
	  8  44   
	  9     - Texture2D TEXTURE_1 : register (t1);
	 10     - Texture2D TEXTURE_2 : register (t2);
	 11  45   
	     46 + cbuffer RenderChunkConstants : register(b0)
	     47 + {
	 12     - // Make sure this thing is actually getting bound
	     48 +     float4 CHUNK_ORIGIN_AND_SCALE;
	     49 +     float RENDER_CHUNK_FOG_ALPHA;
	     50 + }
	 13     - sampler TextureSampler0 : register(s0);
	 14     - sampler TextureSampler1 : register(s1);
	 15     - sampler TextureSampler2 : register(s2);
	 16  51   
	 17     - #ifdef LOW_PRECISION
	 18     - #define lpfloat min16float
	 19     - #define lpfloat2 min16float2
	 20     - #define lpfloat4 min16float4
	     52 + 
	     53 + cbuffer EntityConstants
	     54 + {
	     55 +     float4 OVERLAY_COLOR;
	     56 +     float4 TILE_LIGHT_COLOR;
	 21     - #else
	 22     - #define lpfloat float
	 23     - #define lpfloat2 float2
	 24     - #define lpfloat4 float4
	 25     - #endif
	 26     - 
	     57 +     float4 CHANGE_COLOR;
	     58 +     float4 GLINT_COLOR;
	     59 +     float4 UV_ANIM;
	     60 +     float2 UV_OFFSET;
	     61 +     float2 UV_ROTATION;
	     62 +     float2 GLINT_UV_SCALE;
	     63 + }
	 27     - #if defined(MSAA_FRAMEBUFFER_ENABLED)
	 28     - #define TEXCOORD_0_FB_MSAA TEXCOORD_0_centroid
	 29     - #define TEXCOORD_1_FB_MSAA TEXCOORD_1_centroid
	 30     - #else
	 31     - #define TEXCOORD_0_FB_MSAA TEXCOORD_0
	 32     - #define TEXCOORD_1_FB_MSAA TEXCOORD_1
	 33     - #endif
	 34  64   
	     65 + cbuffer PerFrameConstants : register(b2)
	     66 + {
	 35  67   
	     68 +     float3 VIEW_POS;
	 36     - cbuffer RenderChunkConstants {
	 37     - 	float4 CHUNK_ORIGIN_AND_SCALE;
	     69 +     float TIME;
	 38     - }
	 39  70   
	 40     - cbuffer EntityConstants {
	 41     - 	float4 OVERLAY_COLOR;
	 42     - 	float4 TILE_LIGHT_COLOR;
	 43     - 	float4 CHANGE_COLOR;
	 44     - 	float4 GLINT_COLOR;
	     71 +     float4 FOG_COLOR;
	 45     - 	float4 UV_ANIM;
	     72 + 
	     73 +     float2 FOG_CONTROL;
	 46     - 	float2 UV_OFFSET;
	     74 + 
	     75 +     float RENDER_DISTANCE;
	     76 +     float FAR_CHUNKS_DISTANCE;
	 47     - 	float2 UV_ROTATION;
	 48     - 	float2 GLINT_UV_SCALE;
	 49  77   }
	 50     - 
	 51     - cbuffer PerFrameConstants {
	 52  78   
	 53     - 	float3 VIEW_POS;
	 54     - 	float TIME;
	 55  79   
	     80 + #if !defined(INSTANCEDSTEREO)
	 56     - 	float4 FOG_COLOR;
	 57  81   
	     82 + cbuffer WorldConstants : register(b1)
	     83 + {
	     84 +     float4x4 WORLDVIEWPROJ;
	     85 +     float4x4 WORLD;
	 58     - 	float2 FOG_CONTROL;
	 59     - 
	     86 +     float4x4 WORLDVIEW;
	     87 +     float4x4 PROJ;
	 60     - 	float RENDER_DISTANCE;
	 61     - 	float FAR_CHUNKS_DISTANCE;
	 62  88   }
	 63     - 
	 64  89   
	     90 + #else
	 65     - #if !defined(INSTANCEDSTEREO)
	 66  91   
	     92 + cbuffer WorldConstantsStereographic {
	     93 + 	float4x4 WORLDVIEWPROJ_STEREO[2];
	     94 + 	float4x4 WORLD_STEREO;
	     95 + 	float4x4 WORLDVIEW_STEREO[2];
	     96 + 	float4x4 PROJ_STEREO[2];
	 67     - cbuffer WorldConstants {
	 68     - 	float4x4 WORLDVIEWPROJ;
	 69     - 	float4x4 WORLD;
	 70     - 	float4x4 WORLDVIEW;
	 71     - 	float4x4 PROJ;
	 72  97   }
	 73  98   
	     99 + #endif
	 74     - #else
	 75 100   
	    101 + cbuffer ShaderConstants : register(b3)
	    102 + {
	    103 +     float4 CURRENT_COLOR;
	    104 +     float4 DARKEN;
	    105 +     float3 TEXTURE_DIMENSIONS;
	    106 +     float1 HUD_OPACITY;
	    107 +     float4x4 UV_TRANSFORM;
	    108 + 	int MSAA_SAMPLECOUNT;
	 76     - cbuffer WorldConstantsStereographic {
	 77     - 	float4x4 WORLDVIEWPROJ_STEREO[2];
	 78     - 	float4x4 WORLD_STEREO;
	 79     - 	float4x4 WORLDVIEW_STEREO[2];
	 80     - 	float4x4 PROJ_STEREO[2];
	 81 109   }
	 82 110   
	    111 + cbuffer WeatherConstants
	    112 + {
	    113 +     float4 POSITION_OFFSET;
	    114 +     float4 VELOCITY;
	    115 +     float4 ALPHA;
	    116 +     float4 VIEW_POSITION;
	    117 +     float4 SIZE_SCALE;
	    118 +     float4 FORWARD;
	 83     - #endif
	 84     - 
	 85     - cbuffer ShaderConstants {
	 86     - 	float4 CURRENT_COLOR;
	 87     - 	float4 DARKEN;
	 88     - 	float3 TEXTURE_DIMENSIONS;
	    119 +     float4 UV_INFO;
	    120 +     float4 PARTICLE_BOX;
	 89     - 	float1 HUD_OPACITY;
	 90     - 	float4x4 UV_TRANSFORM;
	 91 121   }
	 92 122   
	    123 + cbuffer FlipbookTextureConstants
	 93     - cbuffer WeatherConstants {
	    124 + {
	 94     - 	float4	POSITION_OFFSET;
	    125 +     float1 V_OFFSET;
	    126 +     float1 V_BLEND_OFFSET;
	 95     - 	float4	VELOCITY;
	 96     - 	float4	ALPHA;
	    127 + }
	    128 + 
	    129 + cbuffer EffectsConstants
	    130 + {
	    131 +     float2 EFFECT_UV_OFFSET;
	 97     - 	float4	VIEW_POSITION;
	 98     - 	float4	SIZE_SCALE;
	 99     - 	float4	FORWARD;
	100     - 	float4	UV_INFO;
	    132 + 
	    133 + 
	101     - 	float4  PARTICLE_BOX;
	102 134   }
	103 135   
	    136 + cbuffer BannerConstants
	104     - cbuffer FlipbookTextureConstants {
	    137 + {
	    138 +     float4 BANNER_COLORS[7];
	    139 +     float4 BANNER_UV_OFFSETS[7];
	105     - 	float1 V_OFFSET;
	106     - 	float1 V_BLEND_OFFSET;
	107 140   }
	108 141   
	    142 + cbuffer TextConstants
	109     - cbuffer EffectsConstants {
	    143 + {
	    144 +     float1 GLYPH_SMOOTH_RADIUS;
	    145 +     float1 GLYPH_CUTOFF;
	110     - 	float2 EFFECT_UV_OFFSET;
	111     - 
	112     - 
	    146 +     float1 OUTLINE_CUTOFF;
	    147 +     float4 OUTLINE_COLOR;
	    148 +     float1 SHADOW_SMOOTH_RADIUS;
	    149 +     float4 SHADOW_COLOR;
	    150 +     float2 SHADOW_OFFSET;
	113     - }
	114     - 
	115     - cbuffer BannerConstants {
	116     - 	float4 BANNER_COLORS[7];
	117     - 	float4 BANNER_UV_OFFSETS[7];
	118 151   }
	119     - 
	    152 + cbuffer DebugConstants
	120     - cbuffer TextConstants {
	    153 + {
	121     - 	float1 GLYPH_SMOOTH_RADIUS;
	    154 +     float TEXTURE_ARRAY_INDEX_0;
	    155 + };
	    156 + 
	    157 + cbuffer InterFrameConstants
	    158 + {
	    159 + 	// in secs. This is reset every 2 mins. so the range is [0, 120)
	    160 + 	// make sure your shader handles the case when it transitions from 120 to 0
	    161 +     float TOTAL_REAL_WORLD_TIME;
	    162 +     float4x4 CUBE_MAP_ROTATION;
	122     - 	float1 GLYPH_CUTOFF;
	123     - 	float1 OUTLINE_CUTOFF;
	124     - 	float4 OUTLINE_COLOR;
	125     - 	float1 SHADOW_SMOOTH_RADIUS;
	126     - 	float4 SHADOW_COLOR;
	127     - 	float2 SHADOW_OFFSET;
	128     - }
	129     - cbuffer DebugConstants {
	130     -     float TEXTURE_ARRAY_INDEX_0;
	131 163   };
	132 164   
	    165 + cbuffer PostProcessConstants {
	133     - cbuffer InterFrameConstants {
	    166 + 	int GaussianBlurSize;
	134     - 	// in secs. This is reset every 2 mins. so the range is [0, 120)
	    167 + 	float DepthOfFieldNearEndDepth;
	    168 + 	float DepthOfFieldFarStartDepth;
	    169 + 	float DepthOfFieldFarEndDepth;
	135     - 	// make sure your shader handles the case when it transitions from 120 to 0
	136     - 	float TOTAL_REAL_WORLD_TIME;
	137     - 	float4x4 CUBE_MAP_ROTATION;
	138 170   };
	    171 + 
	          '''
Changed file "banner.fragment.hlsl":
	Total line: 55 (+3, -0)
	        '''
	        ...
	41 41   	base.rgb = lerp(base.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a );
	42 42   #endif
	43 43   
	44 44   	//WARNING do not refactor this 
	45 45   	PSOutput.color = base;
	   46 + #ifdef UI_ENTITY
	   47 + 	PSOutput.color.a *= HUD_OPACITY;
	   48 + #endif
	46 49   
	47 50   #ifdef VR_FEATURE
	48 51   	// On Rift, the transition from 0 brightness to the lowest 8 bit value is abrupt, so clamp to 
	49 52   	// the lowest 8 bit value.
	50 53   	PSOutput.color = max(PSOutput.color, 1 / 255.0f);
	        ...
	        '''
Changed file "banner.geometry.hlsl":
	Total line: 67 (+0, -2)
	        '''
	 1  1   #include "ShaderConstants.fxh"
	 2  2   
	    3 + struct GeometryShaderInput {
	 3    - struct GeometryShaderInput
	 4    - {
	 5  4   	float4		pos				: SV_POSITION;
	 6  5   #ifdef ENABLE_LIGHT
	 7  6   	float4		light			: LIGHT;
	 8  7   #endif
	 9  8   #ifdef ENABLE_FOG
	10  9   	float4		fogColor		: FOG_COLOR;
	11 10   #endif
	12 11   #ifndef DISABLE_TINTING
	13 12   	float4		color			: COLOR;
	14 13   #endif
	   14 + 	float4		uv				: TEXCOORD_0_FB_MSAA;
	15    - 	float2		uv				: TEXCOORD_0_FB_MSAA;
	16 15   
	17 16   #ifdef INSTANCEDSTEREO
	18 17   	uint		instanceID		: SV_InstanceID;
	19 18   #endif
	20 19   };
	21 20   
	22 21   // Per-pixel color data passed through the pixel shader.
	   22 + struct GeometryShaderOutput {
	23    - struct GeometryShaderOutput
	24    - {
	25 23   	float4		pos				: SV_POSITION;
	26 24   #ifdef ENABLE_LIGHT
	27 25   	float4		light			: LIGHT;
	28 26   #endif
	29 27   #ifdef ENABLE_FOG
	30 28   	float4		fogColor		: FOG_COLOR;
	31 29   #endif
	32 30   #ifndef DISABLE_TINTING
	33 31   	float4		color			: COLOR;
	34 32   #endif
	   33 + 	float4		uv				: TEXCOORD_0_FB_MSAA;
	35    - 	float2		uv				: TEXCOORD_0_FB_MSAA;
	36 34   
	37 35   #ifdef INSTANCEDSTEREO
	38 36   	uint        renTarget_id	: SV_RenderTargetArrayIndex;
	39 37   #endif
	40 38   };
	        ...
	        '''
Added file "blur.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	#if defined(GAUSSIAN_H) || defined(GAUSSIAN_V)
	
	//Optimized bilinear Gaussian Filters. The idea is to use to hardware bilinear filter to get "free" lerp between pixels. 
	//Here we calculate the pixel offset such that we get the desire lerp amount between two pixels.
	//std=1.0
	#define GAUSSIAN_5_TAB_SUM 1.0
	#define G5TABS0 0.0625
	#define G5TABS1 0.25
	#define G5TABS_CENTER 0.375
	#define G5TABS_COUNT 1
	static const float G5Offsets[G5TABS_COUNT] = { (2.0*G5TABS0 + G5TABS1) / (G5TABS0 + G5TABS1) };
	static const float G5Weights[G5TABS_COUNT] = { G5TABS0 + G5TABS1 };
	
	
	//std=2.0
	#define GAUSSIAN_11_TAB_SUM 1.0
	#define G11TABS0 0.008580797401
	#define G11TABS1 0.02788759155
	#define G11TABS2 0.06693021973
	#define G11TABS3 0.1227054028
	#define G11TABS4 0.1752934326
	#define G11TABS_CENTER 0.1972051117
	#define G11TABS_COUNT 3
	static const float G11Offsets[G11TABS_COUNT] = { (5.0*G11TABS0 + 4.0*G11TABS1) / (G11TABS0 + G11TABS1), (3.0*G11TABS2 + 2.0*G11TABS3) / (G11TABS2 + G11TABS3), (G11TABS4) / (G11TABS4 + G11TABS_CENTER) };
	static const float G11Weights[G11TABS_COUNT] = { G11TABS0 + G11TABS1, G11TABS2 + G11TABS3, G11TABS4 + G11TABS_CENTER };
	
	
	//std=3.0
	#define GAUSSIAN_15_TAB_SUM 1.0
	#define G15TABS0 0.008843068404
	#define G15TABS1 0.01842305918
	#define G15TABS2 0.03401180156
	#define G15TABS3 0.05587653113
	#define G15TABS4 0.08195224565
	#define G15TABS5 0.1075623224
	#define G15TABS6 0.1265439087
	#define G15TABS_CENTER 0.1335741259
	#define G15TABS_COUNT 4
	static const float G15Offsets[G15TABS_COUNT] = { (7.0*G15TABS0 + 6.0*G15TABS1) / (G15TABS0 + G15TABS1), (5.0*G15TABS2 + 4.0*G15TABS3) / (G15TABS2 + G15TABS3), (3.0*G15TABS4 + 2.0*G15TABS5) / (G15TABS4 + G15TABS5), (G15TABS6) / (G15TABS6 + G15TABS_CENTER) };
	static const float G15Weights[G15TABS_COUNT] = { G15TABS0 + G15TABS1, G15TABS2 + G15TABS3, G15TABS4 + G15TABS5, G15TABS6 + G15TABS_CENTER };
	
	
	//std=4.0
	#define GAUSSIAN_21_TAB_SUM 1.0
	#define G21TABS0 0.00439142038
	#define G21TABS1 0.008019115477
	#define G21TABS2 0.01369932227
	#define G21TABS3 0.02191891564
	#define G21TABS4 0.03287837346
	#define G21TABS5 0.04627326635
	#define G21TABS6 0.06114681624
	#define G21TABS7 0.07590639258
	#define G21TABS8 0.08855745801
	#define G21TABS9 0.09712753459
	#define G21TABS_CENTER 0.10016277
	#define G21TABS_COUNT 5
	static const float G21Offsets[G21TABS_COUNT] = { (10.0*G21TABS0 + 9.0*G21TABS1) / (G21TABS0 + G21TABS1), (8.0*G21TABS2 + 7.0*G21TABS3) / (G21TABS2 + G21TABS3), (6.0*G21TABS4 + 5.0*G21TABS5) / (G21TABS4 + G21TABS5), (4.0*G21TABS6 + 3.0*G21TABS7) / (G21TABS6 + G21TABS7), (2.0*G21TABS8 + G21TABS9) / (G21TABS8 + G21TABS9) };
	static const float G21Weights[G21TABS_COUNT] = { G21TABS0 + G21TABS1, G21TABS2 + G21TABS3, G21TABS4 + G21TABS5, G21TABS6 + G21TABS7, G21TABS8 + G21TABS9 };
	
	
	//std=5.0
	#define GAUSSIAN_25_TAB_SUM 1.0
	#define G25TABS0 0.00452735756
	#define G25TABS1 0.007197337659
	#define G25TABS2 0.01097593993
	#define G25TABS3 0.01606235112
	#define G25TABS4 0.02256377895
	#define G25TABS5 0.03043486463
	#define G25TABS6 0.03942698373
	#define G25TABS7 0.04906469086
	#define G25TABS8 0.05866430429
	#define G25TABS9 0.0674015411
	#define G25TABS10 0.07442253496
	#define G25TABS11 0.0789790167
	#define G25TABS_CENTER 0.08055859703
	#define G25TABS_COUNT 6
	static const float G25Offsets[G25TABS_COUNT] = { (12.0*G25TABS0 + 11.0*G25TABS1) / (G25TABS0 + G25TABS1), (10.0*G25TABS2 + 9.0*G25TABS3) / (G25TABS2 + G25TABS3), (8.0*G25TABS4 + 7.0*G25TABS5) / (G25TABS4 + G25TABS5), (6.0*G25TABS6 + 5.0*G25TABS7) / (G25TABS6 + G25TABS7), (4.0*G25TABS8 + 3.0*G25TABS9) / (G25TABS8 + G25TABS9), (2.0*G25TABS10 + G25TABS11) / (G25TABS10 + G25TABS11) };
	static const float G25Weights[G25TABS_COUNT] = { G25TABS0 + G25TABS1, G25TABS2 + G25TABS3, G25TABS4 + G25TABS5, G25TABS6 + G25TABS7, G25TABS8 + G25TABS9, G25TABS10 + G25TABS11 };
	
	
	//std=6.0
	#define GAUSSIAN_29_TAB_SUM 1.0
	#define G29TABS0 0.004438649238
	#define G29TABS1 0.006469895499
	#define G29TABS2 0.00916568529
	#define G29TABS3 0.01262159942
	#define G29TABS4 0.01689665728
	#define G29TABS5 0.02199247456
	#define G29TABS6 0.02783422561
	#define G29TABS7 0.03425750845
	#define G29TABS8 0.0410051995
	#define G29TABS9 0.04773739644
	#define G29TABS10 0.05405558126
	#define G29TABS11 0.05953948081
	#define G29TABS12 0.06379230087
	#define G29TABS13 0.0664877502
	#define G29TABS_CENTER 0.06741119117
	#define G29TABS_COUNT 7
	static const float G29Offsets[G29TABS_COUNT] = { (14.0*G29TABS0 + 13.0*G29TABS1) / (G29TABS0 + G29TABS1), (12.0*G29TABS2 + 11.0*G29TABS3) / (G29TABS2 + G29TABS3), (10.0*G29TABS4 + 9.0*G29TABS5) / (G29TABS4 + G29TABS5), (8.0*G29TABS6 + 7.0*G29TABS7) / (G29TABS6 + G29TABS7), (6.0*G29TABS8 + 5.0*G29TABS9) / (G29TABS8 + G29TABS9), (4.0*G29TABS10 + 3.0*G29TABS11) / (G29TABS10 + G29TABS11), (2.0*G29TABS12 + G29TABS13) / (G29TABS12 + G29TABS13) };
	static const float G29Weights[G29TABS_COUNT] = { G29TABS0 + G29TABS1, G29TABS2 + G29TABS3, G29TABS4 + G29TABS5, G29TABS6 + G29TABS7, G29TABS8 + G29TABS9, G29TABS10 + G29TABS11, G29TABS12 + G29TABS13 };
	
	
	//std=7.0
	#define GAUSSIAN_33_TAB_SUM 1.0
	#define G33TABS0 0.004260871965
	#define G33TABS1 0.005852281976
	#define G33TABS2 0.007872712659
	#define G33TABS3 0.01037345668
	#define G33TABS4 0.01338899641
	#define G33TABS5 0.01692861615
	#define G33TABS6 0.02096839955
	#define G33TABS7 0.02544479946
	#define G33TABS8 0.03025103936
	#define G33TABS9 0.03523747441
	#define G33TABS10 0.04021668276
	#define G33TABS11 0.04497349469
	#define G33TABS12 0.04927946759
	#define G33TABS13 0.05291058625
	#define G33TABS14 0.05566634596
	#define G33TABS15 0.05738798552
	#define G33TABS_CENTER 0.05797357721
	#define G33TABS_COUNT 8
	static const float G33Offsets[G33TABS_COUNT] = { (16.0*G33TABS0 + 15.0*G33TABS1) / (G33TABS0 + G33TABS1), (14.0*G33TABS2 + 13.0*G33TABS3) / (G33TABS2 + G33TABS3), (12.0*G33TABS4 + 11.0*G33TABS5) / (G33TABS4 + G33TABS5), (10.0*G33TABS6 + 9.0*G33TABS7) / (G33TABS6 + G33TABS7), (8.0*G33TABS8 + 7.0*G33TABS9) / (G33TABS8 + G33TABS9), (6.0*G33TABS10 + 5.0*G33TABS11) / (G33TABS10 + G33TABS11), (4.0*G33TABS12 + 3.0*G33TABS13) / (G33TABS12 + G33TABS13), (2.0*G33TABS14 + G33TABS15) / (G33TABS14 + G33TABS15) };
	static const float G33Weights[G33TABS_COUNT] = { G33TABS0 + G33TABS1, G33TABS2 + G33TABS3, G33TABS4 + G33TABS5, G33TABS6 + G33TABS7, G33TABS8 + G33TABS9, G33TABS10 + G33TABS11, G33TABS12 + G33TABS13, G33TABS14 + G33TABS15 };
	
	
	//std=8.0
	#define GAUSSIAN_37_TAB_SUM 1.0
	#define G37TABS0 0.004053106611
	#define G37TABS1 0.0053311132
	#define G37TABS2 0.006901887625
	#define G37TABS3 0.008795325822
	#define G37TABS4 0.01103273327
	#define G37TABS5 0.01362302717
	#define G37TABS6 0.0165590244
	#define G37TABS7 0.01981421723
	#define G37TABS8 0.02334047623
	#define G37TABS9 0.02706710689
	#define G37TABS10 0.0309016137
	#define G37TABS11 0.03473239226
	#define G37TABS12 0.03843338487
	#define G37TABS13 0.04187051685
	#define G37TABS14 0.04490950598
	#define G37TABS15 0.04742443831
	#define G37TABS16 0.04930636047
	#define G37TABS17 0.05047107765
	#define G37TABS_CENTER 0.05086538294
	#define G37TABS_COUNT 9
	static const float G37Offsets[G37TABS_COUNT] = { (18.0*G37TABS0 + 17.0*G37TABS1) / (G37TABS0 + G37TABS1), (16.0*G37TABS2 + 15.0*G37TABS3) / (G37TABS2 + G37TABS3), (14.0*G37TABS4 + 13.0*G37TABS5) / (G37TABS4 + G37TABS5), (12.0*G37TABS6 + 11.0*G37TABS7) / (G37TABS6 + G37TABS7), (10.0*G37TABS8 + 9.0*G37TABS9) / (G37TABS8 + G37TABS9), (8.0*G37TABS10 + 7.0*G37TABS11) / (G37TABS10 + G37TABS11), (6.0*G37TABS12 + 5.0*G37TABS13) / (G37TABS12 + G37TABS13), (4.0*G37TABS14 + 3.0*G37TABS15) / (G37TABS14 + G37TABS15), (2.0*G37TABS16 + G37TABS17) / (G37TABS16 + G37TABS17) };
	static const float G37Weights[G37TABS_COUNT] = { G37TABS0 + G37TABS1, G37TABS2 + G37TABS3, G37TABS4 + G37TABS5, G37TABS6 + G37TABS7, G37TABS8 + G37TABS9, G37TABS10 + G37TABS11, G37TABS12 + G37TABS13, G37TABS14 + G37TABS15, G37TABS16 + G37TABS17 };
	
	
	//std=9.0
	#define GAUSSIAN_39_TAB_SUM 1.0
	#define G39TABS0 0.00492716991
	#define G39TABS1 0.006193178845
	#define G39TABS2 0.007688084084
	#define G39TABS3 0.009425801719
	#define G39TABS4 0.01141355582
	#define G39TABS5 0.01364999582
	#define G39TABS6 0.01612348499
	#define G39TABS7 0.01881073249
	#define G39TABS8 0.0216759434
	#define G39TABS9 0.0246706461
	#define G39TABS10 0.02773432111
	#define G39TABS11 0.03079590201
	#define G39TABS12 0.03377615059
	#define G39TABS13 0.03659082981
	#define G39TABS14 0.03915451852
	#define G39TABS15 0.0413848392
	#define G39TABS16 0.04320681325
	#define G39TABS17 0.04455702616
	#define G39TABS18 0.04538728131
	#define G39TABS_CENTER 0.04566744971
	#define G39TABS_COUNT 10
	static const float G39Offsets[G39TABS_COUNT] = { (19.0*G39TABS0 + 18.0*G39TABS1) / (G39TABS0 + G39TABS1), (17.0*G39TABS2 + 16.0*G39TABS3) / (G39TABS2 + G39TABS3), (15.0*G39TABS4 + 14.0*G39TABS5) / (G39TABS4 + G39TABS5), (13.0*G39TABS6 + 12.0*G39TABS7) / (G39TABS6 + G39TABS7), (11.0*G39TABS8 + 10.0*G39TABS9) / (G39TABS8 + G39TABS9), (9.0*G39TABS10 + 8.0*G39TABS11) / (G39TABS10 + G39TABS11), (7.0*G39TABS12 + 6.0*G39TABS13) / (G39TABS12 + G39TABS13), (5.0*G39TABS14 + 4.0*G39TABS15) / (G39TABS14 + G39TABS15), (3.0*G39TABS16 + 2.0*G39TABS17) / (G39TABS16 + G39TABS17), (G39TABS18) / (G39TABS18 + G39TABS_CENTER) };
	static const float G39Weights[G39TABS_COUNT] = { G39TABS0 + G39TABS1, G39TABS2 + G39TABS3, G39TABS4 + G39TABS5, G39TABS6 + G39TABS7, G39TABS8 + G39TABS9, G39TABS10 + G39TABS11, G39TABS12 + G39TABS13, G39TABS14 + G39TABS15, G39TABS16 + G39TABS17, G39TABS18 + G39TABS_CENTER };
	
	
	//std=10.0
	#define GAUSSIAN_43_TAB_SUM 1.0
	#define G43TABS0 0.004544882447
	#define G43TABS1 0.005580105671
	#define G43TABS2 0.006782448882
	#define G43TABS3 0.00816129838
	#define G43TABS4 0.009722202442
	#define G43TABS5 0.01146585831
	#define G43TABS6 0.0133871643
	#define G43TABS7 0.01547441035
	#define G43TABS8 0.0177086835
	#define G43TABS9 0.02006356163
	#define G43TABS10 0.02250515907
	#define G43TABS11 0.02499257139
	#define G43TABS12 0.02747874342
	#define G43TABS13 0.02991175716
	#define G43TABS14 0.03223650512
	#define G43TABS15 0.0343966833
	#define G43TABS16 0.03633700902
	#define G43TABS17 0.03800554515
	#define G43TABS18 0.039355996
	#define G43TABS19 0.04034983428
	#define G43TABS20 0.04095812324
	#define G43TABS_CENTER 0.04116291385
	#define G43TABS_COUNT 11
	static const float G43Offsets[G43TABS_COUNT] = { (21.0*G43TABS0 + 20.0*G43TABS1) / (G43TABS0 + G43TABS1), (19.0*G43TABS2 + 18.0*G43TABS3) / (G43TABS2 + G43TABS3), (17.0*G43TABS4 + 16.0*G43TABS5) / (G43TABS4 + G43TABS5), (15.0*G43TABS6 + 14.0*G43TABS7) / (G43TABS6 + G43TABS7), (13.0*G43TABS8 + 12.0*G43TABS9) / (G43TABS8 + G43TABS9), (11.0*G43TABS10 + 10.0*G43TABS11) / (G43TABS10 + G43TABS11), (9.0*G43TABS12 + 8.0*G43TABS13) / (G43TABS12 + G43TABS13), (7.0*G43TABS14 + 6.0*G43TABS15) / (G43TABS14 + G43TABS15), (5.0*G43TABS16 + 4.0*G43TABS17) / (G43TABS16 + G43TABS17), (3.0*G43TABS18 + 2.0*G43TABS19) / (G43TABS18 + G43TABS19), (G43TABS20) / (G43TABS20 + G43TABS_CENTER) };
	static const float G43Weights[G43TABS_COUNT] = { G43TABS0 + G43TABS1, G43TABS2 + G43TABS3, G43TABS4 + G43TABS5, G43TABS6 + G43TABS7, G43TABS8 + G43TABS9, G43TABS10 + G43TABS11, G43TABS12 + G43TABS13, G43TABS14 + G43TABS15, G43TABS16 + G43TABS17, G43TABS18 + G43TABS19, G43TABS20 + G43TABS_CENTER };
	
	#endif
	
	
	struct PS_Input {
		float4 position : SV_Position;
		float2 uv : TEXCOORD_0_FB_MSAA;
	};
	
	struct PS_Output {
		float4 color : SV_Target;
	};
	
	
	void main(in PS_Input PSInput, out PS_Output PSOutput) {
	
	#if defined(GAUSSIAN_H) || defined(GAUSSIAN_V)
	
	#ifdef GAUSSIAN_H
		float2 texOffset = float2(1.0f, 0.0f) / TEXTURE_DIMENSIONS.xy;
	#else //GAUSSIAN_V
		float2 texOffset = float2(0.0f, 1.0f) / TEXTURE_DIMENSIONS.xy;
	#endif
	
		if (GaussianBlurSize == 1) {	//Total 3 texture samples per fragment
										//Start with the center Guassian number
			float4 color = G5TABS_CENTER * TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
			//Add the other ones 
			[unroll(G5TABS_COUNT)]
			for (int i = 0; i < G5TABS_COUNT; ++i) {
				color += G5Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv - texOffset * G5Offsets[i]);
				color += G5Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv + texOffset * G5Offsets[i]);
			}
			//No need to divide by total weight as gaussianFilter adds up to 1.0 
			PSOutput.color = color;
		}
		else if (GaussianBlurSize == 2) {	//Total 7 texture samples per fragment
											//Start with the center Guassian number. This is negative because we are including the center as 
											//the bilinear calculation below. It will be double counted if we don't first offset it by negative amount
			float4 color = -(G11TABS_CENTER * TEXTURE_0.Sample(TextureSampler0, PSInput.uv));
			//Add the other ones 
			[unroll(G11TABS_COUNT)]
			for (int i = 0; i < G11TABS_COUNT; ++i) {
				color += G11Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv - texOffset * G11Offsets[i]);
				color += G11Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv + texOffset * G11Offsets[i]);
			}
			//No need to divide by total weight as gaussianFilter adds up to 1.0 
			PSOutput.color = color;
		}
		else if (GaussianBlurSize == 3) {	//Total 9 texture samples per fragment
											//Start with the center Guassian number. This is negative because we are including the center as 
											//the bilinear calculation below. It will be double counted if we don't first offset it by negative amount
			float4 color = -(G15TABS_CENTER * TEXTURE_0.Sample(TextureSampler0, PSInput.uv));
			//Add the other ones 
			[unroll(G15TABS_COUNT)]
			for (int i = 0; i < G15TABS_COUNT; ++i) {
				color += G15Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv - texOffset * G15Offsets[i]);
				color += G15Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv + texOffset * G15Offsets[i]);
			}
			//No need to divide by total weight as gaussianFilter adds up to 1.0 
			PSOutput.color = color;
		}
		else if (GaussianBlurSize == 4) {	//Total 11 texture samples per fragment
											//Start with the center Guassian number.
			float4 color = G21TABS_CENTER * TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
			//Add the other ones 
			[unroll(G21TABS_COUNT)]
			for (int i = 0; i < G21TABS_COUNT; ++i) {
				color += G21Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv - texOffset * G21Offsets[i]);
				color += G21Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv + texOffset * G21Offsets[i]);
			}
			//No need to divide by total weight as gaussianFilter adds up to 1.0 
			PSOutput.color = color;
		}
		else if (GaussianBlurSize == 5) {	//Total 13 texture samples per fragment
											//Start with the center Guassian number
			float4 color = G25TABS_CENTER * TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
			//Add the other ones 
			[unroll(G25TABS_COUNT)]
			for (int i = 0; i < G25TABS_COUNT; ++i) {
				color += G25Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv - texOffset * G25Offsets[i]);
				color += G25Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv + texOffset * G25Offsets[i]);
			}
			//No need to divide by total weight as gaussianFilter adds up to 1.0 
			PSOutput.color = color;
		}
		else if (GaussianBlurSize == 6) {	//Total 15 texture samples per fragment
											// Start with the center Guassian number
			float4 color = G29TABS_CENTER * TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
			//Add the other ones 
			[unroll(G29TABS_COUNT)]
			for (int i = 0; i < G29TABS_COUNT; ++i) {
				color += G29Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv - texOffset * G29Offsets[i]);
				color += G29Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv + texOffset * G29Offsets[i]);
			}
			//No need to divide by total weight as gaussianFilter adds up to 1.0 
			PSOutput.color = color;
		}
		else if (GaussianBlurSize == 7) {	//Total 17 texture samples per fragment
											//Start with the center Guassian number. This is negative because we are including the center as 
			float4 color = G33TABS_CENTER * TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
			//Add the other ones 
			[unroll(G33TABS_COUNT)]
			for (int i = 0; i < G33TABS_COUNT; ++i) {
				color += G33Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv - texOffset * G33Offsets[i]);
				color += G33Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv + texOffset * G33Offsets[i]);
			}
			//No need to divide by total weight as gaussianFilter adds up to 1.0 
			PSOutput.color = color;
		}
		else if (GaussianBlurSize == 8) {	//Total 19 texture samples per fragment
											//Start with the center Guassian number. This is negative because we are including the center as 
			float4 color = G37TABS_CENTER * TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
			//Add the other ones 
			[unroll(G37TABS_COUNT)]
			for (int i = 0; i < G37TABS_COUNT; ++i) {
				color += G37Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv - texOffset * G37Offsets[i]);
				color += G37Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv + texOffset * G37Offsets[i]);
			}
			//No need to divide by total weight as gaussianFilter adds up to 1.0 
			PSOutput.color = color;
		}
		else if (GaussianBlurSize == 9) {	//Total 21 texture samples per fragment
											//Start with the center Guassian number. This is negative because we are including the center as 
											//the bilinear calculation below. It will be double counted if we don't first offset it by negative amount
			float4 color = -(G39TABS_CENTER * TEXTURE_0.Sample(TextureSampler0, PSInput.uv));
			//Add the other ones 
			[unroll(G39TABS_COUNT)]
			for (int i = 0; i < G39TABS_COUNT; ++i) {
				color += G39Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv - texOffset * G39Offsets[i]);
				color += G39Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv + texOffset * G39Offsets[i]);
			}
			//No need to divide by total weight as gaussianFilter adds up to 1.0 
			PSOutput.color = color;
		}
		else if (GaussianBlurSize == 10) {	//Total 23 texture samples per fragment
											//Start with the center Guassian number. This is negative because we are including the center as 
											//the bilinear calculation below. It will be double counted if we don't first offset it by negative amount
			float4 color = -(G43TABS_CENTER * TEXTURE_0.Sample(TextureSampler0, PSInput.uv));
			//Add the other ones 
			[unroll(G43TABS_COUNT)]
			for (int i = 0; i < G43TABS_COUNT; ++i) {
				color += G43Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv - texOffset * G43Offsets[i]);
				color += G43Weights[i] * TEXTURE_0.Sample(TextureSampler0, PSInput.uv + texOffset * G43Offsets[i]);
			}
			//No need to divide by total weight as gaussianFilter adds up to 1.0 
			PSOutput.color = color;
		}
		//This should never happen ... 
		else {
			PSOutput.color = float4(1.0, 0.0, 0.0, 1.0);	//Red to indicate it's wrong
		}
	
	#else
	
		//default to not blur anything
		PSOutput.color = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	
	#endif
	
	}
	'''
Changed file "color_texture.fragment.hlsl":
	Total line: 94 (+1, -0)
	        '''
	        ...
	54 54   
	55 55   #ifdef GLINT
	56 56   	float4 layer1 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layer1UV)).rgbr * GLINT_COLOR;
	57 57   	float4 layer2 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layer2UV)).rgbr * GLINT_COLOR;
	58 58   	float4 glint = (layer1 + layer2);
	   59 + 	glint.rgb *= PSInput.color.a;
	59 60   
	60 61   	#ifdef INVENTORY
	61 62   		diffuse.rgb = glint.rgb;
	62 63   	#else
	63 64   		diffuse.rgb = glintBlend(diffuse, glint).rgb;
	        ...
	        '''
Added file "depth_downsample.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct PS_Input
	{
		float4 position : SV_Position;
		float2 uv : TEXCOORD_0_FB_MSAA;
	};
	
	struct PS_Output
	{
		float4 color : SV_Target;
	};
	
	void main(in PS_Input PSInput, out PS_Output PSOutput)
	{
		PSOutput.color = float4(0.0, 0.0, 0.0, 1.0);	//If we don't initialize this, compiler complaints :(
	#if (VERSION >= 0xa100 /*D3D_FEATURE_LEVEL_10_1*/)
	
		float4 samples = TEXTURE_0.Gather(TextureSampler0, PSInput.uv);
		PSOutput.color.r = min(min(samples.x, samples.y), min(samples.z, samples.w));
	
		// Don't reflect things that are too close to the player.  IE ignore all low depth values ( the player's hands model for example ).  We do this by pushing them to the far plane in the HiZ down sampling.
		// If color.r is smaller than 0.1, force it to be 1.0
		const float NEAR_TOLERANCE = 0.1;
		PSOutput.color.r = lerp(1.0, PSOutput.color.r, sign(saturate(PSOutput.color.r - NEAR_TOLERANCE)));
	
	#else
	
														//Also works, but slower than using the gather command.  Can be used for backward compatibility with older shaders.  NOTE: GLSL also has a gather equivalent.
	
														// Take minimum values.
		float x_off = 0.5 / TEXTURE_DIMENSIONS.x;
		float y_off = 0.5 / TEXTURE_DIMENSIONS.y;
	
		float2 uv = PSInput.uv;
		float depth0 = TEXTURE_0.Sample(TextureSampler0, uv + float2(-x_off, -y_off)).r;
		float depth1 = TEXTURE_0.Sample(TextureSampler0, uv + float2(x_off, -y_off)).r;
		float depth2 = TEXTURE_0.Sample(TextureSampler0, uv + float2(-x_off, y_off)).r;
		float depth3 = TEXTURE_0.Sample(TextureSampler0, uv + float2(x_off, y_off)).r;
		PSOutput.color.r = min(min(depth0, depth1), min(depth2, depth3));
	#endif
	
	}
	'''
Added file "depth_of_field.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	#include "util.fxh"
	
	#define FAR_PLANE_DEPTH 1.0f
	#define GAUSSIAN_DOF
	
	struct PS_Input
	{
		float4 position : SV_Position;
		float2 uv : TEXCOORD_0_FB_MSAA;
	};
	
	struct PS_Output
	{
		float4 color : SV_Target;
	};
	
	void main(in PS_Input PSInput, out PS_Output PSOutput)
	{
	#ifdef GAUSSIAN_DOF
	
		const float centerDepth = MakeDepthLinear(TEXTURE_1.Sample(TextureSampler1, float2(0.5f, 0.5f)).r, 0.025f, FAR_CHUNKS_DISTANCE, false);
		const float depth = MakeDepthLinear(TEXTURE_1.Sample(TextureSampler1, PSInput.uv).r, 0.025f, FAR_CHUNKS_DISTANCE, false);
		float4 color = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	
		if ((centerDepth > DepthOfFieldNearEndDepth || depth >= DepthOfFieldFarStartDepth) && depth > 0.01f) {
	
			const float nearBlurPlaneEnd = clamp(DepthOfFieldNearEndDepth, 0, DepthOfFieldFarStartDepth);	//Can only go up to where the far plane starts
			const float farPlaneStart = clamp(DepthOfFieldFarStartDepth, DepthOfFieldNearEndDepth, DepthOfFieldFarEndDepth);
			const float farPlaneEnd = clamp(DepthOfFieldFarEndDepth, DepthOfFieldFarStartDepth, FAR_PLANE_DEPTH);
			float4 baseColor = float4(0.0f, 0.0f, 0.0f, 1.0f);
			float4 blurColor = float4(0.0f, 0.0f, 0.0f, 1.0f);
	
			if (depth >= farPlaneEnd) {	//We are beyound max blur ... so always pick the blurry one
				color = TEXTURE_3.Sample(TextureSampler3, PSInput.uv);	//Far blur
																		//color = float4(1.0f, 0.0f, 0.0f, 1.0f);
			}
			else if (depth < nearBlurPlaneEnd) {
				float lerpRatio = depth / nearBlurPlaneEnd;
				blurColor = TEXTURE_2.Sample(TextureSampler2, PSInput.uv);	//Near blur
				baseColor = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);	//Clear color
																			//blurColor = float4(1.0f, 0.0f, 0.0f, 1.0f);
																			//baseColor = float4(0.0f, 1.0f, 0.0f, 1.0f);
				color = lerp(blurColor, baseColor, lerpRatio);
			}
			else if (depth > farPlaneStart) {
				float lerpRatio = (depth - farPlaneStart) / (farPlaneEnd - farPlaneStart);
				blurColor = TEXTURE_3.Sample(TextureSampler3, PSInput.uv);	//Far blur
				baseColor = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);	//Clear color
																			//blurColor = float4(1.0f, 0.0f, 0.0f, 1.0f);
																			//baseColor = float4(0.0f, 1.0f, 0.0f, 1.0f);
				color = lerp(baseColor, blurColor, lerpRatio);
			}
	
		}
	
		PSOutput.color = color;
	
	#else
	
		//Default to no depth of field
		PSOutput.color = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	
	#endif
	
	}
	'''
Changed file "end_portal.vertex.hlsl":
	Total line: 124 (+0, -0)
	          '''
	          ...
	113 113   			#else
	114 114   				float cameraDepth = PSInput.position.z;
	115 115   			#endif
	116 116   			float len = cameraDepth / RENDER_DISTANCE;
	117 117   			#ifdef ALLOW_FADE
	    118 + 				len += RENDER_CHUNK_FOG_ALPHA.r;
	    119 + #endif
	118     - 				len += CURRENT_COLOR.r;
	119     - 			#endif
	120 120   			PSInput.fogColor.rgb = FOG_COLOR.rgb;
	121 121   			PSInput.fogColor.a = clamp((len - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	122 122   		#endif
	123 123   	#endif
	124 124   }
	          '''
Changed file "entity.fragment.hlsl":
	Total line: 144 (+17, -8)
	          '''
	          ...
	 59  59   	color = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	 60  60   #else
	 61  61   	color = texture2D_AA(TEXTURE_0, TextureSampler0, PSInput.uv);
	 62  62   #endif
	 63  63   
	     64 + #if defined(ALPHA_TEST) && !defined(USE_MULTITEXTURE)
	     65 + 	if( NEEDS_DISCARD( color ) )
	     66 + 	{
	     67 + 		discard;
	     68 + 	}
	     69 + #endif
	     70 + 
	     71 + #ifdef TINTED_ALPHA_TEST
	 64     - #ifdef ALPHA_TEST
	     72 + 	float4 testColor = color;
	     73 + 	testColor.a = testColor.a * PSInput.alphaTestMultiplier.r;
	     74 + 	if( NEEDS_DISCARD( testColor ) )
	 65     - 	if( NEEDS_DISCARD( color ) )
	 66  75   	{
	 67  76   		discard;
	 68  77   	}
	     78 + #endif
	     79 + 
	 69  80   #endif
	 70  81   
	 71     - #ifdef TINTED_ALPHA_TEST
	 72     - 	float4 testColor = color;
	 73     - 	testColor.a = testColor.a * PSInput.alphaTestMultiplier.r;
	 74     - 	if( NEEDS_DISCARD( testColor ) )
	     82 + #ifdef USE_COLOR_MASK
	     83 + 	color.rgb = lerp( color, color * CHANGE_COLOR, color.a ).rgb;
	     84 + 	color.a *= CHANGE_COLOR.a;
	 75     - 	{
	 76     - 		discard;
	 77     - 	}
	 78  85   #endif
	 79  86   
	     87 + #ifdef ITEM_IN_HAND
	     88 + 	color.rgb = lerp(color, color * CHANGE_COLOR, PSInput.light.a).rgb;
	 80  89   #endif
	 81  90   
	     91 + #ifdef USE_MULTITEXTURE
	 82     - #ifdef USE_COLOR_MASK
	     92 + 	float4 tex1 = TEXTURE_1.Sample(TextureSampler1, PSInput.uv);
	     93 + 	float4 tex2 = TEXTURE_2.Sample(TextureSampler2, PSInput.uv);
	     94 + 	color.rgb = lerp(color.rgb, tex1, tex1.a);
	     95 + #ifdef ALPHA_TEST
	     96 + 	if (color.a < 0.5f && tex1.a == 0.0f) {
	     97 + 		discard;
	     98 + 	}
	 83     - 	color.rgb = lerp( color, color * CHANGE_COLOR, color.a ).rgb;
	 84     - 	color.a *= CHANGE_COLOR.a;
	 85     - #endif
	 86     - 
	 87     - #ifdef ITEM_IN_HAND
	 88     - 	color.rgb = lerp(color, color * CHANGE_COLOR, PSInput.light.a).rgb;
	 89  99   #endif
	 90 100   
	 91     - #ifdef USE_MULTITEXTURE
	 92     - 	float4 tex1 = TEXTURE_1.Sample(TextureSampler1, PSInput.uv);
	 93     - 	float4 tex2 = TEXTURE_2.Sample(TextureSampler2, PSInput.uv);
	 94     - 	color.rgb = lerp(color.rgb, tex1, tex1.a);
	 95 101   #ifdef COLOR_SECOND_TEXTURE
	 96 102   	if (tex2.a > 0.0f) {
	 97 103   		color.rgb = lerp(tex2.rgb, tex2 * CHANGE_COLOR, tex2.a);
	 98 104   	}
	 99 105   #else
	          ...
	123 129   	float4 glint = (layer1 + layer2) * TILE_LIGHT_COLOR;
	124 130   	color = glintBlend(color, glint);
	125 131   #endif
	126 132   
	127 133   	//WARNING do not refactor this 
	    134 + 	PSOutput.color = color;
	    135 + #ifdef UI_ENTITY
	    136 + 	PSOutput.color.a *= HUD_OPACITY;
	128     - 	PSOutput.color = color;
	    137 + #endif
	129 138   
	130 139   #ifdef VR_MODE
	131 140   	// On Rift, the transition from 0 brightness to the lowest 8 bit value is abrupt, so clamp to 
	132 141   	// the lowest 8 bit value.
	133 142   	PSOutput.color = max(PSOutput.color, 1 / 255.0f);
	          ...
	          '''
Changed file "rain_snow.vertex.hlsl":
	Total line: 98 (+1, -0)
	        '''
	        ...
	85 85   
	86 86   	//fog
	87 87   	PSInput.fogColor.rgb = FOG_COLOR.rgb;
	88 88   	PSInput.fogColor.a = clamp(((PSInput.position.z / RENDER_DISTANCE) - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	89 89   
	   90 + 	worldPositionBottom.xz += VIEW_POSITION.xz;
	90 91   	worldPositionBottom.xz *= 1.0f / 64.0f;	// Scale by 1/TextureDimensions to get values between
	91 92   	worldPositionBottom.xz += 0.5f;			// Offset so that center of view is in the center of occlusion texture
	92 93   	worldPositionBottom.y += VIEW_POSITION.y - 0.5f;
	93 94   	worldPositionBottom.y *= 1.0f / 255.0f;
	94 95   	PSInput.worldPosition = worldPositionBottom;
	        ...
	        '''
Changed file "renderchunk.fragment.hlsl":
	Total line: 94 (+3, -4)
	        '''
	        ...
	30 30   #ifdef BYPASS_PIXEL_SHADER
	31 31       PSOutput.color = float4(0.0f, 0.0f, 0.0f, 0.0f);
	32 32       return;
	33 33   #else
	34 34   
	   35 + #if USE_TEXEL_AA
	35    - #if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE) || (VERSION < 0xa000 /*D3D_FEATURE_LEVEL_10_0*/) 
	   36 + 	float4 diffuse = texture2D_AA(TEXTURE_0, TextureSampler0, PSInput.uv0 );
	36    - 	float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv0);
	37 37   #else
	   38 + 	float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv0);
	38    - 	float4 diffuse = texture2D_AA(TEXTURE_0, TextureSampler0, PSInput.uv0 );
	39 39   #endif
	40 40   
	41 41   #ifdef SEASONS_FAR
	42 42   	diffuse.a = 1.0f;
	43 43   	PSInput.color.b = 1.0f;
	44 44   #endif
	45 45   
	   46 + #if USE_ALPHA_TEST
	46    - #ifdef ALPHA_TEST
	47    - //If we know that all the verts in a triangle will have the same alpha, we should cull there first.
	48 47   	#ifdef ALPHA_TO_COVERAGE
	   48 + 	#define ALPHA_THRESHOLD 0.05
	49    - 		float alphaThreshold = .05f;
	50 49   	#else
	   50 + 	#define ALPHA_THRESHOLD 0.5
	51    - 		float alphaThreshold = .5f;
	52 51   	#endif
	   52 + 	if(diffuse.a < ALPHA_THRESHOLD)
	53    - 	if(diffuse.a < alphaThreshold)
	54 53   		discard;
	55 54   #endif
	56 55   
	57 56   #if !defined(ALWAYS_LIT)
	58 57   	diffuse = diffuse * TEXTURE_1.Sample(TextureSampler1, PSInput.uv1);
	59 58   #endif
	60 59   
	61 60   #ifndef SEASONS
	62 61   
	   62 + #if !USE_ALPHA_TEST && !defined(BLEND)
	63    - #if !defined(ALPHA_TEST) && !defined(BLEND)
	64 63   	diffuse.a = PSInput.color.a;
	65 64   #elif defined(BLEND)
	66 65   #ifdef NEAR_WATER	
	67 66   	diffuse.a *= PSInput.color.a;
	68 67   
	        ...
	        '''
Changed file "renderchunk.vertex.hlsl":
	Total line: 137 (+1, -1)
	          '''
	          ...
	104 104   	///// apply fog
	105 105   
	106 106   #ifdef FOG
	107 107   	float len = cameraDepth / RENDER_DISTANCE;
	108 108   #ifdef ALLOW_FADE
	    109 + 	len += RENDER_CHUNK_FOG_ALPHA.r;
	109     - 	len += CURRENT_COLOR.r;
	110 110   #endif
	111 111   
	112 112   	PSInput.fogColor.rgb = FOG_COLOR.rgb;
	113 113   	PSInput.fogColor.a = clamp((len - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	114 114   
	          ...
	          '''
Added file "resolve_depth.fragment.hlsl":
	'''
	#include "ShaderConstants.fxh"
	
	struct PS_Input
	{
		float4 position : SV_Position;
		float2 uv : TEXCOORD_0_FB_MSAA;
	};
	
	struct PS_Output
	{
		float depth : SV_Depth;
	#if (VERSION <= 0xa000 /*D3D_FEATURE_LEVEL_10_0*/)
		float4 dx9dummy : SV_Target;
	#endif
	};
	
	void main( in PS_Input PSInput, out PS_Output PSOutput )
	{
	#ifdef MSAA_FRAMEBUFFER_ENABLED
		float depth = 0.0f;
	    int sampleCount = MSAA_SAMPLECOUNT;
		for (int i = 0; i < sampleCount; ++i )
		{
			depth += TEXTURE_0_MS.Load(PSInput.position.xy, i);
		}
		depth /= sampleCount;
	
		PSOutput.depth = depth;  
	#else
	    PSOutput.depth = 0.0;
	#endif
	
	#if (VERSION <= 0xa000 /*D3D_FEATURE_LEVEL_10_0*/)
		PSOutput.dx9dummy = float4(0, 0, 0, 0);
	#endif
	}
	'''
Changed file "texture_blend.fragment.hlsl":
	Total line: 29 (+0, -0)
	        '''
	        ...
	19 19   
	20 20   	if (color.a < 0.01f)
	21 21   	{
	22 22   		color = color1;
	23 23   	}
	   24 + 	else if (color1.a >= 0.01f) {
	24    - 	else if (color.b > 0.01f) {
	25 25   		color = lerp(color, color1, CURRENT_COLOR.a);
	26 26   	}
	27 27   
	28 28   	PSOutput.color = color;
	29 29   }
	        '''
Changed file "util.fxh":
	Total line: 60 (+24, -9)
	        '''
	 1  1   
	    2 + #if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE) || (VERSION < 0xa000 /*D3D_FEATURE_LEVEL_10_0*/) 
	    3 + #define USE_TEXEL_AA 0
	    4 + #else
	    5 + #define USE_TEXEL_AA 1
	    6 + #endif
	    7 + 
	    8 + #ifdef ALPHA_TEST
	    9 + #define USE_ALPHA_TEST 1
	   10 + #else
	   11 + #define USE_ALPHA_TEST 0
	   12 + #endif
	   13 + 
	   14 + #if USE_TEXEL_AA
	   15 + 
	   16 + static const float TEXEL_AA_ALPHA_BIAS = 0.125f;
	   17 + static const float TEXEL_AA_EPSILON = 0.03125f;
	   18 + 
	   19 + static const float TEXEL_AA_LOD_MIN = -0.5f;
	   20 + static const float TEXEL_AA_LOD_MAX = 0.0f;
	   21 + 
	   22 + float4 texture2D_AA(in Texture2D source, in sampler bilinearSampler, in float2 originalUV) {
	 2    - float4 texture2D_AA(in Texture2D tex, in sampler texSampler, in float2 uv)
	 3    - {
	 4    - 	// Texture antialiasing
	 5    - 	//
	 6    - 	// The texture coordinates are modified so that the bilinear filter will be one pixel width wide instead of one texel width. 
	 7 23   
	 8    - 	if (tex.CalculateLevelOfDetailUnclamped(TextureSampler0, uv) < -0.5f)
	 9    - 	{
	   24 + 	const float2 dUV_dX = ddx(originalUV) * TEXTURE_DIMENSIONS.xy;
	   25 + 	const float2 dUV_dY = ddy(originalUV) * TEXTURE_DIMENSIONS.xy;
	10    - 		// Get the UV deltas
	11    - 		float2 dUVdx = ddx(uv) * TEXTURE_DIMENSIONS.xy;
	   26 + 
	   27 + 	const float2 delU = float2(dUV_dX.x, dUV_dY.x);
	   28 + 	const float2 delV = float2(dUV_dX.y, dUV_dY.y);
	12    - 		float2 dUVdy = ddy(uv) * TEXTURE_DIMENSIONS.xy;
	13    - 		float2 dU = float2(dUVdx.x, dUVdy.x);
	   29 + 
	   30 + 	const float2 gradientMagnitudes = float2(length(delU), length(delV));
	14    - 		float2 dV = float2(dUVdx.y, dUVdy.y);
	15 31   
	   32 + 	const float2 fractionalTexel = frac(originalUV * TEXTURE_DIMENSIONS.xy);
	16    - 		float duUV = sqrt(dot(dU, dU));
	   33 + 	const float2 integralTexel = floor(originalUV * TEXTURE_DIMENSIONS.xy);
	17    - 		float dvUV = sqrt(dot(dV, dV));
	18 34   
	19    - 		// First scale the uv so that each texel has a uv range of [0,1]
	   35 + 	const float2 scalar = max(1.0f / max(gradientMagnitudes, TEXEL_AA_EPSILON), 1.0f);
	20    - 		float2 texelUV = frac(uv * TEXTURE_DIMENSIONS.xy);
	21 36   
	   37 + 	const float2 adjustedFractionalTexel = clamp(fractionalTexel * scalar, 0.0f, 0.5f) + clamp(fractionalTexel * scalar - (scalar - 0.5f), 0.0f, 0.5f);
	22    - 		// Initially set uvModified to the floor of the texel position
	   38 + 	const float2 adjustedUV = (adjustedFractionalTexel + integralTexel) / TEXTURE_DIMENSIONS.xy;
	23    - 		float2 uvModified = (uv * TEXTURE_DIMENSIONS.xy) - texelUV;
	24 39   
	   40 + 	const float lod = source.CalculateLevelOfDetailUnclamped(bilinearSampler, originalUV);
	25    - 		// Modify the texelUV to push the uvs toward the edges.
	26    - 		//          |                 |       |                   |
	   41 + 	const float t = smoothstep(TEXEL_AA_LOD_MIN, TEXEL_AA_LOD_MAX, lod);
	   42 + 	const float4 sampledColor = source.Sample(bilinearSampler, lerp(adjustedUV, originalUV, t));
	   43 + 
	   44 + 	#if USE_ALPHA_TEST
	   45 + 		return float4(sampledColor.rgb, lerp(floor(pow(sampledColor.a + TEXEL_AA_ALPHA_BIAS, 2.0f)), sampledColor.a, t));
	   46 + 	#else
	   47 + 		return sampledColor;
	   48 + 	#endif
	   49 + }
	   50 + 
	   51 + #endif // USE_TEXEL_AA
	27    - 		//          |         _/      |       |           /       |
	28    - 		//  Change  | U     _/        |  to   | U     ___/        |
	29    - 		//          |     _/          |       |     /             |
	30    - 		//          |    /            |       |    /              |
	31    - 		//          |         X       |       |         X         |
	32    - 		float scalerU = 1.0f / (duUV);
	33    - 		float scalerV = 1.0f / (dvUV);
	34    - 		float2 scaler = max(float2(scalerU, scalerV), 1.0f);
	35    - 		texelUV = clamp(texelUV * scaler, 0.0f, .5f) + clamp(texelUV*scaler - (scaler - .5f), 0.0f, .5f);
	36    - 		uvModified += texelUV;
	37    - 		uvModified /= TEXTURE_DIMENSIONS.xy;
	38 52   
	   53 + float MakeDepthLinear(float z, float n, float f, bool scaleZ)
	   54 + {
	   55 + 	//Remaps z from [0, 1] to [-1, 1].
	   56 + 	if (scaleZ) {
	   57 + 		z = 2.f * z - 1.f;
	39    - 		// Update uv
	40    - 		uv = uvModified;
	41 58   	}
	42    - 
	   59 + 	return (2.f * n) / (f + n - z * (f - n));
	43    - 	return tex.Sample(TextureSampler0, uv);
	44 60   }
	45    - 
	        '''