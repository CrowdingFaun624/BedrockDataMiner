Difference of "scripts" between "1.19.0.26" (beta of "1.19.0") and "1.19.0.28" (beta of "1.19.0").

Changed behavior pack "vanilla_gametest":
	Changed script "APITests.js":
		Total line: 1823 (+355, -238)
		            '''
		            ...
		 557  557   })
		 558  558     .structureName("ComponentTests:platform")
		 559  559     .tag(GameTest.Tags.suiteDefault);
		 560  560   
		 561  561   GameTest.registerAsync("APITests", "lever_event_multiple_toggles", async (test) => {
		      562 +   const leverLoc = new BlockLocation(1, 2, 1);
		      563 +   let leverPower = false;
		      564 + 
		      565 +   const leverCallback = world.events.leverActivate.subscribe((leverEvent) => {
		      566 +     let blockLoc = test.relativeBlockLocation(leverEvent.block.location);
		      567 +     test.assert(blockLoc.equals(leverLoc), "Expected lever present in leverLoc");
		      568 +     test.assert(!leverEvent.player, "Expected player object to be empty");
		      569 +     test.assert(leverEvent.dimension === test.getDimension(), "Unexpected dimension");
		      570 +     leverPower = leverEvent.isPowered;
		      571 +   });
		      572 + 
		      573 +   test.setBlockType(MinecraftBlockTypes.lever, leverLoc);
		      574 +   await test.idle(5);
		      575 +   test.pullLever(leverLoc);
		      576 +   test.assert(leverPower, "Expected lever power");
		      577 +   test.pullLever(leverLoc);
		      578 +   test.assert(!leverPower, "Expected no lever power");
		      579 +   world.events.leverActivate.unsubscribe(leverCallback);
		      580 +   test.succeed();
		      581 + })
		      582 +   .structureName("ComponentTests:platform")
		      583 +   .tag(GameTest.Tags.suiteDefault);
		      584 + 
		      585 + GameTest.registerAsync("APITests", "lever_event_player", async (test) => {
		      586 +   const leverLoc = new BlockLocation(1, 2, 1);
		      587 +   let eventPlayer;
		      588 +   let testSucceed = false;
		      589 + 
		      590 +   const leverCallback = world.events.leverActivate.subscribe((leverEvent) => {
		      591 +     eventPlayer = leverEvent.player;
		      592 +     test.assert(eventPlayer == simulatedPlayer, "incorrect player found");
		      593 +     let blockLoc = test.relativeBlockLocation(leverEvent.block.location);
		      594 +     test.assert(blockLoc.equals(leverLoc), "Expected lever present in leverLoc");
		      595 +     test.assert(leverEvent.dimension === test.getDimension(), "Unexpected dimension");
		      596 +     test.assert(eventPlayer.name === "Lever_Toggle_Player", "Lever event's player name does not match expected");
		      597 +     testSucceed = true;
		      598 +   });
		      599 + 
		      600 +   test.setBlockType(MinecraftBlockTypes.lever, leverLoc);
		      601 +   const simulatedPlayer = test.spawnSimulatedPlayer(new BlockLocation(2, 2, 1), "Lever_Toggle_Player");
		      602 +   await test.idle(5);
		      603 +   simulatedPlayer.interactWithBlock(leverLoc);
		      604 +   world.events.leverActivate.unsubscribe(leverCallback);
		      605 +   test.assert(testSucceed, "An assert failure occured during callback");
		      606 +   test.succeed();
		      607 + })
		      608 +   .structureName("ComponentTests:platform")
		      609 +   .tag(GameTest.Tags.suiteDefault);
		      610 + 
		      611 + GameTest.registerAsync("APITests", "button_event", async (test) => {
		      612 +   const buttonLoc = new BlockLocation(1, 2, 1);
		      613 +   const buttonPermutation = MinecraftBlockTypes.acaciaButton.createDefaultBlockPermutation();
		      614 +   let testSucceed = false;
		      615 + 
		      616 +   buttonPermutation.getProperty(BlockProperties.facingDirection).value = Direction.up;
		      617 + 
		      618 +   const buttonCallback = world.events.buttonPush.subscribe((buttonEvent) => {
		      619 +     let blockLoc = test.relativeBlockLocation(buttonEvent.block.location);
		      620 +     if (blockLoc.equals(buttonLoc)) {
		      621 +       test.assert(buttonEvent.source === undefined, "Script source should be null");
		      622 +       test.assert(buttonEvent.dimension === test.getDimension(), "Unexpected dimension");
		      623 +       test.assert(!testSucceed, "Callback expected only once");
		      624 +       testSucceed = true;
		      625 +     }
		      626 +   });
		      627 + 
		      628 +   test.setBlockPermutation(buttonPermutation, buttonLoc);
		      629 +   test.pressButton(buttonLoc);
		      630 +   world.events.buttonPush.unsubscribe(buttonCallback);
		      631 +   test.assert(testSucceed, "An assert failure occured during callback");
		      632 +   test.succeed();
		      633 + })
		      634 +   .structureName("ComponentTests:platform")
		      635 +   .tag(GameTest.Tags.suiteDefault);
		      636 + 
		      637 + GameTest.registerAsync("APITests", "button_event_player", async (test) => {
		      638 +   const buttonLoc = new BlockLocation(1, 2, 1);
		      639 +   const buttonPermutation = MinecraftBlockTypes.acaciaButton.createDefaultBlockPermutation();
		      640 +   let testSucceed = false;
		      641 + 
		      642 +   buttonPermutation.getProperty(BlockProperties.facingDirection).value = Direction.up;
		      643 + 
		      644 +   const buttonCallback = world.events.buttonPush.subscribe((buttonEvent) => {
		      645 +     let eventPlayer = buttonEvent.source;
		      646 +     let blockLoc = test.relativeBlockLocation(buttonEvent.block.location);
		      647 +     if (blockLoc.equals(buttonLoc) && eventPlayer == simulatedPlayer) {
		      648 +       test.assert(buttonEvent.dimension === test.getDimension(), "Unexpected dimension");
		      649 +         test.assert(eventPlayer.name === "Button_Push_Player", "Button event's player name does not match expected");
		      650 +         test.assert(buttonEvent.source === eventPlayer, "Button event's source does not match expected");
		      651 +         test.assert(!testSucceed, "Callback expected only once");
		      652 +       testSucceed = true;
		      653 +     }
		      654 +   });
		      655 + 
		      656 +   const simulatedPlayer = test.spawnSimulatedPlayer(new BlockLocation(2, 2, 1), "Button_Push_Player");
		      657 +   await test.idle(5);
		      658 +   test.setBlockPermutation(buttonPermutation, buttonLoc);
		      659 +   simulatedPlayer.interactWithBlock(buttonLoc);
		      660 +   world.events.buttonPush.unsubscribe(buttonCallback);
		      661 +   test.assert(testSucceed, "An assert failure occured during callback");
		      662 +   test.succeed();
		      663 + })
		      664 +   .structureName("ComponentTests:platform")
		      665 +   .tag(GameTest.Tags.suiteDefault);
		      666 + 
		      667 + GameTest.registerAsync("APITests", "button_event_projectile", async (test) => {
		      668 +   const buttonLoc = new BlockLocation(1, 2, 1);
		      669 +   const buttonPermutation = MinecraftBlockTypes.acaciaButton.createDefaultBlockPermutation();
		      670 +   let testSucceed = false;
		      671 +   let spawnedArrow;
		      672 + 
		      673 +   buttonPermutation.getProperty(BlockProperties.facingDirection).value = Direction.up;
		      674 + 
		      675 +   const buttonCallback = world.events.buttonPush.subscribe((buttonEvent) => {
		      676 +     let blockLoc = test.relativeBlockLocation(buttonEvent.block.location);
		      677 +     if (blockLoc.equals(buttonLoc)) {
		      678 +       test.assert(buttonEvent.dimension === test.getDimension(), "Unexpected dimension");
		      679 +       test.assert(buttonEvent.source === spawnedArrow, "Expected arrow source type");
		      680 +       test.assert(!testSucceed, "Callback expected only once");
		      681 +       testSucceed = true;
		      682 +     }
		      683 +   });
		      684 + 
		      685 +   test.setBlockPermutation(buttonPermutation, buttonLoc);
		      686 +   spawnedArrow = test.spawnAtLocation("minecraft:arrow", new Location(1.5, 2.5, 1.5));
		      687 +   await test.idle(20); //give the arrow time to fall
		      688 +   world.events.buttonPush.unsubscribe(buttonCallback);
		      689 +   test.assert(testSucceed, "An assert failure occured during callback");
		      690 +   test.succeed();
		      691 + })
		      692 +   .structureName("ComponentTests:platform")
		      693 +   .tag(GameTest.Tags.suiteDefault);
		      694 + 
		      695 + GameTest.register("APITests", "sneaking", (test) => {
		      696 +   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		      697 +   const pigLoc = new BlockLocation(1, 2, 1);
		      698 +   const pig = test.spawn(pigId, pigLoc);
		      699 +   pig.isSneaking = true;
		      700 +   test
		      701 +     .startSequence()
		      702 +     .thenExecuteAfter(120, () => {
		      703 +       test.assertEntityPresent(pigId, pigLoc, true);
		      704 +     })
		      705 +     .thenSucceed();
		      706 + })
		      707 +   .maxTicks(130)
		      708 +   .tag(GameTest.Tags.suiteDefault);
		      709 + 
		      710 + GameTest.register("APITests", "assert_can_reach_location", (test) => {
		      711 +   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		      712 +   const villager1 = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		      713 +   const villager2 = test.spawn(villagerId, new BlockLocation(1, 2, 3));
		      714 +   const villager3 = test.spawn(villagerId, new BlockLocation(1, 2, 5));
		      715 +   test.assertCanReachLocation(villager1, new BlockLocation(4, 2, 1), true);
		      716 +   test.assertCanReachLocation(villager2, new BlockLocation(4, 2, 3), false);
		      717 +   test.assertCanReachLocation(villager3, new BlockLocation(4, 2, 5), false);
		      718 +   test.succeed();
		      719 + }).tag(GameTest.Tags.suiteDefault);
		      720 + 
		      721 + const isLocationInTest = (test, worldLoc) => {
		      722 +   const size = 4;
		      723 +   let loc = test.relativeBlockLocation(worldLoc);
		      724 +   return loc.x >= 0 && loc.y >= 0 && loc.z >= 0 && loc.x < size && loc.y < size && loc.z < size;
		      725 + };
		      726 + 
		      727 + GameTest.register("APITests", "explosion_event", (test) => {
		      728 +   let exploded = false;
		      729 +   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		      730 +   const polishedAndesiteLoc = new BlockLocation(1, 1, 1);
		      731 + 
		      732 +   const beforeExplosionCallback = world.events.beforeExplosion.subscribe((explosionEvent) => {
		      733 +     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		      734 +     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		      735 +     test.assert(explosionEvent.source !== undefined, "Expected source");
		      736 +     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		      737 +     test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		      738 +     explosionEvent.impactedBlocks = [test.worldBlockLocation(cobblestoneLoc)];
		      739 +   });
		      740 + 
		      741 +   const explosionCallback = world.events.explosion.subscribe((explosionEvent) => {
		      742 +     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		      743 +     test.assert(explosionEvent.source !== undefined, "Expected source");
		      744 +     test.assert(explosionEvent.impactedBlocks.length === 1, "Unexpected number of impacted blocks");
		      745 +     exploded = true;
		      746 +   });
		      747 + 
		      748 +   test
		      749 +     .startSequence()
		      750 +     .thenExecute(() => {
		      751 +       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		      752 +       test.spawn("tnt", new BlockLocation(1, 2, 1));
		      753 +     })
		      754 +     .thenExecuteAfter(85, () => {
		      755 +       test.assert(exploded, "Expected explosion event");
		      756 +       test.assertBlockPresent(MinecraftBlockTypes.stone, polishedAndesiteLoc, true);
		      757 +       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, false);
		      758 +       world.events.beforeExplosion.unsubscribe(beforeExplosionCallback);
		      759 +       world.events.explosion.unsubscribe(explosionCallback);
		      760 +     })
		      761 +     .thenSucceed();
		      762 + })
		      763 +   .padding(10) // The blast can destroy nearby items and mobs
		      764 +   .structureName("ComponentTests:platform")
		      765 +   .tag(GameTest.Tags.suiteDefault);
		 562      -     const leverLoc = new BlockLocation(1, 2, 1);
		 563      -     let leverPower = false;
		 564  766   
		 565      -     const leverCallback = world.events.leverActivate.subscribe((leverEvent) => {
		 566      -         let blockLoc = test.relativeBlockLocation(leverEvent.block.location);
		 567      -         test.assert(blockLoc.equals(leverLoc), "Expected lever present in leverLoc");
		 568      -         test.assert(!leverEvent.player, "Expected player object to be empty");
		      767 + GameTest.register("APITests", "explosion_event_canceled", (test) => {
		      768 +   let canceled = false;
		      769 +   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		 569      -         test.assert(leverEvent.dimension === test.getDimension(), "Unexpected dimension");
		 570      -         leverPower = leverEvent.isPowered;
		 571      -     });
		 572  770   
		 573      -     test.setBlockType(MinecraftBlockTypes.lever, leverLoc);
		 574      -     await test.idle(5);
		 575      -     test.pullLever(leverLoc);
		      771 +   const explosionCallback = world.events.beforeExplosion.subscribe((explosionEvent) => {
		      772 +     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		      773 +     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		      774 +     test.assert(explosionEvent.source !== undefined, "Expected source");
		      775 +     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		      776 +     explosionEvent.cancel = true;
		      777 +     canceled = true;
		      778 +   });
		 576      -     test.assert(leverPower, "Expected lever power");
		 577      -     test.pullLever(leverLoc);
		 578      -     test.assert(!leverPower, "Expected no lever power");
		 579      -     world.events.leverActivate.unsubscribe(leverCallback);
		 580      -     test.succeed();
		 581      - })
		 582      -     .structureName("ComponentTests:platform")
		 583      -     .tag(GameTest.Tags.suiteDefault);
		 584  779   
		      780 +   test
		      781 +     .startSequence()
		      782 +     .thenExecute(() => {
		 585      - GameTest.registerAsync("APITests", "lever_event_player", async (test) => {
		      783 +       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		      784 +       test.spawn("tnt", new BlockLocation(1, 2, 1));
		      785 +     })
		      786 +     .thenExecuteAfter(85, () => {
		      787 +       test.assert(canceled, "Expected canceled beforeExplosionEvent event");
		      788 +       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		      789 +       world.events.beforeExplosion.unsubscribe(explosionCallback);
		      790 +     })
		      791 +     .thenSucceed();
		      792 + })
		      793 +   .padding(10) // The blast can destroy nearby items and mobs
		      794 +   .structureName("ComponentTests:platform")
		      795 +   .tag(GameTest.Tags.suiteDefault);
		 586      -     const leverLoc = new BlockLocation(1, 2, 1);
		 587      -     let eventPlayer;
		 588      -     let testSucceed = false;
		 589      - 
		 590      -     const leverCallback = world.events.leverActivate.subscribe((leverEvent) => {
		 591      -         eventPlayer = leverEvent.player;
		 592      -         test.assert(eventPlayer == simulatedPlayer, "incorrect player found");
		 593      -         let blockLoc = test.relativeBlockLocation(leverEvent.block.location);
		 594      -         test.assert(blockLoc.equals(leverLoc), "Expected lever present in leverLoc");
		 595      -         test.assert(leverEvent.dimension === test.getDimension(), "Unexpected dimension");
		 596      -         test.assert(eventPlayer.name === "Lever_Toggle_Player", "Lever event's player name does not match expected");
		 597      -         testSucceed = true;
		 598      -     });
		 599  796   
		      797 + GameTest.register("APITests", "explode_block_event", (test) => {
		 600      -     test.setBlockType(MinecraftBlockTypes.lever, leverLoc);
		 601      -     const simulatedPlayer = test.spawnSimulatedPlayer(new BlockLocation(2, 2, 1), "Lever_Toggle_Player");
		      798 +   let explodedCount = 0;
		      799 +   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		      800 + 
		      801 +   const blockExplodeCallback = world.events.blockExplode.subscribe((blockExplodeEvent) => {
		      802 +     if (!isLocationInTest(test, blockExplodeEvent.block.location)) return;
		      803 +     test.assert(blockExplodeEvent.source !== undefined, "Expected source");
		      804 +     explodedCount++;
		      805 +   });
		 602      -     await test.idle(5);
		 603      -     simulatedPlayer.interactWithBlock(leverLoc);
		 604      -     world.events.leverActivate.unsubscribe(leverCallback);
		 605      -     test.assert(testSucceed, "An assert failure occured during callback");
		 606      -     test.succeed();
		 607      - })
		 608      -     .structureName("ComponentTests:platform")
		 609      -     .tag(GameTest.Tags.suiteDefault);
		 610  806   
		      807 +   test
		      808 +     .startSequence()
		 611      - GameTest.register("APITests", "sneaking", (test) => {
		 612      -   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		      809 +     .thenExecute(() => {
		      810 +       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		      811 +       test.spawn("tnt", new BlockLocation(1, 2, 1));
		      812 +     })
		      813 +     .thenExecuteAfter(85, () => {
		      814 +       test.assert(explodedCount === 10, "Unexpected number of exploded blocks");
		      815 +       world.events.blockExplode.unsubscribe(blockExplodeCallback);
		 613      -   const pigLoc = new BlockLocation(1, 2, 1);
		 614      -   const pig = test.spawn(pigId, pigLoc);
		 615      -   pig.isSneaking = true;
		 616      -   test
		 617      -     .startSequence()
		 618      -     .thenExecuteAfter(120, () => {
		 619      -       test.assertEntityPresent(pigId, pigLoc, true);
		 620  816       })
		 621  817       .thenSucceed();
		 622  818   })
		      819 +   .padding(10) // The blast can destroy nearby items and mobs
		      820 +   .structureName("ComponentTests:platform")
		 623      -   .maxTicks(130)
		 624  821     .tag(GameTest.Tags.suiteDefault);
		      822 + 
		      823 + GameTest.register("APITests", "connectivity", (test) => {
		      824 +   const centerLoc = new BlockLocation(1, 2, 1);
		 625  825   
		 626      - GameTest.register("APITests", "assert_can_reach_location", (test) => {
		 627      -   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		 628      -   const villager1 = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		 629      -   const villager2 = test.spawn(villagerId, new BlockLocation(1, 2, 3));
		      826 +   let connectivity = test.getFenceConnectivity(centerLoc);
		      827 + 
		      828 +   test.assert(!connectivity.north, "The stair is not oriented the right way to connect");
		      829 +   test.assert(connectivity.east, "Should connect to another fence");
		      830 +   test.assert(connectivity.south, "Should connect to another fence");
		      831 +   test.assert(connectivity.west, "Should connect to the back of the stairs");
		 630      -   const villager3 = test.spawn(villagerId, new BlockLocation(1, 2, 5));
		 631      -   test.assertCanReachLocation(villager1, new BlockLocation(4, 2, 1), true);
		 632      -   test.assertCanReachLocation(villager2, new BlockLocation(4, 2, 3), false);
		 633      -   test.assertCanReachLocation(villager3, new BlockLocation(4, 2, 5), false);
		 634      -   test.succeed();
		 635      - }).tag(GameTest.Tags.suiteDefault);
		 636  832   
		      833 +   test.succeed();
		 637      - const isLocationInTest = (test, worldLoc) => {
		 638      -   const size = 4;
		      834 + })
		      835 +   .rotateTest(true)
		      836 +   .tag(GameTest.Tags.suiteDefault);
		 639      -   let loc = test.relativeBlockLocation(worldLoc);
		 640      -   return loc.x >= 0 && loc.y >= 0 && loc.z >= 0 && loc.x < size && loc.y < size && loc.z < size;
		 641      - };
		 642  837   
		      838 + GameTest.register("APITests", "spawn_at_location", (test) => {
		 643      - GameTest.register("APITests", "explosion_event", (test) => {
		 644      -   let exploded = false;
		      839 +   const spawnLoc = new Location(1.3, 2, 1.3);
		      840 +   const chicken = test.spawnAtLocation("chicken", spawnLoc);
		 645      -   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		 646      -   const polishedAndesiteLoc = new BlockLocation(1, 1, 1);
		 647  841   
		 648      -   const beforeExplosionCallback = world.events.beforeExplosion.subscribe((explosionEvent) => {
		 649      -     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		 650      -     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		      842 +   test
		      843 +     .startSequence()
		      844 +     .thenExecute(() => {
		      845 +       const chickenLoc = chicken.location;
		      846 +       const relativeChickenLoc = test.relativeLocation(chickenLoc);
		      847 +       test.assert(relativeChickenLoc.isNear(spawnLoc, 0.01), "Unexpected spawn location");
		      848 +     })
		      849 +     .thenSucceed();
		      850 + })
		      851 +   .structureName("ComponentTests:animal_pen")
		      852 +   .rotateTest(true)
		      853 +   .tag(GameTest.Tags.suiteDefault);
		 651      -     test.assert(explosionEvent.source !== undefined, "Expected source");
		 652      -     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		 653      -     test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		 654      -     explosionEvent.impactedBlocks = [test.worldBlockLocation(cobblestoneLoc)];
		 655      -   });
		 656      - 
		 657      -   const explosionCallback = world.events.explosion.subscribe((explosionEvent) => {
		 658      -     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		 659      -     test.assert(explosionEvent.source !== undefined, "Expected source");
		 660      -     test.assert(explosionEvent.impactedBlocks.length === 1, "Unexpected number of impacted blocks");
		 661      -     exploded = true;
		 662      -   });
		 663  854   
		      855 + GameTest.register("APITests", "walk_to_location", (test) => {
		 664      -   test
		 665      -     .startSequence()
		      856 +   const spawnLoc = new BlockLocation(1, 2, 1);
		      857 +   const chicken = test.spawnWithoutBehaviors("chicken", spawnLoc);
		      858 + 
		      859 +   const targetLoc = new Location(2.2, 2, 3.2);
		      860 +   test.walkToLocation(chicken, targetLoc, 1);
		      861 + 
		      862 +   test.succeedWhen(() => {
		      863 +     const chickenLoc = chicken.location;
		      864 +     const relativeChickenLoc = test.relativeLocation(chickenLoc);
		      865 +     // Mobs will stop navigating as soon as they intersect the target location
		      866 +     test.assert(relativeChickenLoc.isNear(targetLoc, 0.65), "Chicken did not reach the target location");
		      867 +   });
		 666      -     .thenExecute(() => {
		 667      -       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		 668      -       test.spawn("tnt", new BlockLocation(1, 2, 1));
		 669      -     })
		 670      -     .thenExecuteAfter(85, () => {
		 671      -       test.assert(exploded, "Expected explosion event");
		 672      -       test.assertBlockPresent(MinecraftBlockTypes.stone, polishedAndesiteLoc, true);
		 673      -       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, false);
		 674      -       world.events.beforeExplosion.unsubscribe(beforeExplosionCallback);
		 675      -       world.events.explosion.unsubscribe(explosionCallback);
		 676      -     })
		 677      -     .thenSucceed();
		 678  868   })
		      869 +   .structureName("ComponentTests:large_animal_pen")
		 679      -   .padding(10) // The blast can destroy nearby items and mobs
		 680      -   .structureName("ComponentTests:platform")
		 681  870     .tag(GameTest.Tags.suiteDefault);
		 682      - 
		 683      - GameTest.register("APITests", "explosion_event_canceled", (test) => {
		 684      -   let canceled = false;
		 685      -   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		 686  871   
		      872 + GameTest.register("APITests", "walk_to_location_far", (test) => {
		 687      -   const explosionCallback = world.events.beforeExplosion.subscribe((explosionEvent) => {
		 688      -     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		      873 +   const targetLoc = new BlockLocation(3, 2, 17);
		      874 +   const zombie = test.spawnWithoutBehaviors("minecraft:zombie<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		      875 +   test.walkTo(zombie, targetLoc);
		      876 +   test.succeedWhen(() => {
		      877 +     test.assertRedstonePower(targetLoc, 15);
		 689      -     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		 690      -     test.assert(explosionEvent.source !== undefined, "Expected source");
		 691      -     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		 692      -     explosionEvent.cancel = true;
		 693      -     canceled = true;
		 694  878     });
		      879 + })
		      880 +   .maxTicks(400)
		      881 +   .tag(GameTest.Tags.suiteDefault);
		 695  882   
		 696      -   test
		 697      -     .startSequence()
		 698      -     .thenExecute(() => {
		      883 + GameTest.register("APITests", "spread_from_face_toward_direction", (test) => {
		      884 +   const testEx = new GameTestExtensions(test);
		      885 + 
		      886 +   let multifaceLoc = new BlockLocation(1, 4, 0);
		      887 +   let spreadLoc = new BlockLocation(1, 3, 0);
		      888 + 
		      889 +   const glowLichenPermutation = MinecraftBlockTypes.glowLichen.createDefaultBlockPermutation();
		      890 +   glowLichenPermutation.getProperty(BlockProperties.multiFaceDirectionBits).value =
		      891 +     1 << testEx.getMultiFaceDirection(test.getTestDirection());
		      892 +   test.setBlockPermutation(glowLichenPermutation, multifaceLoc);
		      893 + 
		      894 +   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, multifaceLoc, true);
		      895 +   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, false);
		 699      -       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		 700      -       test.spawn("tnt", new BlockLocation(1, 2, 1));
		 701      -     })
		 702      -     .thenExecuteAfter(85, () => {
		 703      -       test.assert(canceled, "Expected canceled beforeExplosionEvent event");
		 704      -       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		 705      -       world.events.beforeExplosion.unsubscribe(explosionCallback);
		 706      -     })
		 707      -     .thenSucceed();
		 708      - })
		 709      -   .padding(10) // The blast can destroy nearby items and mobs
		 710      -   .structureName("ComponentTests:platform")
		 711      -   .tag(GameTest.Tags.suiteDefault);
		 712  896   
		      897 +   test.spreadFromFaceTowardDirection(multifaceLoc, test.getTestDirection(), Direction.down);
		      898 +   test
		 713      - GameTest.register("APITests", "explode_block_event", (test) => {
		      899 +     .startSequence()
		      900 +     .thenExecuteAfter(1, () => {
		      901 +       test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, true);
		      902 +     })
		      903 +     .thenSucceed();
		      904 + })
		      905 +   .rotateTest(true)
		      906 +   .tag(GameTest.Tags.suiteDefault);
		 714      -   let explodedCount = 0;
		 715      -   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		 716      - 
		 717      -   const blockExplodeCallback = world.events.blockExplode.subscribe((blockExplodeEvent) => {
		 718      -     if (!isLocationInTest(test, blockExplodeEvent.block.location)) return;
		 719      -     test.assert(blockExplodeEvent.source !== undefined, "Expected source");
		 720      -     explodedCount++;
		 721      -   });
		 722  907   
		      908 + GameTest.register("APITests", "rotate_direction", (test) => {
		      909 +   test.assert(
		 723      -   test
		      910 +     test.rotateDirection(Direction.south) == test.getTestDirection(),
		      911 +     "Expected rotated south direction to match test direction"
		      912 +   );
		      913 + 
		      914 +   switch (test.getTestDirection()) {
		      915 +     case Direction.north:
		      916 +       test.assert(
		      917 +         test.rotateDirection(Direction.north) === Direction.south,
		      918 +         "Unexpected rotated direction for Direction.north with testDirection Direction.north"
		      919 +       );
		      920 +       test.assert(
		      921 +         test.rotateDirection(Direction.east) === Direction.west,
		      922 +         "Unexpected rotated direction for Direction.east with testDirection Direction.north"
		      923 +       );
		      924 +       test.assert(
		      925 +         test.rotateDirection(Direction.south) === Direction.north,
		      926 +         "Unexpected rotated direction for Direction.south with testDirection Direction.north"
		      927 +       );
		      928 +       test.assert(
		      929 +         test.rotateDirection(Direction.west) === Direction.east,
		      930 +         "Unexpected rotated direction for Direction.west with testDirection Direction.north"
		      931 +       );
		      932 +       break;
		      933 +     case Direction.east:
		      934 +       test.assert(
		      935 +         test.rotateDirection(Direction.north) === Direction.west,
		      936 +         "Unexpected rotated direction for Direction.north with testDirection Direction.east"
		      937 +       );
		      938 +       test.assert(
		      939 +         test.rotateDirection(Direction.east) === Direction.north,
		      940 +         "Unexpected rotated direction for Direction.east with testDirection Direction.east"
		      941 +       );
		      942 +       test.assert(
		      943 +         test.rotateDirection(Direction.south) === Direction.east,
		      944 +         "Unexpected rotated direction for Direction.south with testDirection Direction.east"
		      945 +       );
		      946 +       test.assert(
		      947 +         test.rotateDirection(Direction.west) === Direction.south,
		      948 +         "Unexpected rotated direction for Direction.west with testDirection Direction.east"
		      949 +       );
		      950 +       break;
		      951 +     case Direction.south:
		      952 +       test.assert(
		      953 +         test.rotateDirection(Direction.north) === Direction.north,
		      954 +         "Unexpected rotated direction for Direction.north with testDirection Direction.south"
		      955 +       );
		      956 +       test.assert(
		      957 +         test.rotateDirection(Direction.east) === Direction.east,
		      958 +         "Unexpected rotated direction for Direction.east with testDirection Direction.south"
		      959 +       );
		      960 +       test.assert(
		      961 +         test.rotateDirection(Direction.south) === Direction.south,
		      962 +         "Unexpected rotated direction for Direction.south with testDirection Direction.south"
		      963 +       );
		      964 +       test.assert(
		      965 +         test.rotateDirection(Direction.west) === Direction.west,
		      966 +         "Unexpected rotated direction for Direction.west with testDirection Direction.south"
		      967 +       );
		      968 +       break;
		      969 +     case Direction.west:
		      970 +       test.assert(
		      971 +         test.rotateDirection(Direction.north) === Direction.east,
		      972 +         "Unexpected rotated direction for Direction.north with testDirection Direction.west"
		      973 +       );
		      974 +       test.assert(
		      975 +         test.rotateDirection(Direction.east) === Direction.south,
		      976 +         "Unexpected rotated direction for Direction.east with testDirection Direction.west"
		      977 +       );
		      978 +       test.assert(
		      979 +         test.rotateDirection(Direction.south) === Direction.west,
		      980 +         "Unexpected rotated direction for Direction.south with testDirection Direction.west"
		      981 +       );
		      982 +       test.assert(
		      983 +         test.rotateDirection(Direction.west) === Direction.north,
		      984 +         "Unexpected rotated direction for Direction.west with testDirection Direction.west"
		      985 +       );
		      986 +       break;
		      987 +     default:
		      988 +       test.assert(false, "Invalid test direction");
		      989 +   }
		 724      -     .startSequence()
		 725      -     .thenExecute(() => {
		 726      -       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		 727      -       test.spawn("tnt", new BlockLocation(1, 2, 1));
		 728      -     })
		 729      -     .thenExecuteAfter(85, () => {
		 730      -       test.assert(explodedCount === 10, "Unexpected number of exploded blocks");
		 731      -       world.events.blockExplode.unsubscribe(blockExplodeCallback);
		 732      -     })
		 733      -     .thenSucceed();
		 734      - })
		 735      -   .padding(10) // The blast can destroy nearby items and mobs
		 736      -   .structureName("ComponentTests:platform")
		 737      -   .tag(GameTest.Tags.suiteDefault);
		 738      - 
		 739      - GameTest.register("APITests", "connectivity", (test) => {
		 740      -   const centerLoc = new BlockLocation(1, 2, 1);
		 741      - 
		 742      -   let connectivity = test.getFenceConnectivity(centerLoc);
		 743      - 
		 744      -   test.assert(!connectivity.north, "The stair is not oriented the right way to connect");
		 745      -   test.assert(connectivity.east, "Should connect to another fence");
		 746      -   test.assert(connectivity.south, "Should connect to another fence");
		 747      -   test.assert(connectivity.west, "Should connect to the back of the stairs");
		 748      - 
		 749      -   test.succeed();
		 750      - })
		 751      -   .rotateTest(true)
		 752      -   .tag(GameTest.Tags.suiteDefault);
		 753      - 
		 754      - GameTest.register("APITests", "spawn_at_location", (test) => {
		 755      -   const spawnLoc = new Location(1.3, 2, 1.3);
		 756      -   const chicken = test.spawnAtLocation("chicken", spawnLoc);
		 757      - 
		 758      -   test
		 759      -     .startSequence()
		 760      -     .thenExecute(() => {
		 761      -       const chickenLoc = chicken.location;
		 762      -       const relativeChickenLoc = test.relativeLocation(chickenLoc);
		 763      -       test.assert(relativeChickenLoc.isNear(spawnLoc, 0.01), "Unexpected spawn location");
		 764      -     })
		 765      -     .thenSucceed();
		 766      - })
		 767      -   .structureName("ComponentTests:animal_pen")
		 768      -   .rotateTest(true)
		 769      -   .tag(GameTest.Tags.suiteDefault);
		 770      - 
		 771      - GameTest.register("APITests", "walk_to_location", (test) => {
		 772      -   const spawnLoc = new BlockLocation(1, 2, 1);
		 773      -   const chicken = test.spawnWithoutBehaviors("chicken", spawnLoc);
		 774      - 
		 775      -   const targetLoc = new Location(2.2, 2, 3.2);
		 776      -   test.walkToLocation(chicken, targetLoc, 1);
		 777      - 
		 778      -   test.succeedWhen(() => {
		 779      -     const chickenLoc = chicken.location;
		 780      -     const relativeChickenLoc = test.relativeLocation(chickenLoc);
		 781      -     // Mobs will stop navigating as soon as they intersect the target location
		 782      -     test.assert(relativeChickenLoc.isNear(targetLoc, 0.65), "Chicken did not reach the target location");
		 783      -   });
		 784      - })
		 785      -   .structureName("ComponentTests:large_animal_pen")
		 786      -   .tag(GameTest.Tags.suiteDefault);
		 787      - 
		 788      - GameTest.register("APITests", "walk_to_location_far", (test) => {
		 789      -   const targetLoc = new BlockLocation(3, 2, 17);
		 790      -   const zombie = test.spawnWithoutBehaviors("minecraft:zombie<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		 791      -   test.walkTo(zombie, targetLoc);
		 792      -   test.succeedWhen(() => {
		 793      -     test.assertRedstonePower(targetLoc, 15);
		 794      -   });
		 795      - })
		 796      -   .maxTicks(400)
		 797      -   .tag(GameTest.Tags.suiteDefault);
		 798      - 
		 799      - GameTest.register("APITests", "spread_from_face_toward_direction", (test) => {
		 800      -   const testEx = new GameTestExtensions(test);
		 801      - 
		 802      -   let multifaceLoc = new BlockLocation(1, 4, 0);
		 803      -   let spreadLoc = new BlockLocation(1, 3, 0);
		 804  990   
		      991 +   const buttonLoc = new BlockLocation(1, 2, 1);
		      992 +   const buttonPermutation = MinecraftBlockTypes.stoneButton.createDefaultBlockPermutation();
		 805      -   const glowLichenPermutation = MinecraftBlockTypes.glowLichen.createDefaultBlockPermutation();
		 806      -   glowLichenPermutation.getProperty(BlockProperties.multiFaceDirectionBits).value =
		      993 +   buttonPermutation.getProperty(BlockProperties.facingDirection).value = test.rotateDirection(Direction.north);
		      994 +   test.setBlockPermutation(buttonPermutation, buttonLoc);
		 807      -     1 << testEx.getMultiFaceDirection(test.getTestDirection());
		 808      -   test.setBlockPermutation(glowLichenPermutation, multifaceLoc);
		 809  995   
		      996 +   test
		      997 +     .startSequence()
		      998 +     .thenExecuteAfter(2, () => {
		 810      -   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, multifaceLoc, true);
		      999 +       test.assertBlockPresent(MinecraftBlockTypes.stoneButton, buttonLoc, true);
		 811      -   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, false);
		 812      - 
		     1000 +     })
		     1001 +     .thenSucceed();
		     1002 + })
		     1003 +   .rotateTest(true)
		     1004 +   .tag(GameTest.Tags.suiteDefault);
		     1005 + 
		     1006 + function isNear(a, b, epsilon = 0.001) {
		     1007 +   return Math.abs(a - b) < epsilon;
		     1008 + }
		 813      -   test.spreadFromFaceTowardDirection(multifaceLoc, test.getTestDirection(), Direction.down);
		 814      -   test
		 815      -     .startSequence()
		 816      -     .thenExecuteAfter(1, () => {
		 817      -       test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, true);
		 818      -     })
		 819      -     .thenSucceed();
		 820      - })
		 821      -   .rotateTest(true)
		 822      -   .tag(GameTest.Tags.suiteDefault);
		 823 1009   
		     1010 + function isNearVec(a, b, epsilon = 0.001) {
		 824      - GameTest.register("APITests", "rotate_direction", (test) => {
		 825      -   test.assert(
		 826      -     test.rotateDirection(Direction.south) == test.getTestDirection(),
		     1011 +   return Vector.distance(a, b) < epsilon;
		     1012 + }
		 827      -     "Expected rotated south direction to match test direction"
		 828      -   );
		 829 1013   
		     1014 + GameTest.register("APITests", "cauldron", (test) => {
		 830      -   switch (test.getTestDirection()) {
		 831      -     case Direction.north:
		 832      -       test.assert(
		     1015 +   const loc = new BlockLocation(0, 1, 0);
		     1016 +   var block = test.getBlock(loc);
		     1017 + 
		     1018 +   test.setFluidContainer(loc, GameTest.FluidType.water);
		     1019 +   test.assert(block.getComponent("waterContainer") != null, "This is a water container");
		     1020 +   test.assert(
		     1021 +     block.getComponent("lavaContainer") == null,
		     1022 +     "A water container should not have a lavaContainer component"
		     1023 +   );
		     1024 +   test.assert(
		     1025 +     block.getComponent("snowContainer") == null,
		     1026 +     "A water container should not have a snowContainer component"
		     1027 +   );
		     1028 +   test.assert(
		     1029 +     block.getComponent("potionContainer") == null,
		     1030 +     "A water container should not have a potionContainer component"
		     1031 +   );
		     1032 + 
		     1033 +   block.getComponent("waterContainer").fillLevel = FluidContainer.maxFillLevel;
		     1034 +   test.assert(
		     1035 +     block.getComponent("waterContainer").fillLevel == FluidContainer.maxFillLevel,
		     1036 +     "The fill level should match with what it was set to"
		     1037 +   );
		     1038 + 
		     1039 +   block.getComponent("waterContainer").customColor = new Color(1, 0, 0, 1);
		     1040 +   test.assert(block.getComponent("waterContainer").customColor.red == 1, "red component should be set");
		     1041 +   test.assert(block.getComponent("waterContainer").customColor.green == 0, "green component should be set");
		     1042 +   test.assert(block.getComponent("waterContainer").customColor.blue == 0, "blue component should be set");
		     1043 + 
		     1044 +   block.getComponent("waterContainer").addDye(MinecraftItemTypes.blueDye);
		     1045 +   test.assert(isNear(block.getComponent("waterContainer").customColor.red, 0.616), "red component should be set");
		     1046 +   test.assert(isNear(block.getComponent("waterContainer").customColor.green, 0.133), "green component should be set");
		     1047 +   test.assert(isNear(block.getComponent("waterContainer").customColor.blue, 0.333), "blue component should be set");
		     1048 + 
		     1049 +   test.setFluidContainer(loc, GameTest.FluidType.lava);
		     1050 +   test.assert(
		     1051 +     block.getComponent("waterContainer") == null,
		     1052 +     "A lava container should not have a waterContainer component"
		     1053 +   );
		     1054 +   test.assert(block.getComponent("lavaContainer") != null, "This is a lava component");
		     1055 +   test.assert(
		     1056 +     block.getComponent("snowContainer") == null,
		     1057 +     "A lava container should not have a snowContainer component"
		     1058 +   );
		     1059 +   test.assert(
		     1060 +     block.getComponent("potionContainer") == null,
		     1061 +     "A lava container should not have a potionContainer component"
		     1062 +   );
		     1063 + 
		     1064 +   test.setFluidContainer(loc, GameTest.FluidType.powderSnow);
		     1065 +   test.assert(
		     1066 +     block.getComponent("waterContainer") == null,
		     1067 +     "A snow container should not have a waterContainer component"
		     1068 +   );
		     1069 +   test.assert(
		     1070 +     block.getComponent("lavaContainer") == null,
		     1071 +     "A snow container should not have a lavaContainer component"
		     1072 +   );
		     1073 +   test.assert(block.getComponent("snowContainer") != null, "This is a snow container");
		     1074 +   test.assert(
		     1075 +     block.getComponent("potionContainer") == null,
		     1076 +     "A snow container should not have a potionContainer component"
		     1077 +   );
		     1078 + 
		     1079 +   test.setFluidContainer(loc, GameTest.FluidType.potion);
		     1080 +   test.assert(
		     1081 +     block.getComponent("snowContainer") == null,
		     1082 +     "A potion container should not have a waterContainer component"
		     1083 +   );
		     1084 +   test.assert(
		     1085 +     block.getComponent("lavaContainer") == null,
		     1086 +     "A potion container should not have a lavaContainer component"
		     1087 +   );
		     1088 +   test.assert(
		     1089 +     block.getComponent("snowContainer") == null,
		     1090 +     "A potion container should not have a snowContainer component"
		     1091 +   );
		     1092 +   test.assert(block.getComponent("potionContainer") != null, "This is a potion container");
		 833      -         test.rotateDirection(Direction.north) === Direction.south,
		 834      -         "Unexpected rotated direction for Direction.north with testDirection Direction.north"
		 835      -       );
		 836      -       test.assert(
		 837      -         test.rotateDirection(Direction.east) === Direction.west,
		 838      -         "Unexpected rotated direction for Direction.east with testDirection Direction.north"
		 839      -       );
		 840      -       test.assert(
		 841      -         test.rotateDirection(Direction.south) === Direction.north,
		 842      -         "Unexpected rotated direction for Direction.south with testDirection Direction.north"
		 843      -       );
		 844      -       test.assert(
		 845      -         test.rotateDirection(Direction.west) === Direction.east,
		 846      -         "Unexpected rotated direction for Direction.west with testDirection Direction.north"
		 847      -       );
		 848      -       break;
		 849      -     case Direction.east:
		 850      -       test.assert(
		 851      -         test.rotateDirection(Direction.north) === Direction.west,
		 852      -         "Unexpected rotated direction for Direction.north with testDirection Direction.east"
		 853      -       );
		 854      -       test.assert(
		 855      -         test.rotateDirection(Direction.east) === Direction.north,
		 856      -         "Unexpected rotated direction for Direction.east with testDirection Direction.east"
		 857      -       );
		 858      -       test.assert(
		 859      -         test.rotateDirection(Direction.south) === Direction.east,
		 860      -         "Unexpected rotated direction for Direction.south with testDirection Direction.east"
		 861      -       );
		 862      -       test.assert(
		 863      -         test.rotateDirection(Direction.west) === Direction.south,
		 864      -         "Unexpected rotated direction for Direction.west with testDirection Direction.east"
		 865      -       );
		 866      -       break;
		 867      -     case Direction.south:
		 868      -       test.assert(
		 869      -         test.rotateDirection(Direction.north) === Direction.north,
		 870      -         "Unexpected rotated direction for Direction.north with testDirection Direction.south"
		 871      -       );
		 872      -       test.assert(
		 873      -         test.rotateDirection(Direction.east) === Direction.east,
		 874      -         "Unexpected rotated direction for Direction.east with testDirection Direction.south"
		 875      -       );
		 876      -       test.assert(
		 877      -         test.rotateDirection(Direction.south) === Direction.south,
		 878      -         "Unexpected rotated direction for Direction.south with testDirection Direction.south"
		 879      -       );
		 880      -       test.assert(
		 881      -         test.rotateDirection(Direction.west) === Direction.west,
		 882      -         "Unexpected rotated direction for Direction.west with testDirection Direction.south"
		 883      -       );
		 884      -       break;
		 885      -     case Direction.west:
		 886      -       test.assert(
		 887      -         test.rotateDirection(Direction.north) === Direction.east,
		 888      -         "Unexpected rotated direction for Direction.north with testDirection Direction.west"
		 889      -       );
		 890      -       test.assert(
		 891      -         test.rotateDirection(Direction.east) === Direction.south,
		 892      -         "Unexpected rotated direction for Direction.east with testDirection Direction.west"
		 893      -       );
		 894      -       test.assert(
		 895      -         test.rotateDirection(Direction.south) === Direction.west,
		 896      -         "Unexpected rotated direction for Direction.south with testDirection Direction.west"
		 897      -       );
		 898      -       test.assert(
		 899      -         test.rotateDirection(Direction.west) === Direction.north,
		 900      -         "Unexpected rotated direction for Direction.west with testDirection Direction.west"
		 901      -       );
		 902      -       break;
		 903      -     default:
		 904      -       test.assert(false, "Invalid test direction");
		 905      -   }
		 906      - 
		 907      -   const buttonLoc = new BlockLocation(1, 2, 1);
		 908      -   const buttonPermutation = MinecraftBlockTypes.stoneButton.createDefaultBlockPermutation();
		 909      -   buttonPermutation.getProperty(BlockProperties.facingDirection).value = test.rotateDirection(Direction.north);
		 910      -   test.setBlockPermutation(buttonPermutation, buttonLoc);
		 911 1093   
		     1094 +   test.succeed();
		 912      -   test
		 913      -     .startSequence()
		 914      -     .thenExecuteAfter(2, () => {
		     1095 + }).tag(GameTest.Tags.suiteDefault);
		     1096 + 
		     1097 + // test for bug: 678331
		     1098 + GameTest.register("APITests", "cauldron_nocrash", (test) => {
		     1099 +   const loc = new BlockLocation(0, 1, 0);
		     1100 +   var block = test.getBlock(loc);
		 915      -       test.assertBlockPresent(MinecraftBlockTypes.stoneButton, buttonLoc, true);
		 916      -     })
		 917      -     .thenSucceed();
		 918      - })
		 919      -   .rotateTest(true)
		 920      -   .tag(GameTest.Tags.suiteDefault);
		 921 1101   
		     1102 +   test.setBlockType(MinecraftBlockTypes.air, loc);
		     1103 +   test.setBlockType(MinecraftBlockTypes.cauldron, loc);
		 922      - function isNear(a, b, epsilon = 0.001) {
		 923      -   return Math.abs(a - b) < epsilon;
		     1104 +   test.setFluidContainer(loc, GameTest.FluidType.potion);
		 924      - }
		 925 1105   
		     1106 +   let cauldron = block.getComponent("potionContainer");
		 926      - function isNearVec(a, b, epsilon = 0.001) {
		 927      -   return Vector.distance(a, b) < epsilon;
		     1107 +   cauldron.fillLevel = 2;
		 928      - }
		 929 1108   
		     1109 +   const poisonPotion = new ItemStack(MinecraftItemTypes.splashPotion, 1, 32);
		 930      - GameTest.register("APITests", "cauldron", (test) => {
		 931      -   const loc = new BlockLocation(0, 1, 0);
		     1110 +   cauldron.setPotionType(poisonPotion); //this line crashes the title
		 932      -   var block = test.getBlock(loc);
		 933 1111   
		     1112 +   test.succeed();
		 934      -   test.setFluidContainer(loc, GameTest.FluidType.water);
		 935      -   test.assert(block.getComponent("waterContainer") != null, "This is a water container");
		     1113 + })
		     1114 +   .structureName("APITests:cauldron")
		     1115 +   .tag(GameTest.Tags.suiteDefault);
		     1116 + 
		     1117 + GameTest.register("APITests", "jukebox", (test) => {
		     1118 +   var jukeboxBlock = test.getBlock(new BlockLocation(0, 1, 0));
		     1119 +   var musicPlayerComp = jukeboxBlock.getComponent("recordPlayer");
		     1120 + 
		     1121 +   try {
		     1122 +     musicPlayerComp.setRecord(MinecraftItemTypes.apple);
		     1123 +     test.fail("An exception should be thrown when playing an item that is not a music disk");
		     1124 +   } catch (e) {}
		 936      -   test.assert(
		 937      -     block.getComponent("lavaContainer") == null,
		 938      -     "A water container should not have a lavaContainer component"
		 939      -   );
		 940      -   test.assert(
		 941      -     block.getComponent("snowContainer") == null,
		 942      -     "A water container should not have a snowContainer component"
		 943      -   );
		 944      -   test.assert(
		 945      -     block.getComponent("potionContainer") == null,
		 946      -     "A water container should not have a potionContainer component"
		 947      -   );
		 948 1125   
		     1126 +   test.assert(musicPlayerComp.isPlaying() === false, "Should be stopped");
		 949      -   block.getComponent("waterContainer").fillLevel = FluidContainer.maxFillLevel;
		 950      -   test.assert(
		 951      -     block.getComponent("waterContainer").fillLevel == FluidContainer.maxFillLevel,
		     1127 +   musicPlayerComp.setRecord(MinecraftItemTypes.musicDiscMellohi);
		     1128 +   test.assert(musicPlayerComp.isPlaying() === true, "Should be playing");
		 952      -     "The fill level should match with what it was set to"
		 953      -   );
		 954 1129   
		     1130 +   test
		     1131 +     .startSequence()
		     1132 +     .thenExecuteAfter(20, () => {
		 955      -   block.getComponent("waterContainer").customColor = new Color(1, 0, 0, 1);
		     1133 +       test.assert(musicPlayerComp.isPlaying() === true, "Disk should not be finished yet");
		     1134 +       musicPlayerComp.clearRecord();
		     1135 +       test.assert(musicPlayerComp.isPlaying() === false, "Disk should be stopped now");
		     1136 +     })
		     1137 +     .thenSucceed();
		     1138 + })
		     1139 +   .maxTicks(25)
		     1140 +   .tag(GameTest.Tags.suiteDefault);
		 956      -   test.assert(block.getComponent("waterContainer").customColor.red == 1, "red component should be set");
		 957      -   test.assert(block.getComponent("waterContainer").customColor.green == 0, "green component should be set");
		 958      -   test.assert(block.getComponent("waterContainer").customColor.blue == 0, "blue component should be set");
		 959      - 
		 960      -   block.getComponent("waterContainer").addDye(MinecraftItemTypes.blueDye);
		 961      -   test.assert(isNear(block.getComponent("waterContainer").customColor.red, 0.616), "red component should be set");
		 962      -   test.assert(isNear(block.getComponent("waterContainer").customColor.green, 0.133), "green component should be set");
		 963      -   test.assert(isNear(block.getComponent("waterContainer").customColor.blue, 0.333), "blue component should be set");
		 964 1141   
		 965      -   test.setFluidContainer(loc, GameTest.FluidType.lava);
		 966      -   test.assert(
		 967      -     block.getComponent("waterContainer") == null,
		 968      -     "A lava container should not have a waterContainer component"
		     1142 + GameTest.register("APITests", "maybe_fill_cauldron", (test) => {
		     1143 +   test
		     1144 +     .startSequence()
		     1145 +     .thenExecute(() => {
		     1146 +       test.triggerInternalBlockEvent(new BlockLocation(1, 3, 1), "minecraft:drip");
		     1147 +       test.triggerInternalBlockEvent(new BlockLocation(3, 3, 1), "minecraft:drip");
		     1148 +     })
		     1149 +     .thenIdle(61)
		     1150 +     .thenExecute(() => {
		     1151 +       var waterCauldron = test.getBlock(new BlockLocation(3, 2, 1));
		     1152 +       var lavaCauldron = test.getBlock(new BlockLocation(1, 2, 1));
		     1153 +       test.assert(
		     1154 +         waterCauldron.getComponent("waterContainer").fillLevel == 2,
		     1155 +         "Expected water to be at level 2, but got " + waterCauldron.getComponent("waterContainer").fillLevel
		     1156 +       );
		     1157 +       test.assert(
		     1158 +         lavaCauldron.getComponent("lavaContainer").fillLevel == FluidContainer.maxFillLevel,
		     1159 +         "Expected lava to be full, but got a fill level of " + lavaCauldron.getComponent("lavaContainer").fillLevel
		     1160 +       );
		     1161 +     })
		     1162 +     .thenSucceed();
		     1163 + })
		     1164 +   .setupTicks(30) // time it takes lava to flow.
		     1165 +   .maxTicks(100)
		     1166 +   .tag(GameTest.Tags.suiteDefault);
		 969      -   );
		 970      -   test.assert(block.getComponent("lavaContainer") != null, "This is a lava component");
		 971      -   test.assert(
		 972      -     block.getComponent("snowContainer") == null,
		 973      -     "A lava container should not have a snowContainer component"
		 974      -   );
		 975      -   test.assert(
		 976      -     block.getComponent("potionContainer") == null,
		 977      -     "A lava container should not have a potionContainer component"
		 978      -   );
		 979      - 
		 980      -   test.setFluidContainer(loc, GameTest.FluidType.powderSnow);
		 981      -   test.assert(
		 982      -     block.getComponent("waterContainer") == null,
		 983      -     "A snow container should not have a waterContainer component"
		 984      -   );
		 985      -   test.assert(
		 986      -     block.getComponent("lavaContainer") == null,
		 987      -     "A snow container should not have a lavaContainer component"
		 988      -   );
		 989      -   test.assert(block.getComponent("snowContainer") != null, "This is a snow container");
		 990      -   test.assert(
		 991      -     block.getComponent("potionContainer") == null,
		 992      -     "A snow container should not have a potionContainer component"
		 993      -   );
		 994 1167   
		 995      -   test.setFluidContainer(loc, GameTest.FluidType.potion);
		 996      -   test.assert(
		 997      -     block.getComponent("snowContainer") == null,
		 998      -     "A potion container should not have a waterContainer component"
		     1168 + GameTest.register("APITests", "grow_pointed_dripstone", (test) => {
		     1169 +   test.triggerInternalBlockEvent(new BlockLocation(1, 5, 1), "grow_stalagtite");
		     1170 +   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 4, 1), true);
		     1171 +   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 2, 1), false);
		     1172 + 
		     1173 +   test.triggerInternalBlockEvent(new BlockLocation(1, 5, 1), "grow_stalagmite");
		     1174 +   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 4, 1), true);
		     1175 +   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 2, 1), true);
		     1176 + 
		     1177 +   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 3, 1), false);
		 999      -   );
		1000      -   test.assert(
		1001      -     block.getComponent("lavaContainer") == null,
		1002      -     "A potion container should not have a lavaContainer component"
		1003      -   );
		1004      -   test.assert(
		1005      -     block.getComponent("snowContainer") == null,
		1006      -     "A potion container should not have a snowContainer component"
		1007      -   );
		1008      -   test.assert(block.getComponent("potionContainer") != null, "This is a potion container");
		1009 1178   
		1010 1179     test.succeed();
		1011 1180   }).tag(GameTest.Tags.suiteDefault);
		1012 1181   
		     1182 + GameTest.register("APITests", "vines", (test) => {
		1013      - // test for bug: 678331
		1014      - GameTest.register("APITests", "cauldron_nocrash", (test) => {
		1015      -   const loc = new BlockLocation(0, 1, 0);
		     1183 +   const testEx = new GameTestExtensions(test);
		1016      -   var block = test.getBlock(loc);
		1017 1184   
		     1185 +   const allBitmask = 15;
		     1186 +   const northBitmask = 1 << testEx.getVineDirection(test.rotateDirection(Direction.north));
		     1187 +   const eastBitmask = 1 << testEx.getVineDirection(test.rotateDirection(Direction.east));
		1018      -   test.setBlockType(MinecraftBlockTypes.air, loc);
		     1188 +   const southBitmask = 1 << testEx.getVineDirection(test.rotateDirection(Direction.south));
		     1189 +   const westBitmask = 1 << testEx.getVineDirection(test.rotateDirection(Direction.west));
		1019      -   test.setBlockType(MinecraftBlockTypes.cauldron, loc);
		1020      -   test.setFluidContainer(loc, GameTest.FluidType.potion);
		1021 1190   
		     1191 +   test.triggerInternalBlockEvent(new BlockLocation(1, 4, 2), "grow_down", [southBitmask | northBitmask]);
		     1192 +   testEx.assertBlockProperty(
		     1193 +     BlockProperties.vineDirectionBits,
		1022      -   let cauldron = block.getComponent("potionContainer");
		     1194 +     southBitmask | northBitmask,
		1023      -   cauldron.fillLevel = 2;
		1024      - 
		     1195 +     new BlockLocation(1, 3, 2)
		     1196 +   );
		1025      -   const poisonPotion = new ItemStack(MinecraftItemTypes.splashPotion, 1, 32);
		1026      -   cauldron.setPotionType(poisonPotion); //this line crashes the title
		1027 1197   
		     1198 +   test.triggerInternalBlockEvent(new BlockLocation(1, 4, 2), "grow_up", [allBitmask]);
		1028      -   test.succeed();
		1029      - })
		1030      -   .structureName("APITests:cauldron")
		     1199 +   testEx.assertBlockProperty(BlockProperties.vineDirectionBits, southBitmask | eastBitmask, new BlockLocation(1, 5, 2));
		1031      -   .tag(GameTest.Tags.suiteDefault);
		1032 1200   
		     1201 +   test.triggerInternalBlockEvent(new BlockLocation(7, 2, 1), "grow_sideways", [
		     1202 +     testEx.getVineDirection(test.rotateDirection(Direction.west)),
		1033      - GameTest.register("APITests", "jukebox", (test) => {
		     1203 +   ]);
		     1204 +   testEx.assertBlockProperty(BlockProperties.vineDirectionBits, southBitmask, new BlockLocation(6, 2, 1));
		1034      -   var jukeboxBlock = test.getBlock(new BlockLocation(0, 1, 0));
		1035      -   var musicPlayerComp = jukeboxBlock.getComponent("recordPlayer");
		1036 1205   
		     1206 +   test.triggerInternalBlockEvent(new BlockLocation(6, 2, 1), "grow_sideways", [
		     1207 +     testEx.getVineDirection(test.rotateDirection(Direction.west)),
		1037      -   try {
		1038      -     musicPlayerComp.setRecord(MinecraftItemTypes.apple);
		     1208 +   ]);
		     1209 +   testEx.assertBlockProperty(BlockProperties.vineDirectionBits, southBitmask | westBitmask, new BlockLocation(6, 2, 1));
		1039      -     test.fail("An exception should be thrown when playing an item that is not a music disk");
		1040      -   } catch (e) {}
		1041 1210   
		     1211 +   test.triggerInternalBlockEvent(new BlockLocation(7, 2, 1), "grow_sideways", [
		     1212 +     testEx.getVineDirection(test.rotateDirection(Direction.east)),
		1042      -   test.assert(musicPlayerComp.isPlaying() === false, "Should be stopped");
		     1213 +   ]);
		     1214 +   testEx.assertBlockProperty(BlockProperties.vineDirectionBits, westBitmask, new BlockLocation(8, 2, 2));
		1043      -   musicPlayerComp.setRecord(MinecraftItemTypes.musicDiscMellohi);
		1044      -   test.assert(musicPlayerComp.isPlaying() === true, "Should be playing");
		1045 1215   
		     1216 +   test.succeed();
		1046      -   test
		1047      -     .startSequence()
		1048      -     .thenExecuteAfter(20, () => {
		     1217 + })
		     1218 +   .rotateTest(true)
		     1219 +   .tag(GameTest.Tags.suiteDefault);
		     1220 + 
		     1221 + GameTest.register("APITests", "tags", (test) => {
		     1222 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1), "tag_player");
		     1223 +   const dimension = test.getDimension();
		1049      -       test.assert(musicPlayerComp.isPlaying() === true, "Disk should not be finished yet");
		1050      -       musicPlayerComp.clearRecord();
		1051      -       test.assert(musicPlayerComp.isPlaying() === false, "Disk should be stopped now");
		1052      -     })
		1053      -     .thenSucceed();
		1054      - })
		1055      -   .maxTicks(25)
		1056      -   .tag(GameTest.Tags.suiteDefault);
		1057 1224   
		1058      - GameTest.register("APITests", "maybe_fill_cauldron", (test) => {
		1059 1225     test
		1060 1226       .startSequence()
		     1227 +     .thenExecuteAfter(2, () => {
		     1228 +       dimension.runCommand("tag @p[name=tag_player] add test_tag_1");
		1061      -     .thenExecute(() => {
		1062      -       test.triggerInternalBlockEvent(new BlockLocation(1, 3, 1), "minecraft:drip");
		     1229 +       test.assert(player.hasTag("test_tag_1"), "Expected tag test_tag_1");
		     1230 +       test.assert(!player.hasTag("test_tag_2"), "Did not expect tag test_tag_2");
		     1231 +       test.assert(player.removeTag("test_tag_1"), "Expected successful tag removal");
		     1232 +       test.assert(!player.removeTag("test_tag_1"), "Expected failed tag removal");
		     1233 +       test.assert(!player.hasTag("test_tag_1"), "Did not expect tag test_tag_1");
		     1234 +       player.addTag("test_tag_2");
		     1235 +       test.assert(player.hasTag("test_tag_2"), "Expected tag test_tag_2");
		     1236 +       let tags = player.getTags();
		     1237 +       test.assert(tags.length === 1 && tags[0] === "test_tag_2", "Unexpected tags value");
		     1238 +     })
		     1239 +     .thenSucceed();
		     1240 + })
		     1241 +   .structureName("ComponentTests:platform")
		     1242 +   .tag(GameTest.Tags.suiteDefault);
		     1243 + 
		     1244 + //AI tests
		1063      -       test.triggerInternalBlockEvent(new BlockLocation(3, 3, 1), "minecraft:drip");
		1064      -     })
		1065      -     .thenIdle(61)
		1066      -     .thenExecute(() => {
		1067      -       var waterCauldron = test.getBlock(new BlockLocation(3, 2, 1));
		1068      -       var lavaCauldron = test.getBlock(new BlockLocation(1, 2, 1));
		1069      -       test.assert(
		1070      -         waterCauldron.getComponent("waterContainer").fillLevel == 2,
		1071      -         "Expected water to be at level 2, but got " + waterCauldron.getComponent("waterContainer").fillLevel
		1072      -       );
		1073      -       test.assert(
		1074      -         lavaCauldron.getComponent("lavaContainer").fillLevel == FluidContainer.maxFillLevel,
		1075      -         "Expected lava to be full, but got a fill level of " + lavaCauldron.getComponent("lavaContainer").fillLevel
		1076      -       );
		1077      -     })
		1078      -     .thenSucceed();
		1079      - })
		     1245 + GameTest.register("APITests", "can_set_target", (test) => {
		     1246 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		     1247 +   let wolf = test.spawn("minecraft:wolf<minecraft:ageable_grow_up>", new BlockLocation(2, 2, 1));
		1080      -   .setupTicks(30) // time it takes lava to flow.
		1081      -   .maxTicks(100)
		1082      -   .tag(GameTest.Tags.suiteDefault);
		1083 1248   
		     1249 +   test
		     1250 +     .startSequence()
		1084      - GameTest.register("APITests", "grow_pointed_dripstone", (test) => {
		1085      -   test.triggerInternalBlockEvent(new BlockLocation(1, 5, 1), "grow_stalagtite");
		     1251 +     .thenExecuteAfter(10, () => {
		     1252 +       wolf.target = player;
		1086      -   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 4, 1), true);
		1087      -   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 2, 1), false);
		1088      - 
		     1253 +       const targetActor = wolf.target;
		     1254 +       wolf.kill();
		     1255 +       test.assert(targetActor == player, "Failed to set/get target on wolf");
		     1256 +     })
		     1257 +     .thenSucceed();
		     1258 + })
		     1259 +   .structureName("ComponentTests:platform")
		     1260 +   .tag(GameTest.Tags.suiteDefault);
		1089      -   test.triggerInternalBlockEvent(new BlockLocation(1, 5, 1), "grow_stalagmite");
		1090      -   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 4, 1), true);
		1091      -   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 2, 1), true);
		1092      - 
		1093      -   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 3, 1), false);
		1094      - 
		1095      -   test.succeed();
		1096      - }).tag(GameTest.Tags.suiteDefault);
		1097 1261   
		     1262 + GameTest.register("APITests", "set_target_attacks_player", (test) => {
		     1263 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		1098      - GameTest.register("APITests", "vines", (test) => {
		     1264 +   let wolf = test.spawn("minecraft:wolf<minecraft:ageable_grow_up>", new BlockLocation(2, 2, 1));
		1099      -   const testEx = new GameTestExtensions(test);
		1100 1265   
		     1266 +   test
		     1267 +     .startSequence()
		     1268 +     .thenExecuteAfter(10, () => {
		1101      -   const allBitmask = 15;
		     1269 +       wolf.target = player;
		     1270 +     })
		     1271 +     .thenWait(() => {
		     1272 +       const healthComponent = player.getComponent("minecraft:health");
		     1273 +       test.assert(healthComponent.current != healthComponent.value, "Player should have been attacked");
		     1274 +     })
		     1275 +     .thenExecute(() => {
		     1276 +       wolf.kill();
		     1277 +     })
		     1278 +     .thenSucceed();
		     1279 + })
		     1280 +   .maxTicks(200)
		     1281 +   .structureName("ComponentTests:platform")
		     1282 +   .tag(GameTest.Tags.suiteDefault);
		1102      -   const northBitmask = 1 << testEx.getVineDirection(test.rotateDirection(Direction.north));
		1103      -   const eastBitmask = 1 << testEx.getVineDirection(test.rotateDirection(Direction.east));
		1104      -   const southBitmask = 1 << testEx.getVineDirection(test.rotateDirection(Direction.south));
		1105      -   const westBitmask = 1 << testEx.getVineDirection(test.rotateDirection(Direction.west));
		1106      - 
		1107      -   test.triggerInternalBlockEvent(new BlockLocation(1, 4, 2), "grow_down", [southBitmask | northBitmask]);
		1108      -   testEx.assertBlockProperty(
		1109      -     BlockProperties.vineDirectionBits,
		1110      -     southBitmask | northBitmask,
		1111      -     new BlockLocation(1, 3, 2)
		1112      -   );
		1113      - 
		1114      -   test.triggerInternalBlockEvent(new BlockLocation(1, 4, 2), "grow_up", [allBitmask]);
		1115      -   testEx.assertBlockProperty(BlockProperties.vineDirectionBits, southBitmask | eastBitmask, new BlockLocation(1, 5, 2));
		1116 1283   
		     1284 + GameTest.register("APITests", "can_get_null_target", (test) => {
		1117      -   test.triggerInternalBlockEvent(new BlockLocation(7, 2, 1), "grow_sideways", [
		1118      -     testEx.getVineDirection(test.rotateDirection(Direction.west)),
		     1285 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		     1286 +   let wolf = test.spawn("minecraft:wolf<minecraft:ageable_grow_up>", new BlockLocation(2, 2, 1));
		1119      -   ]);
		1120      -   testEx.assertBlockProperty(BlockProperties.vineDirectionBits, southBitmask, new BlockLocation(6, 2, 1));
		1121 1287   
		     1288 +   const target = wolf.target;
		     1289 +   if (target) {
		1122      -   test.triggerInternalBlockEvent(new BlockLocation(6, 2, 1), "grow_sideways", [
		1123      -     testEx.getVineDirection(test.rotateDirection(Direction.west)),
		     1290 +     test.fail("Expected wolf to not have a target");
		     1291 +   }
		1124      -   ]);
		1125      -   testEx.assertBlockProperty(BlockProperties.vineDirectionBits, southBitmask | westBitmask, new BlockLocation(6, 2, 1));
		1126 1292   
		     1293 +   test.succeed();
		     1294 + })
		1127      -   test.triggerInternalBlockEvent(new BlockLocation(7, 2, 1), "grow_sideways", [
		1128      -     testEx.getVineDirection(test.rotateDirection(Direction.east)),
		     1295 +   .structureName("ComponentTests:platform")
		     1296 +   .tag(GameTest.Tags.suiteDefault);
		1129      -   ]);
		1130      -   testEx.assertBlockProperty(BlockProperties.vineDirectionBits, westBitmask, new BlockLocation(8, 2, 2));
		1131 1297   
		     1298 + //Entity Teleport Tests
		     1299 + GameTest.register("APITests", "teleport_mob", async (test) => {
		1132      -   test.succeed();
		1133      - })
		     1300 +   let sheepSpawn = new BlockLocation(0, 2, 0);
		     1301 +   let teleportBlockLoc = new BlockLocation(2, 2, 2);
		1134      -   .rotateTest(true)
		1135      -   .tag(GameTest.Tags.suiteDefault);
		1136      - 
		     1302 +   let sheep = test.spawn("minecraft:sheep", sheepSpawn);
		     1303 +   let teleportLoc = new Location(2, 2, 2);
		     1304 +   let teleportWorldLoc = test.worldLocation(teleportLoc);
		1137      - GameTest.register("APITests", "tags", (test) => {
		1138      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1), "tag_player");
		1139      -   const dimension = test.getDimension();
		1140 1305   
		1141      -   test
		1142      -     .startSequence()
		1143      -     .thenExecuteAfter(2, () => {
		     1306 +   await test.idle(10);
		     1307 +   sheep.teleport(teleportWorldLoc, sheep.dimension, 0.0, 0.0);
		     1308 +   test.assertEntityPresent("minecraft:sheep", teleportBlockLoc, true);
		     1309 +   sheep.kill();
		     1310 +   test.succeed();
		     1311 + })
		     1312 +   .structureName("ComponentTests:platform")
		     1313 +   .tag(GameTest.Tags.suiteDefault);
		     1314 + 
		     1315 + GameTest.register("APITests", "teleport_mob_facing", async (test) => {
		     1316 +   let playerSpawn = new BlockLocation(0, 2, 0);
		     1317 +   let player = test.spawnSimulatedPlayer(playerSpawn, "simulatedPlayer");
		     1318 +   let teleportLoc = new Location(2, 2, 2);
		     1319 +   let teleportBlockLoc = new BlockLocation(2, 2, 2);
		     1320 +   let teleportWorldLoc = test.worldLocation(teleportLoc);
		1144      -       dimension.runCommand("tag @p[name=tag_player] add test_tag_1");
		1145      -       test.assert(player.hasTag("test_tag_1"), "Expected tag test_tag_1");
		1146      -       test.assert(!player.hasTag("test_tag_2"), "Did not expect tag test_tag_2");
		1147      -       test.assert(player.removeTag("test_tag_1"), "Expected successful tag removal");
		1148      -       test.assert(!player.removeTag("test_tag_1"), "Expected failed tag removal");
		1149      -       test.assert(!player.hasTag("test_tag_1"), "Did not expect tag test_tag_1");
		1150      -       player.addTag("test_tag_2");
		1151      -       test.assert(player.hasTag("test_tag_2"), "Expected tag test_tag_2");
		1152      -       let tags = player.getTags();
		1153      -       test.assert(tags.length === 1 && tags[0] === "test_tag_2", "Unexpected tags value");
		1154      -     })
		1155      -     .thenSucceed();
		1156      - })
		1157      -   .structureName("ComponentTests:platform")
		1158      -   .tag(GameTest.Tags.suiteDefault);
		1159 1321   
		     1322 +   let facingLoc = new Location(2, 3, 0);
		1160      - //AI tests
		1161      - GameTest.register("APITests", "can_set_target", (test) => {
		     1323 +   let facingBlockLoc = new BlockLocation(2, 3, 0);
		     1324 +   let facingWorldLoc = test.worldLocation(facingLoc);
		1162      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		1163      -   let wolf = test.spawn("minecraft:wolf<minecraft:ageable_grow_up>", new BlockLocation(2, 2, 1));
		1164 1325   
		1165      -   test
		1166      -     .startSequence()
		1167      -     .thenExecuteAfter(10, () => {
		1168      -       wolf.target = player;
		     1326 +   test.setBlockType(MinecraftBlockTypes.diamondBlock, facingBlockLoc);
		     1327 +   const diamondBlock = test.getBlock(facingBlockLoc);
		     1328 +   let facingBlock;
		     1329 + 
		     1330 +   await test.idle(10);
		     1331 +   player.teleportFacing(teleportWorldLoc, player.dimension, facingWorldLoc);
		     1332 +   await test.idle(20);
		     1333 +   facingBlock = player.getBlockFromViewVector();
		     1334 +   test.assert(
		     1335 +     facingBlock.type === diamondBlock.type,
		     1336 +     "expected mob to face diamond block but instead got " + facingBlock.type.id
		     1337 +   );
		     1338 +   test.assertEntityPresent("minecraft:player", teleportBlockLoc, true);
		     1339 +   player.kill();
		     1340 +   test.succeed();
		     1341 + })
		     1342 +   .structureName("ComponentTests:platform")
		     1343 +   .tag(GameTest.Tags.suiteDefault);
		     1344 + 
		     1345 + GameTest.register("APITests", "view_vector", (test) => {
		     1346 +   const spawnLoc = new BlockLocation(1, 2, 1);
		     1347 +   const playerName = "Test Player";
		     1348 +   const player = test.spawnSimulatedPlayer(spawnLoc, playerName);
		     1349 + 
		     1350 +   player.lookAtBlock(new BlockLocation(0, 3, 1));
		     1351 +   test
		     1352 +     .startSequence()
		     1353 +     .thenExecuteAfter(10, () => {
		     1354 +       test.assert(
		     1355 +         isNear(player.viewVector.x, -0.99, 0.01),
		     1356 +         "Expected x component to be -0.99, but got " + player.viewVector.x
		     1357 +       );
		     1358 +       test.assert(
		     1359 +         isNear(player.viewVector.y, -0.12, 0.01),
		     1360 +         "Expected y component to be -0.12, but got " + player.viewVector.y
		     1361 +       );
		     1362 +       test.assert(isNear(player.viewVector.z, 0, 0.01), "Expected z component to be 0, but got " + player.viewVector.z);
		     1363 +       test.assert(player.rotation.y == 90, "Expected body rotation to be 90, but got " + player.rotation.y);
		     1364 +       player.lookAtBlock(new BlockLocation(2, 3, 0));
		     1365 +     })
		     1366 +     .thenExecuteAfter(10, () => {
		     1367 +       test.assert(
		     1368 +         isNear(player.viewVector.x, 0.7, 0.01),
		     1369 +         "Expected x component to be .70, but got " + player.viewVector.x
		     1370 +       );
		     1371 +       test.assert(
		     1372 +         isNear(player.viewVector.y, -0.08, 0.01),
		     1373 +         "Expected y component to be -0.08, but got " + player.viewVector.y
		     1374 +       );
		     1375 +       test.assert(
		     1376 +         isNear(player.viewVector.z, -0.7, 0.01),
		     1377 +         "Expected z component to be -0.70, but got " + player.viewVector.z
		     1378 +       );
		     1379 +       test.assert(player.rotation.y == -135, "Expected body rotation to be -135, but got " + player.rotation.y);
		     1380 +       player.lookAtBlock(new BlockLocation(1, 5, 1));
		     1381 +     })
		     1382 +     .thenExecuteAfter(10, () => {
		     1383 +       test.assert(isNear(player.viewVector.x, 0, 0.01), "Expected x component to be 0, but got " + player.viewVector.x);
		     1384 +       test.assert(isNear(player.viewVector.y, 1, 0.01), "Expected y component to be 1, but got " + player.viewVector.y);
		     1385 +       test.assert(isNear(player.viewVector.z, 0, 0.01), "Expected z component to be 0, but got " + player.viewVector.z);
		     1386 +       test.assert(player.rotation.y == -135, "Expected body rotation to be -135, but got " + player.rotation.y);
		1169      -       const targetActor = wolf.target;
		1170      -       wolf.kill();
		1171      -       test.assert(targetActor == player, "Failed to set/get target on wolf");
		1172      -     })
		1173      -     .thenSucceed();
		1174      - })
		1175      -   .structureName("ComponentTests:platform")
		1176      -   .tag(GameTest.Tags.suiteDefault);
		1177      - 
		1178      - GameTest.register("APITests", "set_target_attacks_player", (test) => {
		1179      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		1180      -   let wolf = test.spawn("minecraft:wolf<minecraft:ageable_grow_up>", new BlockLocation(2, 2, 1));
		1181      - 
		1182      -   test
		1183      -     .startSequence()
		1184      -     .thenExecuteAfter(10, () => {
		1185      -       wolf.target = player;
		1186      -     })
		1187      -     .thenWait(() => {
		1188      -       const healthComponent = player.getComponent("minecraft:health");
		1189      -       test.assert(healthComponent.current != healthComponent.value, "Player should have been attacked");
		1190      -     })
		1191      -     .thenExecute(() => {
		1192      -       wolf.kill();
		1193      -     })
		1194      -     .thenSucceed();
		1195      - })
		1196      -   .maxTicks(200)
		1197      -   .structureName("ComponentTests:platform")
		1198      -   .tag(GameTest.Tags.suiteDefault);
		1199      - 
		1200      - GameTest.register("APITests", "can_get_null_target", (test) => {
		1201      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		1202      -   let wolf = test.spawn("minecraft:wolf<minecraft:ageable_grow_up>", new BlockLocation(2, 2, 1));
		1203      - 
		1204      -   const target = wolf.target;
		1205      -   if (target) {
		1206      -     test.fail("Expected wolf to not have a target");
		1207      -   }
		1208      - 
		1209      -   test.succeed();
		1210      - })
		1211      -   .structureName("ComponentTests:platform")
		1212      -   .tag(GameTest.Tags.suiteDefault);
		1213      - 
		1214      - //Entity Teleport Tests
		1215      - GameTest.register("APITests", "teleport_mob", async (test) => {
		1216      -   let sheepSpawn = new BlockLocation(0, 2, 0);
		1217      -   let teleportBlockLoc = new BlockLocation(2, 2, 2);
		1218      -   let sheep = test.spawn("minecraft:sheep", sheepSpawn);
		1219      -   let teleportLoc = new Location(2, 2, 2);
		1220      -   let teleportWorldLoc = test.worldLocation(teleportLoc);
		1221      - 
		1222      -   await test.idle(10);
		1223      -   sheep.teleport(teleportWorldLoc, sheep.dimension, 0.0, 0.0);
		1224      -   test.assertEntityPresent("minecraft:sheep", teleportBlockLoc, true);
		1225      -   sheep.kill();
		1226      -   test.succeed();
		1227      - })
		1228      -   .structureName("ComponentTests:platform")
		1229      -   .tag(GameTest.Tags.suiteDefault);
		1230 1387   
		     1388 +       const head = test.relativeLocation(player.headLocation);
		     1389 +       test.assert(isNear(head.x, 1.5, 0.01), "Expected x component to be 1.5, but got " + head.x);
		     1390 +       test.assert(isNear(head.y, 3.52, 0.01), "Expected y component to be 3.52, but got " + head.y);
		     1391 +       test.assert(isNear(head.z, 1.5, 0.01), "Expected z component to be 1.5, but got " + head.z);
		     1392 +     })
		     1393 +     .thenSucceed();
		     1394 + })
		     1395 +   .structureName("ComponentTests:platform")
		     1396 +   .tag(GameTest.Tags.suiteDefault);
		1231      - GameTest.register("APITests", "teleport_mob_facing", async (test) => {
		1232      -   let playerSpawn = new BlockLocation(0, 2, 0);
		1233      -   let player = test.spawnSimulatedPlayer(playerSpawn, "simulatedPlayer");
		1234      -   let teleportLoc = new Location(2, 2, 2);
		1235      -   let teleportBlockLoc = new BlockLocation(2, 2, 2);
		1236      -   let teleportWorldLoc = test.worldLocation(teleportLoc);
		1237 1397   
		     1398 + GameTest.register("APITests", "set_velocity", (test) => {
		     1399 +   const zombie = test.spawnWithoutBehaviors("minecraft:zombie<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		     1400 +   test
		     1401 +     .startSequence()
		     1402 +     .thenExecuteFor(30, () => {
		     1403 +       zombie.setVelocity(new Vector(0, 0.1, 0));
		     1404 +     })
		     1405 +     .thenExecute(() => {
		     1406 +       const zombieLoc = test.relativeLocation(zombie.location);
		     1407 +       const expectedLoc = new Location(1.5, 5.0, 1.5);
		1238      -   let facingLoc = new Location(2, 3, 0);
		1239      -   let facingBlockLoc = new BlockLocation(2, 3, 0);
		1240      -   let facingWorldLoc = test.worldLocation(facingLoc);
		1241      - 
		1242      -   test.setBlockType(MinecraftBlockTypes.diamondBlock, facingBlockLoc);
		1243      -   const diamondBlock = test.getBlock(facingBlockLoc);
		1244      -   let facingBlock;
		1245 1408   
		1246      -   await test.idle(10);
		1247      -   player.teleportFacing(teleportWorldLoc, player.dimension, facingWorldLoc);
		1248      -   await test.idle(20);
		     1409 +       test.assert(zombieLoc.isNear(expectedLoc, 0.01), "Expected zombie to levitate to specific place.");
		     1410 +     })
		     1411 +     .thenSucceed();
		     1412 + })
		     1413 +   .structureName("ComponentTests:platform")
		     1414 +   .tag(GameTest.Tags.suiteDefault);
		     1415 + 
		     1416 + GameTest.register("APITests", "lore", (test) => {
		     1417 +   let itemStack = new ItemStack(MinecraftItemTypes.diamondSword);
		     1418 +   itemStack.setLore(["test lore 0", "test lore 1", "test lore 2"]);
		     1419 +   let lore = itemStack.getLore();
		1249      -   facingBlock = player.getBlockFromViewVector();
		1250      -   test.assert(
		1251      -     facingBlock.type === diamondBlock.type,
		1252      -     "expected mob to face diamond block but instead got " + facingBlock.type.id
		1253      -   );
		1254      -   test.assertEntityPresent("minecraft:player", teleportBlockLoc, true);
		1255      -   player.kill();
		1256      -   test.succeed();
		1257      - })
		1258      -   .structureName("ComponentTests:platform")
		1259      -   .tag(GameTest.Tags.suiteDefault);
		1260      - 
		     1420 +   test.assert(lore.length === 3, "Expected 3 lore lines, but got " + lore.length);
		     1421 +   test.assert(lore[0] === "test lore 0", "Expected lore line 0 to be 'test lore 0', but got " + lore[0]);
		     1422 +   test.assert(lore[1] === "test lore 1", "Expected lore line 1 to be 'test lore 1', but got " + lore[1]);
		     1423 +   test.assert(lore[2] === "test lore 2", "Expected lore line 2 to be 'test lore 2', but got " + lore[2]);
		1261      - GameTest.register("APITests", "view_vector", (test) => {
		1262      -   const spawnLoc = new BlockLocation(1, 2, 1);
		1263      -   const playerName = "Test Player";
		1264      -   const player = test.spawnSimulatedPlayer(spawnLoc, playerName);
		1265 1424   
		     1425 +   const chestCart = test.spawn("chest_minecart", new BlockLocation(1, 3, 1));
		1266      -   player.lookAtBlock(new BlockLocation(0, 3, 1));
		1267      -   test
		     1426 +   const inventoryComp = chestCart.getComponent("inventory");
		     1427 +   inventoryComp.container.addItem(itemStack);
		     1428 +   test.succeed();
		     1429 + })
		     1430 +   .structureName("ComponentTests:platform")
		     1431 +   .tag(GameTest.Tags.suiteDefault);
		     1432 + 
		     1433 + GameTest.registerAsync("APITests", "data_driven_actor_event", async (test) => {
		     1434 +   let globalBeforeTriggerSuccess = false;
		     1435 +   let entityEventFilteredBeforeTriggerSuccess = false;
		     1436 +   let globalTriggerSuccess = false;
		     1437 +   let entityEventFilteredTriggerSuccess = false;
		     1438 + 
		     1439 +   //Global Trigger
		     1440 +   let globalBeforeTrigger = world.events.beforeDataDrivenEntityTriggerEvent.subscribe((event) => {
		     1441 +     if (event.entity.id == "minecraft:llama" && event.id == "minecraft:entity_spawned") {
		     1442 +       globalBeforeTriggerSuccess = true;
		     1443 +     }
		     1444 + 
		     1445 +     //Force the llama to spawn as a baby
		     1446 +     if (
		     1447 +       event.modifiers.length > 0 &&
		     1448 +       event.modifiers[0].triggers.length > 0 &&
		     1449 +       event.modifiers[0].triggers[0].eventName == "minecraft:spawn_adult"
		     1450 +     ) {
		     1451 +       event.modifiers[0].triggers[0].eventName = "minecraft:spawn_baby";
		     1452 +     }
		     1453 +   });
		     1454 + 
		     1455 +   let globalTrigger = world.events.dataDrivenEntityTriggerEvent.subscribe((event) => {
		     1456 +     if (event.entity.id == "minecraft:llama" && event.id == "minecraft:entity_spawned") {
		     1457 +       if (!globalBeforeTriggerSuccess) test.fail("globalBeforeTrigger didn't fire for the entity_spawned event!");
		     1458 +       globalTriggerSuccess = true;
		     1459 +     }
		     1460 +   });
		1268      -     .startSequence()
		1269      -     .thenExecuteAfter(10, () => {
		1270      -       test.assert(
		1271      -         isNear(player.viewVector.x, -0.99, 0.01),
		1272      -         "Expected x component to be -0.99, but got " + player.viewVector.x
		1273      -       );
		1274      -       test.assert(
		1275      -         isNear(player.viewVector.y, -0.12, 0.01),
		1276      -         "Expected y component to be -0.12, but got " + player.viewVector.y
		1277      -       );
		1278      -       test.assert(isNear(player.viewVector.z, 0, 0.01), "Expected z component to be 0, but got " + player.viewVector.z);
		1279      -       test.assert(player.bodyRotation == 90, "Expected body rotation to be 90, but got " + player.bodyRotation);
		1280      -       player.lookAtBlock(new BlockLocation(2, 3, 0));
		1281      -     })
		1282      -     .thenExecuteAfter(10, () => {
		1283      -       test.assert(
		1284      -         isNear(player.viewVector.x, 0.7, 0.01),
		1285      -         "Expected x component to be .70, but got " + player.viewVector.x
		1286      -       );
		1287      -       test.assert(
		1288      -         isNear(player.viewVector.y, -0.08, 0.01),
		1289      -         "Expected y component to be -0.08, but got " + player.viewVector.y
		1290      -       );
		1291      -       test.assert(
		1292      -         isNear(player.viewVector.z, -0.7, 0.01),
		1293      -         "Expected z component to be -0.70, but got " + player.viewVector.z
		1294      -       );
		1295      -       test.assert(player.bodyRotation == -135, "Expected body rotation to be -135, but got " + player.bodyRotation);
		1296      -       player.lookAtBlock(new BlockLocation(1, 5, 1));
		1297      -     })
		1298      -     .thenExecuteAfter(10, () => {
		1299      -       test.assert(isNear(player.viewVector.x, 0, 0.01), "Expected x component to be 0, but got " + player.viewVector.x);
		1300      -       test.assert(isNear(player.viewVector.y, 1, 0.01), "Expected y component to be 1, but got " + player.viewVector.y);
		1301      -       test.assert(isNear(player.viewVector.z, 0, 0.01), "Expected z component to be 0, but got " + player.viewVector.z);
		1302      -       test.assert(player.bodyRotation == -135, "Expected body rotation to be -135, but got " + player.bodyRotation);
		1303 1461   
		     1462 +   //Trigger filtered by entity type and event type
		1304      -       const head = test.relativeLocation(player.headLocation);
		1305      -       test.assert(isNear(head.x, 1.5, 0.01), "Expected x component to be 1.5, but got " + head.x);
		     1463 +   let entityEventFilterOptions = new EntityDataDrivenTriggerEventOptions();
		     1464 +   entityEventFilterOptions.entityTypes.push("minecraft:llama");
		     1465 +   entityEventFilterOptions.eventTypes.push("minecraft:entity_spawned");
		     1466 + 
		     1467 +   let entityEventBeforeFilterTrigger = world.events.beforeDataDrivenEntityTriggerEvent.subscribe((event) => {
		     1468 +     entityEventFilteredBeforeTriggerSuccess = true;
		     1469 +   }, entityEventFilterOptions);
		1306      -       test.assert(isNear(head.y, 3.52, 0.01), "Expected y component to be 3.52, but got " + head.y);
		1307      -       test.assert(isNear(head.z, 1.5, 0.01), "Expected z component to be 1.5, but got " + head.z);
		1308      -     })
		1309      -     .thenSucceed();
		1310      - })
		1311      -   .structureName("ComponentTests:platform")
		1312      -   .tag(GameTest.Tags.suiteDefault);
		1313 1470   
		     1471 +   let entityEventFilterTrigger = world.events.dataDrivenEntityTriggerEvent.subscribe((event) => {
		1314      - GameTest.register("APITests", "set_velocity", (test) => {
		1315      -   const zombie = test.spawnWithoutBehaviors("minecraft:zombie<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		1316      -   test
		     1472 +     if (!entityEventFilteredBeforeTriggerSuccess)
		     1473 +       test.fail("actorEventBeforeFilterTrigger didn't fire for the entity_spawned event!");
		     1474 +     entityEventFilteredTriggerSuccess = true;
		     1475 +   }, entityEventFilterOptions);
		     1476 + 
		     1477 +   const llama = test.spawn("minecraft:llama", new BlockLocation(1, 2, 1));
		     1478 +   const villager = test.spawn("minecraft:villager_v2", new BlockLocation(1, 2, 1));
		1317      -     .startSequence()
		1318      -     .thenExecuteFor(30, () => {
		1319      -       zombie.setVelocity(new Vector(0, 0.1, 0));
		1320      -     })
		1321      -     .thenExecute(() => {
		1322      -       const zombieLoc = test.relativeLocation(zombie.location);
		1323      -       const expectedLoc = new Location(1.5, 5.0, 1.5);
		1324 1479   
		     1480 +   world.events.beforeDataDrivenEntityTriggerEvent.unsubscribe(globalBeforeTrigger);
		     1481 +   world.events.beforeDataDrivenEntityTriggerEvent.unsubscribe(entityEventBeforeFilterTrigger);
		1325      -       test.assert(zombieLoc.isNear(expectedLoc, 0.01), "Expected zombie to levitate to specific place.");
		1326      -     })
		     1482 +   world.events.dataDrivenEntityTriggerEvent.unsubscribe(globalTrigger);
		     1483 +   world.events.dataDrivenEntityTriggerEvent.unsubscribe(entityEventFilterTrigger);
		     1484 + 
		     1485 +   let specificEntityBeforeTriggerSuccess = false;
		1327      -     .thenSucceed();
		1328      - })
		1329      -   .structureName("ComponentTests:platform")
		1330      -   .tag(GameTest.Tags.suiteDefault);
		1331 1486   
		1332      - GameTest.register("APITests", "lore", (test) => {
		1333      -   let itemStack = new ItemStack(MinecraftItemTypes.diamondSword);
		1334      -   itemStack.setLore(["test lore 0", "test lore 1", "test lore 2"]);
		1335      -   let lore = itemStack.getLore();
		     1487 +   //Event bound to a specific entity
		     1488 +   let specificEntityFilterOptions = new EntityDataDrivenTriggerEventOptions();
		     1489 +   specificEntityFilterOptions.entities.push(llama);
		     1490 +   specificEntityFilterOptions.eventTypes.push("minecraft:ageable_grow_up");
		1336      -   test.assert(lore.length === 3, "Expected 3 lore lines, but got " + lore.length);
		1337      -   test.assert(lore[0] === "test lore 0", "Expected lore line 0 to be 'test lore 0', but got " + lore[0]);
		1338      -   test.assert(lore[1] === "test lore 1", "Expected lore line 1 to be 'test lore 1', but got " + lore[1]);
		1339      -   test.assert(lore[2] === "test lore 2", "Expected lore line 2 to be 'test lore 2', but got " + lore[2]);
		1340 1491   
		1341      -   const chestCart = test.spawn("chest_minecart", new BlockLocation(1, 3, 1));
		1342      -   const inventoryComp = chestCart.getComponent("inventory");
		1343      -   inventoryComp.container.addItem(itemStack);
		     1492 +   let specificEntityEventBeforeTrigger = world.events.beforeDataDrivenEntityTriggerEvent.subscribe((event) => {
		     1493 +     event.cancel = true;
		     1494 +     specificEntityBeforeTriggerSuccess = true;
		     1495 +   }, specificEntityFilterOptions);
		1344      -   test.succeed();
		1345      - })
		1346      -   .structureName("ComponentTests:platform")
		1347      -   .tag(GameTest.Tags.suiteDefault);
		1348 1496   
		     1497 +   //Event bound to both entities, but only fire on villager to show that multi-filters work
		     1498 +   let allEntityFilterOptions = new EntityDataDrivenTriggerEventOptions();
		1349      - GameTest.registerAsync("APITests", "data_driven_actor_event", async (test) => {
		     1499 +   allEntityFilterOptions.entities.push(llama);
		     1500 +   allEntityFilterOptions.entities.push(villager);
		     1501 +   allEntityFilterOptions.entityTypes.push("minecraft:villager_v2");
		     1502 +   allEntityFilterOptions.eventTypes.push("minecraft:ageable_grow_up");
		1350      -   let globalBeforeTriggerSuccess = false;
		1351      -   let entityEventFilteredBeforeTriggerSuccess = false;
		1352      -   let globalTriggerSuccess = false;
		1353      -   let entityEventFilteredTriggerSuccess = false;
		1354 1503   
		1355      -   //Global Trigger
		1356      -   let globalBeforeTrigger = world.events.beforeDataDrivenEntityTriggerEvent.subscribe((event) => {
		1357      -     if (event.entity.id == "minecraft:llama" && event.id == "minecraft:entity_spawned") {
		1358      -       globalBeforeTriggerSuccess = true;
		     1504 +   let allEntitiesTriggerCount = 0;
		1359      -     }
		1360 1505   
		     1506 +   let allEntitiesEventBeforeTrigger = world.events.beforeDataDrivenEntityTriggerEvent.subscribe((event) => {
		1361      -     //Force the llama to spawn as a baby
		1362      -     if (
		     1507 +     allEntitiesTriggerCount += 1;
		     1508 +   }, allEntityFilterOptions);
		     1509 +   llama.triggerEvent("minecraft:ageable_grow_up");
		     1510 +   villager.triggerEvent("minecraft:ageable_grow_up");
		     1511 + 
		     1512 +   world.events.beforeDataDrivenEntityTriggerEvent.unsubscribe(specificEntityEventBeforeTrigger);
		     1513 +   world.events.beforeDataDrivenEntityTriggerEvent.unsubscribe(allEntitiesEventBeforeTrigger);
		1363      -       event.modifiers.length > 0 &&
		1364      -       event.modifiers[0].triggers.length > 0 &&
		1365      -       event.modifiers[0].triggers[0].eventName == "minecraft:spawn_adult"
		1366      -     ) {
		1367      -       event.modifiers[0].triggers[0].eventName = "minecraft:spawn_baby";
		1368      -     }
		1369      -   });
		1370 1514   
		     1515 +   if (!globalBeforeTriggerSuccess) test.fail("Global beforeDataDrivenEntityTriggerEvent didn't fire!");
		1371      -   let globalTrigger = world.events.dataDrivenEntityTriggerEvent.subscribe((event) => {
		1372      -     if (event.entity.id == "minecraft:llama" && event.id == "minecraft:entity_spawned") {
		1373      -       if (!globalBeforeTriggerSuccess) test.fail("globalBeforeTrigger didn't fire for the entity_spawned event!");
		     1516 +   if (!entityEventFilteredBeforeTriggerSuccess)
		     1517 +     test.fail("Filtered entity/event beforeDataDrivenEntityTriggerEvent didn't fire!");
		     1518 +   if (!globalTriggerSuccess) test.fail("Global dataDrivenEntityTriggerEvent didn't fire!");
		1374      -       globalTriggerSuccess = true;
		1375      -     }
		1376      -   });
		1377      - 
		     1519 +   if (!entityEventFilteredTriggerSuccess) test.fail("Filtered entity/event dataDrivenEntityTriggerEvent didn't fire!");
		     1520 +   if (!specificEntityBeforeTriggerSuccess) test.fail("Specific entity beforeDataDrivenEntityTriggerEvent didn't fire!");
		     1521 +   if (allEntitiesTriggerCount != 1)
		     1522 +     test.fail("All filters beforeDataDrivenEntityTriggerEvent didn't fire exactly one time!");
		1378      -   //Trigger filtered by entity type and event type
		1379      -   let entityEventFilterOptions = new EntityDataDrivenTriggerEventOptions();
		1380      -   entityEventFilterOptions.entityTypes.push("minecraft:llama");
		1381      -   entityEventFilterOptions.eventTypes.push("minecraft:entity_spawned");
		1382 1523   
		     1524 +   await test.idle(10);
		     1525 +   if (llama.getComponent("minecraft:is_baby") == null)
		1383      -   let entityEventBeforeFilterTrigger = world.events.beforeDataDrivenEntityTriggerEvent.subscribe((event) => {
		1384      -     entityEventFilteredBeforeTriggerSuccess = true;
		     1526 +     test.fail("Llama was able to grow up! The beforeDataDrivenEntityTriggerEvent should prevent this!");
		1385      -   }, entityEventFilterOptions);
		1386 1527   
		     1528 +   test.succeed();
		1387      -   let entityEventFilterTrigger = world.events.dataDrivenEntityTriggerEvent.subscribe((event) => {
		1388      -     if (!entityEventFilteredBeforeTriggerSuccess)
		     1529 + })
		     1530 +   .structureName("ComponentTests:animal_pen")
		     1531 +   .tag(GameTest.Tags.suiteDefault);
		1389      -       test.fail("actorEventBeforeFilterTrigger didn't fire for the entity_spawned event!");
		1390      -     entityEventFilteredTriggerSuccess = true;
		1391      -   }, entityEventFilterOptions);
		1392 1532   
		     1533 + GameTest.registerAsync("APITests", "property_components", async (test) => {
		     1534 +   // The following components aren't present in this test since either there aren't mobs that use that component
		     1535 +   //  or it is difficult to get them into the correct state.
		1393      -   const llama = test.spawn("minecraft:llama", new BlockLocation(1, 2, 1));
		     1536 +   // skin_id, push_through, ground_offset, friction_modifier, floats_in_liquid, wants_jockey, is_shaking
		1394      -   const villager = test.spawn("minecraft:villager_v2", new BlockLocation(1, 2, 1));
		1395 1537   
		     1538 +   let testComponent = (entity, compName, expectedValue, canSet) => {
		     1539 +     let comp = entity.getComponent("minecraft:" + compName);
		1396      -   world.events.beforeDataDrivenEntityTriggerEvent.unsubscribe(globalBeforeTrigger);
		     1540 +     test.assert(comp != null, "Entity did not have expected component " + compName);
		     1541 +     if (expectedValue !== undefined) {
		     1542 +       let v = comp.value;
		     1543 +       let pass = false;
		     1544 +       if (typeof v === "number") {
		     1545 +         pass = Math.abs(expectedValue - v) <= 0.001;
		     1546 +       } else {
		     1547 +         pass = v == expectedValue;
		     1548 +       }
		     1549 +       test.assert(pass, `Component ${compName} didn't have expected value! Found ${v}, expected ${expectedValue}`);
		1397      -   world.events.beforeDataDrivenEntityTriggerEvent.unsubscribe(entityEventBeforeFilterTrigger);
		1398      -   world.events.dataDrivenEntityTriggerEvent.unsubscribe(globalTrigger);
		1399      -   world.events.dataDrivenEntityTriggerEvent.unsubscribe(entityEventFilterTrigger);
		1400      - 
		1401      -   let specificEntityBeforeTriggerSuccess = false;
		1402      - 
		1403      -   //Event bound to a specific entity
		1404      -   let specificEntityFilterOptions = new EntityDataDrivenTriggerEventOptions();
		1405      -   specificEntityFilterOptions.entities.push(llama);
		1406      -   specificEntityFilterOptions.eventTypes.push("minecraft:ageable_grow_up");
		1407 1550   
		     1551 +       if (canSet === undefined || canSet === true) {
		     1552 +         comp.value = v;
		1408      -   let specificEntityEventBeforeTrigger = world.events.beforeDataDrivenEntityTriggerEvent.subscribe((event) => {
		     1553 +       }
		     1554 +     }
		     1555 +   };
		1409      -     event.cancel = true;
		1410      -     specificEntityBeforeTriggerSuccess = true;
		1411      -   }, specificEntityFilterOptions);
		1412 1556   
		1413      -   //Event bound to both entities, but only fire on villager to show that multi-filters work
		1414      -   let allEntityFilterOptions = new EntityDataDrivenTriggerEventOptions();
		1415      -   allEntityFilterOptions.entities.push(llama);
		1416      -   allEntityFilterOptions.entities.push(villager);
		     1557 +   const zombie = test.spawn("minecraft:zombie<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		     1558 +   testComponent(zombie, "can_climb");
		1417      -   allEntityFilterOptions.entityTypes.push("minecraft:villager_v2");
		1418      -   allEntityFilterOptions.eventTypes.push("minecraft:ageable_grow_up");
		1419 1559   
		     1560 +   const bee = test.spawn("bee", new BlockLocation(1, 2, 1));
		     1561 +   testComponent(bee, "can_fly");
		     1562 +   testComponent(bee, "flying_speed", 0.15);
		     1563 +   testComponent(bee, "is_hidden_when_invisible");
		1420      -   let allEntitiesTriggerCount = 0;
		1421 1564   
		     1565 +   bee.triggerEvent("collected_nectar");
		1422      -   let allEntitiesEventBeforeTrigger = world.events.beforeDataDrivenEntityTriggerEvent.subscribe((event) => {
		1423      -     allEntitiesTriggerCount += 1;
		1424      -   }, allEntityFilterOptions);
		     1566 +   await test.idle(1);
		     1567 +   testComponent(bee, "is_charged");
		1425      -   llama.triggerEvent("minecraft:ageable_grow_up");
		1426      -   villager.triggerEvent("minecraft:ageable_grow_up");
		1427 1568   
		     1569 +   const magma_cube = test.spawn("magma_cube", new BlockLocation(1, 2, 1));
		     1570 +   testComponent(magma_cube, "fire_immune");
		1428      -   world.events.beforeDataDrivenEntityTriggerEvent.unsubscribe(specificEntityEventBeforeTrigger);
		1429      -   world.events.beforeDataDrivenEntityTriggerEvent.unsubscribe(allEntitiesEventBeforeTrigger);
		1430 1571   
		1431      -   if (!globalBeforeTriggerSuccess) test.fail("Global beforeDataDrivenEntityTriggerEvent didn't fire!");
		1432      -   if (!entityEventFilteredBeforeTriggerSuccess)
		1433      -     test.fail("Filtered entity/event beforeDataDrivenEntityTriggerEvent didn't fire!");
		     1572 +   const horse = test.spawn("horse", new BlockLocation(1, 2, 1));
		     1573 +   horse.triggerEvent("minecraft:horse_saddled");
		     1574 +   await test.idle(1);
		     1575 +   testComponent(horse, "is_saddled");
		     1576 +   testComponent(horse, "can_power_jump");
		1434      -   if (!globalTriggerSuccess) test.fail("Global dataDrivenEntityTriggerEvent didn't fire!");
		1435      -   if (!entityEventFilteredTriggerSuccess) test.fail("Filtered entity/event dataDrivenEntityTriggerEvent didn't fire!");
		1436      -   if (!specificEntityBeforeTriggerSuccess) test.fail("Specific entity beforeDataDrivenEntityTriggerEvent didn't fire!");
		1437      -   if (allEntitiesTriggerCount != 1)
		1438      -     test.fail("All filters beforeDataDrivenEntityTriggerEvent didn't fire exactly one time!");
		1439 1577   
		     1578 +   let forceSpawnBaby = world.events.beforeDataDrivenEntityTriggerEvent.subscribe((event) => {
		     1579 +     //Force the llama to spawn as a baby
		     1580 +     if (
		1440      -   await test.idle(10);
		     1581 +       event.modifiers.length > 0 &&
		     1582 +       event.modifiers[0].triggers.length > 0 &&
		     1583 +       event.modifiers[0].triggers[0].eventName == "minecraft:spawn_adult"
		     1584 +     ) {
		     1585 +       event.modifiers[0].triggers[0].eventName = "minecraft:spawn_baby";
		     1586 +     }
		     1587 +   });
		1441      -   if (llama.getComponent("minecraft:is_baby") == null)
		1442      -     test.fail("Llama was able to grow up! The beforeDataDrivenEntityTriggerEvent should prevent this!");
		1443      - 
		1444      -   test.succeed();
		1445      - })
		1446      -   .structureName("ComponentTests:animal_pen")
		1447      -   .tag(GameTest.Tags.suiteDefault);
		1448 1588   
		     1589 +   const llama = test.spawn("llama", new BlockLocation(1, 2, 1));
		1449      - GameTest.registerAsync("APITests", "property_components", async (test) => {
		1450      -   // The following components aren't present in this test since either there aren't mobs that use that component
		     1590 +   testComponent(llama, "is_baby");
		     1591 +   testComponent(llama, "scale", 0.5);
		1451      -   //  or it is difficult to get them into the correct state.
		1452      -   // skin_id, push_through, ground_offset, friction_modifier, floats_in_liquid, wants_jockey, is_shaking
		1453 1592   
		1454      -   let testComponent = (entity, compName, expectedValue, canSet) => {
		1455      -     let comp = entity.getComponent("minecraft:" + compName);
		1456      -     test.assert(comp != null, "Entity did not have expected component " + compName);
		     1593 +   world.events.beforeDataDrivenEntityTriggerEvent.unsubscribe(forceSpawnBaby);
		     1594 + 
		     1595 +   llama.triggerEvent("minecraft:ageable_grow_up");
		     1596 +   llama.triggerEvent("minecraft:on_tame");
		     1597 +   llama.triggerEvent("minecraft:on_chest");
		     1598 +   await test.idle(1);
		     1599 +   testComponent(llama, "is_tamed");
		     1600 +   testComponent(llama, "is_chested");
		     1601 +   testComponent(llama, "mark_variant", 0);
		1457      -     if (expectedValue !== undefined) {
		1458      -       let v = comp.value;
		1459      -       let pass = false;
		1460      -       if (typeof v === "number") {
		1461      -         pass = Math.abs(expectedValue - v) <= 0.001;
		1462      -       } else {
		1463      -         pass = v == expectedValue;
		1464      -       }
		1465      -       test.assert(pass, `Component ${compName} didn't have expected value! Found ${v}, expected ${expectedValue}`);
		1466 1602   
		     1603 +   const pillager = test.spawn("pillager", new BlockLocation(1, 2, 1));
		1467      -       if (canSet === undefined || canSet === true) {
		1468      -         comp.value = v;
		     1604 +   pillager.triggerEvent("minecraft:spawn_as_illager_captain");
		     1605 +   await test.idle(1);
		     1606 +   testComponent(pillager, "is_illager_captain");
		1469      -       }
		1470      -     }
		1471      -   };
		1472 1607   
		     1608 +   const ravager = test.spawn("ravager", new BlockLocation(1, 2, 1));
		     1609 +   ravager.triggerEvent("minecraft:become_stunned");
		     1610 +   await test.idle(1);
		1473      -   const zombie = test.spawn("minecraft:zombie<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		     1611 +   testComponent(ravager, "is_stunned");
		1474      -   testComponent(zombie, "can_climb");
		1475 1612   
		     1613 +   const sheep = test.spawn("sheep", new BlockLocation(1, 2, 1));
		     1614 +   sheep.triggerEvent("wololo");
		1476      -   const bee = test.spawn("bee", new BlockLocation(1, 2, 1));
		1477      -   testComponent(bee, "can_fly");
		     1615 +   sheep.triggerEvent("minecraft:on_sheared");
		     1616 +   await test.idle(1);
		1478      -   testComponent(bee, "flying_speed", 0.15);
		1479      -   testComponent(bee, "is_hidden_when_invisible");
		1480      - 
		     1617 +   testComponent(sheep, "is_sheared");
		1481      -   bee.triggerEvent("collected_nectar");
		1482 1618     await test.idle(1);
		1483      -   testComponent(bee, "is_charged");
		1484      - 
		1485      -   const magma_cube = test.spawn("magma_cube", new BlockLocation(1, 2, 1));
		     1619 +   testComponent(sheep, "color", 14);
		1486      -   testComponent(magma_cube, "fire_immune");
		1487 1620   
		     1621 +   const cat = test.spawn("cat", new BlockLocation(1, 2, 1));
		     1622 +   cat.triggerEvent("minecraft:spawn_midnight_cat");
		1488      -   const horse = test.spawn("horse", new BlockLocation(1, 2, 1));
		1489      -   horse.triggerEvent("minecraft:horse_saddled");
		1490 1623     await test.idle(1);
		     1624 +   testComponent(cat, "variant", 9, false);
		1491      -   testComponent(horse, "is_saddled");
		1492      -   testComponent(horse, "can_power_jump");
		1493 1625   
		1494      -   let forceSpawnBaby = world.events.beforeDataDrivenEntityTriggerEvent.subscribe((event) => {
		1495      -     //Force the llama to spawn as a baby
		1496      -     if (
		1497      -       event.modifiers.length > 0 &&
		     1626 +   const tnt = test.spawn("tnt_minecart", new BlockLocation(1, 2, 1));
		     1627 +   tnt.triggerEvent("minecraft:on_prime");
		     1628 +   await test.idle(1);
		     1629 +   testComponent(tnt, "is_ignited");
		     1630 +   testComponent(tnt, "is_stackable");
		     1631 +   tnt.kill();
		1498      -       event.modifiers[0].triggers.length > 0 &&
		1499      -       event.modifiers[0].triggers[0].eventName == "minecraft:spawn_adult"
		1500      -     ) {
		1501      -       event.modifiers[0].triggers[0].eventName = "minecraft:spawn_baby";
		1502      -     }
		1503      -   });
		1504 1632   
		     1633 +   test.succeed();
		     1634 + })
		1505      -   const llama = test.spawn("llama", new BlockLocation(1, 2, 1));
		     1635 +   .structureName("ComponentTests:large_glass_cage")
		     1636 +   .tag(GameTest.Tags.suiteDefault);
		1506      -   testComponent(llama, "is_baby");
		1507      -   testComponent(llama, "scale", 0.5);
		1508 1637   
		     1638 + GameTest.register("APITests", "entity_hit_event_hits_entity", async (test) => {
		     1639 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		     1640 +   const cow = test.spawn("minecraft:cow<minecraft:ageable_grow_up>", new BlockLocation(3, 2, 3));
		1509      -   world.events.beforeDataDrivenEntityTriggerEvent.unsubscribe(forceSpawnBaby);
		1510 1641   
		1511      -   llama.triggerEvent("minecraft:ageable_grow_up");
		1512      -   llama.triggerEvent("minecraft:on_tame");
		1513      -   llama.triggerEvent("minecraft:on_chest");
		     1642 +   let hitCallback = world.events.entityHit.subscribe((e) => {
		     1643 +     if (e.entity === player) {
		     1644 +       test.assert(e.hitEntity === cow, "Expected target to be cow, but got " + e.hitEntity);
		     1645 +       test.assert(e.hitBlock === undefined, "Expected no hit block, but got " + e.hitBlock?.id);
		1514      -   await test.idle(1);
		1515      -   testComponent(llama, "is_tamed");
		1516      -   testComponent(llama, "is_chested");
		1517      -   testComponent(llama, "mark_variant", 0);
		1518      - 
		     1646 +       world.events.entityHit.unsubscribe(hitCallback);
		     1647 +       test.succeed();
		     1648 +     }
		     1649 +   });
		     1650 +   await test.idle(5);
		     1651 +   player.attackEntity(cow);
		     1652 + })
		     1653 +   .structureName("ComponentTests:large_animal_pen")
		     1654 +   .tag(GameTest.Tags.suiteDefault);
		1519      -   const pillager = test.spawn("pillager", new BlockLocation(1, 2, 1));
		1520      -   pillager.triggerEvent("minecraft:spawn_as_illager_captain");
		1521      -   await test.idle(1);
		1522      -   testComponent(pillager, "is_illager_captain");
		1523      - 
		1524      -   const ravager = test.spawn("ravager", new BlockLocation(1, 2, 1));
		1525      -   ravager.triggerEvent("minecraft:become_stunned");
		1526      -   await test.idle(1);
		1527      -   testComponent(ravager, "is_stunned");
		1528 1655   
		1529      -   const sheep = test.spawn("sheep", new BlockLocation(1, 2, 1));
		1530      -   sheep.triggerEvent("wololo");
		1531      -   sheep.triggerEvent("minecraft:on_sheared");
		     1656 + GameTest.register("APITests", "entity_hit_event_hits_block", async (test) => {
		     1657 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		     1658 +   const blockLoc = new BlockLocation(1, 2, 1);
		     1659 +   test.setBlockType(MinecraftBlockTypes.diamondBlock, blockLoc);
		1532      -   await test.idle(1);
		1533      -   testComponent(sheep, "is_sheared");
		1534      -   await test.idle(1);
		1535      -   testComponent(sheep, "color", 14);
		1536 1660   
		     1661 +   let hitCallback = world.events.entityHit.subscribe((e) => {
		     1662 +     if (e.entity === player) {
		     1663 +       test.assert(e.hitEntity === undefined, "Expected no hit entity, but got " + e.target);
		1537      -   const cat = test.spawn("cat", new BlockLocation(1, 2, 1));
		     1664 +       test.assert(e.hitBlock?.id === "minecraft:diamond_block", "Expected no hit block, but got " + e.hitBlock?.id);
		     1665 +       world.events.entityHit.unsubscribe(hitCallback);
		     1666 +       test.succeed();
		     1667 +     }
		     1668 +   });
		     1669 +   await test.idle(5);
		     1670 +   player.breakBlock(blockLoc);
		     1671 + })
		     1672 +   .structureName("ComponentTests:platform")
		     1673 +   .tag(GameTest.Tags.suiteDefault);
		1538      -   cat.triggerEvent("minecraft:spawn_midnight_cat");
		1539      -   await test.idle(1);
		1540      -   testComponent(cat, "variant", 9, false);
		1541      - 
		1542      -   const tnt = test.spawn("tnt_minecart", new BlockLocation(1, 2, 1));
		1543      -   tnt.triggerEvent("minecraft:on_prime");
		1544      -   await test.idle(1);
		1545      -   testComponent(tnt, "is_ignited");
		1546      -   testComponent(tnt, "is_stackable");
		1547      -   tnt.kill();
		1548 1674   
		     1675 + GameTest.registerAsync("APITests", "entity_hurt_event_skeleton_hurts_player", async (test) => {
		     1676 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		1549      -   test.succeed();
		1550      - })
		     1677 +   const skeleton = test.spawn("skeleton", new BlockLocation(3, 2, 3));
		1551      -   .structureName("ComponentTests:large_glass_cage")
		1552      -   .tag(GameTest.Tags.suiteDefault);
		1553 1678   
		     1679 +   let hurtCallback = world.events.entityHurt.subscribe((e) => {
		     1680 +     if (e.hurtEntity === player) {
		1554      - GameTest.register("APITests", "entity_hit_event_hits_entity", async (test) => {
		     1681 +       test.assert(
		     1682 +         e.damagingEntity === skeleton,
		     1683 +         "Expected damagingEntity to be skeleton but got " + e.damagingEntity.id
		     1684 +       );
		     1685 +       test.assert(e.cause === EntityDamageCause.projectile, "Expected cause to be entity_attack but got " + e.cause);
		     1686 +       test.assert(e.projectile.id === "minecraft:arrow", "Expected projectile to be arrow but got " + e.cause);
		     1687 +       test.assert(e.damage > 0, "Expected damage to be greater than 0, but got " + e.damage);
		     1688 +       world.events.entityHurt.unsubscribe(hurtCallback);
		1555      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		1556      -   const cow = test.spawn("minecraft:cow<minecraft:ageable_grow_up>", new BlockLocation(3, 2, 3));
		1557      - 
		1558      -   let hitCallback = world.events.entityHit.subscribe((e) => {
		1559      -     if (e.entity === player) {
		1560      -       test.assert(e.hitEntity === cow, "Expected target to be cow, but got " + e.hitEntity);
		1561      -       test.assert(e.hitBlock === undefined, "Expected no hit block, but got " + e.hitBlock?.id);
		1562      -       world.events.entityHit.unsubscribe(hitCallback);
		1563 1689         test.succeed();
		1564 1690       }
		1565 1691     });
		1566      -   await test.idle(5);
		1567      -   player.attackEntity(cow);
		1568 1692   })
		     1693 +   .structureName("ComponentTests:large_glass_cage")
		1569      -   .structureName("ComponentTests:large_animal_pen")
		1570 1694     .tag(GameTest.Tags.suiteDefault);
		1571 1695   
		     1696 + GameTest.registerAsync("APITests", "entity_hurt_event_player_hurts_cow", async (test) => {
		1572      - GameTest.register("APITests", "entity_hit_event_hits_block", async (test) => {
		1573 1697     const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		     1698 +   const cow = test.spawn("minecraft:cow<minecraft:ageable_grow_up>", new BlockLocation(3, 2, 3));
		1574      -   const blockLoc = new BlockLocation(1, 2, 1);
		1575      -   test.setBlockType(MinecraftBlockTypes.diamondBlock, blockLoc);
		1576 1699   
		     1700 +   let hurtCallback = world.events.entityHurt.subscribe((e) => {
		     1701 +     if (e.hurtEntity === cow) {
		1577      -   let hitCallback = world.events.entityHit.subscribe((e) => {
		1578      -     if (e.entity === player) {
		     1702 +       test.assert(e.cause === EntityDamageCause.entityAttack, "Expected cause to be entity_attack but got " + e.cause);
		     1703 +       test.assert(e.damage === 1, "Expected damage to be 1, but got " + e.damage);
		     1704 +       world.events.entityHurt.unsubscribe(hurtCallback);
		1579      -       test.assert(e.hitEntity === undefined, "Expected no hit entity, but got " + e.target);
		1580      -       test.assert(e.hitBlock?.id === "minecraft:diamond_block", "Expected no hit block, but got " + e.hitBlock?.id);
		1581      -       world.events.entityHit.unsubscribe(hitCallback);
		1582 1705         test.succeed();
		1583 1706       }
		1584 1707     });
		1585 1708     await test.idle(5);
		     1709 +   player.attackEntity(cow);
		1586      -   player.breakBlock(blockLoc);
		1587 1710   })
		     1711 +   .structureName("ComponentTests:large_animal_pen")
		1588      -   .structureName("ComponentTests:platform")
		1589 1712     .tag(GameTest.Tags.suiteDefault);
		1590 1713   
		     1714 + GameTest.registerAsync("APITests", "projectile_hit_event_block", async (test) => {
		1591      - GameTest.registerAsync("APITests", "entity_hurt_event_skeleton_hurts_player", async (test) => {
		1592 1715     const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		     1716 +   const targetLoc = new BlockLocation(1, 3, 7);
		1593      -   const skeleton = test.spawn("skeleton", new BlockLocation(3, 2, 3));
		1594 1717   
		1595      -   let hurtCallback = world.events.entityHurt.subscribe((e) => {
		1596      -     if (e.hurtEntity === player) {
		1597      -       test.assert(
		1598      -         e.damagingEntity === skeleton,
		     1718 +   let projectileHitCallback = world.events.projectileHit.subscribe((e) => {
		     1719 +     if (e.blockHit && test.relativeBlockLocation(e.blockHit.block.location).equals(targetLoc)) {
		     1720 +       world.events.projectileHit.unsubscribe(projectileHitCallback);
		     1721 +       test.assert(e.dimension === test.getDimension(), "Unexpected dimension");
		     1722 +       test.assert(e.entityHit === undefined, "Expected no entity hit");
		     1723 +       test.assert(
		     1724 +         e.projectile?.id === "minecraft:arrow",
		     1725 +         "Expected projectile to be arrow, but got " + e.projectile?.id
		     1726 +       );
		     1727 +       test.assert(e.source?.id === "minecraft:player", "Expected source to be player, but got " + e.source?.id);
		     1728 +       test.assert(
		     1729 +         isNearVec(e.hitVector, test.rotateVector(Vector.forward), 0.1),
		     1730 +         `Expected e.hitVector to be forward, but got [${e.hitVector.x}, ${e.hitVector.y}, ${e.hitVector.z}]`
		     1731 +       );
		     1732 +       test.assert(
		     1733 +         e.blockHit.block?.id === "minecraft:target",
		     1734 +         "Expected block to be target, but got " + e.blockHit.block?.id
		     1735 +       );
		     1736 +       test.assert(e.blockHit.face == test.rotateDirection(Direction.north), "Expected north block face");
		     1737 +       test.assert(
		     1738 +         isNear(e.blockHit.faceLocationX, 0, 5, 0.1),
		     1739 +         "Expected faceLocationX to be near center, but got " + e.blockHit.faceLocationX
		     1740 +       );
		     1741 +       test.assert(
		     1742 +         isNear(e.blockHit.faceLocationY, 0.5, 0.1),
		     1743 +         "Expected faceLocationY to be near center, but got " + e.blockHit.faceLocationY
		     1744 +       );
		     1745 +       test.succeed();
		     1746 +     }
		     1747 +   });
		1599      -         "Expected damagingEntity to be skeleton but got " + e.damagingEntity.id
		1600      -       );
		1601      -       test.assert(e.cause === EntityDamageCause.projectile, "Expected cause to be entity_attack but got " + e.cause);
		1602      -       test.assert(e.projectile.id === "minecraft:arrow", "Expected projectile to be arrow but got " + e.cause);
		1603      -       test.assert(e.damage > 0, "Expected damage to be greater than 0, but got " + e.damage);
		1604      -       world.events.entityHurt.unsubscribe(hurtCallback);
		1605      -       test.succeed();
		1606      -     }
		1607      -   });
		1608      - })
		1609      -   .structureName("ComponentTests:large_glass_cage")
		1610      -   .tag(GameTest.Tags.suiteDefault);
		1611      - 
		1612      - GameTest.registerAsync("APITests", "entity_hurt_event_player_hurts_cow", async (test) => {
		1613      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		1614      -   const cow = test.spawn("minecraft:cow<minecraft:ageable_grow_up>", new BlockLocation(3, 2, 3));
		1615      - 
		1616      -   let hurtCallback = world.events.entityHurt.subscribe((e) => {
		1617      -     if (e.hurtEntity === cow) {
		1618      -       test.assert(e.cause === EntityDamageCause.entityAttack, "Expected cause to be entity_attack but got " + e.cause);
		1619      -       test.assert(e.damage === 1, "Expected damage to be 1, but got " + e.damage);
		1620      -       world.events.entityHurt.unsubscribe(hurtCallback);
		1621      -       test.succeed();
		1622      -     }
		1623      -   });
		1624      -   await test.idle(5);
		1625      -   player.attackEntity(cow);
		1626      - })
		1627      -   .structureName("ComponentTests:large_animal_pen")
		1628      -   .tag(GameTest.Tags.suiteDefault);
		1629 1748   
		     1749 +   await test.idle(5);
		     1750 +   player.giveItem(new ItemStack(MinecraftItemTypes.bow, 1), false);
		     1751 +   player.giveItem(new ItemStack(MinecraftItemTypes.arrow, 64), false);
		1630      - GameTest.registerAsync("APITests", "projectile_hit_event_block", async (test) => {
		     1752 +   await test.idle(5);
		     1753 +   player.useItemInSlot(0);
		     1754 +   await test.idle(50);
		     1755 +   player.stopUsingItem();
		     1756 + })
		     1757 +   .structureName("SimulatedPlayerTests:target_practice")
		     1758 +   .tag(GameTest.Tags.suiteDefault);
		     1759 + 
		     1760 + GameTest.registerAsync("APITests", "projectile_hit_event_entity", async (test) => {
		     1761 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		     1762 +   const blaze = test.spawn("blaze", new BlockLocation(1, 2, 3));
		     1763 + 
		     1764 +   let projectileHitCallback = world.events.projectileHit.subscribe((e) => {
		     1765 +     if (e.entityHit && e.entityHit.entity === blaze) {
		     1766 +       world.events.projectileHit.unsubscribe(projectileHitCallback);
		     1767 +       test.assert(e.blockHit === undefined, "Expected no block hit");
		     1768 +       test.assert(e.dimension === test.getDimension(), "Unexpected dimension");
		1631      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		1632      -   const targetLoc = new BlockLocation(1, 3, 7);
		1633      - 
		1634      -   let projectileHitCallback = world.events.projectileHit.subscribe((e) => {
		1635      -     if (e.blockHit && test.relativeBlockLocation(e.blockHit.block.location).equals(targetLoc)) {
		1636      -       world.events.projectileHit.unsubscribe(projectileHitCallback);
		1637      -       test.assert(e.dimension === test.getDimension(), "Unexpected dimension");
		1638      -       test.assert(e.entityHit === undefined, "Expected no entity hit");
		1639      -       test.assert(
		1640      -         e.projectile?.id === "minecraft:arrow",
		1641      -         "Expected projectile to be arrow, but got " + e.projectile?.id
		1642      -       );
		1643      -       test.assert(e.source?.id === "minecraft:player", "Expected source to be player, but got " + e.source?.id);
		1644      -       test.assert(
		1645      -         isNearVec(e.hitVector, test.rotateVector(Vector.forward), 0.1),
		1646      -         `Expected e.hitVector to be forward, but got [${e.hitVector.x}, ${e.hitVector.y}, ${e.hitVector.z}]`
		1647      -       );
		1648 1769         test.assert(
		     1770 +         e.projectile?.id === "minecraft:snowball",
		     1771 +         "Expected projectile to be snowball, but got " + e.projectile?.id
		1649      -         e.blockHit.block?.id === "minecraft:target",
		1650      -         "Expected block to be target, but got " + e.blockHit.block?.id
		1651 1772         );
		     1773 +       test.assert(e.source?.id === "minecraft:player", "Expected source to be player, but got " + e.source?.id);
		1652      -       test.assert(e.blockHit.face == test.rotateDirection(Direction.north), "Expected north block face");
		1653 1774         test.assert(
		     1775 +         isNearVec(e.hitVector, test.rotateVector(Vector.forward)),
		     1776 +         `Expected e.hitVector to be forward, but got [${e.hitVector.x}, ${e.hitVector.y}, ${e.hitVector.z}]`
		1654      -         isNear(e.blockHit.faceLocationX, 0, 5, 0.1),
		1655      -         "Expected faceLocationX to be near center, but got " + e.blockHit.faceLocationX
		1656 1777         );
		1657 1778         test.assert(
		     1779 +         e.entityHit.entity?.id === "minecraft:blaze",
		     1780 +         "Expected entity to be blaze, but got " + e.entityHit.entity?.id
		1658      -         isNear(e.blockHit.faceLocationY, 0.5, 0.1),
		1659      -         "Expected faceLocationY to be near center, but got " + e.blockHit.faceLocationY
		1660 1781         );
		1661 1782         test.succeed();
		1662 1783       }
		1663 1784     });
		1664 1785   
		1665      -   await test.idle(5);
		1666      -   player.giveItem(new ItemStack(MinecraftItemTypes.bow, 1), false);
		1667      -   player.giveItem(new ItemStack(MinecraftItemTypes.arrow, 64), false);
		1668 1786     await test.idle(5);
		     1787 +   player.useItem(new ItemStack(MinecraftItemTypes.snowball));
		1669      -   player.useItemInSlot(0);
		1670      -   await test.idle(50);
		1671      -   player.stopUsingItem();
		1672 1788   })
		     1789 +   .structureName("SimulatedPlayerTests:use_item")
		1673      -   .structureName("SimulatedPlayerTests:target_practice")
		1674 1790     .tag(GameTest.Tags.suiteDefault);
		1675 1791   
		     1792 + GameTest.registerAsync("APITests", "rotate_entity", async (test) => {
		     1793 +   const rotate360 = async (entity) => {
		1676      - GameTest.registerAsync("APITests", "projectile_hit_event_entity", async (test) => {
		     1794 +     for (let i = 0; i < 360; i += 10) {
		     1795 +       await test.idle(1);
		1677      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		1678      -   const blaze = test.spawn("blaze", new BlockLocation(1, 2, 3));
		1679      - 
		     1796 +       entity.setRotation(i, i);
		     1797 +       let rotX = entity.rotation.x;
		     1798 +       let rotY = entity.rotation.y;
		     1799 +       if (rotX < 0) {
		     1800 +         rotX += 360;
		     1801 +       }
		     1802 +       if (rotY < 0) {
		     1803 +         rotY += 360;
		     1804 +       }
		     1805 +       test.assert(rotX === i, `Expected rotX to be ${i} but got ${rotX}`);
		     1806 +       test.assert(rotY === i, `Expected rotY to be ${i} but got ${rotY}`);
		     1807 +     }
		     1808 +   };
		     1809 + 
		     1810 +   const spawnLoc = new BlockLocation(1, 2, 1);
		     1811 +   const cow = test.spawnWithoutBehaviors("minecraft:cow<minecraft:ageable_grow_up>", spawnLoc);
		     1812 +   await rotate360(cow);
		     1813 +   cow.kill();
		     1814 +   const armorStand = test.spawn("armor_stand", spawnLoc);
		     1815 +   await rotate360(armorStand);
		     1816 +   armorStand.kill();
		     1817 +   const player = test.spawnSimulatedPlayer(spawnLoc);
		     1818 +   await rotate360(player);
		     1819 +   test.succeed();
		1680      -   let projectileHitCallback = world.events.projectileHit.subscribe((e) => {
		1681      -     if (e.entityHit && e.entityHit.entity === blaze) {
		1682      -       world.events.projectileHit.unsubscribe(projectileHitCallback);
		1683      -       test.assert(e.blockHit === undefined, "Expected no block hit");
		1684      -       test.assert(e.dimension === test.getDimension(), "Unexpected dimension");
		1685      -       test.assert(
		1686      -         e.projectile?.id === "minecraft:snowball",
		1687      -         "Expected projectile to be snowball, but got " + e.projectile?.id
		1688      -       );
		1689      -       test.assert(e.source?.id === "minecraft:player", "Expected source to be player, but got " + e.source?.id);
		1690      -       test.assert(
		1691      -         isNearVec(e.hitVector, test.rotateVector(Vector.forward)),
		1692      -         `Expected e.hitVector to be forward, but got [${e.hitVector.x}, ${e.hitVector.y}, ${e.hitVector.z}]`
		1693      -       );
		1694      -       test.assert(
		1695      -         e.entityHit.entity?.id === "minecraft:blaze",
		1696      -         "Expected entity to be blaze, but got " + e.entityHit.entity?.id
		1697      -       );
		1698      -       test.succeed();
		1699      -     }
		1700      -   });
		1701      - 
		1702      -   await test.idle(5);
		1703      -   player.useItem(new ItemStack(MinecraftItemTypes.snowball));
		1704 1820   })
		     1821 +   .maxTicks(400)
		     1822 +   .structureName("ComponentTests:animal_pen")
		1705      -   .structureName("SimulatedPlayerTests:use_item")
		1706 1823     .tag(GameTest.Tags.suiteDefault);
		            '''
	Changed script "AllayTests.js":
		Total line: 23 (+2, -2)
		        '''
		        ...
		 6  6   GameTest.register("AllayTests", "allay_pickup_item", (test) => {
		 7  7       const startPosAllay = new BlockLocation(1, 2, 1);
		 8  8       const startPosPlayer = new BlockLocation(3, 2, 1);
		 9  9       const torchItem = new ItemStack(MinecraftItemTypes.torch, 1, 0);
		10 10       test.spawnItem(torchItem, new Location(4.5, 2.5, 4.5));
		   11 +     let playerSim = test.spawnSimulatedPlayer(startPosPlayer, "playerSim_allay");
		11    -     let playerSim = test.spawnSimulatedPlayer(startPosPlayer, "playerSim_frog");
		12 12       let allay = test.spawn("minecraft:allay", startPosAllay);
		13 13       const testEx = new GameTestExtensions(test);
		14 14   
		15 15       test
		16 16           .startSequence()
		        ...
		18 18           .thenExecute(() => test.assert(playerSim.interactWithEntity(allay) == true, ""))
		19 19           .thenWait(() => {
		20 20               test.assertEntityPresentInArea("minecraft:item", false); // Make sure the torch is picked up
		21 21           })
		22 22           .thenSucceed();
		   23 + }).maxTicks(TicksPerSecond * 10).tag(GameTest.Tags.suiteDefault);
		23    - }).maxTicks(TicksPerSecond * 10);
		        '''
	Changed script "FrogTests.js":
		Total line: 107 (+7, -7)
		          '''
		          ...
		 12  12           .startSequence()
		 13  13           .thenWait(() => {
		 14  14               test.assertEntityPresent(frogEntityType, endPos, true);
		 15  15           })
		 16  16           .thenSucceed();
		     17 + }).maxTicks(TicksPerSecond * 20).tag(GameTest.Tags.suiteDefault);
		 17     - }).maxTicks(TicksPerSecond * 20);
		 18  18   
		 19  19   GameTest.register("FrogTests", "frog_eat_slime_drop_slimeball", (test) => {
		 20  20       const frogEntityType = "minecraft:frog";
		 21  21       const startPos = new BlockLocation(1, 2, 1);
		 22  22       test.spawn(frogEntityType, startPos);
		          ...
		 29  29           .startSequence()
		 30  30           .thenWait(() => {
		 31  31               test.assertItemEntityPresent(MinecraftItemTypes.slimeBall, startPos, 10.0, true);
		 32  32           })
		 33  33           .thenSucceed();
		     34 + }).maxTicks(TicksPerSecond * 5).tag(GameTest.Tags.suiteDefault);
		 34     - }).maxTicks(TicksPerSecond * 5);
		 35  35   
		 36  36   GameTest.register("FrogTests", "temperate_frog_magmacube_drop_ochre", (test) => {
		 37  37       const frogEntityType = "minecraft:frog";
		 38  38       const startPos = new BlockLocation(1, 2, 1);
		 39  39       test.spawn(frogEntityType, startPos);
		          ...
		 46  46           .startSequence()
		 47  47           .thenWait(() => {
		 48  48               test.assertItemEntityPresent(MinecraftItemTypes.ochreFroglight, startPos, 10.0, true);
		 49  49           })
		 50  50           .thenSucceed();
		     51 + }).maxTicks(TicksPerSecond * 5).tag(GameTest.Tags.suiteDefault);
		 51     - }).maxTicks(TicksPerSecond * 5);
		 52  52   
		 53  53   GameTest.register("FrogTests", "warm_frog_magmacube_drop_pearlescent", (test) => {
		 54  54       const frogEntityType = "minecraft:frog<spawn_warm>";
		 55  55       const startPos = new BlockLocation(1, 2, 1);
		 56  56       test.spawn(frogEntityType, startPos);
		          ...
		 63  63           .startSequence()
		 64  64           .thenWait(() => {
		 65  65               test.assertItemEntityPresent(MinecraftItemTypes.pearlescentFroglight, startPos, 10.0, true);
		 66  66           })
		 67  67           .thenSucceed();
		     68 + }).maxTicks(TicksPerSecond * 5).tag(GameTest.Tags.suiteDefault);
		 68     - }).maxTicks(TicksPerSecond * 5);
		 69  69   
		 70  70   GameTest.register("FrogTests", "cold_frog_magmacube_drop_verdant", (test) => {
		 71  71       const frogEntityType = "minecraft:frog<spawn_cold>";
		 72  72       const startPos = new BlockLocation(1, 2, 1);
		 73  73       test.spawn(frogEntityType, startPos);
		          ...
		 80  80           .startSequence()
		 81  81           .thenWait(() => {
		 82  82               test.assertItemEntityPresent(MinecraftItemTypes.verdantFroglight, startPos, 10.0, true);
		 83  83           })
		 84  84           .thenSucceed();
		     85 + }).maxTicks(TicksPerSecond * 5).tag(GameTest.Tags.suiteDefault);
		 85     - }).maxTicks(TicksPerSecond * 5);
		 86  86   
		 87  87   GameTest.register("FrogTests", "frog_lay_egg", (test) => {
		 88  88       const startPosFrogOne = new BlockLocation(0, 4, 1);
		 89  89       const startPosFrogTwo = new BlockLocation(4, 4, 1);
		 90  90       const startPosPlayer = new BlockLocation(2, 4, 0);
		          ...
		 95  95       let frogTwo = test.spawn("minecraft:frog", startPosFrogTwo);
		 96  96       const testEx = new GameTestExtensions(test);
		 97  97   
		 98  98       test
		 99  99           .startSequence()
		    100 +         .thenExecute(() => testEx.giveItem(playerSim, MinecraftItemTypes.slimeBall, 2, 0))
		100     -         .thenExecute(() => testEx.giveItem(playerSim, MinecraftItemTypes.seagrass, 2, 0))
		101 101           .thenExecute(() => test.assert(playerSim.interactWithEntity(frogOne) == true, ""))
		102 102           .thenExecute(() => test.assert(playerSim.interactWithEntity(frogTwo) == true, ""))
		103 103           .thenWait(() => {
		104 104               test.assertBlockPresent(MinecraftBlockTypes.frogSpawn, spawnPos, true);
		105 105           })
		106 106           .thenSucceed();
		    107 + }).maxTicks(TicksPerSecond * 90).tag(GameTest.Tags.suiteDefault);
		107     - }).maxTicks(TicksPerSecond * 90);
		          '''
	Changed script "SculkTests.js":
		Total line: 681 (+27, -0)
		          '''
		          ...
		 36  36           test.assertBlockPresent(MinecraftBlockTypes.sculk, new BlockLocation(2, 4, 1));
		 37  37       });
		 38  38   })
		 39  39       .maxTicks(TicksPerSecond * 10)
		 40  40       .padding(TEST_PADDING)
		     41 +     .tag(GameTest.Tags.suiteDefault);
		 41  42   
		 42  43   GameTest.register("SculkTests", "spread_path", (test) => {
		 43  44       const spawnPos = new BlockLocation(0, 5, 1);
		 44  45       test.spawn("minecraft:guardian", spawnPos).kill();
		 45  46   
		          ...
		 49  50           test.assertBlockPresent(MinecraftBlockTypes.stone, new BlockLocation(4, 4, 1));
		 50  51       });
		 51  52   })
		 52  53       .maxTicks(TicksPerSecond * 10)
		 53  54       .padding(TEST_PADDING)
		     55 +     .tag(GameTest.Tags.suiteDefault);
		 54  56   
		 55  57   GameTest.register("SculkTests", "spread_path_restricted", (test) => {
		 56  58       const spawnPos = new BlockLocation(1, 5, 1);
		 57  59       test.spawn("minecraft:creeper", spawnPos).kill();
		 58  60   
		          ...
		 60  62           test.assertBlockPresent(MinecraftBlockTypes.sculk, new BlockLocation(3, 4, 3));
		 61  63       });
		 62  64   })
		 63  65       .maxTicks(TicksPerSecond * 10)
		 64  66       .padding(TEST_PADDING)
		     67 +     .tag(GameTest.Tags.suiteDefault);
		 65  68   
		 66  69   GameTest.register("SculkTests", "spread_uneven", (test) => {
		 67  70       const MIN_CONSUMED_BLOCKS_COUNT = 25;
		 68  71       const MAX_RESIDUAL_CHARGE = 5;
		 69  72       const INITIAL_CHARGE_SMALL = 5;
		          ...
		 95  98       });
		 96  99   })
		 97 100       .maxTicks(TicksPerSecond * 10)
		 98 101       .maxAttempts(5)
		 99 102       .padding(TEST_PADDING)
		    103 +     .tag(GameTest.Tags.suiteDefault);
		100 104   
		101 105   GameTest.register("SculkTests", "spread_uneven_overcharged", (test) => {
		102 106       const MIN_CONSUMED_BLOCKS_COUNT = 25;
		103 107       const MIN_RESIDUAL_CHARGE = 25;
		104 108       const INITIAL_CHARGE = 30;
		          ...
		129 133       });
		130 134   })
		131 135       .maxTicks(TicksPerSecond * 10)
		132 136       .maxAttempts(5)
		133 137       .padding(TEST_PADDING)
		    138 +     .tag(GameTest.Tags.suiteDefault);
		134 139   
		135 140   GameTest.register("SculkTests", "spread_stairway_up", (test) => {
		136 141       const CONSUMABLE_BLOCKS_COUNT = 15;
		137 142       const INITIAL_CHARGE = CONSUMABLE_BLOCKS_COUNT;
		138 143   
		          ...
		150 155           test.assertBlockPresent(MinecraftBlockTypes.sculk, new BlockLocation(0, 17, 0));
		151 156       });
		152 157   })
		153 158       .maxTicks(TicksPerSecond * 10)
		154 159       .padding(TEST_PADDING)
		    160 +     .tag(GameTest.Tags.suiteDefault);
		155 161   
		156 162   GameTest.register("SculkTests", "spread_stairway_up_unsupported", (test) => {
		157 163       const CONSUMABLE_BLOCKS_COUNT = 15;
		158 164       const INITIAL_CHARGE = CONSUMABLE_BLOCKS_COUNT;
		159 165   
		          ...
		171 177           test.assertBlockPresent(MinecraftBlockTypes.sculk, new BlockLocation(0, 17, 0));
		172 178       });
		173 179   })
		174 180       .maxTicks(TicksPerSecond * 10)
		175 181       .padding(TEST_PADDING)
		    182 +     .tag(GameTest.Tags.suiteDefault);
		176 183   
		177 184   GameTest.register("SculkTests", "spread_stairway_down", (test) => {
		178 185       const CONSUMABLE_BLOCKS_COUNT = 15;
		179 186       const INITIAL_CHARGE = CONSUMABLE_BLOCKS_COUNT;
		180 187   
		          ...
		192 199           test.assertBlockPresent(MinecraftBlockTypes.sculk, new BlockLocation(0, 3, 0));
		193 200       });
		194 201   })
		195 202       .maxTicks(TicksPerSecond * 10)
		196 203       .padding(TEST_PADDING)
		    204 +     .tag(GameTest.Tags.suiteDefault);
		197 205   
		198 206   GameTest.register("SculkTests", "spread_pillar_up", (test) => {
		199 207       const CONSUMABLE_BLOCKS_COUNT = 12;
		200 208       const INITIAL_CHARGE = CONSUMABLE_BLOCKS_COUNT - 1;
		201 209   
		          ...
		211 219           test.assertBlockPresent(MinecraftBlockTypes.dirt, new BlockLocation(2, 15, 2));
		212 220       });
		213 221   })
		214 222       .maxTicks(TicksPerSecond * 10)
		215 223       .padding(TEST_PADDING)
		    224 +     .tag(GameTest.Tags.suiteDefault);
		216 225   
		217 226   GameTest.register("SculkTests", "vein_consume_blocks", (test) => {
		218 227       const TEST_AREA_SIZE_X = 9;
		219 228       const TEST_AREA_SIZE_Z = 5;
		220 229       const CONSUME_ROW_DELAY = TEST_AREA_SIZE_X * 2;
		          ...
		240 249               }
		241 250           }
		242 251       }).thenSucceed();
		243 252   })
		244 253       .padding(TEST_PADDING)
		    254 +     .tag(GameTest.Tags.suiteDefault);
		245 255   
		246 256   GameTest.register("SculkTests", "vein_spread_blocks", (test) => {
		247 257       test.spawn("minecraft:creeper", new BlockLocation(2, 4, 2)).kill();
		248 258       test.spawn("minecraft:creeper", new BlockLocation(0, 4, 0)).kill();
		249 259       test.spawn("minecraft:creeper", new BlockLocation(0, 4, 4)).kill();
		          ...
		259 269           };
		260 270       });
		261 271   })
		262 272       .maxTicks(TicksPerSecond * 10)
		263 273       .padding(TEST_PADDING)
		    274 +     .tag(GameTest.Tags.suiteDefault);
		264 275   
		265 276   GameTest.register("SculkTests", "vein_non_spread_blocks", (test) => {
		266 277       test.spawn("minecraft:creeper", new BlockLocation(1, 4, 1)).kill();
		267 278       test.spawn("minecraft:creeper", new BlockLocation(1, 4, 3)).kill();
		268 279       test.spawn("minecraft:creeper", new BlockLocation(3, 4, 1)).kill();
		          ...
		281 292           };
		282 293           test.assert(sculkVeinCount == 4, "Only 4 veins where expected to be placed, one for each mob death position!");
		283 294       });
		284 295   })
		285 296       .padding(TEST_PADDING)
		    297 +     .tag(GameTest.Tags.suiteDefault);
		286 298   
		287 299   GameTest.register("SculkTests", "spread_under_water", (test) => {
		288 300       const INITIAL_CHARGE = 30;
		289 301   
		290 302       const sculkCatalystPos = new BlockLocation(2, 7, 2);
		          ...
		299 311           test.assertBlockPresent(MinecraftBlockTypes.sculk, new BlockLocation(2, 4, 2));
		300 312       })
		301 313   })
		302 314       .maxTicks(TicksPerSecond * 10)
		303 315       .padding(TEST_PADDING)
		    316 +     .tag(GameTest.Tags.suiteDefault);
		304 317   
		305 318   GameTest.register("SculkTests", "vein_non_place_blocks", (test) => {
		306 319       const sculkCatalystPos = new BlockLocation(2, 2, 2);
		307 320       test.assertBlockPresent(MinecraftBlockTypes.sculkCatalyst, sculkCatalystPos);
		308 321       const sculkSpreader = test.getSculkSpreader(sculkCatalystPos);
		          ...
		327 340           }
		328 341       }).thenSucceed();
		329 342   })
		330 343       .maxTicks(TicksPerSecond * 10)
		331 344       .padding(TEST_PADDING)
		    345 +     .tag(GameTest.Tags.suiteDefault);
		332 346   
		333 347   GameTest.register("SculkTests", "charge_cap", (test) => {
		334 348       const MERGEABLE_EXPERIENCE_AMOUNT = 25;
		335 349   
		336 350       const sculkCatalystPos = new BlockLocation(2, 2, 2);
		          ...
		358 372           test.assert(sculkSpreader.getNumberOfCursors() == 2, "Charges should not merge above maximum.");
		359 373       }).thenSucceed();
		360 374   
		361 375   })
		362 376       .padding(TEST_PADDING)
		    377 +     .tag(GameTest.Tags.suiteDefault);
		363 378   
		364 379   GameTest.register("SculkTests", "multiple_catalysts", (test) => {
		365 380       const catalystPositions = [
		366 381           new BlockLocation(0, 2, 0),
		367 382           new BlockLocation(4, 2, 0),
		          ...
		379 394           catalystPositions.forEach(position => numberOfCursors += test.getSculkSpreader(position).getNumberOfCursors());
		380 395           test.assert(numberOfCursors == 1, "Expected total number of cursors to be 1. Actual amount: " + numberOfCursors);
		381 396       }).thenSucceed();
		382 397   })
		383 398       .padding(TEST_PADDING)
		    399 +     .tag(GameTest.Tags.suiteDefault);
		384 400   
		385 401   GameTest.register("SculkTests", "charge_decay_sculk", (test) => {
		386 402       const INITIAL_CHARGE = 20;
		387 403       const FINAL_CHARGE = 19;
		388 404   
		          ...
		398 414       });
		399 415   })
		400 416       .maxAttempts(5)
		401 417       .maxTicks(TicksPerSecond * 20)
		402 418       .padding(TEST_PADDING)
		    419 +     .tag(GameTest.Tags.suiteDefault);
		403 420   
		404 421   GameTest.register("SculkTests", "charge_decay_sculk_vein", (test) => {
		405 422       const INITIAL_CHARGE = 20;
		406 423       const FINAL_CHARGE = 0;
		407 424   
		          ...
		418 435       });
		419 436   })
		420 437       .maxAttempts(5)
		421 438       .maxTicks(TicksPerSecond * 20)
		422 439       .padding(TEST_PADDING)
		    440 +     .tag(GameTest.Tags.suiteDefault);
		423 441   
		424 442   GameTest.register("SculkTests", "sculk_growth_spawning", (test) => {
		425 443       const INITIAL_CHARGE = 100;
		426 444   
		427 445       const sculkCatalystPos = new BlockLocation(4, 4, 2);
		          ...
		466 484       });
		467 485   })
		468 486       .maxTicks(TicksPerSecond * 40)
		469 487       .maxAttempts(5)
		470 488       .padding(TEST_PADDING)
		    489 +     .tag(GameTest.Tags.suiteDefault);
		471 490   
		472 491   GameTest.register("SculkTests", "charge_forced_direction", (test) => {
		473 492       const INITIAL_CHARGE = 25;
		474 493   
		475 494       const sculkCatalystPos = new BlockLocation(2, 2, 2);
		          ...
		492 511           test.assert(expected[1].equals(actual[1]),
		493 512               "Expected charge ends up on on (" + expected[1].x + ", " + expected[1].y + ", " + expected[1].z + "), not (" + actual[1].x + ", " + actual[1].y + ", " + actual[1].z + ").");
		494 513       }).thenSucceed();
		495 514   })
		496 515       .padding(TEST_PADDING)
		    516 +     .tag(GameTest.Tags.suiteDefault);
		497 517   
		498 518   GameTest.register("SculkTests", "charge_redirection", (test) => {
		499 519       const INITIAL_CHARGE = 100;
		500 520   
		501 521       const sculkCatalystPos = new BlockLocation(5, 2, 2);
		          ...
		518 538           test.assert(expectedPos.equals(existingPos),
		519 539               "Expected charge on (" + expectedPos.x + ", " + expectedPos.y + ", " + expectedPos.z + "), not (" + existingPos.x + ", " + existingPos.y + ", " + existingPos.z + ").");
		520 540       }).thenSucceed();
		521 541   })
		522 542       .padding(TEST_PADDING)
		    543 +     .tag(GameTest.Tags.suiteDefault);
		523 544   
		524 545   GameTest.register("SculkTests", "charge_merging", (test) => {
		525 546       const INITIAL_CHARGE = 5;
		526 547       const MIN_RESIDUAL_CHARGE = 12;
		527 548   
		          ...
		541 562           test.assert(totalCharge >= MIN_RESIDUAL_CHARGE, "Total charge of + " + INITIAL_CHARGE * 4 + " + should be roughly preserved, current charge: " + totalCharge);
		542 563       });
		543 564   })
		544 565       .maxTicks(TicksPerSecond * 5)
		545 566       .padding(TEST_PADDING)
		    567 +     .tag(GameTest.Tags.suiteDefault);
		546 568   
		547 569   GameTest.register("SculkTests", "charge_in_air_disappear", (test) => {
		548 570       const INITIAL_CHARGE = 20;
		549 571   
		550 572       const sculkCatalystPos = new BlockLocation(2, 2, 2);
		          ...
		562 584           const numberOfCursors = sculkSpreader.getNumberOfCursors();
		563 585           test.assert(numberOfCursors == 0, "The cursor did not disappear in 3 ticks despite having no substrate.");
		564 586       }).thenSucceed();
		565 587   })
		566 588       .padding(TEST_PADDING)
		    589 +     .tag(GameTest.Tags.suiteDefault);
		567 590   
		568 591   GameTest.register("SculkTests", "charge_in_air_jump", (test) => {
		569 592       const INITIAL_CHARGE = 20;
		570 593   
		571 594       const sculkCatalystPos = new BlockLocation(2, 2, 2);
		          ...
		587 610           test.assert(expectedPos.equals(currentPos),
		588 611               "Expected charge on (" + expectedPos.x + ", " + expectedPos.y + ", " + expectedPos.z + "), not (" + currentPos.x + ", " + currentPos.y + ", " + currentPos.z + ")");
		589 612       }).thenSucceed();
		590 613   })
		591 614       .padding(TEST_PADDING)
		    615 +     .tag(GameTest.Tags.suiteDefault);
		592 616   
		593 617   GameTest.register("SculkTests", "spread_from_moving_blocks", (test) => {
		594 618       test.setBlockType(MinecraftBlockTypes.redstoneBlock, new BlockLocation(8, 9, 2));
		595 619   
		596 620       test.startSequence().thenExecuteAfter(TicksPerSecond * 10, () => {
		          ...
		603 627           }
		604 628       }).thenSucceed();
		605 629   })
		606 630       .maxTicks(TicksPerSecond * 15)
		607 631       .padding(TEST_PADDING)
		    632 +     .tag(GameTest.Tags.suiteDefault);
		608 633   
		609 634   GameTest.register("SculkTests", "spread_to_moving_blocks", (test) => {
		610 635       test.setBlockType(MinecraftBlockTypes.redstoneBlock, new BlockLocation(8, 9, 2));
		611 636   
		612 637       test.startSequence().thenExecuteAfter(TicksPerSecond * 10, () => {
		          ...
		625 650           test.assert(sculkCount >= 5, "Sculk is expected to spread on slow enough moving blocks!");
		626 651       }).thenSucceed();
		627 652   })
		628 653       .maxTicks(TicksPerSecond * 15)
		629 654       .padding(TEST_PADDING)
		    655 +     .tag(GameTest.Tags.suiteDefault);
		630 656   
		631 657   GameTest.register("SculkTests", "spread_on_player_death", (test) => {
		632 658       const DIE_BY_FALL_DAMAGE_HEIGHT = 25;
		633 659       const DIE_BY_FALL_DAMAGE_TIME = TicksPerSecond * 2;
		634 660   
		          ...
		650 676       }).thenExecuteAfter(DIE_BY_FALL_DAMAGE_TIME, () => {
		651 677           test.assertBlockPresent(MinecraftBlockTypes.sculk, grassWithTallGrassPos);
		652 678       }).thenSucceed();
		653 679   })
		654 680       .padding(TEST_PADDING)
		    681 +     .tag(GameTest.Tags.suiteDefault);
		          '''
	Changed script "SimulatedPlayerTests.js":
		Total line: 1154 (+21, -21)
		            '''
		            ...
		 779  779     const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		 780  780   
		 781  781     test
		 782  782       .startSequence()
		 783  783       .thenExecuteAfter(5, () => {
		      784 +       test.assert(player.rotation.y === 0, "Expected body rotation of 0 degrees (1)");
		 784      -       test.assert(player.bodyRotation === 0, "Expected body rotation of 0 degrees (1)");
		 785  785       })
		 786  786       .thenExecuteAfter(5, () => {
		 787  787         player.setBodyRotation(90);
		      788 +       test.assert(player.rotation.y === 90, "Expected body rotation of 90 degrees (2)");
		 788      -       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees (2)");
		 789  789       })
		 790  790       .thenExecuteAfter(5, () => {
		 791  791         player.setBodyRotation(-90);
		      792 +       test.assert(player.rotation.y === -90, "Expected body rotation of -90 degrees (3)");
		 792      -       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees (3)");
		 793  793       })
		 794  794       .thenExecuteAfter(5, () => {
		 795  795         player.setBodyRotation(180);
		      796 +       test.assert(player.rotation.y === -180, "Expected body rotation of -180 degrees (4)");
		 796      -       test.assert(player.bodyRotation === -180, "Expected body rotation of -180 degrees (4)");
		 797  797       })
		 798  798       .thenExecuteAfter(5, () => {
		 799  799         player.rotateBody(180);
		      800 +       test.assert(player.rotation.y === 0, "Expected body rotation of 0 degrees (5)");
		 800      -       test.assert(player.bodyRotation === 0, "Expected body rotation of 0 degrees (5)");
		 801  801       })
		 802  802       .thenExecuteAfter(5, () => {
		 803  803         player.rotateBody(90);
		      804 +       test.assert(player.rotation.y === 90, "Expected body rotation of 90 degrees (6)");
		 804      -       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees (6)");
		 805  805       })
		 806  806       .thenExecuteAfter(5, () => {
		 807  807         player.rotateBody(-180);
		      808 +       test.assert(player.rotation.y === -90, "Expected body rotation of -90 degrees (7)");
		 808      -       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees (7)");
		 809  809       })
		 810  810       .thenSucceed();
		 811  811   })
		 812  812     .structureName("ComponentTests:platform")
		 813  813     .tag(GameTest.Tags.suiteDefault);
		            ...
		 819  819   
		 820  820     test
		 821  821       .startSequence()
		 822  822       .thenExecuteAfter(5, () => {
		 823  823         player.lookAtEntity(leftArmorStand);
		      824 +       test.assert(player.rotation.y === -90, "Expected body rotation of -90 degrees");
		 824      -       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees");
		 825  825       })
		 826  826       .thenExecuteAfter(5, () => {
		 827  827         player.lookAtEntity(rightArmorStand);
		      828 +       test.assert(player.rotation.y === 90, "Expected body rotation of 90 degrees");
		 828      -       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees");
		 829  829       })
		 830  830       .thenSucceed();
		 831  831   })
		 832  832     .structureName("ComponentTests:platform")
		 833  833     .tag(GameTest.Tags.suiteDefault);
		            ...
		 838  838     const rightBlockLoc = new BlockLocation(0, 2, 1);
		 839  839   
		 840  840     test
		 841  841       .startSequence()
		 842  842       .thenExecuteAfter(10, () => {
		      843 +       test.assert(player.rotation.y === 0, "Expected body rotation of 0 degrees");
		      844 +       test.assert(player.headRotation.x === 0, "Expected head pitch of 0 degrees");
		 843      -       test.assert(player.bodyRotation === 0, "Expected body rotation of 0 degrees");
		 844      -       test.assert(player.headRotation.pitch === 0, "Expected head pitch of 0 degrees");
		      845 +       test.assert(player.headRotation.y === 0, "Expected head yaw of 0 degrees");
		 845      -       test.assert(player.headRotation.yaw === 0, "Expected head yaw of 0 degrees");
		 846  846         player.lookAtBlock(leftBlockLoc);
		 847  847       })
		 848  848       .thenExecuteAfter(20, () => {
		      849 +       test.assert(player.rotation.y === -90, "Expected body rotation of -90 degrees");
		      850 +       test.assert(isNear(player.headRotation.x, 48.24), "Expected head pitch of ~48.24 degrees");
		 849      -       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees");
		 850      -       test.assert(isNear(player.headRotation.pitch, 48.24), "Expected head pitch of ~48.24 degrees");
		      851 +       test.assert(player.headRotation.y === -90, "Expected head yaw of -90 degrees");
		 851      -       test.assert(player.headRotation.yaw === -90, "Expected head yaw of -90 degrees");
		 852  852       })
		 853  853       .thenExecuteAfter(10, () => {
		 854  854         player.lookAtBlock(rightBlockLoc);
		 855  855       })
		 856  856       .thenExecuteAfter(20, () => {
		      857 +       test.assert(player.rotation.y === 90, "Expected body rotation of 90 degrees");
		      858 +       test.assert(isNear(player.headRotation.x, 48.24), "Expected head pitch of ~48.24 degrees");
		 857      -       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees");
		 858      -       test.assert(isNear(player.headRotation.pitch, 48.24), "Expected head pitch of ~48.24 degrees");
		      859 +       test.assert(player.headRotation.y === 90, "Expected head yaw of 90 degrees");
		 859      -       test.assert(player.headRotation.yaw === 90, "Expected head yaw of 90 degrees");
		 860  860       })
		 861  861       .thenSucceed();
		 862  862   })
		 863  863     .structureName("ComponentTests:platform")
		 864  864     .tag(GameTest.Tags.suiteDefault);
		            ...
		 869  869     const rightLoc = new Location(0.5, 2, 1.5);
		 870  870   
		 871  871     test
		 872  872       .startSequence()
		 873  873       .thenExecuteAfter(10, () => {
		      874 +       test.assert(player.rotation.y === 0, "Expected body rotation of 0 degrees");
		      875 +       test.assert(player.headRotation.x === 0, "Expected head pitch of 0 degrees");
		 874      -       test.assert(player.bodyRotation === 0, "Expected body rotation of 0 degrees");
		 875      -       test.assert(player.headRotation.pitch === 0, "Expected head pitch of 0 degrees");
		      876 +       test.assert(player.headRotation.y === 0, "Expected head yaw of 0 degrees");
		 876      -       test.assert(player.headRotation.yaw === 0, "Expected head yaw of 0 degrees");
		 877  877         player.lookAtLocation(leftLoc);
		 878  878       })
		 879  879       .thenExecuteAfter(20, () => {
		      880 +       test.assert(player.rotation.y === -90, "Expected body rotation of -90 degrees");
		      881 +       test.assert(isNear(player.headRotation.x, 58.31), "Expected head pitch of ~58.31 degrees");
		 880      -       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees");
		 881      -       test.assert(isNear(player.headRotation.pitch, 58.31), "Expected head pitch of ~58.31 degrees");
		      882 +       test.assert(player.headRotation.y === -90, "Expected head yaw of -90 degrees");
		 882      -       test.assert(player.headRotation.yaw === -90, "Expected head yaw of -90 degrees");
		 883  883       })
		 884  884       .thenExecuteAfter(10, () => {
		 885  885         player.lookAtLocation(rightLoc);
		 886  886       })
		 887  887       .thenExecuteAfter(20, () => {
		      888 +       test.assert(player.rotation.y === 90, "Expected body rotation of 90 degrees");
		      889 +       test.assert(isNear(player.headRotation.x, 58.31), "Expected head pitch of ~58.31 degrees");
		 888      -       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees");
		 889      -       test.assert(isNear(player.headRotation.pitch, 58.31), "Expected head pitch of ~58.31 degrees");
		      890 +       test.assert(player.headRotation.y === 90, "Expected head yaw of 90 degrees");
		 890      -       test.assert(player.headRotation.yaw === 90, "Expected head yaw of 90 degrees");
		 891  891       })
		 892  892       .thenSucceed();
		 893  893   })
		 894  894     .structureName("ComponentTests:platform")
		 895  895     .tag(GameTest.Tags.suiteDefault);
		            ...
		            '''
	Changed script "VibrationTests.js":
		Total line: 703 (+216, -83)
		          '''
		          ...
		 35  35           }
		 36  36       });
		 37  37   
		 38  38       failOnVibrationDetected(test, sensorPos, SENSOR_MAX_DELAY_TICKS);
		 39  39   })
		     40 +     .tag(GameTest.Tags.suiteDefault);
		     41 + 
		     42 + function destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, destroyPos, expectedLitPos) {
		     43 +     sequence.thenExecute(() => {
		     44 +         test.destroyBlock(destroyPos);
		     45 +     }).thenExecuteAfter(SENSOR_MAX_DELAY_TICKS + REDSTONE_DELAY_TICKS, () => {
		     46 +         const testEx = new GameTestExtensions(test);
		     47 +         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		     48 +         test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, expectedLitPos);
		     49 +     }).thenIdle(SENSOR_ACTIVE_TICKS + SENSOR_COOLDOWN_TICKS);
		     50 + }
		     51 + 
		     52 + function spawnCreeperAndTestComparatorOutput(test, sequence, sensorPos, spawnPos, expectedLitPos) {
		     53 +     sequence.thenExecute(() => {
		     54 +         test.spawnWithoutBehaviorsAtLocation("minecraft:creeper", spawnPos);
		     55 +     }).thenExecuteAfter(SENSOR_MAX_DELAY_TICKS + REDSTONE_DELAY_TICKS, () => {
		     56 +         const testEx = new GameTestExtensions(test);
		     57 +         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		     58 +         test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, expectedLitPos);
		     59 +     }).thenIdle(SENSOR_ACTIVE_TICKS + SENSOR_COOLDOWN_TICKS);
		     60 + }
		     61 + 
		     62 + // Tests that the output strenght of a Sculk Sensor (verified by checking Redstone Lamps being powered) is correct for a vibration
		     63 + // emitted at a certain distance (produced by destroying a block).
		     64 + GameTest.register("VibrationTests", "output_distance", (test) => {
		     65 +     const sensorPos = new BlockLocation(16, 2, 9);
		     66 + 
		     67 +     let sequence = test.startSequence();
		     68 + 
		     69 +     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -8), sensorPos.offset(-1, -1, 1));
		     70 +     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -7), sensorPos.offset(-2, -1, 1));
		     71 +     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -6), sensorPos.offset(-4, -1, 1));
		     72 +     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -5), sensorPos.offset(-6, -1, 1));
		     73 +     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -4), sensorPos.offset(-8, -1, 1));
		     74 +     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -3), sensorPos.offset(-10, -1, 1));
		     75 +     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -2), sensorPos.offset(-12, -1, 1));
		     76 +     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -1), sensorPos.offset(-14, -1, 1));
		     77 +     spawnCreeperAndTestComparatorOutput(test, sequence, sensorPos, new Location(16.5, 3, 9.5), sensorPos.offset(-15, -1, 1));
		     78 + 
		     79 +     sequence.thenSucceed();
		     80 + })
		     81 +     .maxTicks(TicksPerSecond * 60)
		     82 +     .tag(GameTest.Tags.suiteDefault);
		     83 + 
		     84 + // Tests that a Sculk Sensor reacts to an in-range vibration and ignores closer ones emitted after it.
		     85 + GameTest.register("VibrationTests", "activation_multiple_vibrations", (test) => {
		     86 +     const sensorPos = new BlockLocation(9, 2, 9);
		     87 + 
		     88 +     const testEx = new GameTestExtensions(test);
		     89 + 
		     90 +     const destroyPosFar = new BlockLocation(9, 2, 1);
		     91 +     const destroyPosClose = new BlockLocation(9, 2, 10);
		     92 + 
		     93 +     test.startSequence().thenExecute(() => {
		     94 +         // Executed at tick 0.
		     95 +         test.destroyBlock(destroyPosFar);
		     96 +         test.destroyBlock(destroyPosClose);
		     97 +     }).thenExecuteAfter(1, () => {
		     98 +         // Executed at tick 1. Sensor shouldn't have been activated by second vibration.
		     99 +         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		    100 +     }).thenExecuteAfter(6, () => {
		    101 +         // Executed at tick 7. Sensor shouldn't have been activated yet by first vibration.
		    102 +         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		    103 +     }).thenExecuteAfter(3, () => {
		    104 +         // Executed at tick 8. Sensor should have been activated by first vibration already.
		    105 +         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		    106 +     }).thenSucceed();
		    107 + })
		    108 +     .tag(GameTest.Tags.suiteDefault);
		    109 + 
		    110 + function destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, destroyPos, delay) {
		    111 +     sequence.thenExecute(() => {
		    112 +         test.destroyBlock(destroyPos);
		    113 +     }).thenExecuteAfter(delay, () => {
		    114 +         const testEx = new GameTestExtensions(test);
		    115 +         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		    116 +     }).thenIdle(SENSOR_ACTIVE_TICKS + SENSOR_COOLDOWN_TICKS);
		    117 + }
		    118 + 
		    119 + // Tests that a Sculk Sensor activates with a delay in ticks equal to the distance a vibration has been emitted at.
		    120 + GameTest.register("VibrationTests", "activation_delay", (test) => {
		    121 +     const sensorPos = new BlockLocation(9, 2, 9);
		    122 + 
		    123 +     let sequence = test.startSequence();
		    124 + 
		    125 +     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -8), 8);
		    126 +     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -7), 7);
		    127 +     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -6), 6);
		    128 +     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -5), 5);
		    129 +     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -4), 4);
		    130 +     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -3), 3);
		    131 +     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -2), 2);
		    132 +     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -1), 1);
		    133 + 
		    134 +     sequence.thenSucceed();
		    135 + })
		    136 +     .maxTicks(TicksPerSecond * 60)
		    137 +     .tag(GameTest.Tags.suiteDefault);
		    138 + 
		    139 + // Tests that a Sculk Sensor activates and stays active for the expected amount of time when receiving a vibration.
		    140 + GameTest.register("VibrationTests", "activation_duration", (test) => {
		    141 +     const sensorPos = new BlockLocation(9, 2, 9);
		    142 + 
		    143 +     const testEx = new GameTestExtensions(test);
		    144 + 
		    145 +     const destroyPos = new BlockLocation(8, 2, 9);
		    146 + 
		    147 +     test.startSequence().thenExecute(() => {
		    148 +         test.destroyBlock(destroyPos);
		    149 +     }).thenWaitAfter(1, () => {
		    150 +         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		    151 +     }).thenWaitAfter(SENSOR_ACTIVE_TICKS, () => {
		    152 +         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		    153 +     }).thenSucceed();
		    154 + })
		    155 +     .tag(GameTest.Tags.suiteDefault);
		 40 156   
		    157 + // Tests that a Sculk Sensor ignores vibrations while on cooldown.
		 41     - function destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, destroyPos, expectedLitPos) {
		 42     -     sequence.thenExecute(() => {
		    158 + GameTest.register("VibrationTests", "activation_cooldown", (test) => {
		    159 +     const sensorPos = new BlockLocation(9, 2, 9);
		    160 + 
		    161 +     const testEx = new GameTestExtensions(test);
		    162 + 
		    163 +     const destroyPos1 = new BlockLocation(8, 2, 9);
		    164 +     const destroyPos2 = new BlockLocation(10, 2, 9);
		 43     -         test.destroyBlock(destroyPos);
		 44     -     }).thenExecuteAfter(SENSOR_MAX_DELAY_TICKS + REDSTONE_DELAY_TICKS, () => {
		 45     -         const testEx = new GameTestExtensions(test);
		 46     -         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		 47     -         test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, expectedLitPos);
		 48     -     }).thenIdle(SENSOR_ACTIVE_TICKS + SENSOR_COOLDOWN_TICKS);
		 49     - }
		 50 165   
		    166 +     test.startSequence().thenExecute(() => {
		 51     - function spawnCreeperAndTestComparatorOutput(test, sequence, sensorPos, spawnPos, expectedLitPos) {
		 52     -     sequence.thenExecute(() => {
		 53     -         test.spawnWithoutBehaviorsAtLocation("minecraft:creeper", spawnPos);
		    167 +         test.destroyBlock(destroyPos1);
		    168 +     }).thenWaitAfter(1, () => {
		 54     -     }).thenExecuteAfter(SENSOR_MAX_DELAY_TICKS + REDSTONE_DELAY_TICKS, () => {
		 55     -         const testEx = new GameTestExtensions(test);
		 56 169           testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		    170 +     }).thenWaitAfter(SENSOR_ACTIVE_TICKS, () => {
		 57     -         test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, expectedLitPos);
		 58     -     }).thenIdle(SENSOR_ACTIVE_TICKS + SENSOR_COOLDOWN_TICKS);
		    171 +         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		    172 +     }).thenExecute(() => {
		    173 +         test.destroyBlock(destroyPos2);
		    174 +     }).thenWaitAfter(SENSOR_COOLDOWN_TICKS, () => {
		    175 +         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		    176 +     }).thenSucceed();
		    177 + })
		    178 +     .tag(GameTest.Tags.suiteDefault);
		 59     - }
		 60     - 
		 61     - // Tests that the output strenght of a Sculk Sensor (verified by checking Redstone Lamps being powered) is correct for a vibration
		 62     - // emitted at a certain distance (produced by destroying a block).
		 63     - GameTest.register("VibrationTests", "output_distance", (test) => {
		 64     -     const sensorPos = new BlockLocation(16, 2, 9);
		 65     - 
		 66     -     let sequence = test.startSequence();
		 67 179   
		 68     -     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -8), sensorPos.offset(-1, -1, 1));
		 69     -     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -7), sensorPos.offset(-2, -1, 1));
		 70     -     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -6), sensorPos.offset(-4, -1, 1));
		 71     -     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -5), sensorPos.offset(-6, -1, 1));
		    180 + // Tests that a Sculk Sensor can react to vibrations (emitted by destroying a block) only if they are not occluded by Wool.
		    181 + GameTest.register("VibrationTests", "activation_wool_occlusion", (test) => {
		    182 +     const sensorPos = new BlockLocation(9, 2, 9);
		    183 + 
		    184 +     const testEx = new GameTestExtensions(test);
		 72     -     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -4), sensorPos.offset(-8, -1, 1));
		 73     -     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -3), sensorPos.offset(-10, -1, 1));
		 74     -     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -2), sensorPos.offset(-12, -1, 1));
		 75     -     destroyBlockAndTestComparatorOutput(test, sequence, sensorPos, sensorPos.offset(0, 0, -1), sensorPos.offset(-14, -1, 1));
		 76     -     spawnCreeperAndTestComparatorOutput(test, sequence, sensorPos, new Location(16.5, 3, 9.5), sensorPos.offset(-15, -1, 1));
		 77 185   
		    186 +     const occuledDestroyPos1 = new BlockLocation(5, 2, 9);
		    187 +     const occuledDestroyPos2 = new BlockLocation(9, 2, 13);
		    188 +     const occuledDestroyPos3 = new BlockLocation(13, 2, 9);
		 78     -     sequence.thenSucceed();
		    189 +     const unocculedDestroyPos1 = new BlockLocation(9, 2, 5);
		    190 +     const unocculedDestroyPos2 = new BlockLocation(9, 6, 9);
		 79     - })
		 80     -     .maxTicks(TicksPerSecond * 60)
		 81 191   
		    192 +     test.startSequence().thenExecute(() => {
		    193 +         test.destroyBlock(occuledDestroyPos1);
		    194 +         test.destroyBlock(occuledDestroyPos2);
		 82     - // Tests that a Sculk Sensor reacts to an in-range vibration and ignores closer ones emitted after it.
		    195 +         test.destroyBlock(occuledDestroyPos3);
		    196 +     }).thenExecuteAfter(SENSOR_MAX_DELAY_TICKS, () => {
		    197 +         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		    198 +     }).thenExecute(() => {
		    199 +         test.destroyBlock(unocculedDestroyPos1);
		    200 +     }).thenWait(() => {
		    201 +         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		    202 +     }).thenExecuteAfter(SENSOR_ACTIVE_TICKS + SENSOR_COOLDOWN_TICKS, () => {
		    203 +         test.destroyBlock(unocculedDestroyPos2);
		    204 +     }).thenWait(() => {
		    205 +         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		    206 +     }).thenSucceed();
		    207 + })
		    208 +     .tag(GameTest.Tags.suiteDefault);
		    209 + 
		    210 + // Tests that a Sculk Sensor cannot react to vibrations (emitted by destroying a block) occluded by Wool, no matter the relative position of the occluded source.
		    211 + GameTest.register("VibrationTests", "activation_wool_occlusion_no_bias", (test) => {
		    212 +     const sensorPos = new BlockLocation(9, 2, 9);
		    213 + 
		    214 +     const occuledDestroyPos1 = new BlockLocation(6, 2, 6);
		    215 +     const occuledDestroyPos2 = new BlockLocation(6, 2, 12);
		    216 +     const occuledDestroyPos3 = new BlockLocation(12, 2, 6);
		    217 +     const occuledDestroyPos4 = new BlockLocation(12, 2, 12);
		 83     - GameTest.register("VibrationTests", "activation_multiple_vibrations", (test) => {
		 84     -     const sensorPos = new BlockLocation(9, 2, 9);
		 85     - 
		 86     -     const testEx = new GameTestExtensions(test);
		 87     - 
		 88     -     const destroyPosFar = new BlockLocation(9, 2, 1);
		 89     -     const destroyPosClose = new BlockLocation(9, 2, 10);
		 90     - 
		 91     -     test.startSequence().thenExecute(() => {
		 92     -         // Executed at tick 0.
		 93     -         test.destroyBlock(destroyPosFar);
		 94     -         test.destroyBlock(destroyPosClose);
		 95     -     }).thenExecuteAfter(1, () => {
		 96     -         // Executed at tick 1. Sensor shouldn't have been activated by second vibration.
		 97     -         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		 98     -     }).thenExecuteAfter(6, () => {
		 99     -         // Executed at tick 7. Sensor shouldn't have been activated yet by first vibration.
		100     -         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		101     -     }).thenExecuteAfter(3, () => {
		102     -         // Executed at tick 8. Sensor should have been activated by first vibration already.
		103     -         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		104     -     }).thenSucceed();
		105     - })
		106 218   
		    219 +     test.destroyBlock(occuledDestroyPos1);
		    220 +     test.destroyBlock(occuledDestroyPos2);
		107     - function destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, destroyPos, delay) {
		108     -     sequence.thenExecute(() => {
		    221 +     test.destroyBlock(occuledDestroyPos3);
		    222 +     test.destroyBlock(occuledDestroyPos4);
		    223 + 
		    224 +     failOnVibrationDetected(test, sensorPos, SENSOR_MAX_DELAY_TICKS);
		    225 + })
		    226 +     .tag(GameTest.Tags.suiteDefault);
		109     -         test.destroyBlock(destroyPos);
		110     -     }).thenExecuteAfter(delay, () => {
		111     -         const testEx = new GameTestExtensions(test);
		112     -         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		113     -     }).thenIdle(SENSOR_ACTIVE_TICKS + SENSOR_COOLDOWN_TICKS);
		114     - }
		115 227   
		    228 + // Tests that a moving entity produces vibrations of the expected frequency.
		    229 + GameTest.register("VibrationTests", "event_entity_move", (test) => {
		116     - // Tests that a Sculk Sensor activates with a delay in ticks equal to the distance a vibration has been emitted at.
		117     - GameTest.register("VibrationTests", "activation_delay", (test) => {
		118 230       const sensorPos = new BlockLocation(9, 2, 9);
		    231 +     const comparatorPos = new BlockLocation(9, 2, 10);
		    232 +     const expectedFrequency = 1;
		119 233   
		    234 +     const spawnPos = new Location(16.5, 2, 7.5);
		    235 +     const pig = test.spawnWithoutBehaviorsAtLocation("minecraft:pig", spawnPos);
		120     -     let sequence = test.startSequence();
		121 236   
		    237 +     const targetPos = new BlockLocation(2, 2, 7);
		122     -     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -8), 8);
		123     -     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -7), 7);
		124     -     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -6), 6);
		    238 +     test.walkTo(pig, targetPos, 1);
		    239 + 
		    240 +     succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		    241 + })
		    242 +     .tag(GameTest.Tags.suiteDefault);
		125     -     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -5), 5);
		126     -     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -4), 4);
		127     -     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -3), 3);
		128     -     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -2), 2);
		129     -     destroyBlockAndTestVibrationDetected(test, sequence, sensorPos, sensorPos.offset(0, 0, -1), 1);
		130 243   
		    244 + // Tests that an entity moving through Cobwebs produces vibrations of the expected frequency.
		    245 + GameTest.register("VibrationTests", "event_entity_move_cobweb", (test) => {
		    246 +     const sensorPos = new BlockLocation(9, 2, 9);
		131     -     sequence.thenSucceed();
		    247 +     const comparatorPos = new BlockLocation(9, 2, 10);
		    248 +     const expectedFrequency = 1;
		132     - })
		133     -     .maxTicks(TicksPerSecond * 60)
		134 249   
		    250 +     const spawnPos = new Location(11.5, 2, 7.5);
		135     - // Tests that a Sculk Sensor activates and stays active for the expected amount of time when receiving a vibration.
		136     - GameTest.register("VibrationTests", "activation_duration", (test) => {
		    251 +     const pig = test.spawnWithoutBehaviorsAtLocation("minecraft:pig", spawnPos);
		137     -     const sensorPos = new BlockLocation(9, 2, 9);
		138 252   
		    253 +     const targetPos = new BlockLocation(7, 2, 7);
		    254 +     test.walkTo(pig, targetPos, 1);
		139     -     const testEx = new GameTestExtensions(test);
		140 255   
		    256 +     succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		    257 + })
		    258 +     .tag(GameTest.Tags.suiteDefault);
		141     -     const destroyPos = new BlockLocation(8, 2, 9);
		142 259   
		    260 + // Tests that an entity moving through Pownder Snow produces vibrations of the expected frequency.
		    261 + GameTest.register("VibrationTests", "event_entity_move_powder_snow", (test) => {
		143     -     test.startSequence().thenExecute(() => {
		144     -         test.destroyBlock(destroyPos);
		    262 +     const sensorPos = new BlockLocation(9, 2, 9);
		    263 +     const comparatorPos = new BlockLocation(9, 2, 10);
		    264 +     const expectedFrequency = 1;
		    265 + 
		    266 +     const spawnPos = new Location(11.5, 2, 7.5);
		    267 +     const pig = test.spawnWithoutBehaviorsAtLocation("minecraft:pig", spawnPos);
		145     -     }).thenWaitAfter(1, () => {
		146     -         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		147     -     }).thenWaitAfter(SENSOR_ACTIVE_TICKS, () => {
		148     -         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		149     -     }).thenSucceed();
		150     - })
		151 268   
		    269 +     const targetPos = new BlockLocation(7, 2, 7);
		152     - // Tests that a Sculk Sensor ignores vibrations while on cooldown.
		153     - GameTest.register("VibrationTests", "activation_cooldown", (test) => {
		    270 +     test.walkTo(pig, targetPos, 1);
		154     -     const sensorPos = new BlockLocation(9, 2, 9);
		155 271   
		    272 +     succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		    273 + })
		    274 +     .tag(GameTest.Tags.suiteDefault);
		156     -     const testEx = new GameTestExtensions(test);
		157 275   
		    276 + // Tests that a moving entity does not produce vibrations while on wool.
		    277 + GameTest.register("VibrationTests", "event_entity_move_wool", (test) => {
		158     -     const destroyPos1 = new BlockLocation(8, 2, 9);
		    278 +     const sensorPos = new BlockLocation(9, 2, 9);
		159     -     const destroyPos2 = new BlockLocation(10, 2, 9);
		160 279   
		161     -     test.startSequence().thenExecute(() => {
		162     -         test.destroyBlock(destroyPos1);
		163     -     }).thenWaitAfter(1, () => {
		164     -         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		    280 +     const spawnPos = new Location(16.5, 2, 7.5);
		    281 +     const pig = test.spawnWithoutBehaviorsAtLocation("minecraft:pig", spawnPos);
		    282 + 
		    283 +     const targetPos = new BlockLocation(2, 2, 7);
		    284 +     test.walkTo(pig, targetPos, 1);
		    285 + 
		    286 +     failOnVibrationDetected(test, sensorPos, TicksPerSecond * 2);
		165     -     }).thenWaitAfter(SENSOR_ACTIVE_TICKS, () => {
		166     -         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		167     -     }).thenExecute(() => {
		168     -         test.destroyBlock(destroyPos2);
		169     -     }).thenWaitAfter(SENSOR_COOLDOWN_TICKS, () => {
		170     -         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		171     -     }).thenSucceed();
		172 287   })
		    288 +     .tag(GameTest.Tags.suiteDefault);
		173 289   
		    290 + // Tests that a moving entity does not produce vibrations while on wool carpet.
		    291 + GameTest.register("VibrationTests", "event_entity_move_carpet", (test) => {
		174     - // Tests that a Sculk Sensor can react to vibrations (emitted by destroying a block) only if they are not occluded by Wool.
		175     - GameTest.register("VibrationTests", "activation_wool_occlusion", (test) => {
		176 292       const sensorPos = new BlockLocation(9, 2, 9);
		    293 + 
		    294 +     const spawnPos = new Location(16.5, 2.5, 7.5);
		    295 +     const pig = test.spawnWithoutBehaviorsAtLocation("minecraft:pig", spawnPos);
		177 296   
		    297 +     const targetPos = new BlockLocation(2, 2, 7);
		    298 +     test.walkTo(pig, targetPos, 1);
		178     -     const testEx = new GameTestExtensions(test);
		179 299   
		    300 +     failOnVibrationDetected(test, sensorPos, TicksPerSecond * 2);
		180     -     const occuledDestroyPos1 = new BlockLocation(5, 2, 9);
		181     -     const occuledDestroyPos2 = new BlockLocation(9, 2, 13);
		182     -     const occuledDestroyPos3 = new BlockLocation(13, 2, 9);
		    301 + })
		    302 +     .tag(GameTest.Tags.suiteDefault);
		183     -     const unocculedDestroyPos1 = new BlockLocation(9, 2, 5);
		184     -     const unocculedDestroyPos2 = new BlockLocation(9, 6, 9);
		185 303   
		186     -     test.startSequence().thenExecute(() => {
		187     -         test.destroyBlock(occuledDestroyPos1);
		188     -         test.destroyBlock(occuledDestroyPos2);
		189     -         test.destroyBlock(occuledDestroyPos3);
		    304 + // Tests that a vibration dampering entity (Warden) does not produce vibrations when moving.
		    305 + GameTest.register("VibrationTests", "event_entity_move_dampering", (test) => {
		    306 +     const sensorPos = new BlockLocation(9, 2, 9);
		    307 + 
		    308 +     const spawnPos = new Location(16.5, 2, 7.5);
		    309 +     const warden = test.spawnWithoutBehaviorsAtLocation("minecraft:warden", spawnPos);
		    310 + 
		    311 +     const targetPos = new BlockLocation(2, 2, 7);
		    312 +     test.walkTo(warden, targetPos, 1);
		    313 + 
		    314 +     failOnVibrationDetected(test, sensorPos, TicksPerSecond * 2);
		190     -     }).thenExecuteAfter(SENSOR_MAX_DELAY_TICKS, () => {
		191     -         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		192     -     }).thenExecute(() => {
		193     -         test.destroyBlock(unocculedDestroyPos1);
		194     -     }).thenWait(() => {
		195     -         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		196     -     }).thenExecuteAfter(SENSOR_ACTIVE_TICKS + SENSOR_COOLDOWN_TICKS, () => {
		197     -         test.destroyBlock(unocculedDestroyPos2);
		198     -     }).thenWait(() => {
		199     -         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		200     -     }).thenSucceed();
		201 315   })
		    316 +     .tag(GameTest.Tags.suiteDefault);
		202 317   
		    318 + // Tests that an entity standing still in Scaffolding does not produce vibrations.
		    319 + GameTest.register("VibrationTests", "event_entity_move_scaffolding", (test) => {
		203     - // Tests that a moving entity produces vibrations of the expected frequency.
		204     - GameTest.register("VibrationTests", "event_entity_move", (test) => {
		205 320       const sensorPos = new BlockLocation(9, 2, 9);
		206     -     const comparatorPos = new BlockLocation(9, 2, 10);
		207     -     const expectedFrequency = 1;
		208 321   
		    322 +     const spawnPos = new Location(9.5, 3, 7.5);
		209     -     const spawnPos = new Location(16.5, 2, 7.5);
		210 323       const pig = test.spawnWithoutBehaviorsAtLocation("minecraft:pig", spawnPos);
		211     - 
		212     -     const targetPos = new BlockLocation(2, 2, 7);
		213     -     test.walkTo(pig, targetPos, 1);
		214 324   
		    325 +     failOnVibrationDetected(test, sensorPos, TicksPerSecond * 2);
		215     -     succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		216 326   })
		    327 +     .tag(GameTest.Tags.suiteDefault);
		217 328   
		    329 + // Tests that a moving player does not produce vibrations when sneaking, but does otherwise.
		    330 + GameTest.register("VibrationTests", "event_entity_move_sneaking", (test) => {
		218     - // Tests that a moving entity does not produce vibrations while on wool.
		219     - GameTest.register("VibrationTests", "event_entity_move_wool", (test) => {
		220 331       const sensorPos = new BlockLocation(9, 2, 9);
		    332 +     const comparatorPos = new BlockLocation(9, 2, 10);
		    333 +     const expectedFrequency = 1;
		221 334   
		    335 +     const spawnPos = new BlockLocation(11, 2, 7);
		    336 +     const targetPos = new BlockLocation(7, 2, 7);
		222     -     const spawnPos = new Location(16.5, 2, 7.5);
		    337 +     const player = test.spawnSimulatedPlayer(spawnPos, "Gordon");
		223     -     const pig = test.spawnWithoutBehaviorsAtLocation("minecraft:pig", spawnPos);
		224 338   
		    339 +     test.startSequence().thenExecute(() => {
		    340 +         player.isSneaking = true;
		    341 +         player.moveToBlock(targetPos);
		225     -     const targetPos = new BlockLocation(2, 2, 7);
		    342 +     }).thenExecuteFor(TicksPerSecond * 5, () => {
		    343 +         const testEx = new GameTestExtensions(test);
		    344 +         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		    345 +     }).thenExecute(() => {
		    346 +         player.isSneaking = false;
		    347 +         player.moveToBlock(spawnPos);
		    348 +     }).thenWait(() => {
		    349 +         const testEx = new GameTestExtensions(test);
		    350 +         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		    351 +         test.assertRedstonePower(comparatorPos, expectedFrequency);
		    352 +     }).thenSucceed();
		    353 + })
		    354 +     .maxTicks(TicksPerSecond * 30)
		    355 +     .tag(GameTest.Tags.suiteDefault);
		226     -     test.walkTo(pig, targetPos, 1);
		227     - 
		228     -     failOnVibrationDetected(test, sensorPos, TicksPerSecond * 2);
		229     - })
		230     - 
		231     - // Tests that a moving player does not produce vibrations when sneaking, but does otherwise.
		232     - GameTest.register("VibrationTests", "event_entity_move_sneaking", (test) => {
		233     -     const sensorPos = new BlockLocation(9, 2, 9);
		234     -     const comparatorPos = new BlockLocation(9, 2, 10);
		235     -     const expectedFrequency = 1;
		236     - 
		237     -     const spawnPos = new BlockLocation(11, 2, 7);
		238     -     const targetPos = new BlockLocation(7, 2, 7);
		239     -     const player = test.spawnSimulatedPlayer(spawnPos, "Gordon");
		240 356   
		    357 + // Tests that a flying entity produces vibrations of the expected frequency.
		241     -     test.startSequence().thenExecute(() => {
		242     -         player.isSneaking = true;
		    358 + GameTest.register("VibrationTests", "event_flap", (test) => {
		    359 +     const sensorPos = new BlockLocation(9, 2, 9);
		    360 +     const comparatorPos = new BlockLocation(9, 2, 10);
		    361 +     const expectedFrequency = 2;
		    362 + 
		    363 +     const spawnPos = new Location(11.5, 2, 9.5);
		    364 +     const parrot = test.spawnWithoutBehaviorsAtLocation("minecraft:parrot", spawnPos);
		    365 + 
		    366 +     const targetPos = new BlockLocation(7, 2, 9);
		    367 +     test.walkTo(parrot, targetPos, 1);
		    368 + 
		    369 +     succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		243     -         player.moveToBlock(targetPos);
		244     -     }).thenExecuteFor(TicksPerSecond * 5, () => {
		245     -         const testEx = new GameTestExtensions(test);
		246     -         testEx.assertBlockProperty("powered_bit", 0, sensorPos);
		247     -     }).thenExecute(() => {
		248     -         player.isSneaking = false;
		249     -         player.moveToBlock(spawnPos);
		250     -     }).thenWait(() => {
		251     -         const testEx = new GameTestExtensions(test);
		252     -         testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		253     -         test.assertRedstonePower(comparatorPos, expectedFrequency);
		254     -     }).thenSucceed();
		255 370   })
		    371 +     .tag(GameTest.Tags.suiteDefault);
		256     -     .maxTicks(TicksPerSecond * 30)
		257 372   
		    373 + // Tests that a swimming entity produces vibrations of the expected frequency.
		    374 + GameTest.register("VibrationTests", "event_swim", (test) => {
		258     - // Tests that a flying entity produces vibrations of the expected frequency.
		259     - GameTest.register("VibrationTests", "event_flap", (test) => {
		260 375       const sensorPos = new BlockLocation(9, 2, 9);
		261 376       const comparatorPos = new BlockLocation(9, 2, 10);
		    377 +     const expectedFrequency = 3;
		262     -     const expectedFrequency = 2;
		263 378   
		264 379       const spawnPos = new Location(11.5, 2, 9.5);
		    380 +     const fish = test.spawnWithoutBehaviorsAtLocation("minecraft:tropicalfish", spawnPos);
		265     -     const parrot = test.spawnWithoutBehaviorsAtLocation("minecraft:parrot", spawnPos);
		266 381   
		267 382       const targetPos = new BlockLocation(7, 2, 9);
		    383 +     test.walkTo(fish, targetPos, 1);
		268     -     test.walkTo(parrot, targetPos, 1);
		269 384   
		270 385       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		271 386   })
		    387 +     .tag(GameTest.Tags.suiteDefault);
		272 388   
		    389 + // Tests that an entity hitting ground produces vibrations of the expected frequency.
		    390 + GameTest.register("VibrationTests", "event_hit_ground", (test) => {
		273     - // Tests that a swimming entity produces vibrations of the expected frequency.
		274     - GameTest.register("VibrationTests", "event_swim", (test) => {
		275 391       const sensorPos = new BlockLocation(9, 2, 9);
		276 392       const comparatorPos = new BlockLocation(9, 2, 10);
		277     -     const expectedFrequency = 3;
		278     - 
		279     -     const spawnPos = new Location(11.5, 2, 9.5);
		    393 +     const expectedFrequency = 5;
		280     -     const fish = test.spawnWithoutBehaviorsAtLocation("minecraft:tropicalfish", spawnPos);
		281 394   
		    395 +     const spawnPos = new Location(9.5, 5, 7.5);
		    396 +     test.spawnWithoutBehaviorsAtLocation("minecraft:creeper", spawnPos);
		282     -     const targetPos = new BlockLocation(7, 2, 9);
		283     -     test.walkTo(fish, targetPos, 1);
		284 397   
		285 398       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		286 399   })
		    400 +     .tag(GameTest.Tags.suiteDefault);
		287 401   
		    402 + // [Bug 734008] Tests that a vibration dampering item (a Wool block, ejected by powering a Dispenser containing it) does not produce vibrations when hitting ground.
		    403 + GameTest.register("VibrationTests", "event_hit_ground_dampering", (test) => {
		288     - // Tests that an entity hitting ground produces vibrations of the expected frequency.
		289     - GameTest.register("VibrationTests", "event_hit_ground", (test) => {
		290 404       const sensorPos = new BlockLocation(9, 2, 9);
		291     -     const comparatorPos = new BlockLocation(9, 2, 10);
		292     -     const expectedFrequency = 5;
		293 405   
		    406 +     const placeAtPos = new BlockLocation(9, 6, 6);
		    407 +     test.setBlockType(MinecraftBlockTypes.redstoneBlock, placeAtPos);
		294     -     const spawnPos = new Location(9.5, 5, 7.5);
		295     -     test.spawnWithoutBehaviorsAtLocation("minecraft:creeper", spawnPos);
		296 408   
		    409 +     failOnVibrationDetected(test, sensorPos, TicksPerSecond * 2);
		297     -     succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		298 410   })
		    411 +     .tag(GameTest.Tags.suiteDefault);
		299 412   
		300 413   // Tests that an entity falling on Wool does not produce vibrations.
		301 414   GameTest.register("VibrationTests", "event_hit_ground_wool", (test) => {
		302 415       const sensorPos = new BlockLocation(9, 2, 9);
		303 416   
		304 417       const spawnPos = new Location(9.5, 5, 7.5);
		305 418       test.spawnWithoutBehaviorsAtLocation("minecraft:creeper", spawnPos);
		306 419   
		307 420       failOnVibrationDetected(test, sensorPos, TicksPerSecond * 2);
		308 421   })
		    422 +     .tag(GameTest.Tags.suiteDefault);
		309 423   
		310 424   // Tests that an entity falling in Water produces vibrations of the expected frequency.
		311 425   GameTest.register("VibrationTests", "event_splash", (test) => {
		312 426       const sensorPos = new BlockLocation(9, 2, 9);
		313 427       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		316 430       const spawnPos = new Location(9.5, 5, 7.5);
		317 431       test.spawnWithoutBehaviorsAtLocation("minecraft:creeper", spawnPos);
		318 432   
		319 433       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		320 434   })
		    435 +     .tag(GameTest.Tags.suiteDefault);
		321 436   
		322 437   // Tests that a projectile being shot (by powering a Dispenser) produces vibrations of the expected frequency.
		323 438   GameTest.register("VibrationTests", "event_projectile_shoot", (test) => {
		324 439       const sensorPos = new BlockLocation(9, 2, 9);
		325 440       const comparatorPos = new BlockLocation(9, 2, 8);
		          ...
		328 443       const placeAtPos = new BlockLocation(9, 4, 4);
		329 444       test.setBlockType(MinecraftBlockTypes.redstoneBlock, placeAtPos);
		330 445   
		331 446       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		332 447   })
		    448 +     .tag(GameTest.Tags.suiteDefault);
		333 449   
		334 450   // Tests that a landing projectile (shot by powering a Dispenser) produces vibrations of the expected frequency.
		335 451   GameTest.register("VibrationTests", "event_projectile_land", (test) => {
		336 452       const sensorPos = new BlockLocation(9, 2, 9);
		337 453       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		340 456       const placeAtPos = new BlockLocation(9, 4, 4);
		341 457       test.setBlockType(MinecraftBlockTypes.redstoneBlock, placeAtPos);
		342 458   
		343 459       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		344 460   })
		    461 +     .tag(GameTest.Tags.suiteDefault);
		345 462   
		346 463   // Tests that an entity being damaged (by standing on Magma) produces vibrations of the expected frequency.
		347 464   GameTest.register("VibrationTests", "event_entity_damage", (test) => {
		348 465       const sensorPos = new BlockLocation(9, 2, 9);
		349 466       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		352 469       const spawnPos = new Location(9.5, 2, 7.5);
		353 470       test.spawnWithoutBehaviorsAtLocation("minecraft:creeper", spawnPos);
		354 471   
		355 472       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		356 473   })
		    474 +     .tag(GameTest.Tags.suiteDefault);
		357 475   
		358 476   // Tests that an emtpy Dispenser trying to dispense produces vibrations of the expected frequency.
		359 477   GameTest.register("VibrationTests", "event_dispense_fail", (test) => {
		360 478       const sensorPos = new BlockLocation(9, 2, 9);
		361 479       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		364 482       const placeAtPos = new BlockLocation(9, 2, 3);
		365 483       test.setBlockType(MinecraftBlockTypes.redstoneBlock, placeAtPos);
		366 484   
		367 485       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		368 486   })
		    487 +     .tag(GameTest.Tags.suiteDefault);
		369 488   
		370 489   // Tests that a Fence Gate being closed (by removing the Redstone Block powering it) produces vibrations of the expected frequency.
		371 490   GameTest.register("VibrationTests", "event_block_close", (test) => {
		372 491       const sensorPos = new BlockLocation(9, 2, 9);
		373 492       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		376 495       const placeAtPos = new BlockLocation(12, 2, 5);
		377 496       test.setBlockType(MinecraftBlockTypes.air, placeAtPos);
		378 497   
		379 498       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		380 499   })
		    500 +     .tag(GameTest.Tags.suiteDefault);
		381 501   
		382 502   // Tests that a Fence Gate being opened (by placing a Redstone Block to power it) produces vibrations of the expected frequency.
		383 503   GameTest.register("VibrationTests", "event_block_open", (test) => {
		384 504       const sensorPos = new BlockLocation(9, 2, 9);
		385 505       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		388 508       const placeAtPos = new BlockLocation(12, 2, 5);
		389 509       test.setBlockType(MinecraftBlockTypes.redstoneBlock, placeAtPos);
		390 510   
		391 511       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		392 512   })
		    513 +     .tag(GameTest.Tags.suiteDefault);
		393 514   
		394 515   // Tests that picking-up Water (by powering a Dispenser with an Empty Bucket in it) produces vibrations of the expected frequency.
		395 516   GameTest.register("VibrationTests", "event_fluid_pickup", (test) => {
		396 517       const sensorPos = new BlockLocation(9, 2, 9);
		397 518       const comparatorPos = new BlockLocation(9, 2, 10);
		    519 +     const expectedFrequency = 13;
		398     -     const expectedFrequency = 12;
		399 520   
		400 521       const placeAtPos = new BlockLocation(9, 2, 3);
		401 522       test.setBlockType(MinecraftBlockTypes.redstoneBlock, placeAtPos);
		402 523   
		403 524       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		404 525   })
		    526 +     .tag(GameTest.Tags.suiteDefault);
		405 527   
		406 528   // Tests that placing Water (by powering a Dispenser with a Water Bucket in it) produces vibrations of the expected frequency.
		407 529   GameTest.register("VibrationTests", "event_fluid_place", (test) => {
		408 530       const sensorPos = new BlockLocation(9, 2, 9);
		409 531       const comparatorPos = new BlockLocation(9, 2, 10);
		    532 +     const expectedFrequency = 12;
		410     -     const expectedFrequency = 13;
		411 533   
		412 534       const placeAtPos = new BlockLocation(9, 2, 3);
		413 535       test.setBlockType(MinecraftBlockTypes.redstoneBlock, placeAtPos);
		414 536   
		415 537       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		416 538   })
		    539 +     .tag(GameTest.Tags.suiteDefault);
		417 540   
		418 541   // Tests that a player destroying a block produces vibrations of the expected frequency.
		419 542   GameTest.register("VibrationTests", "event_block_destroy", (test) => {
		420 543       const sensorPos = new BlockLocation(9, 2, 9);
		421 544       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		428 551       player.lookAtBlock(breakPos);
		429 552       player.breakBlock(breakPos);
		430 553   
		431 554       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		432 555   })
		    556 +     .tag(GameTest.Tags.suiteDefault);
		433 557   
		434 558   // Tests that a player closing a Chest produces vibrations of the expected frequency.
		435 559   GameTest.register("VibrationTests", "event_container_close", (test) => {
		436 560       const sensorPos = new BlockLocation(9, 2, 9);
		437 561       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		451 575           test.assertRedstonePower(comparatorPos, expectedFrequency);
		452 576       }).thenSucceed();
		453 577   
		454 578       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		455 579   })
		    580 +     .tag(GameTest.Tags.suiteDefault);
		456 581   
		457 582   // Tests that a player opening a Chest produces vibrations of the expected frequency.
		458 583   GameTest.register("VibrationTests", "event_container_open", (test) => {
		459 584       const sensorPos = new BlockLocation(9, 2, 9);
		460 585       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		470 595           const testEx = new GameTestExtensions(test);
		471 596           testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		472 597           test.assertRedstonePower(comparatorPos, expectedFrequency);
		473 598       }).thenSucceed();
		474 599   })
		    600 +     .tag(GameTest.Tags.suiteDefault);
		475 601   
		476 602   // Tests that spawning a Pillager (by powering a Dispenser with a Spawn Egg in it) produces vibrations of the expected frequency.
		477 603   GameTest.register("VibrationTests", "event_entity_place", (test) => {
		478 604       const sensorPos = new BlockLocation(9, 2, 9);
		479 605       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		482 608       const placeAtPos = new BlockLocation(9, 2, 4);
		483 609       test.setBlockType(MinecraftBlockTypes.redstoneBlock, placeAtPos);
		484 610   
		485 611       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		486 612   })
		    613 +     .tag(GameTest.Tags.suiteDefault);
		487 614   
		488 615   // Tests that equipping an Armor Stand (by powering a Dispenser with equipment in it) produces vibrations of the expected frequency.
		489 616   GameTest.register("VibrationTests", "event_equip", (test) => {
		490 617       const sensorPos = new BlockLocation(9, 2, 9);
		491 618       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		506 633       }).thenWait(() => {
		507 634           testEx.assertBlockProperty("powered_bit", 1, sensorPos);
		508 635           test.assertRedstonePower(comparatorPos, expectedFrequency);
		509 636       }).thenSucceed();
		510 637   })
		    638 +     .tag(GameTest.Tags.suiteDefault);
		511 639   
		512 640   // Tests that exploding TNT (ignited by placing a Redstone Block) produces vibrations of the expected frequency.
		513 641   GameTest.register("VibrationTests", "event_explode", (test) => {
		514 642       const sensorPos = new BlockLocation(9, 2, 9);
		515 643       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		518 646       const placeAtPos = new BlockLocation(9, 3, 6);
		519 647       test.setBlockType(MinecraftBlockTypes.redstoneBlock, placeAtPos);
		520 648   
		521 649       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		522 650   })
		    651 +     .tag(GameTest.Tags.suiteDefault);
		523 652   
		524 653   // Tests that a piston being contracted (by removing the Redstone Block powering it) produces vibrations of the expected frequency.
		525 654   GameTest.register("VibrationTests", "event_piston_contract", (test) => {
		526 655       const sensorPos = new BlockLocation(9, 2, 9);
		527 656       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		530 659       const placeAtPos = new BlockLocation(9, 2, 5);
		531 660       test.setBlockType(MinecraftBlockTypes.air, placeAtPos);
		532 661   
		533 662       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		534 663   })
		    664 +     .tag(GameTest.Tags.suiteDefault);
		535 665   
		536 666   // Tests that a piston being extened (by placing a Redstone Block to power it) produces vibrations of the expected frequency.
		537 667   GameTest.register("VibrationTests", "event_piston_extend", (test) => {
		538 668       const sensorPos = new BlockLocation(9, 2, 9);
		539 669       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		542 672       const placeAtPos = new BlockLocation(9, 2, 5);
		543 673       test.setBlockType(MinecraftBlockTypes.redstoneBlock, placeAtPos);
		544 674   
		545 675       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		546 676   })
		    677 +     .tag(GameTest.Tags.suiteDefault);
		547 678   
		548 679   // Tests that a Cake with Candle being ignited (by powering a Dispenser with a Flint and Steel in it) produces vibrations of the expected frequency.
		549 680   GameTest.register("VibrationTests", "event_block_change", (test) => {
		550 681       const sensorPos = new BlockLocation(9, 2, 9);
		551 682       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		554 685       const placeAtPos = new BlockLocation(9, 2, 5);
		555 686       test.setBlockType(MinecraftBlockTypes.redstoneBlock, placeAtPos);
		556 687   
		557 688       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		558 689   })
		    690 +     .tag(GameTest.Tags.suiteDefault);
		559 691   
		560 692   // Tests that a lightning produces vibrations of the expected frequency.
		561 693   GameTest.register("VibrationTests", "event_lightning_strike", (test) => {
		562 694       const sensorPos = new BlockLocation(9, 2, 9);
		563 695       const comparatorPos = new BlockLocation(9, 2, 10);
		          ...
		566 698       const spawnPos = new Location(9.5, 2, 5.5);
		567 699       test.spawnAtLocation("minecraft:lightning_bolt", spawnPos);
		568 700   
		569 701       succeedOnVibrationDetected(test, sensorPos, comparatorPos, expectedFrequency);
		570 702   })
		    703 +     .tag(GameTest.Tags.suiteDefault);
		          '''
	Changed script "WardenTests.js":
		Total line: 100 (+21, -19)
		          '''
		  1   1   import * as GameTest from "mojang-gametest";
		  2   2   import { BlockLocation, TicksPerSecond, Location } from "mojang-minecraft";
		      3 + const WARDEN_TESTS_PADDING = 16; // The paddings is there to make sure vibrations don't interefere with the warden 
		  3   4   
		  4   5   
		  5   6   GameTest.register("WardenTests", "warden_despawn", (test) => {
		  6   7       const wardenEntityType = "minecraft:warden";
		  7   8       const startPos = new BlockLocation(3, 1, 3);
		          ...
		 11  12           .startSequence()
		 12  13           .thenWait(() => {
		 13  14               test.assertEntityPresentInArea(wardenEntityType, false);
		 14  15           })
		 15  16           .thenSucceed();
		     17 + }).maxTicks(TicksPerSecond * 100).tag(GameTest.Tags.suiteDefault).padding(WARDEN_TESTS_PADDING); //timeout after 100 seconds
		 16     - }).maxTicks(TicksPerSecond * 90); //timeout after 90 seconds
		 17  18   
		 18  19   GameTest.register("WardenTests", "warden_kill_moving_entity", (test) => {
		 19  20       const wardenEntityType = "minecraft:warden";
		 20  21       const pigEntityType = "minecraft:pig";
		 21  22       const startPosWarden = new BlockLocation(1, 1, 1);
		          ...
		 40  41       sequence
		 41  42           .thenWait(() => {
		 42  43               test.assertEntityPresentInArea(pigEntityType, false);
		 43  44           })
		 44  45           .thenSucceed();
		     46 + }).maxTicks(TicksPerSecond * 90).tag(GameTest.Tags.suiteDefault).padding(WARDEN_TESTS_PADDING); //timeout after 90 seconds
		 45     - }).maxTicks(TicksPerSecond * 90); //timeout after 90 seconds
		 46  47   
		 47  48   GameTest.register("WardenTests", "warden_sniff_and_kill_static_entity", (test) => {
		 48  49       const wardenEntityType = "minecraft:warden";
		 49  50       const pigEntityType = "minecraft:pig";
		 50  51       const startPosWarden = new BlockLocation(1, 1, 1);
		          ...
		 56  57           .startSequence()
		 57  58           .thenWait(() => {
		 58  59               test.assertEntityPresentInArea(pigEntityType, false);
		 59  60           })
		 60  61           .thenSucceed();
		     62 + }).maxTicks(TicksPerSecond * 60).tag(GameTest.Tags.suiteDefault).padding(WARDEN_TESTS_PADDING); //timeout after 60 seconds
		 61     - }).maxTicks(TicksPerSecond * 60); //timeout after 60 seconds
		 62  63   
		     64 + GameTest.register("WardenTests", "warden_sniff_and_kill_player_before_mob", (test) => {
		 63     - GameTest.register("WardenTests", "warden_go_to_projectile", (test) => {
		 64  65       const wardenEntityType = "minecraft:warden";
		     66 +     const pigEntityType = "minecraft:pig";
		 65  67       const startPosWarden = new BlockLocation(1, 1, 1);
		     68 +     const startPosPlayer = new BlockLocation(1, 2, 6);
		     69 +     const startPosPig = new Location(6, 2, 6);
		 66     -     const snowballEntityType = "minecraft:snowball";
		 67     -     const startPosSnowball = new BlockLocation(7, 2, 7);
		 68  70       test.spawn(wardenEntityType, startPosWarden.above());
		     71 +     test.spawnWithoutBehaviorsAtLocation(pigEntityType, startPosPig);
		     72 +     test.spawnSimulatedPlayer(startPosPlayer, "playerSim_warden");
		 69     -     test.spawn(snowballEntityType, startPosSnowball);
		 70  73   
		 71  74       test
		 72  75           .startSequence()
		     76 +         .thenWait(() => {
		     77 +             test.assertEntityPresentInArea("minecraft:player", false);
		     78 +         })
		 73  79           .thenWait(() => {
		     80 +             test.assertEntityPresentInArea("minecraft:pig", true);
		 74     -             test.assertEntityPresent(wardenEntityType, startPosSnowball, true);
		 75  81           })
		 76  82           .thenSucceed();
		     83 + }).maxTicks(TicksPerSecond * 60).tag(GameTest.Tags.suiteDefault).padding(WARDEN_TESTS_PADDING); //timeout after 60 seconds
		 77     - }).maxTicks(TicksPerSecond * 10); //timeout after 10 seconds
		 78  84   
		     85 + GameTest.register("WardenTests", "warden_go_to_projectile", (test) => {
		 79     - GameTest.register("WardenTests", "warden_sniff_and_kill_player_before_mob", (test) => {
		 80  86       const wardenEntityType = "minecraft:warden";
		 81     -     const pigEntityType = "minecraft:pig";
		 82  87       const startPosWarden = new BlockLocation(1, 1, 1);
		     88 +     const snowballEntityType = "minecraft:snowball";
		     89 +     // spawns snowball above the ground so that it falls down and breaks
		 83     -     const startPosPlayer = new BlockLocation(1, 2, 6);
		     90 +     const startPosSnowball = new BlockLocation(7, 4, 7);
		 84     -     const startPosPig = new Location(6, 2, 6);
		 85  91       test.spawn(wardenEntityType, startPosWarden.above());
		     92 +     test.spawn(snowballEntityType, startPosSnowball);
		 86     -     test.spawnWithoutBehaviorsAtLocation(pigEntityType, startPosPig);
		 87     -     test.spawnSimulatedPlayer(startPosPlayer, "playerSim_warden");
		 88  93   
		 89  94       test
		 90  95           .startSequence()
		 91     -         .thenWait(() => {
		 92     -             test.assertEntityPresentInArea("minecraft:player", false);
		 93     -         })
		 94  96           .thenWait(() => {
		     97 +             test.assertEntityPresent(wardenEntityType, startPosSnowball, true);
		 95     -             test.assertEntityPresentInArea("minecraft:pig", true);
		 96  98           })
		 97  99           .thenSucceed();
		    100 + }).maxTicks(TicksPerSecond * 10).padding(WARDEN_TESTS_PADDING); //timeout after 10 seconds
		 98     - }).maxTicks(TicksPerSecond * 60); //timeout after 60 seconds
		          '''