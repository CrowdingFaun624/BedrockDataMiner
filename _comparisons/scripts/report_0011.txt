Difference of "scripts" between "1.17.10.20" (beta of "1.17.10") and "1.17.10.22" (beta of "1.17.10").
Unable to create data files for 1 file between: "1.17.10.21"

Changed behavior pack "vanilla_gametest":
	Total script: 19 (+2, -0)
	Changed script "APITests.js":
		Total line: 355 (+194, -58)
		          '''
		  1   1   import * as GameTest from "GameTest";
		      2 + import { BlockLocation, BlockTypes, ExplosionOptions, Effects, Items, ItemStack, Location, World } from "Minecraft";
		      3 + 
		      4 + GameTest.register("APITests", "on_entity_created", (test) => {
		      5 +   const entityCreatedCallback = World.events.createEntity.subscribe((entity) => {
		      6 +     if (entity) {
		      7 +       test.succeed();
		      8 +     } else {
		      9 +       test.fail("Expected entity");
		     10 +     }
		     11 +   });
		     12 +   test.spawn("minecraft:horse<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		     13 +   World.events.createEntity.unsubscribe(entityCreatedCallback);
		     14 + })
		     15 +   .structureName("ComponentTests:animal_pen")
		     16 +   .tag(GameTest.Tags.suiteDefault);
		     17 + 
		     18 + GameTest.register("APITests", "assert_is_waterlogged", (test) => {
		     19 +   const waterChestLoc = new BlockLocation(5, 2, 1);
		     20 +   const waterLoc = new BlockLocation(4, 2, 1);
		     21 +   const chestLoc = new BlockLocation(2, 2, 1);
		     22 +   const airLoc = new BlockLocation(1, 2, 1);
		     23 + 
		     24 +   test.assertIsWaterlogged(waterChestLoc, true);
		     25 +   test.assertIsWaterlogged(waterLoc, false);
		     26 +   test.assertIsWaterlogged(chestLoc, false);
		     27 +   test.assertIsWaterlogged(airLoc, false);
		     28 +   test.succeed();
		     29 + }).tag(GameTest.Tags.suiteDefault);
		     30 + 
		     31 + GameTest.register("APITests", "assert_redstone_power", (test) => {
		     32 +   const redstoneBlockLoc = new BlockLocation(3, 2, 1);
		     33 +   const redstoneTorchLoc = new BlockLocation(2, 2, 1);
		     34 +   const poweredLampLoc = new BlockLocation(1, 2, 1);
		     35 +   const unpoweredLampLoc = new BlockLocation(0, 2, 1);
		     36 +   const airLoc = new BlockLocation(3, 2, 0);
		     37 +   const redstoneWireLoc = new BlockLocation(0, 1, 0);
		     38 + 
		     39 +   test.succeedWhen(() => {
		     40 +     test.assertRedstonePower(redstoneBlockLoc, 15);
		     41 +     test.assertRedstonePower(redstoneTorchLoc, 15);
		     42 +     test.assertRedstonePower(poweredLampLoc, 15);
		     43 +     test.assertRedstonePower(unpoweredLampLoc, 0);
		     44 +     test.assertRedstonePower(airLoc, -1);
		     45 +     test.assertRedstonePower(redstoneWireLoc, 13); // 3 length wire
		     46 +   });
		     47 + })
		     48 +   .maxTicks(20)
		     49 +   .tag(GameTest.Tags.suiteDefault);
		     50 + 
		     51 + GameTest.register("APITests", "spawn_item", (test) => {
		     52 +   const featherItem = new ItemStack(Items.feather, 1, 0);
		     53 +   test.spawnItem(featherItem, new Location(1.5, 3.5, 1.5));
		     54 +   test.succeedWhen(() => {
		     55 +     test.assertEntityPresent("minecraft:item", new BlockLocation(1, 2, 1));
		     56 +   });
		     57 + }).tag(GameTest.Tags.suiteDefault);
		     58 + 
		     59 + GameTest.register("APITests", "assert_entity_data", (test) => {
		     60 +   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		     61 +   const pigLoc = new BlockLocation(1, 2, 1);
		     62 +   test.spawn(pigId, pigLoc);
		     63 +   test.succeedWhen(() => {
		     64 +     test.assertEntityData(pigLoc, pigId, (entity) => entity.id !== undefined);
		     65 +   });
		     66 + })
		     67 +   .structureName("ComponentTests:animal_pen")
		     68 +   .tag(GameTest.Tags.suiteDefault);
		     69 + 
		     70 + GameTest.register("APITests", "add_effect", (test) => {
		     71 +   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		     72 +   const villagerLoc = new BlockLocation(1, 2, 1);
		     73 +   const villager = test.spawn(villagerId, villagerLoc);
		     74 +   const duration = 20;
		     75 +   villager.addEffect(Effects.poison, duration, 1);
		     76 + 
		     77 +   test.assertEntityData(villagerLoc, villagerId, (entity) => entity.getEffect(Effects.poison).duration == duration);
		     78 +   test.assertEntityData(villagerLoc, villagerId, (entity) => entity.getEffect(Effects.poison).amplifier == 1);
		     79 + 
		     80 +   test.runAfterDelay(duration, () => {
		     81 +     test.assertEntityData(villagerLoc, villagerId, (entity) => entity.getEffect(Effects.poison) === undefined);
		     82 +     test.succeed();
		     83 +   });
		     84 + })
		     85 +   .structureName("ComponentTests:animal_pen")
		     86 +   .tag(GameTest.Tags.suiteDefault);
		     87 + 
		     88 + GameTest.register("APITests", "assert_entity_present", (test) => {
		     89 +   const villagerId = "minecraft:villager_v2";
		     90 +   const villagerLoc = new BlockLocation(1, 2, 3);
		     91 +   const emeraldItem = new ItemStack(Items.emerald, 1, 0);
		     92 +   const emeraldItemLoc = new BlockLocation(3, 2, 3);
		     93 +   const minecartId = "minecraft:minecart";
		     94 +   const minecartLoc = new BlockLocation(3, 2, 1);
		     95 +   const armorStandId = "minecraft:armor_stand";
		     96 +   const armorStandLoc = new BlockLocation(1, 2, 1);
		     97 + 
		     98 +   test.spawn(villagerId, villagerLoc);
		     99 +   test.spawnItem(emeraldItem, new Location(3.5, 4.5, 3.5));
		    100 + 
		    101 +   test.succeedWhen(() => {
		    102 +     test.assertEntityPresent(villagerId, villagerLoc);
		    103 +     test.assertItemEntityPresent(Items.emerald, emeraldItemLoc, 0);
		    104 +     test.assertEntityPresent(armorStandId, armorStandLoc);
		    105 + 
		    106 +     // Check all blocks surrounding the minecart
		    107 +     for (let x = -1; x <= 1; x++) {
		    108 +       for (let z = -1; z <= 1; z++) {
		    109 +         let offsetLoc = new BlockLocation(minecartLoc.x + x, minecartLoc.y, minecartLoc.z + z);
		    110 +         if (x == 0 && z == 0) {
		    111 +           test.assertEntityPresent(minecartId, offsetLoc);
		    112 +         } else {
		    113 +           test.assertEntityNotPresent(minecartId, offsetLoc);
		    114 +         }
		    115 +       }
		    116 +     }
		    117 +   });
		    118 + }).tag(GameTest.Tags.suiteDefault);
		    119 + 
		    120 + GameTest.register("APITests", "assert_entity_not_present", (test) => {
		    121 +   const armorStandId = "minecraft:armor_stand";
		    122 +   const pigId = "minecraft:pig";
		    123 +   const armorStandLoc = new BlockLocation(1, 2, 1);
		    124 +   const airLoc = new BlockLocation(0, 2, 1);
		    125 + 
		    126 +   try {
		    127 +     test.assertEntityNotPresentInArea(armorStandId);
		    128 +     test.fail(); // this assert should throw
		    129 +   } catch (e) {}
		    130 + 
		    131 +   try {
		    132 +     test.assertEntityNotPresent(armorStandId, armorStandLoc);
		    133 +     test.fail(); // this assert should throw
		    134 +   } catch (e) {}
		    135 + 
		    136 +   test.assertEntityNotPresent(armorStandId, airLoc);
		    137 +   test.assertEntityNotPresentInArea(pigId);
		    138 + 
		    139 +   test.succeed();
		    140 + })
		    141 +   .structureName("APITests:armor_stand")
		    142 +   .tag(GameTest.Tags.suiteDefault);
		    143 + 
		    144 + GameTest.register("APITests", "assert_item_entity_count_is", (test) => {
		    145 +   let oneItemLoc = new BlockLocation(3, 2, 1);
		    146 +   let fiveItemsLoc = new BlockLocation(1, 2, 1);
		    147 +   let noItemsLoc = new BlockLocation(2, 2, 1);
		    148 +   let diamondPickaxeLoc = new BlockLocation(2, 2, 4);
		    149 + 
		    150 +   const oneEmerald = new ItemStack(Items.emerald, 1, 0);
		    151 +   const onePickaxe = new ItemStack(Items.diamondPickaxe, 1, 0);
		    152 +   const fiveEmeralds = new ItemStack(Items.emerald, 5, 0);
		    153 + 
		    154 +   test.spawnItem(oneEmerald, new Location(3.5, 3, 1.5));
		    155 +   test.spawnItem(fiveEmeralds, new Location(1.5, 3, 1.5));
		  2     - import { BlockLocation, Effects, Items, ItemStack, Location, World } from "Minecraft";
		  3 156   
		    157 +   // spawn 9 pickaxes in a 3x3 grid
		  4     - GameTest.register("APITests", "on_entity_created", (test) => {
		  5     -   World.addEventListener("onEntityCreated", (entity) => {
		  6     -     if (entity) {
		    158 +   for (let x = 1.5; x <= 3.5; x++) {
		    159 +     for (let z = 3.5; z <= 5.5; z++) {
		    160 +       test.spawnItem(onePickaxe, new Location(x, 3, z));
		  7     -       test.succeed();
		  8     -     } else {
		  9     -       test.fail("Expected entity");
		 10 161       }
		 11     -   });
		 12     -   test.spawn("minecraft:horse<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		 13     - })
		 14     -   .structureName("ComponentTests:animal_pen")
		    162 +   }
		 15     -   .tag(GameTest.Tags.suiteDisabled); // This test will succeed multiple times, need to unregister the listener
		 16 163   
		 17     - GameTest.register("APITests", "assert_is_waterlogged", (test) => {
		 18     -   const waterChestLoc = new BlockLocation(5, 2, 1);
		 19     -   const waterLoc = new BlockLocation(4, 2, 1);
		 20     -   const chestLoc = new BlockLocation(2, 2, 1);
		    164 +   test.assertItemEntityCountIs(Items.emerald, noItemsLoc, 0, 0);
		 21     -   const airLoc = new BlockLocation(1, 2, 1);
		 22 165   
		    166 +   test.succeedWhen(() => {
		 23     -   test.assertIsWaterlogged(waterChestLoc, true);
		 24     -   test.assertIsWaterlogged(waterLoc, false);
		    167 +     test.assertItemEntityCountIs(Items.feather, oneItemLoc, 0, 0);
		    168 +     test.assertItemEntityCountIs(Items.emerald, oneItemLoc, 0, 1);
		    169 +     test.assertItemEntityCountIs(Items.feather, fiveItemsLoc, 0, 0);
		    170 +     test.assertItemEntityCountIs(Items.emerald, fiveItemsLoc, 0, 5);
		    171 +     test.assertItemEntityCountIs(Items.emerald, fiveItemsLoc, 0, 5);
		    172 +     test.assertItemEntityCountIs(Items.diamondPickaxe, diamondPickaxeLoc, 1, 9);
		    173 +     test.assertItemEntityCountIs(Items.diamondPickaxe, diamondPickaxeLoc, 0, 1);
		    174 +   });
		    175 + }).tag(GameTest.Tags.suiteDefault);
		    176 + 
		    177 + GameTest.register("APITests", "assert_entity_touching", (test) => {
		    178 +   const armorStandId = "minecraft:armor_stand";
		 25     -   test.assertIsWaterlogged(chestLoc, false);
		 26     -   test.assertIsWaterlogged(airLoc, false);
		 27     -   test.succeed();
		 28     - }).tag(GameTest.Tags.suiteDefault);
		 29     - 
		 30     - GameTest.register("APITests", "assert_redstone_power", (test) => {
		 31     -   const redstoneBlockLoc = new BlockLocation(3, 2, 1);
		 32     -   const redstoneTorchLoc = new BlockLocation(2, 2, 1);
		 33     -   const poweredLampLoc = new BlockLocation(1, 2, 1);
		 34     -   const unpoweredLampLoc = new BlockLocation(0, 2, 1);
		 35     -   const airLoc = new BlockLocation(3, 2, 0);
		 36     -   const redstoneWireLoc = new BlockLocation(0, 1, 0);
		 37 179   
		    180 +   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.5));
		    181 +   test.assertEntityTouching(armorStandId, new Location(1.5, 3.5, 1.5));
		 38     -   test.succeedWhen(() => {
		 39     -     test.assertRedstonePower(redstoneBlockLoc, 15);
		    182 +   test.assertEntityNotTouching(armorStandId, new Location(1.0, 2.5, 1.5));
		    183 +   test.assertEntityNotTouching(armorStandId, new Location(2.0, 2.5, 1.5));
		    184 +   test.assertEntityNotTouching(armorStandId, new Location(1.5, 2.5, 1.0));
		    185 +   test.assertEntityNotTouching(armorStandId, new Location(1.5, 2.5, 2.0));
		    186 + 
		    187 +   test.succeed();
		 40     -     test.assertRedstonePower(redstoneTorchLoc, 15);
		 41     -     test.assertRedstonePower(poweredLampLoc, 15);
		 42     -     test.assertRedstonePower(unpoweredLampLoc, 0);
		 43     -     test.assertRedstonePower(airLoc, -1);
		 44     -     test.assertRedstonePower(redstoneWireLoc, 13); // 3 length wire
		 45     -   });
		 46 188   })
		    189 +   .structureName("APITests:armor_stand")
		 47     -   .maxTicks(20)
		 48 190     .tag(GameTest.Tags.suiteDefault);
		 49 191   
		    192 + GameTest.register("APITests", "pulse_redstone", (test) => {
		 50     - GameTest.register("APITests", "spawn_item", (test) => {
		 51     -   const featherItem = new ItemStack(Items.feather, 1, 0);
		 52     -   test.spawnItem(featherItem, new Location(1.5, 3.5, 1.5));
		    193 +   const pulseLoc = new BlockLocation(1, 2, 2);
		    194 +   const lampLoc = new BlockLocation(1, 2, 1);
		    195 +   test.assertRedstonePower(lampLoc, 0);
		    196 +   test.pulseRedstone(pulseLoc, 2);
		 53     -   test.succeedWhen(() => {
		 54     -     test.assertEntityPresent("minecraft:item", new BlockLocation(1, 2, 1));
		 55     -   });
		 56     - }).tag(GameTest.Tags.suiteDefault);
		 57 197   
		    198 +   test
		 58     - GameTest.register("APITests", "assert_entity_data", (test) => {
		 59     -   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		 60     -   const pigLoc = new BlockLocation(1, 2, 1);
		    199 +     .startSequence()
		    200 +     .thenIdle(2)
		    201 +     .thenExecute(() => test.assertRedstonePower(lampLoc, 15))
		    202 +     .thenIdle(1)
		    203 +     .thenExecute(() => test.assertRedstonePower(lampLoc, 0))
		    204 +     .thenSucceed();
		    205 + }).tag(GameTest.Tags.suiteDefault);
		 61     -   test.spawn(pigId, pigLoc);
		 62     -   test.succeedWhen(() => {
		 63     -     test.assertEntityData(pigLoc, pigId, (entity) => entity.id !== undefined);
		 64     -   });
		 65     - })
		 66     -   .structureName("ComponentTests:animal_pen")
		 67     -   .tag(GameTest.Tags.suiteDefault);
		 68 206   
		    207 + GameTest.register("APITests", "location", (test) => {
		 69     - GameTest.register("APITests", "add_effect", (test) => {
		 70     -   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		 71     -   const villagerLoc = new BlockLocation(1, 2, 1);
		    208 +   let testLoc = new BlockLocation(1, 1, 1);
		    209 +   let worldLoc = test.worldLocation(testLoc);
		    210 +   let relativeLoc = test.relativeLocation(worldLoc);
		 72     -   const villager = test.spawn(villagerId, villagerLoc);
		 73     -   const duration = 20;
		 74     -   villager.addEffect(Effects.poison, duration, 1);
		 75     - 
		    211 +   test.assert(!relativeLoc.equals(worldLoc), "Expected relativeLoc and worldLoc to be different");
		    212 +   test.assert(relativeLoc.equals(testLoc), "Expected relativeLoc to match testLoc");
		    213 +   test.succeed();
		    214 + })
		    215 +   .structureName("ComponentTests:platform")
		    216 +   .tag(GameTest.Tags.suiteDefault);
		 76     -   test.assertEntityData(
		 77     -     villagerLoc,
		 78     -     villagerId,
		 79     -     (entity) => entity.getEffect(Effects.poison).getDuration() == duration
		 80     -   );
		 81     -   test.assertEntityData(villagerLoc, villagerId, (entity) => entity.getEffect(Effects.poison).getAmplifier() == 1);
		 82 217   
		    218 + GameTest.register("APITests", "create_explosion_basic", (test) => {
		 83     -   test.runAfterDelay(duration, () => {
		 84     -     test.assertEntityData(villagerLoc, villagerId, (entity) => entity.getEffect(Effects.poison) === undefined);
		 85     -     test.succeed();
		    219 +   let overworld = World.getDimension("overworld");
		    220 +   const center = new BlockLocation(2, 3, 2);
		    221 + 
		    222 +   test.assertBlockTypePresent(BlockTypes.cobblestone, center);
		 86     -   });
		 87     - })
		 88     -   .structureName("ComponentTests:animal_pen")
		 89     -   .tag(GameTest.Tags.suiteDefault);
		 90 223   
		    224 +   const loc = test.worldLocation(center);
		 91     - GameTest.register("APITests", "assert_entity_present", (test) => {
		 92     -   const villagerId = "minecraft:villager_v2";
		    225 +   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		    226 +   overworld.createExplosion(explosionLoc, 10, new ExplosionOptions());
		    227 + 
		    228 +   for (let x = 1; x <= 3; x++) {
		    229 +     for (let y = 2; y <= 4; y++) {
		    230 +       for (let z = 1; z <= 3; z++) {
		    231 +         test.assertBlockTypeNotPresent(BlockTypes.cobblestone, new BlockLocation(x, y, z));
		    232 +       }
		    233 +     }
		    234 +   }
		 93     -   const villagerLoc = new BlockLocation(1, 2, 3);
		 94     -   const emeraldItem = new ItemStack(Items.emerald, 1, 0);
		 95     -   const emeraldItemLoc = new BlockLocation(3, 2, 3);
		 96     -   const minecartId = "minecraft:minecart";
		 97     -   const minecartLoc = new BlockLocation(3, 2, 1);
		 98     -   const armorStandId = "minecraft:armor_stand";
		 99     -   const armorStandLoc = new BlockLocation(1, 2, 1);
		100     - 
		101     -   test.spawn(villagerId, villagerLoc);
		102     -   test.spawnItem(emeraldItem, new Location(3.5, 4.5, 3.5));
		103 235   
		    236 +   test.succeed();
		    237 + })
		104     -   test.succeedWhen(() => {
		105     -     test.assertEntityPresent(villagerId, villagerLoc);
		    238 +   .padding(10) // The blast can destroy nearby items and mobs
		    239 +   .tag(GameTest.Tags.suiteDefault);
		106     -     test.assertItemEntityPresent(Items.emerald, emeraldItemLoc, 0);
		107     -     test.assertEntityPresent(armorStandId, armorStandLoc);
		108 240   
		    241 + GameTest.register("APITests", "create_explosion_advanced", (test) => {
		109     -     // Check all blocks surrounding the minecart
		110     -     for (let x = -1; x <= 1; x++) {
		111     -       for (let z = -1; z <= 1; z++) {
		    242 +   let overworld = World.getDimension("overworld");
		    243 +   const center = new BlockLocation(2, 3, 2);
		    244 + 
		    245 +   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		    246 +   const pigLoc = new BlockLocation(2, 4, 2);
		    247 +   test.spawn(pigId, pigLoc);
		    248 + 
		    249 +   const loc = test.worldLocation(center);
		    250 +   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		    251 +   let explosionOptions = new ExplosionOptions();
		112     -         let offsetLoc = new BlockLocation(minecartLoc.x + x, minecartLoc.y, minecartLoc.z + z);
		113     -         if (x == 0 && z == 0) {
		114     -           test.assertEntityPresent(minecartId, offsetLoc);
		115     -         } else {
		116     -           test.assertEntityNotPresent(minecartId, offsetLoc);
		117     -         }
		118     -       }
		119     -     }
		120     -   });
		121     - }).tag(GameTest.Tags.suiteDefault);
		122 252   
		123     - GameTest.register("APITests", "assert_entity_not_present", (test) => {
		124     -   const armorStandId = "minecraft:armor_stand";
		125     -   const pigId = "minecraft:pig";
		126     -   const armorStandLoc = new BlockLocation(1, 2, 1);
		    253 +   test.assertBlockTypePresent(BlockTypes.cobblestone, center);
		127     -   const airLoc = new BlockLocation(0, 2, 1);
		128 254   
		    255 +   // Start by exploding without breaking blocks
		    256 +   explosionOptions.breaksBlocks = false;
		129     -   try {
		130     -     test.assertEntityNotPresentInArea(armorStandId);
		    257 +   const creeper = test.spawn("minecraft:creeper", new BlockLocation(1, 2, 1));
		    258 +   explosionOptions.source = creeper;
		    259 +   test.assertEntityPresent(pigId, pigLoc);
		    260 +   overworld.createExplosion(explosionLoc, 10, explosionOptions);
		    261 +   creeper.kill();
		    262 +   test.assertEntityNotPresent(pigId, pigLoc);
		    263 +   test.assertBlockTypePresent(BlockTypes.cobblestone, center);
		131     -     test.fail(); // this assert should throw
		132     -   } catch (e) {}
		133     - 
		134     -   try {
		135     -     test.assertEntityNotPresent(armorStandId, armorStandLoc);
		136     -     test.fail(); // this assert should throw
		137     -   } catch (e) {}
		138 264   
		    265 +   // Next, explode with fire
		    266 +   explosionOptions = new ExplosionOptions();
		139     -   test.assertEntityNotPresent(armorStandId, airLoc);
		    267 +   explosionOptions.causesFire = true;
		140     -   test.assertEntityNotPresentInArea(pigId);
		141 268   
		    269 +   let findFire = () => {
		    270 +     let foundFire = false;
		142     -   test.succeed();
		143     - })
		    271 +     for (let x = 0; x <= 4; x++) {
		    272 +       for (let z = 0; z <= 4; z++) {
		144     -   .structureName("APITests:armor_stand")
		145     -   .tag(GameTest.Tags.suiteDefault);
		146     - 
		    273 +         try {
		    274 +           test.assertBlockTypePresent(BlockTypes.fire, new BlockLocation(x, 3, z));
		    275 +           foundFire = true;
		    276 +           break;
		    277 +         } catch (e) {}
		    278 +       }
		    279 +     }
		    280 +     return foundFire;
		    281 +   };
		147     - GameTest.register("APITests", "assert_item_entity_count_is", (test) => {
		148     -   let oneItemLoc = new BlockLocation(3, 2, 1);
		149     -   let fiveItemsLoc = new BlockLocation(1, 2, 1);
		150     -   let noItemsLoc = new BlockLocation(2, 2, 1);
		151     -   let diamondPickaxeLoc = new BlockLocation(2, 2, 4);
		152     - 
		153     -   const oneEmerald = new ItemStack(Items.emerald, 1, 0);
		154     -   const onePickaxe = new ItemStack(Items.diamondPickaxe, 1, 0);
		155     -   const fiveEmeralds = new ItemStack(Items.emerald, 5, 0);
		156 282   
		    283 +   test.assert(!findFire(), "Unexpected fire");
		    284 +   overworld.createExplosion(explosionLoc, 10, explosionOptions);
		    285 +   test.assertBlockTypeNotPresent(BlockTypes.cobblestone, center);
		157     -   test.spawnItem(oneEmerald, new Location(3.5, 3, 1.5));
		    286 +   test.assert(findFire(), "No fire found");
		158     -   test.spawnItem(fiveEmeralds, new Location(1.5, 3, 1.5));
		159 287   
		    288 +   // Finally, explode in water
		    289 +   explosionOptions.allowUnderwater = true;
		    290 +   const belowWaterLoc = new BlockLocation(2, 1, 2);
		160     -   // spawn 9 pickaxes in a 3x3 grid
		    291 +   test.assertBlockTypeNotPresent(BlockTypes.air, belowWaterLoc);
		    292 +   overworld.createExplosion(explosionLoc, 7, explosionOptions);
		    293 +   test.assertBlockTypePresent(BlockTypes.air, belowWaterLoc);
		    294 +   test.succeed();
		    295 + })
		    296 +   .padding(10) // The blast can destroy nearby items and mobs
		    297 +   .tag(GameTest.Tags.suiteDefault);
		161     -   for (let x = 1.5; x <= 3.5; x++) {
		162     -     for (let z = 3.5; z <= 5.5; z++) {
		163     -       test.spawnItem(onePickaxe, new Location(x, 3, z));
		164     -     }
		165     -   }
		166     - 
		167     -   test.assertItemEntityCountIs(Items.emerald, noItemsLoc, 0, 0);
		168 298   
		    299 + GameTest.register("APITests", "triggerEvent", (test) => {
		169     -   test.succeedWhen(() => {
		170     -     test.assertItemEntityCountIs(Items.feather, oneItemLoc, 0, 0);
		171     -     test.assertItemEntityCountIs(Items.emerald, oneItemLoc, 0, 1);
		    300 +   const creeper = test.spawn("creeper", new BlockLocation(1, 2, 1));
		    301 +   creeper.triggerEvent("minecraft:start_exploding_forced");
		    302 + 
		    303 +   test.succeedWhen(() => {
		    304 +     test.assertEntityNotPresentInArea("creeper");
		172     -     test.assertItemEntityCountIs(Items.feather, fiveItemsLoc, 0, 0);
		173     -     test.assertItemEntityCountIs(Items.emerald, fiveItemsLoc, 0, 5);
		174     -     test.assertItemEntityCountIs(Items.emerald, fiveItemsLoc, 0, 5);
		175     -     test.assertItemEntityCountIs(Items.diamondPickaxe, diamondPickaxeLoc, 1, 9);
		176     -     test.assertItemEntityCountIs(Items.diamondPickaxe, diamondPickaxeLoc, 0, 1);
		177 305     });
		    306 + })
		    307 +   .structureName("ComponentTests:glass_cage")
		    308 +   .tag(GameTest.Tags.suiteDefault);
		178     - }).tag(GameTest.Tags.suiteDefault);
		179 309   
		    310 + GameTest.register("APITests", "chat", (test) => {
		    311 +   test.print("subscribing");
		180     - GameTest.register("APITests", "assert_entity_touching", (test) => {
		181     -   const armorStandId = "minecraft:armor_stand";
		182 312   
		    313 +   const chatCallback = World.events.beforeChat.subscribe((eventData) => {
		    314 +     if (eventData.message === "!killme") {
		    315 +       eventData.sender.kill();
		183     -   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.5));
		    316 +       eventData.canceled = true;
		    317 +     } else if (eventData.message === "!players") {
		    318 +       test.print(`There are ${eventData.targets.length} players in the server.`);
		    319 +       for (const target of eventData.targets) {
		    320 +         test.print("Player: " + target.name);
		    321 +       }
		    322 +     } else {
		    323 +       eventData.message = `Modified '${eventData.message}'`;
		    324 +     }
		    325 +   });
		184     -   test.assertEntityTouching(armorStandId, new Location(1.5, 3.5, 1.5));
		185     -   test.assertEntityNotTouching(armorStandId, new Location(1.0, 2.5, 1.5));
		186     -   test.assertEntityNotTouching(armorStandId, new Location(2.0, 2.5, 1.5));
		187     -   test.assertEntityNotTouching(armorStandId, new Location(1.5, 2.5, 1.0));
		188     -   test.assertEntityNotTouching(armorStandId, new Location(1.5, 2.5, 2.0));
		189     - 
		190     -   test.succeed();
		191     - })
		192     -   .structureName("APITests:armor_stand")
		193     -   .tag(GameTest.Tags.suiteDefault);
		194 326   
		    327 +   test
		    328 +     .startSequence()
		    329 +     .thenIdle(200)
		195     - GameTest.register("APITests", "pulse_redstone", (test) => {
		    330 +     .thenExecute(() => {
		    331 +       World.events.beforeChat.unsubscribe(chatCallback);
		    332 +       test.print("unsubscribed");
		    333 +     })
		    334 +     .thenSucceed();
		    335 + })
		    336 +   .structureName("ComponentTests:platform")
		    337 +   .maxTicks(1000)
		    338 +   .tag(GameTest.Tags.suiteDisabled);
		    339 + 
		    340 + GameTest.register("APITests", "add_effect_event", (test) => {
		    341 +   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		    342 +   const villager = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		196     -   const pulseLoc = new BlockLocation(1, 2, 2);
		197     -   const lampLoc = new BlockLocation(1, 2, 1);
		198     -   test.assertRedstonePower(lampLoc, 0);
		199     -   test.pulseRedstone(pulseLoc, 2);
		200     - 
		201     -   test
		202     -     .startSequence()
		203     -     .thenIdle(2)
		204     -     .thenExecute(() => test.assertRedstonePower(lampLoc, 15))
		205     -     .thenIdle(1)
		206     -     .thenExecute(() => test.assertRedstonePower(lampLoc, 0))
		207     -     .thenSucceed();
		208     - }).tag(GameTest.Tags.suiteDefault);
		209 343   
		    344 +   const addEffectCallback = World.events.addEffect.subscribe((eventData) => {
		    345 +     test.assert(eventData.entity.id === "minecraft:villager_v2", "Unexpected id");
		    346 +     test.assert(eventData.effect.displayName === "Poison II", "Unexpected display name");
		210     - GameTest.register("APITests", "location", (test) => {
		    347 +     test.assert(eventData.effectState === 1, "Unexpected effect state");
		    348 +     test.succeed();
		    349 +   });
		    350 + 
		    351 +   villager.addEffect(Effects.poison, 5, 1);
		    352 +   World.events.beforeChat.unsubscribe(addEffectCallback);
		211     -   let testLoc = new BlockLocation(1, 1, 1);
		212     -   let worldLoc = test.worldLocation(testLoc);
		213     -   let relativeLoc = test.relativeLocation(worldLoc);
		214     -   test.assert(!relativeLoc.equals(worldLoc), "Expected relativeLoc and worldLoc to be different");
		215     -   test.assert(relativeLoc.equals(testLoc), "Expected relativeLoc to match testLoc");
		216     -   test.succeed();
		217 353   })
		    354 +   .structureName("ComponentTests:animal_pen")
		218     -   .structureName("ComponentTests:platform")
		219 355     .tag(GameTest.Tags.suiteDefault);
		          '''
	Changed script "BlockTests.js":
		Total line: 261 (+90, -92)
		          '''
		  1   1   import * as GameTest from "GameTest";
		      2 + import { BlockLocation, BlockTypes, Items, ItemStack } from "Minecraft";
		  2     - import { BlockLocation, Blocks, Items, ItemStack } from "Minecraft";
		  3   3   
		  4   4   const TicksPerSecond = 20;
		  5   5   const FiveSecondsInTicks = 5 * TicksPerSecond;
		  6   6   
		  7   7   const FALLING_SAND_TEMPLATE_NAME = "BlockTests:falling_sand_template";
		  8   8   const FALLING_SAND_STARTUP_TICKS = 1;
		  9   9   const FALLING_SAND_TIMEOUT_TICKS = 20;
		 10  10   
		 11  11   const BLOCKS_THAT_POP_SAND = [
		     12 +   [BlockTypes.woodenSlab, BlockTypes.air], //replace missing oakSlab() with woodenSlab()
		     13 +   [BlockTypes.chest, BlockTypes.stone],
		 12     -     [Blocks.woodenSlab(), Blocks.air()],  //replace missing oakSlab() with woodenSlab()
		 13     -     [Blocks.chest(), Blocks.stone()],
		     14 +   [BlockTypes.rail, BlockTypes.stone],
		     15 +   [BlockTypes.stoneButton, BlockTypes.stone],
		     16 +   [BlockTypes.woodenPressurePlate, BlockTypes.stone], //replace missing OakPressurePlate() with woodenPressurePlate()
		     17 +   [BlockTypes.torch, BlockTypes.stone],
		     18 +   [BlockTypes.soulSand, BlockTypes.air],
		 14     -     [Blocks.rail(), Blocks.stone()],
		 15     -     [Blocks.stoneButton(), Blocks.stone()],
		 16     -     [Blocks.woodenPressurePlate(), Blocks.stone()],  //replace missing OakPressurePlate() with woodenPressurePlate()
		 17     -     [Blocks.torch(), Blocks.stone()],
		 18     -     [Blocks.soulSand(), Blocks.air()],
		 19  19   ];
		 20  20   
		 21  21   const BLOCKS_REPLACED_BY_SAND = [
		     22 +   BlockTypes.water,
		     23 +   BlockTypes.air,
		 22     -     Blocks.water(),
		 23     -     Blocks.air(),
		     24 +   BlockTypes.tallgrass, //replace grass() with tallgrass(). It needs grass, not grass block, BlockTypes.grass is actually grass block.
		 24     -     Blocks.tallgrass() //replace grass() with tallgrass(). It needs grass, not grass block, Blocks.grass() is actually grass block.
		 25  25   ];
		 26  26   
		 27  27   const BLOCKS_THAT_SUPPORT_SAND = [
		     28 +   BlockTypes.stone,
		     29 +   BlockTypes.fence, //replace missing oakFence() with fence()
		 28     -     Blocks.stone(),
		 29     -     Blocks.fence(),  //replace missing oakFence() with fence()
		     30 +   BlockTypes.oakStairs,
		     31 +   BlockTypes.scaffolding,
		 30     -     Blocks.oakStairs(),
		 31     -     Blocks.scaffolding()
		 32  32   ];
		 33  33   
		 34  34   function testThatFallingSandPopsIntoItem(test) {
		     35 +   test.setBlockType(BlockTypes.sand, new BlockLocation(1, 4, 1));
		     36 +   const targetPos = new BlockLocation(1, 2, 1);
		 35     -     test.setBlock(Blocks.sand(), new BlockLocation(1, 4, 1));
		 36     -     const targetPos = new BlockLocation(1, 2, 1);
		 37  37   
		     38 +   test.succeedWhen(() => {
		     39 +     test.assertEntityPresentInArea("minecraft:item");
		 38     -     test.succeedWhen(() => {
		 39     -         test.assertEntityPresentInArea("minecraft:item");
		     40 +     test.assertEntityNotPresent("minecraft:falling_block", targetPos);
		     41 +   });
		 40     -         test.assertEntityNotPresent("minecraft:falling_block", targetPos);
		 41     -     });
		 42  42   }
		 43  43   
		 44  44   function testThatFallingSandReplaces(test) {
		     45 +   test.setBlockType(BlockTypes.sand, new BlockLocation(1, 4, 1));
		     46 +   test.succeedWhenBlockTypePresent(BlockTypes.sand, new BlockLocation(1, 2, 1));
		 45     -     test.setBlock(Blocks.sand(), new BlockLocation(1, 4, 1));
		 46     -     test.succeedWhenBlockPresent(Blocks.sand(), new BlockLocation(1, 2, 1));
		 47  47   }
		 48  48   
		 49  49   function testThatFallingSandLandsOnTop(test) {
		     50 +   test.setBlockType(BlockTypes.sand, new BlockLocation(1, 4, 1));
		     51 +   test.succeedWhenBlockTypePresent(BlockTypes.sand, new BlockLocation(1, 3, 1));
		 50     -     test.setBlock(Blocks.sand(), new BlockLocation(1, 4, 1));
		 51     -     test.succeedWhenBlockPresent(Blocks.sand(), new BlockLocation(1, 3, 1));
		 52  52   }
		 53  53   
		 54  54   ///
		 55  55   // Concrete Tests
		 56  56   ///
		 57  57   for (let i = 0; i < BLOCKS_THAT_POP_SAND.length; i++) {
		     58 +   const topBlock = BLOCKS_THAT_POP_SAND[i][0];
		     59 +   const bottomBlock = BLOCKS_THAT_POP_SAND[i][1];
		 58     -     const topBlock = BLOCKS_THAT_POP_SAND[i][0];
		 59     -     const bottomBlock = BLOCKS_THAT_POP_SAND[i][1];
		     60 +   const testName = "blocktests.falling_sand_pops_on_" + topBlock.name;
		     61 +   let tag = null;
		 60     -     const testName = "blocktests.falling_sand_pops_on_" + topBlock.name;
		 61     -     let tag = null;
		 62  62   
		     63 +   //When sand block falls on soul sand, it should pop into item.
		 63     -     //When sand block falls on soul sand, it should pop into item.
		 64     -     //Buttons will break off if they face the worng direction. Wait API that can set the block property for "direction" for the button.
		     64 +   //Buttons will break off if they face the worng direction. Wait API that can set the block property for "direction" for the button.
		     65 +   if (topBlock.name == "soul_sand" || topBlock.name == "stone_button") {
		     66 +     tag = GameTest.Tags.suiteDisabled;
		     67 +   } else {
		     68 +     tag = GameTest.Tags.suiteDefault;
		     69 +   }
		 65     -     if (topBlock.name == "soul_sand" || topBlock.name == "stone_button") {
		 66     -         tag = GameTest.Tags.suiteDisabled;
		 67     -     }
		 68     -     else {
		 69     -         tag = GameTest.Tags.suiteDefault;
		 70     -     }
		 71  70   
		     71 +   GameTest.register("BlockTests", testName, (test) => {
		     72 +     test.setBlockType(topBlock, new BlockLocation(1, 2, 1));
		 72     -     GameTest.register("BlockTests", testName, (test) => {
		 73     -         test.setBlock(topBlock, new BlockLocation(1, 2, 1));
		     73 +     test.setBlockType(bottomBlock, new BlockLocation(1, 1, 1));
		     74 +     testThatFallingSandPopsIntoItem(test);
		     75 +   })
		     76 +     .batch("day")
		     77 +     .structureName(FALLING_SAND_TEMPLATE_NAME)
		     78 +     .maxTicks(FALLING_SAND_TIMEOUT_TICKS)
		     79 +     .setupTicks(FALLING_SAND_STARTUP_TICKS)
		     80 +     .required(true)
		     81 +     .tag(tag);
		 74     -         test.setBlock(bottomBlock, new BlockLocation(1, 1, 1));
		 75     -         testThatFallingSandPopsIntoItem(test);
		 76     -     })
		 77     -         .batch("day")
		 78     -         .structureName(FALLING_SAND_TEMPLATE_NAME)
		 79     -         .maxTicks(FALLING_SAND_TIMEOUT_TICKS)
		 80     -         .setupTicks(FALLING_SAND_STARTUP_TICKS)
		 81     -         .required(true)
		 82     -         .tag(tag);
		 83  82   }
		 84  83   
		 85  84   for (const block of BLOCKS_REPLACED_BY_SAND) {
		     85 +   const testName = "blocktests.falling_sand_replaces_" + block.name;
		 86     -     const testName = "blocktests.falling_sand_replaces_" + block.name;
		 87  86   
		     87 +   GameTest.register("BlockTests", testName, (test) => {
		     88 +     //SetBlock will fail if set a block to what it already is. Skip to call setblock() for test falling_sand_replaces_air because it's just air block in initial structure.
		 88     -     GameTest.register("BlockTests", testName, (test) => {
		 89     -         //SetBlock will fail if set a block to what it already is. Skip to call setblock() for test falling_sand_replaces_air because it's just air block in initial structure.
		     89 +     if (block.name != "air") {
		     90 +       test.setBlockType(block, new BlockLocation(1, 2, 1));
		     91 +     }
		     92 +     testThatFallingSandReplaces(test);
		     93 +   })
		     94 +     .batch("day")
		     95 +     .structureName(FALLING_SAND_TEMPLATE_NAME)
		     96 +     .maxTicks(FALLING_SAND_TIMEOUT_TICKS)
		     97 +     .setupTicks(FALLING_SAND_STARTUP_TICKS)
		     98 +     .required(true)
		     99 +     .tag(GameTest.Tags.suiteDefault);
		 90     -         if (block.name != "air") {
		 91     -             test.setBlock(block, new BlockLocation(1, 2, 1));
		 92     -         }
		 93     -         testThatFallingSandReplaces(test);
		 94     -     })
		 95     -         .batch("day")
		 96     -         .structureName(FALLING_SAND_TEMPLATE_NAME)
		 97     -         .maxTicks(FALLING_SAND_TIMEOUT_TICKS)
		 98     -         .setupTicks(FALLING_SAND_STARTUP_TICKS)
		 99     -         .required(true)
		100     -         .tag(GameTest.Tags.suiteDefault);
		101 100   }
		102 101   
		103 102   for (const block of BLOCKS_THAT_SUPPORT_SAND) {
		    103 +   const testName = "blocktests.falling_sand_lands_on_" + block.name;
		    104 +   let tag = null;
		104     -     const testName = "blocktests.falling_sand_lands_on_" + block.name;
		105     -     let tag = null;
		106 105   
		    106 +   //When sand block falls on fence or stair, it shouldn't pop into item.
		107     -     //When sand block falls on fence or stair, it shouldn't pop into item.
		108     -     if (block.name == "fence" || block.name == "oak_stairs") {
		    107 +   if (block.name == "fence" || block.name == "oak_stairs") {
		    108 +     tag = GameTest.Tags.suiteDisabled;
		    109 +   } else {
		    110 +     tag = GameTest.Tags.suiteDefault;
		    111 +   }
		109     -         tag = GameTest.Tags.suiteDisabled;
		110     -     }
		111     -     else {
		112     -         tag = GameTest.Tags.suiteDefault;
		113     -     }
		114 112   
		    113 +   GameTest.register("BlockTests", testName, (test) => {
		    114 +     test.setBlockType(block, new BlockLocation(1, 2, 1));
		115     -     GameTest.register("BlockTests", testName, (test) => {
		116     -         test.setBlock(block, new BlockLocation(1, 2, 1));
		    115 +     testThatFallingSandLandsOnTop(test);
		    116 +   })
		    117 +     .batch("day")
		    118 +     .structureName(FALLING_SAND_TEMPLATE_NAME)
		    119 +     .maxTicks(FALLING_SAND_TIMEOUT_TICKS)
		    120 +     .setupTicks(FALLING_SAND_STARTUP_TICKS)
		    121 +     .required(true)
		    122 +     .tag(tag);
		117     -         testThatFallingSandLandsOnTop(test);
		118     -     })
		119     -         .batch("day")
		120     -         .structureName(FALLING_SAND_TEMPLATE_NAME)
		121     -         .maxTicks(FALLING_SAND_TIMEOUT_TICKS)
		122     -         .setupTicks(FALLING_SAND_STARTUP_TICKS)
		123     -         .required(true)
		124     -         .tag(tag);
		125 123   }
		126 124   
		127 125   GameTest.register("BlockTests", "concrete_solidifies_in_shallow_water", (test) => {
		    126 +   test.setBlockType(BlockTypes.concretepowder, new BlockLocation(1, 3, 1));
		128     -     test.setBlock(Blocks.concretepowder(), new BlockLocation(1, 3, 1));
		129 127   
		    128 +   test.succeedWhen(() => {
		    129 +     test.assertBlockTypePresent(BlockTypes.concrete, new BlockLocation(1, 2, 1));
		130     -     test.succeedWhen(() => {
		131     -         test.assertBlockPresent(Blocks.concrete(), new BlockLocation(1, 2, 1));
		    130 +   });
		132     -     });
		133 131   })
		    132 +   .maxTicks(FiveSecondsInTicks)
		    133 +   .tag(GameTest.Tags.suiteDefault);
		134     -     .maxTicks(FiveSecondsInTicks)
		135     -     .tag(GameTest.Tags.suiteDefault);
		136 134   
		137 135   GameTest.register("BlockTests", "concrete_solidifies_in_deep_water", (test) => {
		    136 +   test.setBlockType(BlockTypes.concretepowder, new BlockLocation(1, 4, 1));
		138     -     test.setBlock(Blocks.concretepowder(), new BlockLocation(1, 4, 1));
		139 137   
		    138 +   test.succeedWhen(() => {
		    139 +     test.assertBlockTypePresent(BlockTypes.concrete, new BlockLocation(1, 2, 1));
		140     -     test.succeedWhen(() => {
		141     -         test.assertBlockPresent(Blocks.concrete(), new BlockLocation(1, 2, 1));
		    140 +   });
		142     -     });
		143 141   })
		    142 +   .maxTicks(FiveSecondsInTicks)
		    143 +   .tag(GameTest.Tags.suiteDefault);
		144     -     .maxTicks(FiveSecondsInTicks)
		145     -     .tag(GameTest.Tags.suiteDefault);
		146 144   
		147 145   GameTest.register("BlockTests", "concrete_solidifies_next_to_water", (test) => {
		    146 +   test.setBlockType(BlockTypes.concretepowder, new BlockLocation(1, 3, 1));
		148     -     test.setBlock(Blocks.concretepowder(), new BlockLocation(1, 3, 1));
		149 147   
		    148 +   test.succeedWhen(() => {
		    149 +     test.assertBlockTypePresent(BlockTypes.concrete, new BlockLocation(1, 2, 1));
		150     -     test.succeedWhen(() => {
		151     -         test.assertBlockPresent(Blocks.concrete(), new BlockLocation(1, 2, 1));
		    150 +   });
		152     -     });
		153 151   })
		    152 +   .maxTicks(FiveSecondsInTicks)
		    153 +   .tag(GameTest.Tags.suiteDefault);
		154     -     .maxTicks(FiveSecondsInTicks)
		155     -     .tag(GameTest.Tags.suiteDefault);
		156 154   
		157 155   GameTest.register("BlockTests", "sand_fall_boats", (test) => {
		    156 +   test.setBlockType(BlockTypes.sand, new BlockLocation(1, 4, 1));
		158     -     test.setBlock(Blocks.sand(), new BlockLocation(1, 4, 1));
		159 157   
		    158 +   test.succeedWhen(() => {
		    159 +     test.assertBlockTypePresent(BlockTypes.sand, new BlockLocation(1, 2, 1));
		160     -     test.succeedWhen(() => {
		161     -         test.assertBlockPresent(Blocks.sand(), new BlockLocation(1, 2, 1));
		    160 +   });
		162     -     });
		163 161   })
		    162 +   .maxTicks(FiveSecondsInTicks)
		    163 +   .tag(GameTest.Tags.suiteDefault);
		164     -     .maxTicks(FiveSecondsInTicks)
		165     -     .tag(GameTest.Tags.suiteDefault);
		166 164   
		167 165   GameTest.register("BlockTests", "sand_fall_shulker", (test) => {
		    166 +   const EntitySpawnType = "minecraft:shulker";
		    167 +   const spawnPos = new BlockLocation(1, 2, 1);
		168     -     const EntitySpawnType = "minecraft:shulker";
		169     -     const spawnPos = new BlockLocation(1, 2, 1);
		170 168   
		    169 +   test.spawn(EntitySpawnType, spawnPos);
		    170 +   testThatFallingSandPopsIntoItem(test);
		171     -     test.spawn(EntitySpawnType, spawnPos);
		172     -     testThatFallingSandPopsIntoItem(test);
		173 171   })
		    172 +   .maxTicks(FiveSecondsInTicks)
		    173 +   .tag(GameTest.Tags.suiteDefault);
		174     -     .maxTicks(FiveSecondsInTicks)
		175     -     .tag(GameTest.Tags.suiteDefault);
		176 174   
		177 175   ///
		178 176   // Turtle Egg Tests
		179 177   ///
		180 178   
		181 179   GameTest.register("BlockTests", "turtle_eggs_survive_xp", (test) => {
		    180 +   const xpOrb = "minecraft:xp_orb";
		    181 +   const spawnPos = new BlockLocation(1, 3, 1);
		182     -     const xpOrb = "minecraft:xp_orb";
		183     -     const spawnPos = new BlockLocation(1, 3, 1);
		184 182   
		    183 +   for (let i = 0; i < 8; i++) {
		    184 +     test.spawn(xpOrb, spawnPos);
		185     -     for (let i = 0; i < 8; i++) {
		186     -         test.spawn(xpOrb, spawnPos);
		    185 +   }
		187     -     }
		188 186   
		    187 +   // Fail if the turtle egg dies
		    188 +   test.failIf(() => {
		189     -     // Fail if the turtle egg dies
		190     -     test.failIf(() => {
		    189 +     test.assertBlockTypePresent(BlockTypes.air, new BlockLocation(1, 2, 1));
		    190 +   });
		191     -         test.assertBlockPresent(Blocks.air(), new BlockLocation(1, 2, 1));
		192     -     });
		193 191   
		    192 +   // Succeed after 4 seconds
		    193 +   test.startSequence().thenIdle(80).thenSucceed();
		194     -     // Succeed after 4 seconds
		195     -     test.startSequence().thenIdle(80).thenSucceed();
		196 194   })
		    195 +   .maxTicks(FiveSecondsInTicks)
		    196 +   .tag(GameTest.Tags.suiteDefault);
		197     -     .maxTicks(FiveSecondsInTicks)
		198     -     .tag(GameTest.Tags.suiteDefault);
		199 197   
		200 198   GameTest.register("BlockTests", "turtle_eggs_survive_item", (test) => {
		    199 +   test.pressButton(new BlockLocation(2, 4, 0));
		201     -     test.pressButton(new BlockLocation(2, 4, 0));
		202 200   
		    201 +   // Fail if the turtle egg dies
		    202 +   test.failIf(() => {
		203     -     // Fail if the turtle egg dies
		204     -     test.failIf(() => {
		    203 +     test.assertBlockTypePresent(BlockTypes.air, new BlockLocation(1, 2, 1));
		    204 +   });
		205     -         test.assertBlockPresent(Blocks.air(), new BlockLocation(1, 2, 1));
		206     -     });
		207 205   
		    206 +   // Succeed after 4 seconds
		    207 +   test.startSequence().thenIdle(80).thenSucceed();
		208     -     // Succeed after 4 seconds
		209     -     test.startSequence().thenIdle(80).thenSucceed();
		210 208   })
		    209 +   .maxTicks(FiveSecondsInTicks)
		    210 +   .tag(GameTest.Tags.suiteDefault);
		211     -     .maxTicks(FiveSecondsInTicks)
		212     -     .tag(GameTest.Tags.suiteDefault);
		213 211   
		214 212   GameTest.register("BlockTests", "turtle_eggs_squished_by_mob", (test) => {
		    213 +   const zombieEntityType = "minecraft:husk";
		    214 +   const zombiePosition = new BlockLocation(1, 5, 1);
		215     -     const zombieEntityType = "minecraft:husk";
		216     -     const zombiePosition = new BlockLocation(1, 5, 1);
		    215 +   test.spawn(zombieEntityType, zombiePosition);
		    216 +   test.succeedWhenBlockTypePresent(BlockTypes.air, new BlockLocation(1, 2, 1));
		217     -     test.spawn(zombieEntityType, zombiePosition);
		218     -     test.succeedWhenBlockPresent(Blocks.air(), new BlockLocation(1, 2, 1));
		219 217   })
		    218 +   .required(false)
		    219 +   .maxTicks(TicksPerSecond * 20)
		220     -     .required(false)
		221     -     .maxTicks(TicksPerSecond * 20)
		    220 +   .tag(GameTest.Tags.suiteDefault);
		222     -     .tag(GameTest.Tags.suiteDefault);
		223 221   
		224 222   GameTest.register("BlockTests", "explosion_drop_location", (test) => {
		    223 +   test.pressButton(new BlockLocation(4, 3, 4));
		225     -     test.pressButton(new BlockLocation(4, 3, 4));
		226 224   
		    225 +   test.succeedWhen(() => {
		    226 +     const redSandstonePos = new BlockLocation(6, 2, 4);
		227     -     test.succeedWhen(() => {
		228     -         const redSandstonePos = new BlockLocation(6, 2, 4);
		    227 +     const sandstonePos = new BlockLocation(2, 2, 4);
		229     -         const sandstonePos = new BlockLocation(2, 2, 4);
		230 228   
		    229 +     test.assertBlockTypeNotPresent(BlockTypes.redSandstone, redSandstonePos);
		    230 +     test.assertBlockTypeNotPresent(BlockTypes.sandstone, sandstonePos);
		231     -         test.assertBlockNotPresent(Blocks.redSandstone(), redSandstonePos);
		232     -         test.assertBlockNotPresent(Blocks.sandstone(), sandstonePos);
		    231 +     test.assertItemEntityPresent(Items.redSandstone, redSandstonePos, 2.0);
		    232 +     test.assertItemEntityPresent(Items.sandstone, sandstonePos, 2.0);
		    233 +   });
		233     -         test.assertItemEntityPresent(Items.redSandstone, redSandstonePos, 2.0);
		234     -         test.assertItemEntityPresent(Items.sandstone, sandstonePos, 2.0);
		235     -     });
		236 234   })
		    235 +   .maxTicks(TicksPerSecond * 10)
		    236 +   .tag("suite:java_parity")
		237     -     .maxTicks(TicksPerSecond * 10)
		238     -     .tag("suite:java_parity")
		    237 +   .tag(GameTest.Tags.suiteDisabled) //redSandstone and sandstone items should be present.
		    238 +   .maxAttempts(3);
		239     -     .tag(GameTest.Tags.suiteDisabled) //redSandstone and sandstone items should be present.
		240     -     .maxAttempts(3);
		241 239   
		242 240   GameTest.register("BlockTests", "concrete_pops_off_waterlogged_chest", (test) => {
		    241 +   test.setBlockType(BlockTypes.concretepowder, new BlockLocation(1, 4, 1));
		    242 +   test.succeedWhen(() => {
		243     -     test.setBlock(Blocks.concretepowder(), new BlockLocation(1, 4, 1));
		244     -     test.succeedWhen(() => {
		    243 +     const chestPos = new BlockLocation(1, 2, 1);
		    244 +     test.assertBlockTypePresent(BlockTypes.chest, chestPos);
		    245 +     test.assertItemEntityPresent(Items.concretePowder, chestPos, 2);
		    246 +     test.assertEntityNotPresentInArea("falling_block");
		    247 +   });
		245     -         const chestPos = new BlockLocation(1, 2, 1);
		246     -         test.assertBlockPresent(Blocks.chest(), chestPos);
		247     -         test.assertItemEntityPresent(Items.concretePowder, chestPos, 2);
		248     -         test.assertEntityNotPresent("falling_block");
		249     -     });
		250 248   })
		    249 +   .maxTicks(TicksPerSecond * 5)
		    250 +   .tag(GameTest.Tags.suiteDefault);
		251     -     .maxTicks(TicksPerSecond * 5)
		252     -     .tag(GameTest.Tags.suiteDefault);
		253 251   
		254 252   GameTest.register("BlockTests", "waterlogged_slab", (test) => {
		    253 +   const slabPos = new BlockLocation(1, 1, 1);
		    254 +   test.assertIsWaterlogged(slabPos, false);
		255     -     const slabPos = new BlockLocation(1, 1, 1);
		256     -     test.assertIsWaterlogged(slabPos, false);
		    255 +   test.succeedWhen(() => {
		    256 +     test.assertIsWaterlogged(slabPos, true);
		    257 +   });
		257     -     test.succeedWhen(() => {
		258     -         test.assertIsWaterlogged(slabPos, true);
		259     -     });
		260 258   })
		    259 +   .tag("suite:java_parity")
		    260 +   .tag(GameTest.Tags.suiteDisabled) // Slab should be waterlogged
		261     -     .tag("suite:java_parity")
		262     -     .tag(GameTest.Tags.suiteDisabled) // Slab should be waterlogged 
		    261 +   .maxTicks(TicksPerSecond * 2);
		263     -     .maxTicks(TicksPerSecond * 2);
		          '''
	Changed script "ComponentTests.js":
		Total line: 463 (+1, -1)
		          '''
		          ...
		 76  76   
		 77  77   GameTest.register("ComponentTests", "health_component", (test) => {
		 78  78     const sheepId = "minecraft:sheep<minecraft:ageable_grow_up>";
		 79  79     const sheepPos = new BlockLocation(4, 2, 2);
		 80  80     const sheep = test.spawn(sheepId, sheepPos);
		     81 +   test.assertEntityInstancePresent(sheep, sheepPos);
		 81     -   test.assertEntityInstancePresent(sheep);
		 82  82     test.pullLever(new BlockLocation(2, 3, 2));
		 83  83   
		 84  84     const healthComponent = sheep.getComponent("minecraft:health");
		 85  85     test.assert(healthComponent !== undefined, "Expected health component");
		 86  86   
		          ...
		          '''
	Changed script "DispenserTests.js":
		Total line: 245 (+5, -6)
		          '''
		  1   1   import * as GameTest from "GameTest";
		      2 + import { BlockLocation, BlockTypes, Items, ItemStack } from "Minecraft";
		  2     - import { BlockLocation, Blocks, Items, ItemStack } from "Minecraft";
		  3   3   
		  4   4   const dispenserDelay = 5; // Number of ticks to wait for the dispenser to use or dispense an item
		  5   5   const armorSlotTorso = 1;
		  6   6   const pinkCarpet = 6;
		  7   7   const tameMountComponentName = "minecraft:tamemount";
		          ...
		175 175     .tag(GameTest.Tags.suiteDefault);
		176 176   
		177 177   GameTest.register("DispenserTests", "dispenser_water", (test) => {
		178 178     const waterPos = new BlockLocation(1, 2, 1);
		179 179     const dispenserPos = new BlockLocation(0, 2, 1);
		    180 +   test.assertBlockTypeNotPresent(BlockTypes.water, waterPos);
		180     -   test.assertBlockNotPresent(Blocks.water(), waterPos);
		181 181     test.assertContainerContains(new ItemStack(Items.waterBucket, 1, 0), dispenserPos);
		182 182   
		183 183     test.pressButton(new BlockLocation(0, 2, 0));
		184 184   
		185 185     test.succeedOnTickWhen(dispenserDelay, () => {
		186 186       test.assertContainerContains(new ItemStack(Items.bucket, 1, 0), dispenserPos);
		    187 +     test.assertBlockTypePresent(BlockTypes.water, waterPos);
		187     -     test.assertBlockPresent(Blocks.water(), waterPos);
		188 188     });
		189 189   })
		190 190     .maxTicks(threeSecondsInTicks)
		191 191     .tag(GameTest.Tags.suiteDefault);
		192 192   
		          ...
		205 205     test.pressButton(new BlockLocation(0, 2, 0));
		206 206     const respawnAnchorPos = new BlockLocation(1, 2, 1);
		207 207     const dispenserPos = new BlockLocation(0, 2, 1);
		208 208     test.assertContainerContains(new ItemStack(Items.glowstone, 1, 0), dispenserPos);
		209 209   
		    210 +   test.assertBlockState("respawn_anchor_charge", 0, respawnAnchorPos);
		210     -     test.assertBlockState("respawn_anchor_charge", 0, respawnAnchorPos);
		211     -     test.succeedWhen(() => {
		    211 +   test.succeedWhen(() => {
		    212 +     test.assertBlockState("respawn_anchor_charge", 1, respawnAnchorPos);
		    213 +     test.assertContainerEmpty(dispenserPos);
		    214 +   });
		    215 + })
		212     -       test.assertBlockState("respawn_anchor_charge", 1, respawnAnchorPos);
		213     -       test.assertContainerEmpty(dispenserPos);
		214     -     });
		215     -   }
		216     - )
		217 216     .maxTicks(threeSecondsInTicks)
		218 217     .tag(GameTest.Tags.suiteDefault);
		219 218   
		220 219   GameTest.register("DispenserTests", "dispenser_fire", (test) => {
		221 220     test.pullLever(new BlockLocation(2, 5, 1));
		          ...
		228 227       new BlockLocation(2, 7, 1),
		229 228     ];
		230 229   
		231 230     test.succeedOnTickWhen(dispenserDelay, () => {
		232 231       for (const pos of firePositions) {
		    232 +       test.assertBlockTypePresent(BlockTypes.fire, pos);
		233     -       test.assertBlockPresent(Blocks.fire(), pos);
		234 233       }
		235 234     });
		236 235   })
		237 236     .maxTicks(threeSecondsInTicks)
		238 237     .tag(GameTest.Tags.suiteDefault);
		          ...
		          '''
	Changed script "FlyingMachineTests.js":
		Total line: 264 (+85, -32)
		          '''
		  1   1   import * as GameTest from "GameTest";
		      2 + import { BlockLocation, BlockTypes } from "Minecraft";
		      3 + 
		      4 + GameTest.register("FlyingMachineTests", "machine_a", (test) => {
		      5 +   const triggerPos = new BlockLocation(1, 5, 1);
		      6 +   const farPos = new BlockLocation(2, 3, 5);
		      7 +   const nearPos = new BlockLocation(2, 3, 1);
		      8 + 
		      9 +   test
		     10 +     .startSequence()
		     11 +     .thenExecute(() => {
		     12 +       test.setBlockType(BlockTypes.fire, triggerPos);
		     13 +     })
		     14 +     .thenExecuteAfter(20, () => {
		     15 +       test.assertBlockTypePresent(BlockTypes.slime, farPos);
		     16 +     })
		     17 +     .thenExecuteAfter(20, () => {
		     18 +       test.assertBlockTypePresent(BlockTypes.slime, nearPos);
		     19 +     })
		     20 +     .thenSucceed();
		     21 + })
		     22 +   .tag("suite:java_parity") // The behavior is different between Java and Bedrock.In Java the flying machine move forward to the end and then returns to its original position, but in Bedrock it returns before it reaches the end.That cause the far point or near point been judged fail.
		     23 +   .tag(GameTest.Tags.suiteDisabled); // Unstable, about 50% pass rate.
		     24 + 
		     25 + GameTest.register("FlyingMachineTests", "machine_b", (test) => {
		     26 +   const triggerPos = new BlockLocation(5, 4, 1);
		     27 +   const farPos = new BlockLocation(3, 3, 4);
		     28 +   const nearPos = new BlockLocation(4, 3, 1);
		     29 + 
		     30 +   test
		     31 +     .startSequence()
		     32 +     .thenExecute(() => {
		     33 +       test.pulseRedstone(triggerPos, 2);
		     34 +     })
		     35 +     .thenExecuteAfter(20, () => {
		     36 +       test.assertBlockTypePresent(BlockTypes.slime, farPos);
		     37 +     })
		     38 +     .thenExecuteAfter(20, () => {
		     39 +       test.assertBlockTypePresent(BlockTypes.slime, nearPos);
		     40 +     })
		     41 +     .thenSucceed();
		     42 + })
		     43 +   .tag("suite:java_parity")
		     44 +   .tag(GameTest.Tags.suiteDisabled); // After I use redstone instead of set fire block to active the observer, I can see this machine use 2 reverse sticky-piston for flying forward and back in Java. It didn't work well in bedrock.
		     45 + 
		     46 + GameTest.register("FlyingMachineTests", "machine_c", (test) => {
		     47 +   const triggerPos = new BlockLocation(4, 4, 0);
		     48 +   const farPos = new BlockLocation(4, 3, 5);
		     49 +   const nearPos = new BlockLocation(4, 3, 2);
		     50 +   const stopBlock = new BlockLocation(4, 3, 4);
		     51 + 
		     52 +   test
		     53 +     .startSequence()
		     54 +     .thenExecute(() => {
		     55 +       test.pulseRedstone(triggerPos, 2);
		     56 +     })
		     57 +     .thenExecuteAfter(20, () => {
		     58 +       test.assertBlockTypePresent(BlockTypes.slime, farPos);
		     59 +     })
		     60 +     .thenExecuteAfter(20, () => {
		     61 +       test.setBlockType(BlockTypes.obsidian, stopBlock);
		     62 +     })
		     63 +     .thenExecuteAfter(2, () => {
		     64 +       test.assertBlockTypePresent(BlockTypes.stickyPiston, nearPos);
		     65 +     })
		     66 +     .thenSucceed();
		     67 + })
		     68 +   .tag("suite:java_parity")
		     69 +   .tag(GameTest.Tags.suiteDisabled); // Could not set fire block in the air even I use pulseRedstone() the machine didn't move.
		  2     - import { BlockLocation, Blocks } from "Minecraft";
		  3     - 
		  4     - 
		  5     - GameTest.register("FlyingMachineTests", "machine_a", (test) => {
		  6     -     const triggerPos = new BlockLocation(1, 5, 1);
		  7     -     const farPos = new BlockLocation(2, 3, 5);
		  8     -     const nearPos = new BlockLocation(2, 3, 1);
		  9     - 
		 10     -     test.startSequence()
		 11     -         .thenExecute(() => { test.setBlock(Blocks.fire(), triggerPos); })
		 12     -         .thenExecuteAfter(20, () => { test.assertBlockPresent(Blocks.slime(), farPos); })
		 13     -         .thenExecuteAfter(20, () => { test.assertBlockPresent(Blocks.slime(), nearPos); })
		 14     -         .thenSucceed();
		 15  70   
		     71 + GameTest.register("FlyingMachineTests", "machine_d", (test) => {
		     72 +   const triggerPos = new BlockLocation(3, 7, 3);
		 16     - })
		     73 +   const dropPos = new BlockLocation(5, 5, 2);
		     74 +   const farPos = new BlockLocation(2, 5, 8);
		     75 +   const nearPos = new BlockLocation(3, 5, 1);
		 17     -     .tag("suite:java_parity")  // The behavior is different between Java and Bedrock.In Java the flying machine move forward to the end and then returns to its original position, but in Bedrock it returns before it reaches the end.That cause the far point or near point been judged fail.
		 18     -     .tag(GameTest.Tags.suiteDisabled); // Unstable, about 50% pass rate. 
		 19     - 
		 20  76   
		     77 +   test
		     78 +     .startSequence()
		     79 +     .thenExecute(() => {
		     80 +       test.setBlockType(BlockTypes.fire, triggerPos);
		     81 +     })
		     82 +     .thenExecuteAfter(16, () => {
		     83 +       test.assertBlockTypePresent(BlockTypes.slime, dropPos);
		     84 +       test.assertBlockTypePresent(BlockTypes.slime, farPos);
		     85 +     })
		     86 +     .thenSucceed();
		     87 + })
		     88 +   .tag("suite:java_parity")
		     89 +   .tag(GameTest.Tags.suiteDisabled); // Can't fly as a whole thing as expectation
		     90 + 
		     91 + GameTest.register("FlyingMachineTests", "machine_e", (test) => {
		     92 +   const triggerPos = new BlockLocation(1, 2, 1);
		     93 +   const farPos = new BlockLocation(1, 11, 1);
		     94 +   const nearPos = new BlockLocation(1, 3, 1);
		 21     - GameTest.register("FlyingMachineTests", "machine_b", (test) => {
		 22     -     const triggerPos = new BlockLocation(5, 4, 1);
		 23     -     const farPos = new BlockLocation(3, 3, 4);
		 24     -     const nearPos = new BlockLocation(4, 3, 1);
		 25     - 
		 26     -     test.startSequence()
		 27     -         .thenExecute(() => {
		 28     -             test.pulseRedstone(triggerPos, 2);
		 29     -         })
		 30     -         .thenExecuteAfter(20, () => { test.assertBlockPresent(Blocks.slime(), farPos); })
		 31     -         .thenExecuteAfter(20, () => { test.assertBlockPresent(Blocks.slime(), nearPos); })
		 32     -         .thenSucceed();
		 33     - })
		 34     -     .tag("suite:java_parity")
		 35     -     .tag(GameTest.Tags.suiteDisabled); // After I use redstone instead of set fire block to active the observer, I can see this machine use 2 reverse sticky-piston for flying forward and back in Java. It didn't work well in bedrock.
		 36     - 
		 37  95   
		     96 +   test
		 38     - GameTest.register("FlyingMachineTests", "machine_c", (test) => {
		 39     -     const triggerPos = new BlockLocation(4, 4, 0);
		     97 +     .startSequence()
		     98 +     .thenExecute(() => {
		     99 +       test.setBlockType(BlockTypes.dirt, triggerPos);
		 40     -     const farPos = new BlockLocation(4, 3, 5);
		 41     -     const nearPos = new BlockLocation(4, 3, 2);
		 42     -     const stopBlock = new BlockLocation(4, 3, 4);
		 43     - 
		    100 +     })
		    101 +     .thenExecuteAfter(16, () => {
		    102 +       test.assertBlockTypePresent(BlockTypes.honeyBlock, farPos);
		    103 +     })
		    104 +     .thenExecuteAfter(20, () => {
		    105 +       test.assertBlockTypePresent(BlockTypes.observer, nearPos);
		    106 +     })
		    107 +     .thenSucceed();
		 44     -     test.startSequence()
		 45     -         .thenExecute(() => {
		 46     -             test.pulseRedstone(triggerPos, 2);
		 47     -         })
		 48     -         .thenExecuteAfter(20, () => { test.assertBlockPresent(Blocks.slime(), farPos); })
		 49     -         .thenExecuteAfter(20, () => { test.setBlock(Blocks.obsidian(), stopBlock); })
		 50     -         .thenExecuteAfter(2, () => { test.assertBlockPresent(Blocks.stickyPiston(), nearPos); })
		 51     -         .thenSucceed();
		 52 108   })
		    109 +   .tag("suite:java_parity") // The behavior is different between Java and Bedrock. In Java the flying machine move forward to the end and then returns to its original position, but in Bedrock it returns before it reaches the end. That cause the far point or near point been judged fail.
		 53     -     .tag("suite:java_parity")
		 54     -     .tag(GameTest.Tags.suiteDisabled); // Could not set fire block in the air even I use pulseRedstone() the machine didn't move.
		    110 +   .tag(GameTest.Tags.suiteDisabled); // Unstable
		 55     - 
		 56 111   
		    112 + GameTest.register("FlyingMachineTests", "machine_f", (test) => {
		    113 +   const triggerPos = new BlockLocation(4, 6, 1);
		 57     - GameTest.register("FlyingMachineTests", "machine_d", (test) => {
		 58     -     const triggerPos = new BlockLocation(3, 7, 3);
		    114 +   const farPos = new BlockLocation(3, 4, 8);
		    115 +   const dropPos = new BlockLocation(3, 4, 6);
		    116 +   const nearPos = new BlockLocation(3, 4, 1);
		 59     -     const dropPos = new BlockLocation(5, 5, 2);
		 60     -     const farPos = new BlockLocation(2, 5, 8);
		 61     -     const nearPos = new BlockLocation(3, 5, 1);
		 62 117   
		    118 +   test
		    119 +     .startSequence()
		 63     -     test.startSequence()
		 64     -         .thenExecute(() => { test.setBlock(Blocks.fire(), triggerPos); })
		    120 +     .thenExecute(() => {
		    121 +       test.setBlockType(BlockTypes.fire, triggerPos);
		    122 +     })
		    123 +     .thenExecuteAfter(18, () => {
		    124 +       test.assertBlockTypePresent(BlockTypes.slime, farPos);
		    125 +     })
		    126 +     .thenExecuteAfter(40, () => {
		    127 +       test.assertBlockTypePresent(BlockTypes.slime, dropPos);
		    128 +       test.assertBlockTypePresent(BlockTypes.slime, nearPos);
		    129 +     })
		    130 +     .thenSucceed();
		    131 + })
		    132 +   .tag("suite:java_parity")
		    133 +   .tag(GameTest.Tags.suiteDisabled); // Unstable, when noFinishingSequence appears, it failed.
		 65     -         .thenExecuteAfter(16, () => {
		 66     -             test.assertBlockPresent(Blocks.slime(), dropPos);
		 67     -             test.assertBlockPresent(Blocks.slime(), farPos);
		 68     -         })
		 69     -         .thenSucceed();
		 70     - })
		 71     -     .tag("suite:java_parity")
		 72     -     .tag(GameTest.Tags.suiteDisabled);  // Can't fly as a whole thing as expectation
		 73     - 
		 74     - 
		 75     - GameTest.register("FlyingMachineTests", "machine_e", (test) => {
		 76     -     const triggerPos = new BlockLocation(1, 2, 1);
		 77     -     const farPos = new BlockLocation(1, 11, 1);
		 78     -     const nearPos = new BlockLocation(1, 3, 1);
		 79 134   
		 80     -     test.startSequence()
		 81     -         .thenExecute(() => { test.setBlock(Blocks.dirt(), triggerPos); })
		 82     -         .thenExecuteAfter(16, () => { test.assertBlockPresent(Blocks.honeyBlock(), farPos); })
		 83     -         .thenExecuteAfter(20, () => { test.assertBlockPresent(Blocks.observer(), nearPos); })
		    135 + GameTest.register("FlyingMachineTests", "machine_g", (test) => {
		    136 +   const triggerPos = new BlockLocation(1, 3, 0);
		    137 +   const farPos = new BlockLocation(2, 3, 6);
		    138 +   const nearPos = new BlockLocation(1, 3, 1);
		 84     -         .thenSucceed();
		 85     - })
		 86     -     .tag("suite:java_parity") // The behavior is different between Java and Bedrock. In Java the flying machine move forward to the end and then returns to its original position, but in Bedrock it returns before it reaches the end. That cause the far point or near point been judged fail.
		 87     -     .tag(GameTest.Tags.suiteDisabled); // Unstable
		 88     - 
		 89 139   
		    140 +   test
		    141 +     .startSequence()
		    142 +     .thenExecute(() => {
		    143 +       test.pulseRedstone(triggerPos, 2);
		    144 +     })
		    145 +     .thenExecuteAfter(16, () => {
		    146 +       test.assertBlockTypePresent(BlockTypes.slime, farPos);
		    147 +     })
		    148 +     .thenExecuteAfter(20, () => {
		    149 +       test.assertBlockTypePresent(BlockTypes.observer, nearPos);
		    150 +     })
		    151 +     .thenSucceed();
		    152 + })
		    153 +   .tag("suite:java_parity")
		    154 +   .tag(GameTest.Tags.suiteDisabled); // Could not set fire in the air, so I use pulseRedstone to active the observer. It's 50% pass rate.
		    155 + 
		    156 + GameTest.register("FlyingMachineTests", "machine_h", (test) => {
		    157 +   const triggerPos = new BlockLocation(1, 4, 0);
		    158 +   const farPos = new BlockLocation(1, 3, 8);
		    159 +   const dropPos = new BlockLocation(1, 3, 7);
		    160 +   const nearPos = new BlockLocation(1, 4, 1);
		 90     - GameTest.register("FlyingMachineTests", "machine_f", (test) => {
		 91     -     const triggerPos = new BlockLocation(4, 6, 1);
		 92     -     const farPos = new BlockLocation(3, 4, 8);
		 93     -     const dropPos = new BlockLocation(3, 4, 6);
		 94     -     const nearPos = new BlockLocation(3, 4, 1);
		 95     - 
		 96     -     test.startSequence()
		 97     -         .thenExecute(() => { test.setBlock(Blocks.fire(), triggerPos); })
		 98     -         .thenExecuteAfter(18, () => { test.assertBlockPresent(Blocks.slime(), farPos) })
		 99     -         .thenExecuteAfter(40, () => {
		100     -             test.assertBlockPresent(Blocks.slime(), dropPos);
		101     -             test.assertBlockPresent(Blocks.slime(), nearPos);
		102     -         })
		103     -         .thenSucceed();
		104     - })
		105     -     .tag("suite:java_parity")
		106     -     .tag(GameTest.Tags.suiteDisabled);  // Unstable, when noFinishingSequence appears, it failed.
		107     - 
		108 161   
		    162 +   test
		    163 +     .startSequence()
		109     - GameTest.register("FlyingMachineTests", "machine_g", (test) => {
		    164 +     .thenExecute(() => {
		    165 +       test.pulseRedstone(triggerPos, 2);
		    166 +     })
		    167 +     .thenExecuteAfter(20, () => {
		    168 +       test.assertBlockTypePresent(BlockTypes.slime, farPos);
		    169 +     })
		    170 +     .thenExecuteAfter(20, () => {
		    171 +       test.assertBlockTypePresent(BlockTypes.slime, dropPos);
		    172 +       test.assertBlockTypePresent(BlockTypes.observer, nearPos);
		    173 +     })
		    174 +     .thenSucceed();
		110     -     const triggerPos = new BlockLocation(1, 3, 0);
		111     -     const farPos = new BlockLocation(2, 3, 6);
		112     -     const nearPos = new BlockLocation(1, 3, 1);
		113     - 
		114     -     test.startSequence()
		115     -         .thenExecute(() => {
		116     -             test.pulseRedstone(triggerPos, 2);
		117     -         })
		118     -         .thenExecuteAfter(16, () => { test.assertBlockPresent(Blocks.slime(), farPos) })
		119     -         .thenExecuteAfter(20, () => { test.assertBlockPresent(Blocks.observer(), nearPos) })
		120     -         .thenSucceed();
		121 175   })
		    176 +   .tag("suite:java_parity")
		122     -     .tag("suite:java_parity")
		123     -     .tag(GameTest.Tags.suiteDisabled); // Could not set fire in the air, so I use pulseRedstone to active the observer. It's 50% pass rate.
		    177 +   .tag(GameTest.Tags.suiteDisabled); // Could not set fire in the air, so I use pulseRedstone to active the observer, pass rate is less than 10%, the sticky-piston always unstick.
		124     - 
		125 178   
		    179 + GameTest.register("FlyingMachineTests", "machine_i", (test) => {
		126     - GameTest.register("FlyingMachineTests", "machine_h", (test) => {
		127     -     const triggerPos = new BlockLocation(1, 4, 0);
		    180 +   const triggerPos = new BlockLocation(4, 2, 1);
		    181 +   const farPos = new BlockLocation(3, 8, 1);
		    182 +   const nearPos = new BlockLocation(4, 3, 1);
		128     -     const farPos = new BlockLocation(1, 3, 8);
		129     -     const dropPos = new BlockLocation(1, 3, 7);
		130     -     const nearPos = new BlockLocation(1, 4, 1);
		131 183   
		    184 +   test
		    185 +     .startSequence()
		    186 +     .thenExecute(() => {
		132     -     test.startSequence()
		    187 +       test.setBlockType(BlockTypes.dirt, triggerPos);
		    188 +     })
		    189 +     .thenExecuteAfter(18, () => {
		    190 +       test.assertBlockTypePresent(BlockTypes.honeyBlock, farPos);
		    191 +     })
		    192 +     .thenExecuteAfter(18, () => {
		    193 +       test.assertBlockTypePresent(BlockTypes.observer, nearPos);
		    194 +     })
		    195 +     .thenSucceed();
		133     -         .thenExecute(() => {
		134     -             test.pulseRedstone(triggerPos, 2);
		135     -         })
		136     -         .thenExecuteAfter(20, () => { test.assertBlockPresent(Blocks.slime(), farPos) })
		137     -         .thenExecuteAfter(20, () => {
		138     -             test.assertBlockPresent(Blocks.slime(), dropPos);
		139     -             test.assertBlockPresent(Blocks.observer(), nearPos);
		140     -         })
		141     -         .thenSucceed();
		142 196   })
		    197 +   .tag("suite:java_parity") // The behavior is different between Java and Bedrock. In Java the flying machine move forward to the end and then returns to its original position, but in Bedrock it returns before it reaches the end. That cause the far point or near point been judged fail.
		143     -     .tag("suite:java_parity")
		144     -     .tag(GameTest.Tags.suiteDisabled); // Could not set fire in the air, so I use pulseRedstone to active the observer, pass rate is less than 10%, the sticky-piston always unstick.
		    198 +   .tag(GameTest.Tags.suiteDisabled); // Unstable.
		145     - 
		146 199   
		    200 + GameTest.register("FlyingMachineTests", "m_bedrock", (test) => {
		    201 +   // For bedrock. Follow the simple engine 1
		147     - GameTest.register("FlyingMachineTests", "machine_i", (test) => {
		    202 +   const triggerPos = new BlockLocation(0, 3, 0);
		    203 +   const sourcePos = new BlockLocation(1, 3, 0);
		    204 +   const targetPos = new BlockLocation(8, 3, 1);
		148     -     const triggerPos = new BlockLocation(4, 2, 1);
		149     -     const farPos = new BlockLocation(3, 8, 1);
		150     -     const nearPos = new BlockLocation(4, 3, 1);
		151 205   
		    206 +   test
		    207 +     .startSequence()
		    208 +     .thenExecute(() => {
		152     -     test.startSequence()
		    209 +       test.assertBlockTypePresent(BlockTypes.slime, sourcePos);
		    210 +       test.assertBlockTypeNotPresent(BlockTypes.slime, targetPos);
		    211 +       test.setBlockType(BlockTypes.redstoneBlock, triggerPos);
		    212 +     })
		    213 +     .thenExecuteAfter(10, () => {
		    214 +       test.assertBlockTypeNotPresent(BlockTypes.slime, sourcePos);
		    215 +     })
		    216 +     .thenExecuteAfter(10, () => {
		    217 +       test.assertBlockTypePresent(BlockTypes.slime, targetPos);
		    218 +     })
		    219 +     .thenSucceed();
		    220 + }).tag(GameTest.Tags.suiteDefault);
		153     -         .thenExecute(() => { test.setBlock(Blocks.dirt(), triggerPos) })
		154     -         .thenExecuteAfter(18, () => { test.assertBlockPresent(Blocks.honeyBlock(), farPos) })
		155     -         .thenExecuteAfter(18, () => { test.assertBlockPresent(Blocks.observer(), nearPos) })
		156     -         .thenSucceed();
		157     - })
		158     -     .tag("suite:java_parity")  // The behavior is different between Java and Bedrock. In Java the flying machine move forward to the end and then returns to its original position, but in Bedrock it returns before it reaches the end. That cause the far point or near point been judged fail.
		159     -     .tag(GameTest.Tags.suiteDisabled); // Unstable.
		160     - 
		161     - GameTest.register("FlyingMachineTests", "m_bedrock", (test) => { // For bedrock. Follow the simple engine 1
		162     -     const triggerPos = new BlockLocation(0, 3, 0);
		163     -     const sourcePos = new BlockLocation(1, 3, 0);
		164     -     const targetPos = new BlockLocation(8, 3, 1);
		165 221   
		    222 + GameTest.register("FlyingMachineTests", "m2_bedrock", (test) => {
		166     -     test.startSequence()
		167     -         .thenExecute(() => {
		    223 +   // For bedrock. Follow the simple engine 2
		    224 +   const triggerPos = new BlockLocation(0, 3, 1);
		    225 +   const sourcePos = new BlockLocation(2, 3, 0);
		    226 +   const targetPos = new BlockLocation(6, 3, 1);
		    227 + 
		    228 +   test
		    229 +     .startSequence()
		    230 +     .thenExecute(() => {
		    231 +       test.assertBlockTypePresent(BlockTypes.slime, sourcePos);
		168     -             test.assertBlockPresent(Blocks.slime(), sourcePos);
		169     -             test.assertBlockNotPresent(Blocks.slime(), targetPos);
		170     -             test.setBlock(Blocks.redstoneBlock(), triggerPos);
		171     -         })
		172     -         .thenExecuteAfter(10, () => { test.assertBlockNotPresent(Blocks.slime(), sourcePos) })
		173     -         .thenExecuteAfter(10, () => { test.assertBlockPresent(Blocks.slime(), targetPos) })
		174     -         .thenSucceed();
		175     - })
		176     -     .tag(GameTest.Tags.suiteDefault);
		177     - 
		    232 +       test.assertBlockTypeNotPresent(BlockTypes.slime, targetPos);
		    233 +       test.setBlockType(BlockTypes.redstoneBlock, triggerPos);
		    234 +     })
		    235 +     .thenExecuteAfter(10, () => {
		    236 +       test.assertBlockTypeNotPresent(BlockTypes.slime, sourcePos);
		    237 +     })
		    238 +     .thenExecuteAfter(10, () => {
		    239 +       test.assertBlockTypePresent(BlockTypes.slime, targetPos);
		    240 +     })
		    241 +     .thenSucceed();
		    242 + }).tag(GameTest.Tags.suiteDefault);
		    243 + 
		    244 + GameTest.register("FlyingMachineTests", "m3_bedrock", (test) => {
		    245 +   // for bedrock. Follow the simple engine 2 with trailer
		    246 +   const triggerPos = new BlockLocation(1, 3, 2);
		    247 +   const sourcePos = new BlockLocation(4, 3, 2);
		    248 +   const targetPos = new BlockLocation(7, 3, 2);
		178     - 
		179     - GameTest.register("FlyingMachineTests", "m2_bedrock", (test) => { // For bedrock. Follow the simple engine 2
		180     -     const triggerPos = new BlockLocation(0, 3, 1);
		181     -     const sourcePos = new BlockLocation(2, 3, 0);
		182     -     const targetPos = new BlockLocation(6, 3, 1);
		183     - 
		184     -     test.startSequence()
		185     -         .thenExecute(() => {
		186     -             test.assertBlockPresent(Blocks.slime(), sourcePos);
		187     -             test.assertBlockNotPresent(Blocks.slime(), targetPos);
		188     -             test.setBlock(Blocks.redstoneBlock(), triggerPos);
		189     -         })
		190     -         .thenExecuteAfter(10, () => { test.assertBlockNotPresent(Blocks.slime(), sourcePos) })
		191     -         .thenExecuteAfter(10, () => { test.assertBlockPresent(Blocks.slime(), targetPos) })
		192     -         .thenSucceed();
		193     - })
		194     -     .tag(GameTest.Tags.suiteDefault);
		195 249   
		    250 +   test
		    251 +     .startSequence()
		196     - GameTest.register("FlyingMachineTests", "m3_bedrock", (test) => { // for bedrock. Follow the simple engine 2 with trailer
		197     -     const triggerPos = new BlockLocation(1, 3, 2);
		    252 +     .thenExecute(() => {
		    253 +       test.assertBlockTypePresent(BlockTypes.slime, sourcePos);
		198     -     const sourcePos = new BlockLocation(4, 3, 2);
		199     -     const targetPos = new BlockLocation(7, 3, 2);
		200     - 
		    254 +       test.assertBlockTypeNotPresent(BlockTypes.slime, targetPos);
		    255 +       test.setBlockType(BlockTypes.redstoneBlock, triggerPos);
		    256 +     })
		    257 +     .thenExecuteAfter(10, () => {
		    258 +       test.assertBlockTypeNotPresent(BlockTypes.slime, sourcePos);
		    259 +     })
		    260 +     .thenExecuteAfter(10, () => {
		    261 +       test.assertBlockTypePresent(BlockTypes.slime, targetPos);
		    262 +     })
		    263 +     .thenSucceed();
		    264 + }).tag(GameTest.Tags.suiteDisabled); // Unstable, the pass rate is 85%
		201     -     test.startSequence()
		202     -         .thenExecute(() => {
		203     -             test.assertBlockPresent(Blocks.slime(), sourcePos);
		204     -             test.assertBlockNotPresent(Blocks.slime(), targetPos);
		205     -             test.setBlock(Blocks.redstoneBlock(), triggerPos);
		206     -         })
		207     -         .thenExecuteAfter(10, () => { test.assertBlockNotPresent(Blocks.slime(), sourcePos) })
		208     -         .thenExecuteAfter(10, () => { test.assertBlockPresent(Blocks.slime(), targetPos) })
		209     -         .thenSucceed();
		210     - })
		211     -     .tag(GameTest.Tags.suiteDisabled); // Unstable, the pass rate is 85%
		          '''
	Changed script "Main.js":
		Total line: 18 (+2, -0)
		        '''
		        ...
		12 12   import "scripts/MinecartTests.js";
		13 13   import "scripts/MobTests.js";
		14 14   import "scripts/PathFindingTests.js";
		15 15   import "scripts/FlyingMachineTests.js";
		16 16   import "scripts/PistonTests.js";
		   17 + import "scripts/TntTests.js";
		   18 + import "scripts/SmallMobTests.js";
		        '''
	Changed script "MinecartTests.js":
		Total line: 214 (+83, -84)
		          '''
		  1   1   import * as GameTest from "GameTest";
		      2 + import { BlockLocation, BlockTypes } from "Minecraft";
		  2     - import { BlockLocation, Blocks } from "Minecraft";
		  3   3   
		  4   4   GameTest.register("MinecartTests", "turn", (test) => {
		      5 +   const minecartEntityType = "minecart";
		  5     -     const minecartEntityType = "minecart";
		  6   6   
		      7 +   const endPos = new BlockLocation(1, 2, 2);
		      8 +   const startPos = new BlockLocation(1, 2, 0);
		  7     -     const endPos = new BlockLocation(1, 2, 2);
		  8     -     const startPos = new BlockLocation(1, 2, 0);
		  9   9   
		     10 +   test.assertEntityPresent(minecartEntityType, startPos);
		     11 +   test.assertEntityNotPresent(minecartEntityType, endPos);
		 10     -     test.assertEntityPresent(minecartEntityType, startPos);
		 11     -     test.assertEntityNotPresent(minecartEntityType, endPos);
		 12  12   
		     13 +   test.pressButton(new BlockLocation(0, 3, 0));
		 13     -     test.pressButton(new BlockLocation(0, 3, 0));
		 14  14   
		     15 +   test.succeedWhenEntityPresent(minecartEntityType, endPos);
		 15     -     test.succeedWhenEntityPresent(minecartEntityType, endPos);
		 16  16   }).tag(GameTest.Tags.suiteDefault);
		 17  17   
		 18  18   GameTest.register("MinecartTests", "furnace_corner", (test) => {
		     19 +   const furnaceMinecart = "furnace_minecart";
		 19     -     const furnaceMinecart = "furnace_minecart";
		 20  20   
		     21 +   const endPos = new BlockLocation(2, 2, 1);
		     22 +   const startPos = new BlockLocation(1, 2, 0);
		 21     -     const endPos = new BlockLocation(2, 2, 1);
		 22     -     const startPos = new BlockLocation(1, 2, 0);
		 23  23   
		     24 +   test.assertEntityPresent(furnaceMinecart, startPos);
		 24     -     test.assertEntityPresent(furnaceMinecart, startPos);
		 25  25   
		     26 +   test.succeedWhenEntityPresent(furnace_minecart, endPos);
		 26     -     test.succeedWhenEntityPresent(furnace_minecart, endPos);
		 27  27   })
		     28 +   .tag("suite:java_parity")
		     29 +   .tag(GameTest.Tags.suiteDisabled); //furnace_minecart doesn't exist in bedrock
		 28     -     .tag("suite:java_parity")
		 29     -     .tag(GameTest.Tags.suiteDisabled); //furnace_minecart doesn't exist in bedrock
		 30  30   
		 31  31   GameTest.register("MinecartTests", "detector_rail_slope", (test) => {
		     32 +   const poweredDetectorPos = new BlockLocation(2, 2, 1);
		     33 +   const ascendingSouth = 5;
		 32     -     const poweredDetectorPos = new BlockLocation(2, 2, 1);
		 33     -     const ascendingSouth = 5;
		     34 +   test.assertBlockTypePresent(BlockTypes.detectorRail, poweredDetectorPos);
		     35 +   test.assertBlockState("rail_direction", ascendingSouth, poweredDetectorPos);
		 34     -     test.assertBlockPresent(Blocks.detectorRail(), poweredDetectorPos);
		 35     -     test.assertBlockState("rail_direction", ascendingSouth, poweredDetectorPos);
		 36  36   
		     37 +   test.pressButton(new BlockLocation(0, 3, 3));
		 37     -     test.pressButton(new BlockLocation(0, 3, 3));
		 38     -     test.runAfterDelay(20, () => {
		     38 +   test.runAfterDelay(20, () => {
		     39 +     test.succeedWhen(() => {
		     40 +       test.assertBlockTypePresent(BlockTypes.detectorRail, poweredDetectorPos);
		     41 +       test.assertBlockState("rail_direction", ascendingSouth, poweredDetectorPos);
		 39     -         test.succeedWhen(() => {
		 40     -             test.assertBlockPresent(Blocks.detectorRail(), poweredDetectorPos);
		 41     -             test.assertBlockState("rail_direction", ascendingSouth, poweredDetectorPos);
		 42     -         });
		 43  42       });
		     43 +   });
		     44 + }).tag(GameTest.Tags.suiteDefault);
		 44     - }) .tag(GameTest.Tags.suiteDefault);
		 45  45   
		 46  46   GameTest.register("MinecartTests", "detector_rail_piston", (test) => {
		     47 +   const pistonRight = new BlockLocation(5, 3, 0);
		     48 +   const pistonLeft = new BlockLocation(0, 3, 0);
		 47     -     const pistonRight = new BlockLocation(5, 3, 0);
		 48     -     const pistonLeft = new BlockLocation(0, 3, 0);
		     49 +   const torchRight = new BlockLocation(3, 2, 0);
		     50 +   const torchLeft = new BlockLocation(2, 2, 0);
		     51 +   const ascendingNorth = 4;
		 49     -     const torchRight = new BlockLocation(3, 2, 0);
		 50     -     const torchLeft = new BlockLocation(2, 2, 0);
		 51     -     const ascendingNorth = 4;
		 52  52   
		     53 +   let minecart = undefined;
		     54 +   test
		 53     -     let minecart = undefined;
		     55 +     .startSequence()
		     56 +     .thenExecute(() => test.pulseRedstone(pistonRight, 1))
		     57 +     .thenExecuteAfter(3, () => test.pulseRedstone(pistonLeft, 1))
		     58 +     .thenExecuteAfter(3, () => {
		     59 +       test.assertBlockState("torch_facing_direction", ascendingNorth, torchRight);
		     60 +       test.assertBlockState("torch_facing_direction", ascendingNorth, torchLeft);
		     61 +       minecart = test.spawn("minecart", new BlockLocation(3, 3, 1));
		     62 +     })
		     63 +     .thenExecuteAfter(3, () => {
		     64 +       test.assertBlockState("torch_facing_direction", ascendingNorth, torchRight);
		     65 +       test.pulseRedstone(pistonRight, 1);
		     66 +     })
		     67 +     .thenExecuteAfter(7, () => {
		     68 +       test.assertBlockState("torch_facing_direction", ascendingNorth, torchRight);
		     69 +       test.assertBlockState("torch_facing_direction", ascendingNorth, torchLeft);
		     70 +       test.pulseRedstone(pistonLeft, 1);
		     71 +     })
		     72 +     .thenExecuteAfter(7, () => {
		     73 +       test.assertBlockState("torch_facing_direction", ascendingNorth, torchRight);
		     74 +       test.assertBlockState("torch_facing_direction", ascendingNorth, torchLeft);
		     75 +       minecart.kill();
		     76 +     })
		     77 +     .thenExecuteAfter(6, () => {
		     78 +       test.assertBlockState("torch_facing_direction", ascendingNorth, torchRight);
		     79 +       test.assertBlockState("torch_facing_direction", ascendingNorth, torchLeft);
		     80 +     })
		     81 +     .thenSucceed();
		 54     -     test.startSequence()
		 55     -         .thenExecute(() => test.pulseRedstone(pistonRight, 1))
		 56     -         .thenExecuteAfter(3, () => test.pulseRedstone(pistonLeft, 1))
		 57     -         .thenExecuteAfter(3, () => {
		 58     -             test.assertBlockState("torch_facing_direction", ascendingNorth, torchRight);
		 59     -             test.assertBlockState("torch_facing_direction", ascendingNorth, torchLeft);
		 60     -             minecart = test.spawn("minecart", new BlockLocation(3, 3, 1));
		 61     -         })
		 62     -         .thenExecuteAfter(3, () => {
		 63     -             test.assertBlockState("torch_facing_direction", ascendingNorth,torchRight);
		 64     -             test.pulseRedstone(pistonRight, 1);
		 65     -         })
		 66     -         .thenExecuteAfter(7, () => {
		 67     -             test.assertBlockState("torch_facing_direction", ascendingNorth, torchRight);
		 68     -             test.assertBlockState("torch_facing_direction", ascendingNorth, torchLeft);
		 69     -             test.pulseRedstone(pistonLeft, 1);
		 70     -         })
		 71     -         .thenExecuteAfter(7, () => {
		 72     -             test.assertBlockState("torch_facing_direction",ascendingNorth, torchRight);
		 73     -             test.assertBlockState("torch_facing_direction", ascendingNorth, torchLeft);
		 74     -             minecart.kill();
		 75     -         })
		 76     -         .thenExecuteAfter(6, () => {
		 77     -             test.assertBlockState("torch_facing_direction", ascendingNorth, torchRight);
		 78     -             test.assertBlockState("torch_facing_direction", ascendingNorth, torchLeft);
		 79     -         })
		 80     -         .thenSucceed();
		 81  82   })
		     83 +   .required(false)
		     84 +   .tag(GameTest.Tags.suiteDefault);
		 82     -     .required(false)
		 83     -     .tag(GameTest.Tags.suiteDefault) 
		 84  85   
		 85  86   function runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, entityType) {
		     87 +   test.assertEntityNotPresent(entityType, dryTrackEndPos);
		     88 +   test.assertEntityNotPresent(entityType, wetTrackEndPos);
		 86     -     test.assertEntityNotPresent(entityType, dryTrackEndPos);
		 87     -     test.assertEntityNotPresent(entityType, wetTrackEndPos);
		 88  89   
		     90 +   test.pressButton(buttonPos);
		 89     -     test.pressButton(buttonPos);
		 90  91   
		     92 +   test
		     93 +     .startSequence()
		 91     -     test
		 92     -         .startSequence()
		     94 +     .thenWait(() => test.assertEntityPresent(entityType, dryTrackEndPos))
		     95 +     .thenExecute(() => test.assertEntityNotPresent(entityType, wetTrackEndPos))
		     96 +     .thenWait(() => test.assertEntityPresent(entityType, wetTrackEndPos))
		     97 +     .thenSucceed();
		 93     -         .thenWait(() => test.assertEntityPresent(entityType, dryTrackEndPos))
		 94     -         .thenExecute(() => test.assertEntityNotPresent(entityType, wetTrackEndPos))
		 95     -         .thenWait(() => test.assertEntityPresent(entityType, wetTrackEndPos))
		 96     -         .thenSucceed();
		 97  98   }
		 98  99   
		 99 100   function runWaterSlowdown(test, entityType) {
		    101 +   const buttonPos = new BlockLocation(1, 4, 2);
		    102 +   const dryTrackEndPos = new BlockLocation(8, 3, 1);
		100     -     const buttonPos = new BlockLocation(1, 4, 2);
		101     -     const dryTrackEndPos = new BlockLocation(8, 3, 1);
		    103 +   const wetTrackEndPos = new BlockLocation(8, 3, 3);
		102     -     const wetTrackEndPos = new BlockLocation(8, 3, 3);
		103 104   
		    105 +   runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, entityType);
		104     -     runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, entityType);
		105 106   }
		106     - 
		107 107   
		108 108   GameTest.register("MinecartTests", "water_slowdown", (test) => {
		    109 +   runWaterSlowdown(test, "minecart");
		109     -     runWaterSlowdown(test, "minecart");
		110 110   })
		    111 +   .tag("suite:java_parity")
		    112 +   .tag(GameTest.Tags.suiteDisabled); //the minecart cannot slow down in water.
		111     -     .tag("suite:java_parity")
		112     -     .tag(GameTest.Tags.suiteDisabled); //the minecart cannot slow down in water.
		113 113   
		114 114   GameTest.register("MinecartTests", "water_slowdown_occupied_cart", (test) => {
		    115 +   runWaterSlowdown(test, "minecart");
		115     -     runWaterSlowdown(test, "minecart"); 
		116 116   })
		    117 +   .tag("suite:java_parity")
		    118 +   .tag(GameTest.Tags.suiteDisabled); //the minecart cannot slow down in water.
		117     -     .tag("suite:java_parity")
		118     -     .tag(GameTest.Tags.suiteDisabled);//the minecart cannot slow down in water.
		119 119   
		120 120   GameTest.register("MinecartTests", "water_slowdown_tnt_cart", (test) => {
		    121 +   runWaterSlowdown(test, "tnt_minecart");
		121     -     runWaterSlowdown(test, "tnt_minecart");
		122 122   })
		    123 +   .tag("suite:java_parity")
		    124 +   .tag(GameTest.Tags.suiteDisabled); //the tnt_minecart cannot slow down in water.
		123     -     .tag("suite:java_parity")
		124     -     .tag(GameTest.Tags.suiteDisabled);//the tnt_minecart cannot slow down in water.
		125 125   
		126 126   GameTest.register("MinecartTests", "water_slowdown_hopper_cart", (test) => {
		    127 +   runWaterSlowdown(test, "hopper_minecart");
		127     -     runWaterSlowdown(test, "hopper_minecart");
		128 128   })
		    129 +   .tag("suite:java_parity")
		    130 +   .tag(GameTest.Tags.suiteDisabled); //the hopper_minecart cannot slow down in water.
		129     -     .tag("suite:java_parity")
		130     -     .tag(GameTest.Tags.suiteDisabled);//the hopper_minecart cannot slow down in water.
		131 131   
		132 132   GameTest.register("MinecartTests", "water_slowdown_chest_cart", (test) => {
		    133 +   runWaterSlowdown(test, "chest_minecart");
		133     -     runWaterSlowdown(test, "chest_minecart");
		134 134   })
		    135 +   .tag("suite:java_parity")
		    136 +   .tag(GameTest.Tags.suiteDisabled); //the chest_minecart cannot slow down in water.
		135     -     .tag("suite:java_parity")
		136     -     .tag(GameTest.Tags.suiteDisabled);//the chest_minecart cannot slow down in water.
		137 137   
		138 138   GameTest.register("MinecartTests", "water_slowdown_commandblock_cart", (test) => {
		    139 +   runWaterSlowdown(test, "command_block_minecart");
		139     -     runWaterSlowdown(test, "command_block_minecart");
		140 140   })
		    141 +   .tag("suite:java_parity")
		    142 +   .tag(GameTest.Tags.suiteDisabled); //the command_block_minecart cannot slow down in water.
		141     -     .tag("suite:java_parity")
		142     -     .tag(GameTest.Tags.suiteDisabled);//the command_block_minecart cannot slow down in water.
		143 143   
		144 144   GameTest.register("MinecartTests", "water_slowdown_powered_furnace_cart", (test) => {
		    145 +   const buttonPos = new BlockLocation(1, 4, 4);
		    146 +   const dryTrackEndPos = new BlockLocation(7, 3, 1);
		145     -     const buttonPos = new BlockLocation(1, 4, 4);
		146     -     const dryTrackEndPos = new BlockLocation(7, 3, 1);
		    147 +   const wetTrackEndPos = new BlockLocation(7, 3, 7);
		    148 +   runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "furnace_minecart");
		147     -     const wetTrackEndPos = new BlockLocation(7, 3, 7);
		148     -     runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "furnace_minecart");
		149 149   })
		    150 +   .tag("suite:java_parity")
		    151 +   .tag(GameTest.Tags.suiteDisabled); //furnace_minecart doesn't exist in bedrock
		150     -     .tag("suite:java_parity")
		151     -     .tag(GameTest.Tags.suiteDisabled);//furnace_minecart doesn't exist in bedrock
		152 152   
		153 153   GameTest.register("MinecartTests", "water_slowdown_vertical", (test) => {
		    154 +   const buttonPos = new BlockLocation(1, 6, 2);
		    155 +   const dryTrackEndPos = new BlockLocation(3, 2, 1);
		154     -     const buttonPos = new BlockLocation(1, 6, 2);
		155     -     const dryTrackEndPos = new BlockLocation(3, 2, 1);
		    156 +   const wetTrackEndPos = new BlockLocation(3, 2, 3);
		    157 +   runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "minecart");
		156     -     const wetTrackEndPos = new BlockLocation(3, 2, 3);
		157     -     runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "minecart");
		158 158   })
		    159 +   .tag("suite:java_parity")
		    160 +   .tag(GameTest.Tags.suiteDisabled); //the minecart cannot slow down in water.
		159     -     .tag("suite:java_parity")
		160     -     .tag(GameTest.Tags.suiteDisabled);//the minecart cannot slow down in water.
		161 161   
		162 162   GameTest.register("MinecartTests", "water_slowdown_vertical_furnace", (test) => {
		    163 +   const buttonPos = new BlockLocation(1, 6, 2);
		    164 +   const dryTrackEndPos = new BlockLocation(3, 2, 1);
		163     -     const buttonPos = new BlockLocation(1, 6, 2);
		164     -     const dryTrackEndPos = new BlockLocation(3, 2, 1);
		    165 +   const wetTrackEndPos = new BlockLocation(3, 2, 3);
		    166 +   runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "furnace_minecart");
		165     -     const wetTrackEndPos = new BlockLocation(3, 2, 3);
		166     -     runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "furnace_minecart");
		167 167   })
		    168 +   .tag("suite:java_parity")
		    169 +   .tag(GameTest.Tags.suiteDisabled); //furnace_minecart doesn't exist in bedrock
		168     -     .tag("suite:java_parity")
		169     -     .tag(GameTest.Tags.suiteDisabled);//furnace_minecart doesn't exist in bedrock
		170 170   
		171 171   GameTest.register("MinecartTests", "water_slowdown_slope_down", (test) => {
		    172 +   const buttonPos = new BlockLocation(1, 6, 2);
		    173 +   const dryTrackEndPos = new BlockLocation(6, 2, 1);
		172     -     const buttonPos = new BlockLocation(1, 6, 2);
		173     -     const dryTrackEndPos = new BlockLocation(6, 2, 1);
		    174 +   const wetTrackEndPos = new BlockLocation(6, 2, 3);
		    175 +   runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "minecart");
		174     -     const wetTrackEndPos = new BlockLocation(6, 2, 3);
		175     -     runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "minecart");
		176 176   })
		    177 +   .tag("suite:java_parity")
		    178 +   .tag(GameTest.Tags.suiteDisabled); //the minecart cannot slow down in water.
		177     -     .tag("suite:java_parity")
		178     -     .tag(GameTest.Tags.suiteDisabled);//the minecart cannot slow down in water.
		179 179   
		180 180   GameTest.register("MinecartTests", "water_slowdown_slope_down_furnace", (test) => {
		    181 +   const buttonPos = new BlockLocation(1, 6, 2);
		    182 +   const dryTrackEndPos = new BlockLocation(6, 2, 1);
		181     -     const buttonPos = new BlockLocation(1, 6, 2);
		182     -     const dryTrackEndPos = new BlockLocation(6, 2, 1);
		    183 +   const wetTrackEndPos = new BlockLocation(6, 2, 3);
		    184 +   runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "furnace_minecart");
		183     -     const wetTrackEndPos = new BlockLocation(6, 2, 3);
		184     -     runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "furnace_minecart");
		185 185   })
		    186 +   .tag("suite:java_parity")
		    187 +   .tag(GameTest.Tags.suiteDisabled); //furnace_minecart doesn't exist in bedrock
		186     -     .tag("suite:java_parity")
		187     -     .tag(GameTest.Tags.suiteDisabled);//furnace_minecart doesn't exist in bedrock
		188 188   
		189 189   GameTest.register("MinecartTests", "water_slowdown_slope_up", (test) => {
		    190 +   const buttonPos = new BlockLocation(1, 3, 1);
		    191 +   const dryTrackEndPos = new BlockLocation(7, 5, 0);
		190     -     const buttonPos = new BlockLocation(1, 3, 1);
		191     -     const dryTrackEndPos = new BlockLocation(7, 5, 0);
		    192 +   const wetTrackEndPos = new BlockLocation(7, 5, 2);
		    193 +   runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "minecart");
		192     -     const wetTrackEndPos = new BlockLocation(7, 5, 2);
		193     -     runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "minecart");
		194 194   })
		    195 +   .tag("suite:java_parity")
		    196 +   .tag(GameTest.Tags.suiteDisabled); //the minecart cannot slow down in water.
		195     -     .tag("suite:java_parity")
		196     -     .tag(GameTest.Tags.suiteDisabled);//the minecart cannot slow down in water.
		197 197   
		198 198   GameTest.register("MinecartTests", "water_slowdown_powered_rail", (test) => {
		    199 +   const buttonPos = new BlockLocation(1, 3, 1);
		    200 +   const dryTrackEndPos = new BlockLocation(7, 5, 0);
		199     -     const buttonPos = new BlockLocation(1, 3, 1);
		200     -     const dryTrackEndPos = new BlockLocation(7, 5, 0);
		    201 +   const wetTrackEndPos = new BlockLocation(7, 5, 2);
		    202 +   runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "minecart");
		201     -     const wetTrackEndPos = new BlockLocation(7, 5, 2);
		202     -     runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "minecart");
		203 203   })
		    204 +   .tag("suite:java_parity")
		    205 +   .tag(GameTest.Tags.suiteDisabled); //the minecart cannot slow down in water.
		204     -     .tag("suite:java_parity")
		205     -     .tag(GameTest.Tags.suiteDisabled);//the minecart cannot slow down in water.
		206 206   
		207 207   GameTest.register("MinecartTests", "water_slowdown_powered_rail_furnace", (test) => {
		    208 +   const buttonPos = new BlockLocation(1, 3, 1);
		    209 +   const dryTrackEndPos = new BlockLocation(7, 2, 0);
		208     -     const buttonPos = new BlockLocation(1, 3, 1);
		209     -     const dryTrackEndPos = new BlockLocation(7, 2, 0);
		    210 +   const wetTrackEndPos = new BlockLocation(7, 2, 2);
		    211 +   runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "furnace_minecart");
		210     -     const wetTrackEndPos = new BlockLocation(7, 2, 2);
		211     -     runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, "furnace_minecart");
		212 212   })
		    213 +   .tag("suite:java_parity")
		213     -     .tag("suite:java_parity")
		214     -     .tag(GameTest.Tags.suiteDisabled);//furnace_minecart doesn't exist in bedrock
		    214 +   .tag(GameTest.Tags.suiteDisabled); //furnace_minecart doesn't exist in bedrock
		215     - 
		          '''
	Changed script "MobTests.js":
		Total line: 134 (+10, -35)
		          '''
		  1   1   import * as GameTest from "GameTest";
		  2   2   import GameTestExtensions from "./GameTestExtensions.js";
		  3     - import { BlockLocation, BlockStates,Effects , Blocks } from "Minecraft";
		  4     - 
		  5     - const TicksPerSecond = 20;
		  6     - 
		  7     - GameTest.register("MobTests", "zombie_burn", (test) => {
		  8     -   const zombieEntityType = "minecraft:zombie";
		  9     -   const zombiePosition = new BlockLocation(1, 2, 1);
		 10     - 
		 11     -   test.succeedWhenEntityNotPresent(zombieEntityType, zombiePosition);
		 12     - })
		 13     -   .maxTicks(TicksPerSecond * 30)
		 14     -   .tag(GameTest.Tags.suiteDefault)
		 15     -   .batch("day");
		 16     - 
		 17     - GameTest.register("MobTests", "effect_durations_longer_first", (test) => {
		 18     -   const villagerId = "minecraft:villager_v2";
		 19     -   const villagerPos = new BlockLocation(1, 2, 1);
		 20     -   const buttonPos = new BlockLocation(1, 4, 0);
		      3 + 
		      4 + import { BlockLocation, Effects, BlockTypes } from "Minecraft";
		 21     -   const strongPotion = new BlockLocation(0, 4, 0);
		 22     -   const weakPotion = new BlockLocation(2, 4, 0);
		 23   5   
		      6 + const TicksPerSecond = 20;
		 24     -   test.spawn(villagerId, villagerPos);
		 25   7   
		 26     -   test
		 27     -     .startSequence()
		 28     -     .thenExecute(() => test.setBlock(Blocks.air(), weakPotion))
		      8 + GameTest.register("MobTests", "zombie_burn", (test) => {
		      9 +   const zombieEntityType = "minecraft:zombie";
		     10 +   const zombiePosition = new BlockLocation(1, 2, 1);
		     11 + 
		     12 +   test.succeedWhenEntityNotPresent(zombieEntityType, zombiePosition);
		     13 + })
		     14 +   .maxTicks(TicksPerSecond * 30)
		     15 +   .tag(GameTest.Tags.suiteDefault)
		     16 +   .batch("day");
		     17 + 
		     18 + GameTest.register("MobTests", "effect_durations_longer_first", (test) => {
		     19 +   const villagerId = "minecraft:villager_v2";
		     20 +   const villagerPos = new BlockLocation(1, 2, 1);
		     21 +   const buttonPos = new BlockLocation(1, 4, 0);
		     22 +   const strongPotion = new BlockLocation(0, 4, 0);
		     23 +   const weakPotion = new BlockLocation(2, 4, 0);
		     24 + 
		     25 +   test.spawn(villagerId, villagerPos);
		 29     -     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		 30     -     .thenWait(() => test.assertBlockState("button_pressed_bit", 0, buttonPos))
		 31     -     .thenExecute(() => test.setBlock(Blocks.air(), strongPotion))
		 32     -     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		 33     -     .thenIdle(41)
		 34     -     .thenWait(() => {
		 35     -       test.assertEntityData(villagerPos, villagerId, (entity) => entity.getEffect(Effects.regeneration).getAmplifier() == 0); // Strength level I
		 36     -       test.assertEntityData(villagerPos, villagerId, (entity) => entity.getEffect(Effects.regeneration).getDuration() > 120); // At least 6 seconds remaining
		 37     -     })
		 38     -     .thenSucceed();
		 39     - })
		 40     -   .structureName("MobTests:effect_durations")
		 41     -   .tag("suite:java_parity")
		 42     -   .tag(GameTest.Tags.suiteDisabled); // Potions don't explode when shot from dispensers
		 43     -   
		 44     - GameTest.register("MobTests", "drowning_test", (test) => {
		 45     - 	const villagerEntitySpawnType = "minecraft:villager_v2";
		 46     - 	const pigSpawnType = "minecraft:pig";
		 47  26   
		 48     - 	test.spawn(villagerEntitySpawnType, new BlockLocation(3, 2, 2));
		 49     - 	test.spawn(pigSpawnType, new BlockLocation(3, 2, 4));
		 50     - 	test.succeedWhen(() => {
		     27 +   test
		     28 +     .startSequence()
		     29 +     .thenExecute(() => test.setBlockType(BlockTypes.air, weakPotion))
		     30 +     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		     31 +     .thenWait(() => test.assertBlockState("button_pressed_bit", 0, buttonPos))
		     32 +     .thenExecute(() => test.setBlockType(BlockTypes.air, strongPotion))
		     33 +     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		     34 +     .thenIdle(41)
		     35 +     .thenWait(() => {
		     36 +       test.assertEntityData(
		     37 +         villagerPos,
		     38 +         villagerId,
		     39 +         (entity) => entity.getEffect(Effects.regeneration).getAmplifier() == 0
		     40 +       ); // Strength level I
		     41 +       test.assertEntityData(
		     42 +         villagerPos,
		     43 +         villagerId,
		     44 +         (entity) => entity.getEffect(Effects.regeneration).getDuration() > 120
		     45 +       ); // At least 6 seconds remaining
		     46 +     })
		     47 +     .thenSucceed();
		 51     - 		test.assertEntityNotPresentInArea(pigSpawnType);
		 52     - 		test.assertEntityNotPresentInArea(villagerEntitySpawnType);
		 53     - 	});
		 54     - })  
		 55     - 	.maxTicks(TicksPerSecond * 45)
		 56     - 	.tag(GameTest.Tags.suiteDefault);
		 57     - 
		 58     - GameTest.register("MobTests", "golem_vs_pillager", (test) => {
		 59     -     const ironGolem = "minecraft:iron_golem";
		 60     -     const pillager = "minecraft:pillager";
		 61     -     const ironGolemPos = new BlockLocation(3, 2, 3);
		 62     -     const pillagerPos = new BlockLocation(3, 2, 4);
		 63     - 
		 64     - 
		 65     - 	test.spawn(ironGolem, ironGolemPos);
		 66     - 	test.spawn(pillager, pillagerPos);
		 67     - 
		 68     - 	test.succeedWhen(() => {
		 69     - 		test.assertEntityNotPresent(pillager, ironGolemPos);
		 70     - 		test.assertEntityPresent(ironGolem, pillagerPos);
		 71     - 	});
		 72  48   })
		     49 +   .structureName("MobTests:effect_durations")
		     50 +   .tag("suite:java_parity")
		     51 +   .tag(GameTest.Tags.suiteDisabled); // Potions don't explode when shot from dispensers
		 73     - 	.tag(GameTest.Tags.suiteDefault);
		 74  52   
		 75     - GameTest.register("MobTests", "effect_durations_stronger_first", (test) => {
		 76     -     const villagerId = "minecraft:villager_v2";
		 77     -     const villagerPos = new BlockLocation(1, 2, 1);
		     53 + GameTest.register("MobTests", "drowning_test", (test) => {
		     54 +   const villagerEntitySpawnType = "minecraft:villager_v2";
		     55 +   const pigSpawnType = "minecraft:pig";
		 78     -     const buttonPos = new BlockLocation(1, 4, 0);
		 79     -     const strongPotion = new BlockLocation(0, 4, 0);
		 80     -     const weakPotion = new BlockLocation(2, 4, 0);
		 81  56   
		     57 +   test.spawn(villagerEntitySpawnType, new BlockLocation(3, 2, 2));
		     58 +   test.spawn(pigSpawnType, new BlockLocation(3, 2, 4));
		     59 +   test.succeedWhen(() => {
		     60 +     test.assertEntityNotPresentInArea(pigSpawnType);
		 82     -     test.spawn(villagerId, villagerPos);
		 83     - 
		     61 +     test.assertEntityNotPresentInArea(villagerEntitySpawnType);
		     62 +   });
		     63 + })
		     64 +   .maxTicks(TicksPerSecond * 45)
		     65 +   .tag(GameTest.Tags.suiteDefault);
		     66 + 
		     67 + GameTest.register("MobTests", "golem_vs_pillager", (test) => {
		     68 +   const ironGolem = "minecraft:iron_golem";
		     69 +   const pillager = "minecraft:pillager";
		     70 +   const ironGolemPos = new BlockLocation(3, 2, 3);
		     71 +   const pillagerPos = new BlockLocation(3, 2, 4);
		     72 + 
		     73 +   test.spawn(ironGolem, ironGolemPos);
		     74 +   test.spawn(pillager, pillagerPos);
		     75 + 
		     76 +   test.succeedWhen(() => {
		     77 +     test.assertEntityNotPresent(pillager, ironGolemPos);
		     78 +     test.assertEntityPresent(ironGolem, pillagerPos);
		     79 +   });
		     80 + }).tag(GameTest.Tags.suiteDefault);
		     81 + 
		     82 + GameTest.register("MobTests", "effect_durations_stronger_first", (test) => {
		     83 +   const villagerId = "minecraft:villager_v2";
		     84 +   const villagerPos = new BlockLocation(1, 2, 1);
		     85 +   const buttonPos = new BlockLocation(1, 4, 0);
		     86 +   const strongPotion = new BlockLocation(0, 4, 0);
		     87 +   const weakPotion = new BlockLocation(2, 4, 0);
		     88 + 
		     89 +   test.spawn(villagerId, villagerPos);
		     90 + 
		     91 +   test
		     92 +     .startSequence()
		     93 +     .thenExecute(() => test.setBlockType(BlockTypes.air, strongPotion))
		     94 +     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		     95 +     .thenWait(() => test.assertBlockState("button_pressed_bit", 0, buttonPos))
		     96 +     .thenExecute(() => test.setBlockType(BlockTypes.air, weakPotion))
		     97 +     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		     98 +     .thenIdle(41)
		     99 +     .thenWait(() => {
		    100 +       test.assertEntityData(
		    101 +         villagerPos,
		    102 +         villagerId,
		    103 +         (entity) => entity.getEffect(Effects.regeneration).getAmplifier() == 0
		    104 +       ); // Strength level I
		    105 +       test.assertEntityData(
		    106 +         villagerPos,
		    107 +         villagerId,
		    108 +         (entity) => entity.getEffect(Effects.regeneration).getDuration() > 120
		    109 +       ); // At least 6 seconds remaining
		    110 +     })
		    111 +     .thenSucceed();
		 84     -     test
		 85     -     .startSequence()
		 86     -     .thenExecute(() => test.setBlock(Blocks.air(), strongPotion))
		 87     -     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		 88     -     .thenWait(() => test.assertBlockState("button_pressed_bit", 0, buttonPos))
		 89     -     .thenExecute(() => test.setBlock(Blocks.air(), weakPotion))
		 90     -     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		 91     -     .thenIdle(41)
		 92     -     .thenWait(() => {
		 93     -       test.assertEntityData(villagerPos, villagerId, (entity) => entity.getEffect(Effects.regeneration).getAmplifier() == 0); // Strength level I
		 94     -       test.assertEntityData(villagerPos, villagerId, (entity) => entity.getEffect(Effects.regeneration).getDuration() > 120); // At least 6 seconds remaining
		 95     -     })
		 96     -     .thenSucceed();
		 97     - })
		 98     -     .structureName("MobTests:effect_durations")
		 99     -     .tag("suite:java_parity")
		100     -     .tag(GameTest.Tags.suiteDisabled); // Potions don't explode when shot from dispensers
		101     -   
		102     - GameTest.register("MobTests", "silverfish_no_suffocate", (test) => {
		103     -     const silverfishPos = new BlockLocation(1, 2, 1);
		104     -     const silverfish = "minecraft:silverfish";
		105     - 	
		106     -     test.startSequence()
		107     -         .thenExecute(() => test.assertEntityHasComponent(silverfish, "minecraft:health", silverfishPos, true))
		108     -         .thenIdle(40)
		109     -         .thenExecute(() => test.assertEntityHasComponent(silverfish, "minecraft:health", silverfishPos, true))
		110     -         .thenSucceed();
		111     -     test.startSequence()
		112     -         .thenWait(() => test.assertEntityNotPresent(silverfish, silverfishPos))
		113     -         .thenFail("Silverfish died");
		114     - })
		115     -    .maxTicks(TicksPerSecond * 30)
		116     -    .required(false)
		117     - 	.tag(GameTest.Tags.suiteDefault);
		118     - 
		119     - GameTest.register("MobTests", "small_mobs_keep_head_above_water", (test) => { 
		120     - 	const testEx = new GameTestExtensions(test);
		121     - 	const swimmerPos = new BlockLocation(1, 3, 1);//When the silverfish is produced at (1, 2, 1), the silverfish is stuck in the glass below and dies, so the y-axis goes up one frame
		122     - 	const swimmer = test.spawn("minecraft:silverfish", swimmerPos);
		123     - 	
		124     - 	const drownerPos = new BlockLocation(5, 2, 1);
		125     - 	const drowner = test.spawn("minecraft:silverfish", drownerPos);
		126     - 	
		127     - 	testEx.makeAboutToDrown(swimmer);
		128     - 	testEx.makeAboutToDrown(drowner);
		129     - 	
		130     - 	test.startSequence()
		131     - 		.thenIdle(40)
		132     - 		.thenExecute(() => test.assertEntityPresent("minecraft:silverfish", swimmerPos))
		133     - 		.thenExecute(() => test.assertEntityNotPresent("minecraft:silverfish", drownerPos))
		134     - 		.thenSucceed();
		135 112   })
		136     - 	.tag(GameTest.Tags.suiteDefault);
		137     - 
		138     - GameTest.register("MobTests", "small_mobs_breathe_in_boats", (test) => { 
		139     - 	const testEx = new GameTestExtensions(test);
		    113 +   .structureName("MobTests:effect_durations")
		    114 +   .tag("suite:java_parity")
		    115 +   .tag(GameTest.Tags.suiteDisabled); // Potions don't explode when shot from dispensers
		    116 + 
		    117 + GameTest.register("MobTests", "silverfish_no_suffocate", (test) => {
		    118 +   const silverfishPos = new BlockLocation(1, 2, 1);
		    119 +   const silverfish = "minecraft:silverfish";
		    120 + 
		    121 +   test
		    122 +     .startSequence()
		    123 +     .thenExecute(() => test.assertEntityHasComponent(silverfish, "minecraft:health", silverfishPos, true))
		    124 +     .thenIdle(40)
		    125 +     .thenExecute(() => test.assertEntityHasComponent(silverfish, "minecraft:health", silverfishPos, true))
		    126 +     .thenSucceed();
		    127 +   test
		    128 +     .startSequence()
		    129 +     .thenWait(() => test.assertEntityNotPresent(silverfish, silverfishPos))
		    130 +     .thenFail("Silverfish died");
		140     - 	const catPos = new BlockLocation(2, 3, 2);
		141     - 	const cat = testEx.addEntityInBoat("minecraft:cat", catPos);
		142     - 	testEx.makeAboutToDrown(cat);
		143     - 	
		144     - 	const silverfishPos = new BlockLocation(4, 3, 2);
		145     - 	const silverfish = testEx.addEntityInBoat("minecraft:silverfish", silverfishPos);
		146     - 	testEx.makeAboutToDrown(silverfish);
		147     - 	
		148     - 	const underWaterPos = new BlockLocation(6, 2, 2);
		149     - 	const silverfish2 = testEx.addEntityInBoat("minecraft:silverfish", underWaterPos);
		150     - 	testEx.makeAboutToDrown(silverfish2);
		151     - 	
		152     - 	test.startSequence()
		153     - 		.thenIdle(40)
		154     - 		.thenExecute(() => test.assertEntityPresent("minecraft:cat", catPos))
		155     - 		.thenExecute(() => test.assertEntityPresent("minecraft:silverfish", silverfishPos))
		156     - 		.thenExecute(() => test.assertEntityNotPresent("minecraft:silverfish", underWaterPos))
		157     - 		.thenSucceed();
		158 131   })
		    132 +   .maxTicks(TicksPerSecond * 30)
		    133 +   .required(false)
		    134 +   .tag(GameTest.Tags.suiteDefault);
		159     - 	.tag(GameTest.Tags.suiteDefault);
		          '''
	Changed script "PathFindingTests.js":
		Total line: 389 (+58, -79)
		          '''
		  1   1   import * as GameTest from "GameTest";
		      2 + import { BlockTypes, BlockProperties, BlockLocation } from "Minecraft";
		  2     - import { Blocks, BlockStates, BlockLocation } from "Minecraft";
		  3   3   
		  4   4   ///
		  5   5   // Setup constants
		  6   6   ///
		  7   7   const VERTICAL_TEST_TEMPLATE_NAME = "PathFindingTests:veritcal_template";
		  8   8   const VERTICAL_TEST_MAX_TICKS = 900; // This value may need to be increased if additional villager tests are added since village POI search is time sliced across all villagers
		  9   9   const VERTICAL_TEST_STARTUP_TICKS = 0;
		 10  10   const VERTICAL_TEST_PADDING = 100; // Space these tests apart so that villagers aren't assigned beds from nearby tests. Villages need to be kept separate.
		 11  11   const TEST_MAX_TICKS = 900; //This value is used for other four tests except vertical tests.
		     12 + const TEST_PADDING = 100; //Space other four tests except vertical tests apart so that villagers aren't assigned beds from nearby tests.
		 12     - const TEST_PADDING = 100; //Space other four tests except vertical tests apart so that villagers aren't assigned beds from nearby tests. 
		 13  13   
		 14  14   // Here we can define small vertical obstacle courses. Villager moves from left to right.
		 15  15   const VERTICAL_TEST_PLACEMENT_MAP = [
		 16  16     ["^^##  ", "  ^^  ", "    ^^", "######"],
		 17  17     ["  ^^^^", "      ", "  ^^  ", "######"],
		 18  18     ["  ####", "      ", "      ", "____##", "######"],
		 19  19   ];
		 20  20   
		 21  21   function placeBottomSlab(test, pos) {
		     22 +   const blockPermutation = BlockTypes.stoneSlab.createDefaultBlockPermutation();
		     23 +   blockPermutation.getProperty(BlockProperties.stoneSlabType).value = "stone_brick";
		 22     -   const blockType = Blocks.stoneSlab();
		 23     -   blockType.setState(BlockStates.stoneSlabType("stoneBrick"));
		     24 +   test.setBlockPermutation(blockPermutation, pos);
		 24     -   test.setBlock(blockType, pos);
		 25  25   }
		 26  26   
		 27  27   function placeTopSlab(test, pos) {
		     28 +   const blockPermutation = BlockTypes.stoneSlab.createDefaultBlockPermutation();
		     29 +   blockPermutation.getProperty(BlockProperties.stoneSlabType).value = "stone_brick";
		 28     -   const blockType = Blocks.stoneSlab();
		 29     -   blockType.setState(BlockStates.stoneSlabType("stoneBrick"));
		     30 +   blockPermutation.getProperty(BlockProperties.topSlotBit).value = true;
		     31 +   test.setBlockPermutation(blockPermutation, pos);
		 30     -   blockType.setState(BlockStates.topSlotBit(true));
		 31     -   test.setBlock(blockType, pos);
		 32  32   }
		 33  33   
		 34  34   function placeBlock(test, pos) {
		     35 +   test.setBlockType(BlockTypes.stonebrick, pos);
		 35     -   const blockType = Blocks.stonebrick();
		 36     -   test.setBlock(blockType, pos);
		 37  36   }
		 38  37   
		 39  38   /*
		 40  39     Places out blocks matching the given pattern (viewed from the side).
		 41  40     The bottom row (last string in the array) will match the floor level in the structure.
		          ...
		 63  62         // one block, for example __ (2 chars wide)
		 64  63   
		 65  64         // Figure out which type of block to place (full block, bottom slab, or top slab)
		 66  65         const mapChar = mapRow[mapColIndex];
		 67  66         if (mapChar != " ") {
		     67 +         const blockPerm = getBlockPermutationForMapChar(mapChar);
		 68     -         const block = getBlockStateForMapChar(mapChar);
		 69  68   
		 70  69           // Place two next to each other
		 71  70           for (let currentZ = spawnZ; currentZ >= spawnZ - 1; --currentZ) {
		     71 +           test.setBlockPermutation(blockPerm, new BlockLocation(currentX, currentY, currentZ));
		 72     -           test.setBlock(block, new BlockLocation(currentX, currentY, currentZ));
		 73  72           }
		 74  73         }
		 75  74         --currentX;
		 76  75       }
		 77  76       ++currentY;
		          ...
		 85  84     Here's what the strings mean.
		 86  85   
		 87  86     block: ##
		 88  87     top slab: ""
		 89  88     bottom slab: __
		 90     - 
		 91     -   --------------------------------------------------------------------
		 92  89   
		 93     -             |         |__       |##
		 94     -             |####     |####     |####
		 95     -   floor1:    none      0.5       1
		 96  90     --------------------------------------------------------------------
		 97  91   
		     92 +             |         |__       |##
		 98     -             |         |  __     |  ##
		 99  93               |####     |####     |####
		     94 +   floor1:    none      0.5       1
		100     -   floor2:    none      0.5       1
		101  95     --------------------------------------------------------------------
		102  96   
		     97 +             |         |  __     |  ##
		103     -             |         |         |  __     |  ^^     |  ##
		104     -             |         |  ^^     |         |         |
		     98 +             |####     |####     |####
		     99 +   floor2:    none      0.5       1
		105     -             |####     |####     |####     |####     |####
		106     -   mid2:      none      0.5 slab  1 slab    1.5 slab  1 full
		107 100     --------------------------------------------------------------------
		108 101   
		    102 +             |         |         |  __     |  ^^     |  ##
		109     -             |         |  ##     |  ##     |  ##     |  ##     |  ^^
		110     -             |         |  ##     |  ##     |  ^^     |         |
		    103 +             |         |  ^^     |         |         |
		    104 +             |####     |####     |####     |####     |####
		    105 +   mid2:      none      0.5 slab  1 slab    1.5 slab  1 full
		111     -             |         |  ^^     |         |         |         |
		112     -             |####     |####     |####     |####     |####     |####
		113     -   ceiling:   none      0.5       1         1.5       2         2.5
		114 106     --------------------------------------------------------------------
		115     - */
		116     - function placeBlocks(test, floor1, floor2, mid2, ceiling2) {
		117     -   const spawnPos = new BlockLocation(5, 2, 4);
		118 107   
		    108 +             |         |  ##     |  ##     |  ##     |  ##     |  ^^
		    109 +             |         |  ##     |  ##     |  ^^     |         |
		119     -   // we place two of each block, at z and z-1.
		    110 +             |         |  ^^     |         |         |         |
		    111 +             |####     |####     |####     |####     |####     |####
		    112 +   ceiling:   none      0.5       1         1.5       2         2.5
		    113 +   --------------------------------------------------------------------
		    114 + */
		    115 + function placeBlocks(test, floor1, floor2, mid2, ceiling2) {
		    116 +   const spawnPos = new BlockLocation(5, 2, 4);
		120     -   for (let zOffset = 0; zOffset >= -1; --zOffset) {
		121     -     // floor1 defines how high the block is where the villager spawns
		122     -     if (floor1 == "0.5") {
		123     -       placeBottomSlab(test, spawnPos.offset(0, 0, zOffset));
		124     -     } else if (floor1 == "1") {
		125     -       placeBlock(test, spawnPos.offset(0, 0, zOffset));
		126     -     }
		127 117   
		    118 +   // we place two of each block, at z and z-1.
		    119 +   for (let zOffset = 0; zOffset >= -1; --zOffset) {
		    120 +     // floor1 defines how high the block is where the villager spawns
		128     -     // floor2 defines the height of the position to the right of the villager spawn
		    121 +     if (floor1 == "0.5") {
		    122 +       placeBottomSlab(test, spawnPos.offset(0, 0, zOffset));
		    123 +     } else if (floor1 == "1") {
		    124 +       placeBlock(test, spawnPos.offset(0, 0, zOffset));
		129     -     if (floor2 == "0.5") {
		130     -       placeBottomSlab(test, spawnPos.offset(-1, 0, zOffset));
		131     -     } else if (floor2 == "1") {
		132     -       placeBlock(test, spawnPos.offset(-1, 0, zOffset));
		133 125       }
		134 126   
		135     -     // mid2 defines any mid-level block in the position to the right of the villager spawn
		136     -     if (mid2 == "0.5 slab") {
		137     -       placeTopSlab(test, spawnPos.offset(-1, 0, zOffset));
		138     -     } else if (mid2 == "1 slab") {
		    127 +     // floor2 defines the height of the position to the right of the villager spawn
		    128 +     if (floor2 == "0.5") {
		    129 +       placeBottomSlab(test, spawnPos.offset(-1, 0, zOffset));
		    130 +     } else if (floor2 == "1") {
		    131 +       placeBlock(test, spawnPos.offset(-1, 0, zOffset));
		139     -       placeBottomSlab(test, spawnPos.offset(-1, 1, zOffset));
		140     -     } else if (mid2 == "1.5 slab") {
		141     -       placeTopSlab(test, spawnPos.offset(-1, 1, zOffset));
		142     -     } else if (mid2 == "1 full") {
		143     -       placeBlock(test, spawnPos.offset(-1, 1, zOffset));
		144 132       }
		145 133   
		    134 +     // mid2 defines any mid-level block in the position to the right of the villager spawn
		146     -     // ceiling2 defines the ceiling height in the position to the right of the villager spawn
		147     -     if (ceiling2 == "0.5") {
		148     -       placeBlock(test, spawnPos.offset(-1, 2, zOffset));
		    135 +     if (mid2 == "0.5 slab") {
		149     -       placeBlock(test, spawnPos.offset(-1, 1, zOffset));
		150 136         placeTopSlab(test, spawnPos.offset(-1, 0, zOffset));
		    137 +     } else if (mid2 == "1 slab") {
		151     -     } else if (ceiling2 == "1") {
		152     -       placeBlock(test, spawnPos.offset(-1, 2, zOffset));
		153     -       placeBlock(test, spawnPos.offset(-1, 1, zOffset));
		    138 +       placeBottomSlab(test, spawnPos.offset(-1, 1, zOffset));
		    139 +     } else if (mid2 == "1.5 slab") {
		154     -     } else if (ceiling2 == "1.5") {
		155     -       placeBlock(test, spawnPos.offset(-1, 2, zOffset));
		156 140         placeTopSlab(test, spawnPos.offset(-1, 1, zOffset));
		    141 +     } else if (mid2 == "1 full") {
		157     -     } else if (ceiling2 == "2") {
		158     -       placeBlock(test, spawnPos.offset(-1, 2, zOffset));
		159     -     } else if (ceiling2 == "2.5") {
		    142 +       placeBlock(test, spawnPos.offset(-1, 1, zOffset));
		160     -       placeTopSlab(test, spawnPos.offset(-1, 2, zOffset));
		161 143       }
		162     -   }
		163     - }
		164 144   
		    145 +     // ceiling2 defines the ceiling height in the position to the right of the villager spawn
		    146 +     if (ceiling2 == "0.5") {
		    147 +       placeBlock(test, spawnPos.offset(-1, 2, zOffset));
		165     - function getBlockStateForMapChar(mapChar) {
		    148 +       placeBlock(test, spawnPos.offset(-1, 1, zOffset));
		    149 +       placeTopSlab(test, spawnPos.offset(-1, 0, zOffset));
		    150 +     } else if (ceiling2 == "1") {
		    151 +       placeBlock(test, spawnPos.offset(-1, 2, zOffset));
		    152 +       placeBlock(test, spawnPos.offset(-1, 1, zOffset));
		    153 +     } else if (ceiling2 == "1.5") {
		    154 +       placeBlock(test, spawnPos.offset(-1, 2, zOffset));
		    155 +       placeTopSlab(test, spawnPos.offset(-1, 1, zOffset));
		    156 +     } else if (ceiling2 == "2") {
		    157 +       placeBlock(test, spawnPos.offset(-1, 2, zOffset));
		    158 +     } else if (ceiling2 == "2.5") {
		    159 +       placeTopSlab(test, spawnPos.offset(-1, 2, zOffset));
		    160 +     }
		166     -   if (mapChar == "#") {
		167     -     return Blocks.stonebrick();
		168     -   } else if (mapChar == "_") {
		169     -     let result = Blocks.stoneSlab();
		170     -     result.setState(BlockStates.stoneSlabType("stoneBrick"));
		171     -     return result;
		172     -   } else if (mapChar == "^") {
		173     -     let result = Blocks.stoneSlab();
		174     -     result.setState(BlockStates.stoneSlabType("stoneBrick"));
		175     -     result.setState(BlockStates.topSlotBit(true));
		176     -     return result;
		177     -   } else {
		178     -     return Blocks.air();
		179 161     }
		180 162   }
		181 163   
		    164 + function getBlockPermutationForMapChar(mapChar) {
		    165 +   if (mapChar == "#") {
		    166 +     return BlockTypes.stonebrick.createDefaultBlockPermutation();
		182     - function createVerticalTestFunctionWithPlacementMap(
		    167 +   } else if (mapChar == "_") {
		    168 +     let result = BlockTypes.stoneSlab.createDefaultBlockPermutation();
		    169 +     result.getProperty(BlockProperties.stoneSlabType).value = "stone_brick";
		    170 +     return result;
		    171 +   } else if (mapChar == "^") {
		    172 +     let result = BlockTypes.stoneSlab.createDefaultBlockPermutation();
		    173 +     result.getProperty(BlockProperties.stoneSlabType).value = "stone_brick";
		    174 +     result.getProperty(BlockProperties.topSlotBit).value = true;
		    175 +     return result;
		    176 +   } else {
		    177 +     return BlockTypes.air.createDefaultBlockPermutation();
		    178 +   }
		    179 + }
		183     -   counter,
		184     -   placementMap,
		185     -   tag
		186     - ) {
		187     -   if (tag == null) {
		188     -     tag = GameTest.Tags.suiteDefault;
		189     -   }
		190     - 
		191     -   const testName = "Vertical" + counter;
		192     -   GameTest.register("PathFindingTests", testName, (test) => {
		193     -     const villagerEntityType = "minecraft:villager_v2";
		194     -     const villagerEntitySpawnType =
		195     -       villagerEntityType + "<minecraft:become_farmer>"; // Attempt to spawn the villagers as farmers
		196 180   
		    181 + function createVerticalTestFunctionWithPlacementMap(counter, placementMap, tag) {
		197     -     // Prepare the map
		198     -     placeBlocksFromMap(test, placementMap);
		    182 +   if (tag == null) {
		    183 +     tag = GameTest.Tags.suiteDefault;
		    184 +   }
		199     -     const bedPos = new BlockLocation(1, 2, 4);
		200     -     const aboveBedPos = bedPos.above().above(); // Check 2 blocks above the bed because under rare circumstances the villager hit box may stick out above the bed block when lying down.
		201     -     const spawnPos = new BlockLocation(5, 3, 4);
		202 185   
		    186 +   const testName = "Vertical" + counter;
		    187 +   GameTest.register("PathFindingTests", testName, (test) => {
		203     -     // Do the test
		    188 +     const villagerEntityType = "minecraft:villager_v2";
		    189 +     const villagerEntitySpawnType = villagerEntityType + "<minecraft:become_farmer>"; // Attempt to spawn the villagers as farmers
		204     -     test.assertEntityNotPresent(villagerEntityType, bedPos);
		205     -     test.spawn(villagerEntitySpawnType, spawnPos);
		206 190   
		    191 +     // Prepare the map
		    192 +     placeBlocksFromMap(test, placementMap);
		    193 +     const bedPos = new BlockLocation(1, 2, 4);
		207     -     test.succeedWhen(() => {
		    194 +     const aboveBedPos = bedPos.above().above(); // Check 2 blocks above the bed because under rare circumstances the villager hit box may stick out above the bed block when lying down.
		    195 +     const spawnPos = new BlockLocation(5, 3, 4);
		208     -       test.assertEntityNotPresent(villagerEntityType, aboveBedPos);
		209     -       test.assertEntityPresent(villagerEntityType, bedPos);
		210 196   
		211     -       test.killAllEntities(); // Clean up villagers so the VillageManager doesn't waste time looking for points of interest (POIs)
		212     -     });
		213     -   })
		    197 +     // Do the test
		    198 +     test.assertEntityNotPresent(villagerEntityType, bedPos);
		    199 +     test.spawn(villagerEntitySpawnType, spawnPos);
		    200 + 
		    201 +     test.succeedWhen(() => {
		    202 +       test.assertEntityNotPresent(villagerEntityType, aboveBedPos);
		    203 +       test.assertEntityPresent(villagerEntityType, bedPos);
		214     -     .structureName(VERTICAL_TEST_TEMPLATE_NAME)
		215     -     .maxTicks(VERTICAL_TEST_MAX_TICKS)
		216     -     .setupTicks(VERTICAL_TEST_STARTUP_TICKS)
		217     -     .padding(VERTICAL_TEST_PADDING)
		218     -     .batch("night")
		219     -     .tag(tag);
		220     - }
		221 204   
		    205 +       test.killAllEntities(); // Clean up villagers so the VillageManager doesn't waste time looking for points of interest (POIs)
		222     - function createVerticalTestFunctionWithCustomBlocks(
		223     -   testName,
		    206 +     });
		    207 +   })
		    208 +     .structureName(VERTICAL_TEST_TEMPLATE_NAME)
		    209 +     .maxTicks(VERTICAL_TEST_MAX_TICKS)
		    210 +     .setupTicks(VERTICAL_TEST_STARTUP_TICKS)
		    211 +     .padding(VERTICAL_TEST_PADDING)
		    212 +     .batch("night")
		    213 +     .tag(tag);
		    214 + }
		224     -   floor1,
		225     -   floor2,
		226     -   mid2,
		227     -   ceiling2,
		228     -   tag
		229     - ) {
		230     -   if (tag == null) {
		231     -     tag = GameTest.Tags.suiteDefault;
		232     -   }
		233 215   
		    216 + function createVerticalTestFunctionWithCustomBlocks(testName, floor1, floor2, mid2, ceiling2, tag) {
		    217 +   if (tag == null) {
		234     -   GameTest.register("PathFindingTests", testName, (test) => {
		235     -     const villagerEntityType = "minecraft:villager_v2";
		    218 +     tag = GameTest.Tags.suiteDefault;
		    219 +   }
		236     -     const villagerEntitySpawnType =
		237     -       villagerEntityType + "<minecraft:become_farmer>"; // Attempt to spawn the villagers as farmers
		238 220   
		    221 +   GameTest.register("PathFindingTests", testName, (test) => {
		239     -     // Prepare the map
		240     -     placeBlocks(test, floor1, floor2, mid2, ceiling2);
		241     -     const bedPos = new BlockLocation(1, 2, 4);
		    222 +     const villagerEntityType = "minecraft:villager_v2";
		    223 +     const villagerEntitySpawnType = villagerEntityType + "<minecraft:become_farmer>"; // Attempt to spawn the villagers as farmers
		242     -     const aboveBedPos = bedPos.above().above(); // Check 2 blocks above the bed because under rare circumstances the villager hit box may stick out above the bed block when lying down.
		243     -     const spawnPos = new BlockLocation(5, 3, 4);
		244 224   
		    225 +     // Prepare the map
		245     -     // Do the test
		246     -     test.assertEntityNotPresent(villagerEntityType, bedPos);
		    226 +     placeBlocks(test, floor1, floor2, mid2, ceiling2);
		    227 +     const bedPos = new BlockLocation(1, 2, 4);
		    228 +     const aboveBedPos = bedPos.above().above(); // Check 2 blocks above the bed because under rare circumstances the villager hit box may stick out above the bed block when lying down.
		    229 +     const spawnPos = new BlockLocation(5, 3, 4);
		247     -     test.spawn(villagerEntitySpawnType, spawnPos);
		248     -     test.succeedWhen(() => {
		249     -       test.assertEntityNotPresent(villagerEntityType, aboveBedPos);
		250     -       test.assertEntityPresent(villagerEntityType, bedPos);
		251 230   
		    231 +     // Do the test
		    232 +     test.assertEntityNotPresent(villagerEntityType, bedPos);
		252     -       test.killAllEntities(); // Clean up villagers so the VillageManager doesn't waste time looking for points of interest (POIs)
		    233 +     test.spawn(villagerEntitySpawnType, spawnPos);
		    234 +     test.succeedWhen(() => {
		    235 +       test.assertEntityNotPresent(villagerEntityType, aboveBedPos);
		    236 +       test.assertEntityPresent(villagerEntityType, bedPos);
		    237 + 
		    238 +       test.killAllEntities(); // Clean up villagers so the VillageManager doesn't waste time looking for points of interest (POIs)
		    239 +     });
		    240 +   })
		    241 +     .structureName(VERTICAL_TEST_TEMPLATE_NAME)
		253     -     });
		254     -   })
		255     -     .structureName(VERTICAL_TEST_TEMPLATE_NAME)
		256     -     .maxTicks(VERTICAL_TEST_MAX_TICKS)
		257     -     .setupTicks(VERTICAL_TEST_STARTUP_TICKS)
		258     -     .padding(VERTICAL_TEST_PADDING)
		259     -     .batch("night")
		260     -     .tag(tag);
		261     - }
		262     - 
		    242 +     .maxTicks(VERTICAL_TEST_MAX_TICKS)
		    243 +     .setupTicks(VERTICAL_TEST_STARTUP_TICKS)
		    244 +     .padding(VERTICAL_TEST_PADDING)
		    245 +     .batch("night")
		    246 +     .tag(tag);
		    247 + }
		    248 + 
		    249 + function addVerticalTest(counter, floor1, floor2, mid2, ceiling2, tag) {
		    250 +   const testName = "Vertical" + counter;
		    251 +   createVerticalTestFunctionWithCustomBlocks(testName, floor1, floor2, mid2, ceiling2, tag);
		263     - function addVerticalTest(counter, floor1, floor2, mid2, ceiling2, tag) {
		264     -   const testName = "Vertical" + counter;
		265     -   createVerticalTestFunctionWithCustomBlocks(
		266     -     testName,
		267     -     floor1,
		268     -     floor2,
		269     -     mid2,
		270     -     ceiling2,
		271     -     tag
		272     -   );
		273 252   }
		274 253   
		275 254   GameTest.register("PathFindingTests", "doorway_bottleneck", (test) => {
		    255 +   const villagerEntitySpawnType = "minecraft:villager_v2<minecraft:spawn_farmer>";
		276     - 	const villagerEntitySpawnType = "minecraft:villager_v2<minecraft:spawn_farmer>";
		277 256   
		    257 +   test.spawn(villagerEntitySpawnType, new BlockLocation(5, 2, 4));
		    258 +   test.spawn(villagerEntitySpawnType, new BlockLocation(4, 2, 5));
		278     - 	test.spawn(villagerEntitySpawnType, new BlockLocation(5, 2, 4));
		279     - 	test.spawn(villagerEntitySpawnType, new BlockLocation(4, 2, 5));
		    259 +   test.spawn(villagerEntitySpawnType, new BlockLocation(2, 2, 5));
		    260 +   test.spawn(villagerEntitySpawnType, new BlockLocation(1, 2, 4));
		280     - 	test.spawn(villagerEntitySpawnType, new BlockLocation(2, 2, 5));
		281     - 	test.spawn(villagerEntitySpawnType, new BlockLocation(1, 2, 4));
		282 261   
		283 262     test.succeedWhen(() => {
		284 263       test.assertEntityPresent(villagerEntitySpawnType, new BlockLocation(5, 2, 2));
		285 264       test.assertEntityPresent(villagerEntitySpawnType, new BlockLocation(5, 2, 1));
		286 265       test.assertEntityPresent(villagerEntitySpawnType, new BlockLocation(1, 2, 2));
		287 266       test.assertEntityPresent(villagerEntitySpawnType, new BlockLocation(1, 2, 1));
		288 267     });
		289 268   })
		    269 +   .padding(TEST_PADDING) // Space out villager tests to stop them from confusing each other
		    270 +   .batch("night")
		290     -     .padding(TEST_PADDING) // Space out villager tests to stop them from confusing each other
		291     - 	.batch("night")
		    271 +   .maxTicks(TEST_MAX_TICKS)
		    272 +   .tag("suite:java_parity")
		    273 +   .tag(GameTest.Tags.suiteDisabled); // Villagers can get stuck on sleeping villagers sometimes
		    274 + 
		292     -     .maxTicks(TEST_MAX_TICKS)
		293     -     .tag("suite:java_parity")
		294     -     .tag(GameTest.Tags.suiteDisabled)  // Villagers can get stuck on sleeping villagers sometimes
		295     -   
		296 275   GameTest.register("PathFindingTests", "big_obstacle_course", (test) => {
		    276 +   const bedPos = new BlockLocation(4, 3, 6);
		    277 +   const spawnPos = new BlockLocation(5, 3, 4);
		297     - 	const bedPos = new BlockLocation(4, 3, 6);
		298     - 	const spawnPos = new BlockLocation(5, 3, 4);
		    278 +   const villagerEntitySpawnType = "minecraft:villager_v2<minecraft:spawn_farmer>";
		    279 + 
		    280 +   test.assertEntityNotPresent(villagerEntitySpawnType, bedPos);
		    281 +   test.spawn(villagerEntitySpawnType, spawnPos);
		299     - 	const villagerEntitySpawnType ="minecraft:villager_v2<minecraft:spawn_farmer>";
		300     - 		
		301     - 	test.assertEntityNotPresent(villagerEntitySpawnType,bedPos);
		302     - 	test.spawn(villagerEntitySpawnType,spawnPos);
		303 282   
		    283 +   test.succeedWhenEntityPresent(villagerEntitySpawnType, bedPos);
		304     - 	test.succeedWhenEntityPresent(villagerEntitySpawnType,bedPos);
		305 284   })
		    285 +   .padding(TEST_PADDING)
		    286 +   .maxTicks(TEST_MAX_TICKS)
		306     -     .padding(TEST_PADDING)
		307     -     .maxTicks(TEST_MAX_TICKS)
		    287 +   .batch("night")
		    288 +   .required(false)
		    289 +   .tag("suite:java_parity") //Test fails both on Java and Bedrock sometimes.
		    290 +   .tag(GameTest.Tags.suiteDisabled); //Village couldn't cross the polished granite most times, so fail to find a path to bed.
		    291 + 
		308     - 	.batch("night")
		309     - 	.required(false)
		310     -     .tag("suite:java_parity")    //Test fails both on Java and Bedrock sometimes.
		311     -     .tag(GameTest.Tags.suiteDisabled)   //Village couldn't cross the polished granite most times, so fail to find a path to bed.
		312     - 			
		313 292   GameTest.register("PathFindingTests", "simple", (test) => {
		    293 +   const bedPos = new BlockLocation(1, 2, 4);
		    294 +   const spawnPos = new BlockLocation(5, 3, 4);
		314     - 	const bedPos = new BlockLocation(1, 2, 4);
		315     - 	const spawnPos = new BlockLocation(5, 3, 4);
		    295 +   const villagerEntitySpawnType = "minecraft:villager_v2<minecraft:spawn_farmer>";
		    296 + 
		    297 +   test.assertEntityNotPresent(villagerEntitySpawnType, bedPos);
		    298 +   test.spawn(villagerEntitySpawnType, spawnPos);
		    299 + 
		    300 +   test.succeedWhenEntityPresent(villagerEntitySpawnType, bedPos);
		316     -     const villagerEntitySpawnType ="minecraft:villager_v2<minecraft:spawn_farmer>";
		317     - 		
		318     - 	test.assertEntityNotPresent(villagerEntitySpawnType,bedPos);
		319     - 	test.spawn(villagerEntitySpawnType,spawnPos);
		320     - 		
		321     - 	test.succeedWhenEntityPresent(villagerEntitySpawnType,bedPos);
		322 301   })
		    302 +   .maxTicks(TEST_MAX_TICKS)
		    303 +   .batch("night")
		323     -     .maxTicks(TEST_MAX_TICKS)
		324     - 	.batch("night")
		    304 +   .required(false)
		    305 +   .padding(TEST_PADDING)
		    306 +   .tag(GameTest.Tags.suiteDefault);
		    307 + 
		325     - 	.required(false)
		326     -     .padding(TEST_PADDING)
		327     -     .tag(GameTest.Tags.suiteDefault); 
		328     - 		
		329 308   GameTest.register("PathFindingTests", "carpet_walk_around", (test) => {
		    309 +   const bedPos = new BlockLocation(1, 2, 4);
		    310 +   const spawnPos = new BlockLocation(5, 3, 4);
		330     - 	const bedPos = new BlockLocation(1, 2, 4);
		331     - 	const spawnPos = new BlockLocation(5, 3, 4);
		    311 +   const villagerEntitySpawnType = "minecraft:villager_v2<minecraft:spawn_farmer>";
		    312 + 
		    313 +   test.assertEntityNotPresent(villagerEntitySpawnType, bedPos);
		    314 +   test.spawn(villagerEntitySpawnType, spawnPos);
		    315 + 
		    316 +   test.succeedWhenEntityPresent(villagerEntitySpawnType, bedPos);
		332     - 	const villagerEntitySpawnType ="minecraft:villager_v2<minecraft:spawn_farmer>";
		333     - 		
		334     - 	test.assertEntityNotPresent(villagerEntitySpawnType,bedPos);
		335     - 	test.spawn(villagerEntitySpawnType,spawnPos);
		336     - 		
		337     - 	test.succeedWhenEntityPresent(villagerEntitySpawnType,bedPos);
		338 317   })
		    318 +   .padding(TEST_PADDING)
		    319 +   .maxTicks(TEST_MAX_TICKS)
		339     -     .padding(TEST_PADDING)
		340     -     .maxTicks(TEST_MAX_TICKS)
		    320 +   .batch("night")
		    321 +   .required(false)
		    322 +   .tag("suite:java_parity") //Test fails both on Java and Bedrock sometimes.
		    323 +   .tag(GameTest.Tags.suiteDisabled); // Village couldn't walk around the carpet sometimes.
		341     - 	.batch("night")
		342     - 	.required(false)
		343     -     .tag("suite:java_parity")  //Test fails both on Java and Bedrock sometimes.
		344     -     .tag(GameTest.Tags.suiteDisabled);  // Village couldn't walk around the carpet sometimes.
		345 324   
		346 325   ///
		347 326   // Register tests
		348 327   ///
		349 328   createVerticalTestFunctionWithPlacementMap(0, VERTICAL_TEST_PLACEMENT_MAP[0]);
		          ...
		          '''
	Changed script "PistonTests.js":
		Total line: 817 (+162, -116)
		          '''
		  1   1   import * as GameTest from "GameTest";
		      2 + import { BlockLocation, Location, BlockTypes, ItemStack } from "Minecraft";
		      3 + 
		      4 + GameTest.register("PistonTests", "honey_block_entity_drag_sideways", (test) => {
		      5 +   const startPos = new BlockLocation(3, 4, 1);
		      6 +   const endPos = new BlockLocation(2, 4, 1);
		      7 +   const pullLeverPos = new BlockLocation(0, 3, 0);
		      8 +   const chickenEntityType = "minecraft:chicken";
		      9 + 
		     10 +   test.assertEntityNotPresent(chickenEntityType, endPos);
		     11 +   test.spawn(chickenEntityType, startPos);
		     12 +   test
		     13 +     .startSequence()
		     14 +     .thenExecuteAfter(1, () => {
		     15 +       test.pullLever(pullLeverPos);
		     16 +     })
		     17 +     .thenWait(() => {
		     18 +       test.assertEntityPresent(chickenEntityType, endPos);
		     19 +     })
		     20 +     .thenSucceed();
		     21 + }).tag(GameTest.Tags.suiteDefault);
		     22 + 
		     23 + GameTest.register("PistonTests", "quasiconnectivity", (test) => {
		     24 +   const topStartPos = new BlockLocation(3, 3, 0);
		     25 +   const bottomStartPos = new BlockLocation(3, 2, 0);
		     26 +   const topEndPos = new BlockLocation(2, 3, 0);
		     27 +   const bottomEndPos = new BlockLocation(2, 2, 0);
		     28 +   const pullLeverPos = new BlockLocation(0, 4, 0);
		     29 + 
		     30 +   test.pullLever(pullLeverPos);
		     31 +   test
		     32 +     .startSequence()
		     33 +     .thenWaitWithDelay(3, () => {
		     34 +       test.assertBlockTypePresent(BlockTypes.stone, topStartPos);
		     35 +       test.assertBlockTypePresent(BlockTypes.stone, bottomStartPos);
		     36 +     })
		     37 +     .thenExecute(() => {
		     38 +       test.pullLever(pullLever);
		     39 +     })
		     40 +     .thenWaitWithDelay(3, () => {
		     41 +       test.assertBlockTypePresent(BlockTypes.stone, topEndPos);
		     42 +       test.assertBlockTypePresent(BlockTypes.stone, bottomEndPos);
		     43 +     })
		     44 +     .thenSucceed();
		     45 + })
		     46 +   .tag("suite:java_parity")
		     47 +   .tag(GameTest.Tags.suiteDisabled); //There are version differences. Java version has a switch, which can control one piston at the same time, while bedrock version can only control one piston. All the structures have been modified, and the pull rod and its coordinates have been changed to (0, 3, 0) ,next to "quasiconnectivity_bedrock"
		     48 + 
		     49 + GameTest.register("PistonTests", "quasiconnectivity_bedrock", (test) => {
		     50 +   const topStartPos = new BlockLocation(3, 3, 0);
		     51 +   const bottomStartPos = new BlockLocation(3, 2, 0);
		     52 +   const topEndPos = new BlockLocation(2, 3, 0);
		     53 +   const bottomEndPos = new BlockLocation(2, 2, 0);
		     54 +   const pullLeverPos = new BlockLocation(0, 3, 0);
		     55 + 
		     56 +   test.pullLever(pullLeverPos); //There are version differences. Java version has a switch, which can control one piston at the same time, while bedrock version can only control one piston. All the structures have been modified, and the pull rod and its coordinates have been changed to (0, 3, 0)
		     57 + 
		     58 +   test
		     59 +     .startSequence()
		     60 +     .thenIdle(6) //it's not possible to time it exactly due to redstone differences then you can just pull the lever, wait 6 ticks, assert, pull, wait 6, assert.
		     61 +     .thenExecute(() => {
		     62 +       test.assertBlockTypePresent(BlockTypes.stone, topStartPos);
		     63 +       test.assertBlockTypePresent(BlockTypes.stone, bottomStartPos);
		     64 +     })
		     65 +     .thenExecute(() => {
		     66 +       test.pullLever(pullLeverPos);
		     67 +     })
		     68 +     .thenIdle(6)
		     69 +     .thenExecute(() => {
		     70 +       test.assertBlockTypePresent(BlockTypes.stone, topEndPos);
		     71 +       test.assertBlockTypePresent(BlockTypes.stone, bottomEndPos);
		     72 +     })
		     73 +     .thenSucceed();
		     74 + }).tag(GameTest.Tags.suiteDefault);
		     75 + 
		     76 + GameTest.register("PistonTests", "redstone_simple_vertical_bud", (test) => {
		     77 +   const blockPos = new BlockLocation(0, 5, 0);
		     78 +   const setblockPos = new BlockLocation(0, 1, 0);
		     79 +   test.setBlockType(BlockTypes.stone, setblockPos);
		     80 + 
		     81 +   test
		     82 +     .startSequence()
		     83 +     .thenIdle(3)
		     84 +     .thenWait(() => {
		     85 +       test.assertBlockTypePresent(BlockTypes.redstoneBlock, blockPos);
		     86 +     })
		     87 +     .thenIdle(1)
		     88 +     .thenWait(() => {
		     89 +       test.assertBlockTypePresent(BlockTypes.air, blockPos);
		     90 +     })
		     91 +     .thenSucceed();
		     92 + })
		     93 +   .tag("suite:java_parity")
		     94 +   .tag(GameTest.Tags.suiteDisabled); //The lack of quasi-connectivity in bedrock is parity difference that causes this test not to succeed.
		  2     - import { BlockLocation, Location, Blocks, ItemStack, BlockStates } from "Minecraft";
		  3     - 
		  4     - GameTest.register("PistonTests", "honey_block_entity_drag_sideways", (test) => {
		  5     -     const startPos = new BlockLocation(3, 4, 1);
		  6     -     const endPos = new BlockLocation(2, 4, 1);
		  7     -     const pullLeverPos = new BlockLocation(0, 3, 0);
		  8     -     const chickenEntityType = "minecraft:chicken";
		  9  95   
		 10     -     test.assertEntityNotPresent(chickenEntityType, endPos);
		 11     -     test.spawn(chickenEntityType, startPos);
		 12     -     test.startSequence()
		 13     -         .thenExecuteAfter(1, () => { test.pullLever(pullLeverPos); })
		     96 + GameTest.register("PistonTests", "redstone_simple_horizontal_bud", (test) => {
		     97 +   const extendedPos = new BlockLocation(3, 2, 0);
		     98 +   const retractedPos = new BlockLocation(2, 2, 0);
		     99 +   test.setBlockType(BlockTypes.stone, new BlockLocation(0, 1, 0));
		 14     -         .thenWait(() => { test.assertEntityPresent(chickenEntityType, endPos); })
		 15     -         .thenSucceed();
		 16     - })
		 17     -     .tag(GameTest.Tags.suiteDefault)
		 18 100   
		    101 +   test
		 19     - GameTest.register("PistonTests", "quasiconnectivity", (test) => {
		 20     -     const topStartPos = new BlockLocation(3, 3, 0);
		    102 +     .startSequence()
		    103 +     .thenWaitWithDelay(3, () => {
		    104 +       test.assertBlockTypePresent(BlockTypes.redstoneBlock, extendedPos);
		    105 +       test.assertBlockTypePresent(BlockTypes.air, retractedPos);
		    106 +     })
		    107 +     .thenWaitWithDelay(3, () => {
		    108 +       test.assertBlockTypePresent(BlockTypes.air, extendedPos);
		    109 +       test.assertBlockTypePresent(BlockTypes.redstoneBlock, retractedPos);
		    110 +     })
		    111 +     .thenSucceed();
		    112 + })
		    113 +   .tag("suite:java_parity")
		    114 +   .tag(GameTest.Tags.suiteDisabled); // The lack of quasi-connectivity in bedrock is parity difference that causes this test not to succeed.
		    115 + 
		    116 + GameTest.register("PistonTests", "redstone_bud", (test) => {
		    117 +   const blockPos = new BlockLocation(0, 3, 5);
		    118 +   const pullLeverPos = new BlockLocation(0, 4, 0);
		    119 +   test.pullLever(pullLeverPos);
		    120 +   test
		    121 +     .startSequence()
		    122 +     .thenWaitWithDelay(3, () => {
		    123 +       test.assertBlockTypePresent(BlockTypes.redstoneBlock, blockPos);
		    124 +     })
		    125 +     .thenWaitWithDelay(5, () => {
		    126 +       test.assertBlockTypePresent(BlockTypes.air, blockPos);
		    127 +     })
		    128 +     .thenWait(() => {
		    129 +       test.pullLever(pullLeverPos);
		    130 +     })
		    131 +     .thenWaitWithDelay(3, () => {
		    132 +       test.assertBlockTypePresent(BlockTypes.redstoneBlock, blockPos);
		    133 +     })
		    134 +     .thenWaitWithDelay(5, () => {
		    135 +       test.assertBlockTypePresent(BlockTypes.air, blockPos);
		    136 +     })
		    137 +     .thenSucceed();
		    138 + })
		    139 +   .setupTicks(10)
		    140 +   .tag("suite:java_parity")
		    141 +   .tag(GameTest.Tags.suiteDisabled); // The lack of quasi-connectivity in bedrock is parity difference that causes this test not to succeed.
		    142 + 
		    143 + GameTest.register("PistonTests", "slime_block_pull", (test) => {
		    144 +   const targetPos = new BlockLocation(3, 3, 0);
		    145 +   const pullLeverPos = new BlockLocation(0, 4, 0);
		 21     -     const bottomStartPos = new BlockLocation(3, 2, 0);
		 22     -     const topEndPos = new BlockLocation(2, 3, 0);
		 23     -     const bottomEndPos = new BlockLocation(2, 2, 0);
		 24     -     const pullLeverPos = new BlockLocation(0, 4, 0);
		 25     - 
		 26     -     test.pullLever(pullLeverPos);
		 27     -     test.startSequence()
		 28     -         .thenWaitWithDelay(3, () => {
		 29     -             test.assertBlockPresent(Blocks.stone(), topStartPos);
		 30     -             test.assertBlockPresent(Blocks.stone(), bottomStartPos);
		 31     -         })
		 32     -         .thenExecute(() => { test.pullLever(pullLever); })
		 33     -         .thenWaitWithDelay(3, () => {
		 34     -             test.assertBlockPresent(Blocks.stone(), topEndPos);
		 35     -             test.assertBlockPresent(Blocks.stone(), bottomEndPos);
		 36     -         })
		 37     -         .thenSucceed();
		 38     - })
		 39     -     .tag("suite:java_parity")
		 40     -     .tag(GameTest.Tags.suiteDisabled); //There are version differences. Java version has a switch, which can control one piston at the same time, while bedrock version can only control one piston. All the structures have been modified, and the pull rod and its coordinates have been changed to (0, 3, 0) ,next to "quasiconnectivity_bedrock"
		 41     - 
		 42     - GameTest.register("PistonTests", "quasiconnectivity_bedrock", (test) => {
		 43     -     const topStartPos = new BlockLocation(3, 3, 0);
		 44     -     const bottomStartPos = new BlockLocation(3, 2, 0);
		 45     -     const topEndPos = new BlockLocation(2, 3, 0);
		 46     -     const bottomEndPos = new BlockLocation(2, 2, 0);
		 47     -     const pullLeverPos = new BlockLocation(0, 3, 0);
		 48     - 
		 49     -     test.pullLever(pullLeverPos); //There are version differences. Java version has a switch, which can control one piston at the same time, while bedrock version can only control one piston. All the structures have been modified, and the pull rod and its coordinates have been changed to (0, 3, 0)
		 50     - 
		 51     -     test.startSequence()
		 52     -         .thenIdle(6) //it's not possible to time it exactly due to redstone differences then you can just pull the lever, wait 6 ticks, assert, pull, wait 6, assert.
		 53     -         .thenExecute(() => {
		 54     -             test.assertBlockPresent(Blocks.stone(), topStartPos);
		 55     -             test.assertBlockPresent(Blocks.stone(), bottomStartPos);
		 56     -         })
		 57     -         .thenExecute(() => { test.pullLever(pullLeverPos); })
		 58     -         .thenIdle(6)
		 59     -         .thenExecute(() => {
		 60     -             test.assertBlockPresent(Blocks.stone(), topEndPos);
		 61     -             test.assertBlockPresent(Blocks.stone(), bottomEndPos);
		 62     -         })
		 63     -         .thenSucceed();
		 64     - })
		 65 146   
		    147 +   test.assertBlockTypeNotPresent(BlockTypes.planks, targetPos);
		    148 +   test.pullLever(pullLeverPos);
		    149 +   test.succeedWhenBlockTypePresent(BlockTypes.planks, targetPos);
		    150 + }).tag(GameTest.Tags.suiteDefault);
		 66     -     .tag(GameTest.Tags.suiteDefault);
		 67 151   
		    152 + GameTest.register("PistonTests", "normal_extend", (test) => {
		 68     - GameTest.register("PistonTests", "redstone_simple_vertical_bud", (test) => {
		 69     -     const blockPos = new BlockLocation(0, 5, 0);
		    153 +   const targetPos = new BlockLocation(3, 2, 0);
		    154 +   const pullLeverPos = new BlockLocation(0, 3, 0);
		 70     -     const setblockPos = new BlockLocation(0, 1, 0);
		 71     -     test.setBlock(Blocks.stone(), setblockPos);
		 72 155   
		 73     -     test.startSequence()
		 74     -         .thenIdle(3)
		 75     -         .thenWait(() => { test.assertBlockPresent(Blocks.redstoneBlock(), blockPos); })
		    156 +   test.assertBlockTypeNotPresent(BlockTypes.stone, targetPos);
		    157 +   test.pullLever(pullLeverPos);
		    158 +   test.succeedOnTickWhen(3, () => {
		    159 +     test.assertBlockTypePresent(BlockTypes.stone, targetPos);
		    160 +   });
		    161 + }).tag(GameTest.Tags.suiteDefault);
		 76     -         .thenIdle(1)
		 77     -         .thenWait(() => { test.assertBlockPresent(Blocks.air(), blockPos); })
		 78     -         .thenSucceed();
		 79     - })
		 80     -     .tag("suite:java_parity")
		 81     -     .tag(GameTest.Tags.suiteDisabled)	//The lack of quasi-connectivity in bedrock is parity difference that causes this test not to succeed.
		 82 162   
		    163 + GameTest.register("PistonTests", "normal_extend_retract", (test) => {
		    164 +   const extendedPos = new BlockLocation(3, 2, 0);
		 83     - GameTest.register("PistonTests", "redstone_simple_horizontal_bud", (test) => {
		 84     -     const extendedPos = new BlockLocation(3, 2, 0);
		    165 +   const retractedPos = new BlockLocation(2, 2, 0);
		    166 +   const pullLeverPos = new BlockLocation(0, 3, 0);
		 85     -     const retractedPos = new BlockLocation(2, 2, 0);
		 86     -     test.setBlock(Blocks.stone(), new BlockLocation(0, 1, 0));
		 87 167   
		 88     -     test.startSequence()
		 89     -         .thenWaitWithDelay(3, () => {
		 90     -             test.assertBlockPresent(Blocks.redstoneBlock(), extendedPos);
		    168 +   test.assertBlockTypeNotPresent(BlockTypes.stone, extendedPos);
		    169 +   test.pullLever(pullLeverPos);
		    170 + 
		    171 +   test
		    172 +     .startSequence()
		    173 +     .thenWaitWithDelay(3, () => {
		    174 +       test.assertBlockTypePresent(BlockTypes.stone, extendedPos);
		    175 +       test.assertBlockTypePresent(BlockTypes.pistonarmcollision, retractedPos);
		    176 +     })
		    177 +     .thenExecute(() => {
		    178 +       test.pullLever(pullLeverPos);
		    179 +     })
		    180 +     .thenWaitWithDelay(1, () => {
		    181 +       test.assertBlockTypePresent(BlockTypes.air, retractedPos);
		    182 +       test.assertBlockTypePresent(BlockTypes.stone, extendedPos);
		    183 +     })
		    184 +     .thenSucceed();
		    185 + })
		    186 +   .structureName("PistonTests:normal_extend")
		    187 +   .tag("suite:java_parity")
		    188 +   .tag(GameTest.Tags.suiteDisabled); //Pistons react at different speeds in Bedrock, create a new test called normal_extend_retract_bedrock.
		    189 + 
		    190 + GameTest.register("PistonTests", "normal_extend_retract_bedrock", (test) => {
		    191 +   const extendedPos = new BlockLocation(3, 2, 0);
		    192 +   const retractedPos = new BlockLocation(2, 2, 0);
		    193 +   const pullLeverPos = new BlockLocation(0, 3, 0);
		 91     -             test.assertBlockPresent(Blocks.air(), retractedPos);
		 92     -         })
		 93     -         .thenWaitWithDelay(3, () => {
		 94     -             test.assertBlockPresent(Blocks.air(), extendedPos);
		 95     -             test.assertBlockPresent(Blocks.redstoneBlock(), retractedPos);
		 96     -         })
		 97     -         .thenSucceed();
		 98     - })
		 99     -     .tag("suite:java_parity")
		100     -     .tag(GameTest.Tags.suiteDisabled) // The lack of quasi-connectivity in bedrock is parity difference that causes this test not to succeed.
		101     - 
		102     - GameTest.register("PistonTests", "redstone_bud", (test) => {
		103     -     const blockPos = new BlockLocation(0, 3, 5);
		104     -     const pullLeverPos = new BlockLocation(0, 4, 0);
		105     -     test.pullLever(pullLeverPos);
		106     -     test.startSequence()
		107     -         .thenWaitWithDelay(3, () => { test.assertBlockPresent(Blocks.redstoneBlock(), blockPos); })
		108     -         .thenWaitWithDelay(5, () => { test.assertBlockPresent(Blocks.air(), blockPos); })
		109     -         .thenWait(() => { test.pullLever(pullLeverPos); })
		110     -         .thenWaitWithDelay(3, () => { test.assertBlockPresent(Blocks.redstoneBlock(), blockPos); })
		111     -         .thenWaitWithDelay(5, () => { test.assertBlockPresent(Blocks.air(), blockPos); })
		112     -         .thenSucceed();
		113     - })
		114     -     .setupTicks(10)
		115     -     .tag("suite:java_parity")
		116     -     .tag(GameTest.Tags.suiteDisabled) // The lack of quasi-connectivity in bedrock is parity difference that causes this test not to succeed.
		117 194   
		    195 +   test.assertBlockTypeNotPresent(BlockTypes.stone, extendedPos);
		118     - GameTest.register("PistonTests", "slime_block_pull", (test) => {
		119     -     const targetPos = new BlockLocation(3, 3, 0);
		    196 +   test.pullLever(pullLeverPos);
		120     -     const pullLeverPos = new BlockLocation(0, 4, 0);
		121 197   
		    198 +   //it's not possible to time it exactly due to redstone differences, so just validate assert can pass before given delay.
		    199 +   test
		    200 +     .startSequence()
		122     -     test.assertBlockNotPresent(Blocks.planks(), targetPos);
		    201 +     .thenIdle(6)
		    202 +     .thenExecute(() => {
		    203 +       test.assertBlockTypePresent(BlockTypes.stone, extendedPos);
		    204 +       test.assertBlockTypePresent(BlockTypes.pistonarmcollision, retractedPos);
		    205 +     })
		    206 +     .thenExecute(() => {
		    207 +       test.pullLever(pullLeverPos);
		    208 +     })
		    209 +     .thenIdle(4)
		    210 +     .thenExecute(() => {
		    211 +       test.assertBlockTypePresent(BlockTypes.air, retractedPos);
		    212 +       test.assertBlockTypePresent(BlockTypes.stone, extendedPos);
		    213 +     })
		    214 +     .thenSucceed();
		123     -     test.pullLever(pullLeverPos);
		124     -     test.succeedWhenBlockPresent(Blocks.planks(), targetPos);
		125     - })
		126     -     .tag(GameTest.Tags.suiteDefault);
		127     - 
		128     - GameTest.register("PistonTests", "normal_extend", (test) => {
		129     -     const targetPos = new BlockLocation(3, 2, 0);
		130     -     const pullLeverPos = new BlockLocation(0, 3, 0);
		131     - 
		132     -     test.assertBlockNotPresent(Blocks.stone(), targetPos);
		133     -     test.pullLever(pullLeverPos);
		134     -     test.succeedOnTickWhen(3, () => {
		135     -         test.assertBlockPresent(Blocks.stone(), targetPos);
		136     -     });
		137 215   })
		138     -     .tag(GameTest.Tags.suiteDefault);
		139     - 
		140     - GameTest.register("PistonTests", "normal_extend_retract", (test) => {
		141     -     const extendedPos = new BlockLocation(3, 2, 0);
		    216 +   .structureName("PistonTests:normal_extend")
		    217 +   .tag(GameTest.Tags.suiteDefault);
		142     -     const retractedPos = new BlockLocation(2, 2, 0);
		143     -     const pullLeverPos = new BlockLocation(0, 3, 0);
		144 218   
		    219 + GameTest.register("PistonTests", "sticky_extend", (test) => {
		    220 +   const targetPos = new BlockLocation(3, 2, 0);
		145     -     test.assertBlockNotPresent(Blocks.stone(), extendedPos);
		    221 +   const pullLeverPos = new BlockLocation(0, 3, 0);
		146     -     test.pullLever(pullLeverPos);
		147 222   
		    223 +   test.assertBlockTypeNotPresent(BlockTypes.stone, targetPos);
		148     -     test.startSequence()
		149     -         .thenWaitWithDelay(3, () => {
		    224 +   test.pullLever(pullLeverPos);
		    225 +   test.succeedOnTickWhen(3, () => {
		    226 +     test.assertBlockTypePresent(BlockTypes.stone, targetPos);
		    227 +   });
		    228 + }).tag(GameTest.Tags.suiteDefault);
		    229 + 
		    230 + GameTest.register("PistonTests", "sticky_extend_retract", (test) => {
		    231 +   const extendedPos = new BlockLocation(3, 2, 0);
		    232 +   const retractedPos = new BlockLocation(2, 2, 0);
		    233 +   const pullLeverPos = new BlockLocation(0, 3, 0);
		    234 + 
		    235 +   test.assertBlockTypeNotPresent(BlockTypes.stone, extendedPos);
		    236 +   test.pullLever(pullLeverPos);
		150     -             test.assertBlockPresent(Blocks.stone(), extendedPos);
		151     -             test.assertBlockPresent(Blocks.pistonarmcollision(), retractedPos);
		152     -         })
		153     -         .thenExecute(() => { test.pullLever(pullLeverPos); })
		154     -         .thenWaitWithDelay(1, () => {
		155     -             test.assertBlockPresent(Blocks.air(), retractedPos);
		156     -             test.assertBlockPresent(Blocks.stone(), extendedPos);
		157     -         })
		158     -         .thenSucceed();
		159     - })
		160     -     .structureName("PistonTests:normal_extend")
		161     -     .tag("suite:java_parity")
		162     -     .tag(GameTest.Tags.suiteDisabled);   //Pistons react at different speeds in Bedrock, create a new test called normal_extend_retract_bedrock.
		163 237   
		    238 +   test
		    239 +     .startSequence()
		164     - GameTest.register("PistonTests", "normal_extend_retract_bedrock", (test) => {
		165     -     const extendedPos = new BlockLocation(3, 2, 0);
		    240 +     .thenWaitWithDelay(3, () => {
		    241 +       test.assertBlockTypePresent(BlockTypes.stone, extendedPos);
		166     -     const retractedPos = new BlockLocation(2, 2, 0);
		167     -     const pullLeverPos = new BlockLocation(0, 3, 0);
		168     - 
		    242 +       test.assertBlockTypePresent(BlockTypes.stickypistonarmcollision, retractedPos);
		    243 +     })
		    244 +     .thenExecute(() => {
		    245 +       test.pullLever(pullLeverPos);
		    246 +     })
		    247 +     .thenWaitWithDelay(3, () => {
		    248 +       test.assertBlockTypePresent(BlockTypes.stone, retractedPos);
		    249 +       test.assertBlockTypePresent(BlockTypes.air, extendedPos);
		    250 +     })
		    251 +     .thenSucceed();
		    252 + })
		    253 +   .structureName("PistonTests:sticky_extend")
		    254 +   .tag("suite:java_parity")
		    255 +   .tag(GameTest.Tags.suiteDisabled); //Pistons react at different speeds in Bedrock, create a new test called sticky_extend_retract_bedrock.
		    256 + 
		    257 + GameTest.register("PistonTests", "sticky_extend_retract_bedrock", (test) => {
		    258 +   const extendedPos = new BlockLocation(3, 2, 0);
		    259 +   const retractedPos = new BlockLocation(2, 2, 0);
		    260 +   const pullLeverPos = new BlockLocation(0, 3, 0);
		    261 + 
		    262 +   test.assertBlockTypeNotPresent(BlockTypes.stone, extendedPos);
		    263 +   test.pullLever(pullLeverPos);
		169     -     test.assertBlockNotPresent(Blocks.stone(), extendedPos);
		170     -     test.pullLever(pullLeverPos);
		171     - 
		172     -     //it's not possible to time it exactly due to redstone differences, so just validate assert can pass before given delay.
		173     -     test.startSequence()
		174     -         .thenIdle(6)
		175     -         .thenExecute(() => {
		176     -             test.assertBlockPresent(Blocks.stone(), extendedPos);
		177     -             test.assertBlockPresent(Blocks.pistonarmcollision(), retractedPos);
		178     -         })
		179     -         .thenExecute(() => {
		180     -             test.pullLever(pullLeverPos);
		181     -         })
		182     -         .thenIdle(4)
		183     -         .thenExecute(() => {
		184     -             test.assertBlockPresent(Blocks.air(), retractedPos);
		185     -             test.assertBlockPresent(Blocks.stone(), extendedPos);
		186     -         })
		187     -         .thenSucceed();
		188     - })
		189     -     .structureName("PistonTests:normal_extend")
		190     -     .tag(GameTest.Tags.suiteDefault);
		191 264   
		    265 +   //it's not possible to time it exactly due to redstone differences, so just validate assert can pass before given delay.
		    266 +   test
		192     - GameTest.register("PistonTests", "sticky_extend", (test) => {
		    267 +     .startSequence()
		    268 +     .thenIdle(6)
		    269 +     .thenExecute(() => {
		    270 +       test.assertBlockTypePresent(BlockTypes.stone, extendedPos);
		    271 +       test.assertBlockTypePresent(BlockTypes.stickypistonarmcollision, retractedPos);
		    272 +     })
		    273 +     .thenExecute(() => {
		    274 +       test.pullLever(pullLeverPos);
		    275 +     })
		    276 +     .thenIdle(6)
		    277 +     .thenExecute(() => {
		    278 +       test.assertBlockTypePresent(BlockTypes.stone, retractedPos);
		    279 +       test.assertBlockTypePresent(BlockTypes.air, extendedPos);
		    280 +     })
		    281 +     .thenSucceed();
		    282 + })
		    283 +   .structureName("PistonTests:sticky_extend")
		    284 +   .tag(GameTest.Tags.suiteDefault);
		193     -     const targetPos = new BlockLocation(3, 2, 0);
		194     -     const pullLeverPos = new BlockLocation(0, 3, 0);
		195     - 
		196     -     test.assertBlockNotPresent(Blocks.stone(), targetPos);
		197     -     test.pullLever(pullLeverPos);
		198     -     test.succeedOnTickWhen(3, () => {
		199     -         test.assertBlockPresent(Blocks.stone(), targetPos);
		200     -     });
		201     - })
		202     -     .tag(GameTest.Tags.suiteDefault);
		203     - 
		204     - GameTest.register("PistonTests", "sticky_extend_retract", (test) => {
		205     -     const extendedPos = new BlockLocation(3, 2, 0);
		206     -     const retractedPos = new BlockLocation(2, 2, 0);
		207     -     const pullLeverPos = new BlockLocation(0, 3, 0);
		208     - 
		209     -     test.assertBlockNotPresent(Blocks.stone(), extendedPos);
		210     -     test.pullLever(pullLeverPos);
		211 285   
		    286 + GameTest.register("PistonTests", "push_limit", (test) => {
		212     -     test.startSequence()
		213     -         .thenWaitWithDelay(3, () => {
		214     -             test.assertBlockPresent(Blocks.stone(), extendedPos);
		    287 +   const underLimitTip = new BlockLocation(0, 2, 6);
		    288 +   const overLimitTip = new BlockLocation(2, 2, 6);
		    289 +   const pullLeverPos = new BlockLocation(1, 2, 0);
		    290 +   const underLimitExtendedTip = new BlockLocation(0, 2, 7);
		    291 + 
		    292 +   test.assertBlockTypePresent(BlockTypes.goldBlock, underLimitTip);
		    293 +   test.assertBlockTypePresent(BlockTypes.emeraldBlock, overLimitTip);
		    294 +   test.pullLever(pullLeverPos);
		    295 + 
		    296 +   test.succeedOnTickWhen(3, () => {
		    297 +     test.assertBlockTypePresent(BlockTypes.goldBlock, underLimitExtendedTip);
		    298 +     test.assertBlockTypePresent(BlockTypes.emeraldBlock, overLimitTip);
		    299 +   });
		    300 + }).tag(GameTest.Tags.suiteDefault);
		215     -             test.assertBlockPresent(Blocks.stickypistonarmcollision(), retractedPos);
		216     -         })
		217     -         .thenExecute(() => {
		218     -             test.pullLever(pullLeverPos);
		219     -         })
		220     -         .thenWaitWithDelay(3, () => {
		221     -             test.assertBlockPresent(Blocks.stone(), retractedPos);
		222     -             test.assertBlockPresent(Blocks.air(), extendedPos);
		223     -         })
		224     -         .thenSucceed();
		225     - })
		226     -     .structureName("PistonTests:sticky_extend")
		227     -     .tag("suite:java_parity")
		228     -     .tag(GameTest.Tags.suiteDisabled);     //Pistons react at different speeds in Bedrock, create a new test called sticky_extend_retract_bedrock.
		229 301   
		    302 + GameTest.register("PistonTests", "block_leave", (test) => {
		    303 +   const trigger = new BlockLocation(3, 1, 1);
		230     - GameTest.register("PistonTests", "sticky_extend_retract_bedrock", (test) => {
		231     -     const extendedPos = new BlockLocation(3, 2, 0);
		    304 +   const retracted = new BlockLocation(1, 1, 1);
		    305 +   const extended = new BlockLocation(0, 1, 1);
		232     -     const retractedPos = new BlockLocation(2, 2, 0);
		233     -     const pullLeverPos = new BlockLocation(0, 3, 0);
		234 306   
		    307 +   test.pulseRedstone(trigger, 2);
		    308 +   test
		    309 +     .startSequence()
		235     -     test.assertBlockNotPresent(Blocks.stone(), extendedPos);
		    310 +     .thenWaitWithDelay(3, () => {
		236     -     test.pullLever(pullLeverPos);
		237     - 
		    311 +       test.assertBlockTypePresent(BlockTypes.concrete, extended);
		    312 +       test.assertBlockTypePresent(BlockTypes.air, retracted);
		    313 +     })
		    314 +     .thenExecuteAfter(3, () => {
		    315 +       test.pulseRedstone(trigger, 2);
		    316 +     })
		    317 +     .thenWaitWithDelay(5, () => {
		    318 +       test.assertBlockTypePresent(BlockTypes.concrete, retracted);
		    319 +       test.assertBlockTypePresent(BlockTypes.air, extended);
		    320 +     })
		    321 +     .thenSucceed();
		    322 + })
		    323 +   .tag("suite:java_parity")
		    324 +   .tag(GameTest.Tags.suiteDisabled); //In Java Edition, pistons finish extending early and start retracting if given a pulse shorter than 3 game ticks (1.5 redstone ticks; 0.15 seconds). These shorter pulses cause sticky pistons to "drop" their block, leaving it behind when trying to push it with a short pulse. Also, this causes the block to end up in its final position earlier.Therefore, the bedrock version can't be modified, and can only be verified according to the piston tension,
		    325 + 
		    326 + GameTest.register("PistonTests", "block_leave_bedrock", (test) => {
		    327 +   const trigger = new BlockLocation(3, 1, 1);
		    328 +   const retracted = new BlockLocation(1, 1, 1);
		    329 +   const extended = new BlockLocation(0, 1, 1);
		238     -     //it's not possible to time it exactly due to redstone differences, so just validate assert can pass before given delay.
		239     -     test.startSequence()
		240     -         .thenIdle(6)
		241     -         .thenExecute(() => {
		242     -             test.assertBlockPresent(Blocks.stone(), extendedPos);
		243     -             test.assertBlockPresent(Blocks.stickypistonarmcollision(), retractedPos);
		244     -         })
		245     -         .thenExecute(() => {
		246     -             test.pullLever(pullLeverPos);
		247     -         })
		248     -         .thenIdle(6)
		249     -         .thenExecute(() => {
		250     -             test.assertBlockPresent(Blocks.stone(), retractedPos);
		251     -             test.assertBlockPresent(Blocks.air(), extendedPos);
		252     -         })
		253     -         .thenSucceed();
		254     - })
		255     -     .structureName("PistonTests:sticky_extend")
		256     -     .tag(GameTest.Tags.suiteDefault);
		257 330   
		    331 +   test.pulseRedstone(trigger, 2);
		    332 +   test
		258     - GameTest.register("PistonTests", "push_limit", (test) => {
		    333 +     .startSequence()
		    334 +     .thenIdle(2)
		    335 +     .thenWait(() => {
		    336 +       test.assertBlockTypePresent(BlockTypes.concrete, extended);
		    337 +       test.assertBlockTypePresent(BlockTypes.air, retracted);
		    338 +     })
		    339 +     .thenExecuteAfter(3, () => {
		    340 +       test.pulseRedstone(trigger, 2);
		    341 +     })
		    342 +     .thenIdle(6)
		    343 +     .thenWait(() => {
		    344 +       test.assertBlockTypePresent(BlockTypes.concrete, retracted);
		    345 +       test.assertBlockTypePresent(BlockTypes.air, extended);
		    346 +     })
		    347 +     .thenSucceed();
		    348 + }).tag(GameTest.Tags.suiteDefault);
		259     -     const underLimitTip = new BlockLocation(0, 2, 6);
		260     -     const overLimitTip = new BlockLocation(2, 2, 6);
		261     -     const pullLeverPos = new BlockLocation(1, 2, 0);
		262     -     const underLimitExtendedTip = new BlockLocation(0, 2, 7);
		263     - 
		264     -     test.assertBlockPresent(Blocks.goldBlock(), underLimitTip);
		265     -     test.assertBlockPresent(Blocks.emeraldBlock(), overLimitTip);
		266     -     test.pullLever(pullLeverPos);
		267     - 
		268     -     test.succeedOnTickWhen(3, () => {
		269     -         test.assertBlockPresent(Blocks.goldBlock(), underLimitExtendedTip);
		270     -         test.assertBlockPresent(Blocks.emeraldBlock(), overLimitTip);
		271     -     });
		272     - })
		273     -     .tag(GameTest.Tags.suiteDefault);
		274     - 
		275 349   
		    350 + GameTest.register("PistonTests", "update_order", (test) => {
		    351 +   const posA = new BlockLocation(2, 1, 1);
		276     - GameTest.register("PistonTests", "block_leave", (test) => {
		    352 +   const posB = new BlockLocation(2, 1, 0);
		    353 +   const posC = new BlockLocation(3, 1, 0);
		    354 +   const posD = new BlockLocation(1, 1, 0);
		277     -     const trigger = new BlockLocation(3, 1, 1);
		278     -     const retracted = new BlockLocation(1, 1, 1);
		279     -     const extended = new BlockLocation(0, 1, 1);
		280 355   
		281     -     test.pulseRedstone(trigger, 2);
		282     -     test.startSequence()
		283     -         .thenWaitWithDelay(3, () => {
		284     -             test.assertBlockPresent(Blocks.concrete(), extended);
		    356 +   const trigger = new BlockLocation(6, 2, 2);
		    357 +   test.setBlockType(trigger, BlockTypes.greenWool);
		    358 + 
		    359 +   test
		    360 +     .startSequence()
		    361 +     .thenWaitWithDelay(4, () => {
		    362 +       test.assertBlockTypePresent(BlockTypes.yellowWool, posB);
		    363 +     })
		    364 +     .thenExecuteAfter(4, () => {
		    365 +       test.setBlockType(trigger, BlockTypes.blueWool);
		    366 +     })
		    367 +     .thenWaitWithDelay(6, () => {
		    368 +       test.assertBlockTypePresent(BlockTypes.yellowWool, posC);
		    369 +     })
		    370 +     .thenExecuteAfter(4, () => {
		    371 +       test.setBlockType(trigger, BlockTypes.purpleWool);
		    372 +     })
		    373 +     .thenWaitWithDelay(6, () => {
		    374 +       test.assertBlockTypePresent(BlockTypes.yellowWool, posD);
		    375 +     })
		    376 +     .thenExecuteAfter(4, () => {
		    377 +       test.setBlockType(trigger, BlockTypes.cyanWool);
		    378 +     })
		    379 +     .thenWaitWithDelay(6, () => {
		    380 +       test.assertBlockTypePresent(BlockTypes.yellowWool, posA);
		    381 +     })
		    382 +     .thenSucceed();
		    383 + })
		    384 +   .required(false)
		    385 +   .tag("suite:java_parity")
		    386 +   .tag(GameTest.Tags.suiteDisabled); //Due to redstone differences, create a new test called update_order_bedrock. Also, use colored glazed terracotta instead of missing colored wool blocks.
		    387 + 
		    388 + GameTest.register("PistonTests", "update_order_bedrock", (test) => {
		    389 +   const posA = new BlockLocation(2, 1, 1);
		    390 +   const posB = new BlockLocation(2, 1, 0);
		    391 +   const posC = new BlockLocation(3, 1, 0);
		    392 +   const posD = new BlockLocation(1, 1, 0);
		285     -             test.assertBlockPresent(Blocks.air(), retracted);
		286     -         })
		287     -         .thenExecuteAfter(3, () => {
		288     -             test.pulseRedstone(trigger, 2);
		289     -         })
		290     -         .thenWaitWithDelay(5, () => {
		291     -             test.assertBlockPresent(Blocks.concrete(), retracted);
		292     -             test.assertBlockPresent(Blocks.air(), extended);
		293     -         })
		294     -         .thenSucceed();
		295     - })
		296     -     .tag("suite:java_parity")
		297     -     .tag(GameTest.Tags.suiteDisabled);  //In Java Edition, pistons finish extending early and start retracting if given a pulse shorter than 3 game ticks (1.5 redstone ticks; 0.15 seconds). These shorter pulses cause sticky pistons to "drop" their block, leaving it behind when trying to push it with a short pulse. Also, this causes the block to end up in its final position earlier.Therefore, the bedrock version can't be modified, and can only be verified according to the piston tension,
		298     - 
		299     - GameTest.register("PistonTests", "block_leave_bedrock", (test) => {
		300     -     const trigger = new BlockLocation(3, 1, 1);
		301     -     const retracted = new BlockLocation(1, 1, 1);
		302     -     const extended = new BlockLocation(0, 1, 1);
		303     - 
		304     -     test.pulseRedstone(trigger, 2);
		305     -     test.startSequence()
		306     -         .thenIdle(2)
		307     -         .thenWait(() => {
		308     -             test.assertBlockPresent(Blocks.concrete(), extended);
		309     -             test.assertBlockPresent(Blocks.air(), retracted);
		310     -         })
		311     -         .thenExecuteAfter(3, () => {
		312     -             test.pulseRedstone(trigger, 2);
		313     -         })
		314     -         .thenIdle(6)
		315     -         .thenWait(() => {
		316     -             test.assertBlockPresent(Blocks.concrete(), retracted);
		317     -             test.assertBlockPresent(Blocks.air(), extended);
		318     -         })
		319     -         .thenSucceed();
		320     - })
		321     -     .tag(GameTest.Tags.suiteDefault);
		322 393   
		    394 +   const trigger = new BlockLocation(6, 2, 2);
		    395 +   test.setBlockType(BlockTypes.greenGlazedTerracotta, trigger);
		323     - GameTest.register("PistonTests", "update_order", (test) => {
		    396 +   test
		    397 +     .startSequence()
		    398 +     .thenIdle(5)
		    399 +     .thenWait(() => {
		    400 +       test.assertBlockTypePresent(BlockTypes.wool, posB);
		    401 +     })
		    402 +     .thenIdle(4)
		    403 +     .thenWait(() => {
		    404 +       test.setBlockType(BlockTypes.blueGlazedTerracotta, trigger);
		    405 +     })
		    406 +     .thenIdle(6)
		    407 +     .thenWait(() => {
		    408 +       test.assertBlockTypePresent(BlockTypes.wool, posC);
		    409 +     })
		    410 +     .thenIdle(4)
		    411 +     .thenWait(() => {
		    412 +       test.setBlockType(BlockTypes.purpleGlazedTerracotta, trigger);
		    413 +     })
		    414 +     .thenIdle(6)
		    415 +     .thenWait(() => {
		    416 +       test.assertBlockTypePresent(BlockTypes.wool, posD);
		    417 +     })
		    418 +     .thenIdle(4)
		    419 +     .thenWait(() => {
		    420 +       test.setBlockType(BlockTypes.cyanGlazedTerracotta, trigger);
		    421 +     })
		    422 +     .thenIdle(6)
		    423 +     .thenWait(() => {
		    424 +       test.assertBlockTypePresent(BlockTypes.wool, posA);
		    425 +     })
		    426 +     .thenSucceed();
		324     -     const posA = new BlockLocation(2, 1, 1);
		325     -     const posB = new BlockLocation(2, 1, 0);
		326     -     const posC = new BlockLocation(3, 1, 0);
		327     -     const posD = new BlockLocation(1, 1, 0);
		328     - 
		329     -     const trigger = new BlockLocation(6, 2, 2);
		330     -     test.setBlock(trigger, Blocks.greenWool());
		331     - 
		332     -     test.startSequence()
		333     -         .thenWaitWithDelay(4, () => {
		334     -             test.assertBlockPresent(Blocks.yellowWool(), posB);
		335     -         })
		336     -         .thenExecuteAfter(4, () => {
		337     -             test.setBlock(trigger, Blocks.blueWool());
		338     -         })
		339     -         .thenWaitWithDelay(6, () => {
		340     -             test.assertBlockPresent(Blocks.yellowWool(), posC);
		341     -         })
		342     -         .thenExecuteAfter(4, () => {
		343     -             test.setBlock(trigger, Blocks.purpleWool());
		344     -         })
		345     -         .thenWaitWithDelay(6, () => {
		346     -             test.assertBlockPresent(Blocks.yellowWool(), posD);
		347     -         })
		348     -         .thenExecuteAfter(4, () => {
		349     -             test.setBlock(trigger, Blocks.cyanWool());
		350     -         })
		351     -         .thenWaitWithDelay(6, () => {
		352     -             test.assertBlockPresent(Blocks.yellowWool(), posA);
		353     -         })
		354     -         .thenSucceed();
		355 427   })
		    428 + 
		    429 +   .required(false)
		356     -     .required(false)
		357     -     .tag("suite:java_parity")
		    430 +   .tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed as block position doesn't update with the right order.
		358     -     .tag(GameTest.Tags.suiteDisabled); //Due to redstone differences, create a new test called update_order_bedrock. Also, use colored glazed terracotta instead of missing colored wool blocks.
		359 431   
		    432 + GameTest.register("PistonTests", "double_extender", (test) => {
		360     - GameTest.register("PistonTests", "update_order_bedrock", (test) => {
		361     -     const posA = new BlockLocation(2, 1, 1);
		    433 +   const pullLeverPos = new BlockLocation(2, 3, 2);
		    434 +   const blockPresentPosA = new BlockLocation(0, 2, 2);
		    435 +   const blockPresentPosB = new BlockLocation(0, 2, 4);
		362     -     const posB = new BlockLocation(2, 1, 0);
		363     -     const posC = new BlockLocation(3, 1, 0);
		364     -     const posD = new BlockLocation(1, 1, 0);
		365 436   
		366     -     const trigger = new BlockLocation(6, 2, 2);
		367     -     test.setBlock(Blocks.greenGlazedTerracotta(), trigger);
		368     -     test.startSequence()
		    437 +   test.pullLever(pullLeverPos);
		    438 +   test.assertBlockTypePresent(BlockTypes.emeraldBlock, blockPresentPosA);
		    439 + 
		    440 +   test
		    441 +     .startSequence()
		    442 +     .thenWaitWithDelay(11, () => {
		    443 +       test.assertBlockTypePresent(BlockTypes.emeraldBlock, blockPresentPosB);
		    444 +       test.pullLever(pullLeverPos);
		    445 +     })
		    446 +     .thenWaitWithDelay(12, () => {
		    447 +       test.assertBlockTypePresent(BlockTypes.emeraldBlock, blockPresentPosA);
		    448 +     })
		    449 +     .thenSucceed();
		    450 + })
		    451 +   .tag("suite:java_parity")
		    452 +   .tag(GameTest.Tags.suiteDisabled); //Pistons react at different speeds in Bedrock, create a new test called double_extender_bedrock.
		    453 + 
		    454 + GameTest.register("PistonTests", "double_extender_bedrock", (test) => {
		    455 +   const pullLeverPos = new BlockLocation(2, 3, 2);
		    456 +   const blockPresentPosA = new BlockLocation(0, 2, 2);
		    457 +   const blockPresentPosB = new BlockLocation(0, 2, 4);
		    458 + 
		    459 +   test.pullLever(pullLeverPos);
		    460 +   test.assertBlockTypePresent(BlockTypes.emeraldBlock, blockPresentPosA);
		    461 + 
		    462 +   //it's not possible to time it exactly due to redstone differences, so just validate assert can pass before given delay.
		    463 +   test
		    464 +     .startSequence()
		    465 +     .thenIdle(17)
		    466 +     .thenExecute(() => {
		    467 +       test.assertBlockTypePresent(BlockTypes.emeraldBlock, blockPresentPosB);
		    468 +       test.pullLever(pullLeverPos);
		    469 +     })
		    470 +     .thenIdle(18)
		    471 +     .thenExecute(() => {
		    472 +       test.assertBlockTypePresent(BlockTypes.emeraldBlock, blockPresentPosA);
		    473 +     })
		    474 +     .thenSucceed();
		    475 + })
		    476 +   .structureName("PistonTests:double_extender")
		    477 +   .tag(GameTest.Tags.suiteDefault);
		369     -         .thenIdle(5)
		370     -         .thenWait(() => {
		371     -             test.assertBlockPresent(Blocks.wool(), posB);
		372     -         })
		373     -         .thenIdle(4)
		374     -         .thenWait(() => {
		375     -             test.setBlock(Blocks.blueGlazedTerracotta(), trigger);
		376     -         })
		377     -         .thenIdle(6)
		378     -         .thenWait(() => {
		379     -             test.assertBlockPresent(Blocks.wool(), posC);
		380     -         })
		381     -         .thenIdle(4)
		382     -         .thenWait(() => {
		383     -             test.setBlock(Blocks.purpleGlazedTerracotta(), trigger);
		384     -         })
		385     -         .thenIdle(6)
		386     -         .thenWait(() => {
		387     -             test.assertBlockPresent(Blocks.wool(), posD);
		388     -         })
		389     -         .thenIdle(4)
		390     -         .thenWait(() => {
		391     -             test.setBlock(Blocks.cyanGlazedTerracotta(), trigger);
		392     -         })
		393     -         .thenIdle(6)
		394     -         .thenWait(() => {
		395     -             test.assertBlockPresent(Blocks.wool(), posA);
		396     -         })
		397     -         .thenSucceed();
		398     - })
		399     - 
		400     -     .required(false)
		401     -     .tag(GameTest.Tags.suiteDisabled);  //Both of Java and Bedrock are failed as block position doesn't update with the right order.
		402     - 
		403     - GameTest.register("PistonTests", "double_extender", (test) => {
		404     -     const pullLeverPos = new BlockLocation(2, 3, 2);
		405     -     const blockPresentPosA = new BlockLocation(0, 2, 2);
		406     -     const blockPresentPosB = new BlockLocation(0, 2, 4);
		407     - 
		408     -     test.pullLever(pullLeverPos);
		409     -     test.assertBlockPresent(Blocks.emeraldBlock(), blockPresentPosA);
		410 478   
		411     -     test.startSequence()
		412     -         .thenWaitWithDelay(11, () => {
		413     -             test.assertBlockPresent(Blocks.emeraldBlock(), blockPresentPosB);
		    479 + GameTest.register("PistonTests", "triple_extender", (test) => {
		    480 +   const retracted = new BlockLocation(0, 4, 4);
		    481 +   const extended = new BlockLocation(0, 1, 4);
		    482 +   const trigger = new BlockLocation(0, 8, 0);
		    483 +   const assertBlockPresentA = new BlockLocation(0, 7, 4);
		    484 +   const assertBlockPresentB = new BlockLocation(0, 6, 4);
		    485 +   const assertBlockPresentC = new BlockLocation(0, 5, 4);
		    486 + 
		    487 +   test.pressButton(trigger);
		414     -             test.pullLever(pullLeverPos);
		415     -         })
		416     -         .thenWaitWithDelay(12, () => {
		417     -             test.assertBlockPresent(Blocks.emeraldBlock(), blockPresentPosA);
		418     -         })
		419     -         .thenSucceed();
		420     - })
		421     -     .tag("suite:java_parity")
		422     -     .tag(GameTest.Tags.suiteDisabled);  //Pistons react at different speeds in Bedrock, create a new test called double_extender_bedrock.
		423 488   
		    489 +   test
		    490 +     .startSequence()
		424     - GameTest.register("PistonTests", "double_extender_bedrock", (test) => {
		    491 +     .thenIdle(30)
		    492 +     .thenWait(() => {
		    493 +       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentA);
		    494 +       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentB);
		    495 +       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentC);
		    496 +       test.assertBlockTypePresent(BlockTypes.concrete, extended);
		    497 +     })
		    498 +     .thenIdle(20)
		    499 +     .thenWait(() => {
		    500 +       test.pressButton(trigger);
		    501 +     })
		    502 +     .thenIdle(42)
		    503 +     .thenWait(() => {
		    504 +       test.assertBlockTypePresent(BlockTypes.stickyPiston, new assertBlockPresentA());
		    505 +       test.assertBlockTypePresent(BlockTypes.stickyPiston, new assertBlockPresentB());
		    506 +       test.assertBlockTypePresent(BlockTypes.stickyPiston, new assertBlockPresentC());
		    507 +       test.assertBlockTypePresent(BlockTypes.concrete, retracted);
		    508 +     })
		    509 +     .thenSucceed();
		425     -     const pullLeverPos = new BlockLocation(2, 3, 2);
		426     -     const blockPresentPosA = new BlockLocation(0, 2, 2);
		427     -     const blockPresentPosB = new BlockLocation(0, 2, 4);
		428     - 
		429     -     test.pullLever(pullLeverPos);
		430     -     test.assertBlockPresent(Blocks.emeraldBlock(), blockPresentPosA);
		431     - 
		432     -     //it's not possible to time it exactly due to redstone differences, so just validate assert can pass before given delay.
		433     -     test.startSequence()
		434     -         .thenIdle(17)
		435     -         .thenExecute(() => {
		436     -             test.assertBlockPresent(Blocks.emeraldBlock(), blockPresentPosB);
		437     -             test.pullLever(pullLeverPos);
		438     -         })
		439     -         .thenIdle(18)
		440     -         .thenExecute(() => {
		441     -             test.assertBlockPresent(Blocks.emeraldBlock(), blockPresentPosA);
		442     -         })
		443     -         .thenSucceed();
		444 510   })
		    511 +   .tag("suite:java_parity")
		    512 +   .tag(GameTest.Tags.suiteDisabled); // Game parity issue. Create a new test called triple_extender_bedrock using new structure, and updated piston react time.
		445     -     .structureName("PistonTests:double_extender")
		446     -     .tag(GameTest.Tags.suiteDefault);
		447 513   
		    514 + GameTest.register("PistonTests", "triple_extender_bedrock", (test) => {
		448     - GameTest.register("PistonTests", "triple_extender", (test) => {
		449     -     const retracted = new BlockLocation(0, 4, 4);
		    515 +   const retracted = new BlockLocation(0, 4, 4);
		    516 +   const extended = new BlockLocation(0, 1, 4);
		    517 +   const trigger = new BlockLocation(0, 7, 0);
		    518 +   const assertBlockPresentA = new BlockLocation(0, 7, 4);
		    519 +   const assertBlockPresentB = new BlockLocation(0, 6, 4);
		    520 +   const assertBlockPresentC = new BlockLocation(0, 5, 4);
		    521 +   const assertBlockPresentD = new BlockLocation(0, 3, 4);
		450     -     const extended = new BlockLocation(0, 1, 4);
		451     -     const trigger = new BlockLocation(0, 8, 0);
		452     -     const assertBlockPresentA = new BlockLocation(0, 7, 4);
		453     -     const assertBlockPresentB = new BlockLocation(0, 6, 4);
		454     -     const assertBlockPresentC = new BlockLocation(0, 5, 4);
		455     - 
		456     -     test.pressButton(trigger);
		457 522   
		    523 +   test.pressButton(trigger);
		    524 +   test
		    525 +     .startSequence()
		458     -     test.startSequence()
		    526 +     .thenIdle(33)
		    527 +     .thenExecute(() => {
		    528 +       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentA);
		    529 +       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentC);
		    530 +       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentD);
		    531 +       test.assertBlockTypePresent(BlockTypes.concrete, extended);
		    532 +     })
		    533 +     .thenIdle(1)
		    534 +     .thenExecute(() => {
		    535 +       test.pressButton(trigger);
		    536 +     })
		    537 +     .thenIdle(45)
		    538 +     .thenExecute(() => {
		    539 +       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentA);
		    540 +       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentB);
		    541 +       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentC);
		    542 +       test.assertBlockTypePresent(BlockTypes.concrete, retracted);
		    543 +     })
		    544 +     .thenSucceed();
		459     -         .thenIdle(30)
		460     -         .thenWait(() => {
		461     -             test.assertBlockPresent(Blocks.stickyPiston(), assertBlockPresentA);
		462     -             test.assertBlockPresent(Blocks.stickyPiston(), assertBlockPresentB);
		463     -             test.assertBlockPresent(Blocks.stickyPiston(), assertBlockPresentC);
		464     -             test.assertBlockPresent(Blocks.concrete(), extended);
		465     -         })
		466     -         .thenIdle(20)
		467     -         .thenWait(() => {
		468     -             test.pressButton(trigger);
		469     -         })
		470     -         .thenIdle(42)
		471     -         .thenWait(() => {
		472     -             test.assertBlockPresent(Blocks.stickyPiston(), new assertBlockPresentA);
		473     -             test.assertBlockPresent(Blocks.stickyPiston(), new assertBlockPresentB);
		474     -             test.assertBlockPresent(Blocks.stickyPiston(), new assertBlockPresentC);
		475     -             test.assertBlockPresent(Blocks.concrete(), retracted);
		476     -         })
		477     -         .thenSucceed();
		478 545   })
		    546 +   .tag(GameTest.Tags.suiteDisabled) // Disable this test after it is not passing 100% in Main.
		    547 +   .maxTicks(300);
		479     -     .tag("suite:java_parity")
		480     -     .tag(GameTest.Tags.suiteDisabled);  // Game parity issue. Create a new test called triple_extender_bedrock using new structure, and updated piston react time.
		481 548   
		    549 + GameTest.register("PistonTests", "monostable", (test) => {
		482     - GameTest.register("PistonTests", "triple_extender_bedrock", (test) => {
		483     -     const retracted = new BlockLocation(0, 4, 4);
		484     -     const extended = new BlockLocation(0, 1, 4);
		    550 +   const lampPos = new BlockLocation(0, 3, 5);
		    551 +   const pullLeverPos = new BlockLocation(0, 2, 0);
		    552 + 
		    553 +   test.assertBlockState("redstone_signal", 0, lampPos);
		    554 +   test.pullLever(pullLeverPos);
		485     -     const trigger = new BlockLocation(0, 7, 0);
		486     -     const assertBlockPresentA = new BlockLocation(0, 7, 4);
		487     -     const assertBlockPresentB = new BlockLocation(0, 6, 4);
		488     -     const assertBlockPresentC = new BlockLocation(0, 5, 4);
		489     -     const assertBlockPresentD = new BlockLocation(0, 3, 4);
		490 555   
		    556 +   test
		491     -     test.pressButton(trigger);
		492     -     test.startSequence()
		    557 +     .startSequence()
		    558 +     .thenWaitWithDelay(2, () => {
		    559 +       test.assertBlockState("redstone_signal", 1, lampPos);
		    560 +     })
		    561 +     .thenWaitWithDelay(4, () => {
		    562 +       test.assertBlockState("redstone_signal", 0, lampPos);
		    563 +     })
		    564 +     .thenSucceed();
		    565 + })
		    566 +   .tag("suite:java_parity")
		    567 +   .tag(GameTest.Tags.suiteDisabled); //quasi connectivity problem: when the repeater is in the upper right corner of the piston, the bedrock piston will not stretch, but Java will stretch
		    568 + 
		    569 + GameTest.register("PistonTests", "monostable_bedrock", (test) => {
		    570 +   const lampPos = new BlockLocation(0, 3, 5);
		    571 +   const pullLeverPos = new BlockLocation(0, 2, 0);
		    572 + 
		    573 +   test.assertRedstonePower(lampPos, 0);
		    574 + 
		    575 +   test
		    576 +     .startSequence()
		    577 +     .thenIdle(10)
		    578 +     .thenExecute(() => {
		    579 +       test.pullLever(pullLeverPos);
		    580 +     })
		    581 +     .thenIdle(5)
		    582 +     .thenExecute(() => {
		    583 +       test.assertRedstonePower(lampPos, 15);
		    584 +     })
		    585 +     .thenIdle(9)
		    586 +     .thenExecute(() => {
		    587 +       test.assertRedstonePower(lampPos, 0);
		    588 +     })
		    589 +     .thenSucceed();
		    590 + })
		    591 +   .maxTicks(100)
		    592 +   .tag(GameTest.Tags.suiteDefault);
		    593 + 
		    594 + GameTest.register("PistonTests", "instant_retraction", (test) => {
		493     -         .thenIdle(33)
		494     -         .thenExecute(() => {
		495     -             test.assertBlockPresent(Blocks.stickyPiston(), assertBlockPresentA);
		496     -             test.assertBlockPresent(Blocks.stickyPiston(), assertBlockPresentC);
		497     -             test.assertBlockPresent(Blocks.stickyPiston(), assertBlockPresentD);
		498     -             test.assertBlockPresent(Blocks.concrete(), extended);
		499     -         })
		500     -         .thenIdle(1)
		501     -         .thenExecute(() => {
		502     -             test.pressButton(trigger);
		503     -         })
		504     -         .thenIdle(45)
		505     -         .thenExecute(() => {
		506     -             test.assertBlockPresent(Blocks.stickyPiston(), assertBlockPresentA);
		507     -             test.assertBlockPresent(Blocks.stickyPiston(), assertBlockPresentB);
		508     -             test.assertBlockPresent(Blocks.stickyPiston(), assertBlockPresentC);
		509     -             test.assertBlockPresent(Blocks.concrete(), retracted);
		510     -         })
		511     -         .thenSucceed();
		512     - })
		513     -     .tag(GameTest.Tags.suiteDisabled) // Disable this test after it is not passing 100% in Main.
		514     -     .maxTicks(300);
		515     - 
		516     - GameTest.register("PistonTests", "monostable", (test) => {
		517     -     const lampPos = new BlockLocation(0, 3, 5);
		518     -     const pullLeverPos = new BlockLocation(0, 2, 0);
		519     - 
		520     -     test.assertBlockState("redstone_signal", 0, lampPos);
		521     -     test.pullLever(pullLeverPos);
		522     - 
		523     -     test.startSequence()
		524     -         .thenWaitWithDelay(2, () => {
		525     -             test.assertBlockState("redstone_signal", 1, lampPos);
		526     -         })
		527     -         .thenWaitWithDelay(4, () => {
		528     -             test.assertBlockState("redstone_signal", 0, lampPos);
		529     -         })
		530     -         .thenSucceed();
		531     - })
		    595 +   const airPos = new BlockLocation(2, 1, 1);
		    596 +   const concretePos = new BlockLocation(0, 1, 3);
		532     -     .tag("suite:java_parity")
		533     -     .tag(GameTest.Tags.suiteDisabled); //quasi connectivity problem: when the repeater is in the upper right corner of the piston, the bedrock piston will not stretch, but Java will stretch
		534 597   
		    598 +   test.setBlockType(BlockTypes.air, airPos);
		    599 +   test.succeedOnTickWhen(3, () => {
		    600 +     test.assertBlockTypePresent(BlockTypes.concrete, concretePos);
		535     - GameTest.register("PistonTests", "monostable_bedrock", (test) => {
		    601 +   });
		    602 + }).tag(GameTest.Tags.suiteDefault);
		536     -     const lampPos = new BlockLocation(0, 3, 5);
		537     -     const pullLeverPos = new BlockLocation(0, 2, 0);
		538 603   
		    604 + GameTest.register("PistonTests", "instant_repeater", (test) => {
		    605 +   const triggerPos = new BlockLocation(0, 3, 0);
		    606 +   const outputPos = new BlockLocation(0, 3, 25);
		    607 +   test.pullLever(triggerPos);
		539     -     test.assertRedstonePower(lampPos, 0);
		540 608   
		    609 +   test
		541     -     test.startSequence()
		542     -         .thenIdle(10)
		    610 +     .startSequence()
		    611 +     .thenWaitWithDelay(1, () => {
		    612 +       test.assertBlockState("redstone_signal", 1, outputPos);
		    613 +     })
		    614 +     .thenIdle(10) // relaxation time
		    615 +     .thenExecute(() => {
		    616 +       test.pullLever(triggerPos);
		    617 +     })
		    618 +     .thenWaitWithDelay(5, () => {
		    619 +       test.assertBlockState("redstone_signal", 0, outputPos);
		    620 +     })
		    621 +     .thenSucceed();
		543     -         .thenExecute(() => {
		544     -             test.pullLever(pullLeverPos);
		545     -         })
		546     -         .thenIdle(5)
		547     -         .thenExecute(() => {
		548     -             test.assertRedstonePower(lampPos, 15);
		549     -         })
		550     -         .thenIdle(9)
		551     -         .thenExecute(() => {
		552     -             test.assertRedstonePower(lampPos, 0);
		553     -         })
		554     -         .thenSucceed();
		555 622   })
		556     -     .maxTicks(100)
		557     -     .tag(GameTest.Tags.suiteDefault);
		558     - 
		559     - GameTest.register("PistonTests", "instant_retraction", (test) => {
		    623 +   .tag("suite:java_parity")
		    624 +   .tag(GameTest.Tags.suiteDisabled); //Instant repeaters rely on block update detection due to quasi-connectivity and cannot be built in Bedrock.
		560     -     const airPos = new BlockLocation(2, 1, 1);
		561     -     const concretePos = new BlockLocation(0, 1, 3);
		562 625   
		563     -     test.setBlock(Blocks.air(), airPos);
		564     -     test.succeedOnTickWhen(3, () => {
		565     -         test.assertBlockPresent(Blocks.concrete(), concretePos);
		    626 + GameTest.register("PistonTests", "entity_backside", (test) => {
		    627 +   const buttonPos = new BlockLocation(2, 2, 0);
		    628 +   const lampFailPos = new BlockLocation(4, 3, 2);
		566     -     })
		567     - })
		568     -     .tag(GameTest.Tags.suiteDefault);
		569 629   
		    630 +   test.pressButton(buttonPos);
		    631 +   test
		570     - GameTest.register("PistonTests", "instant_repeater", (test) => {
		571     -     const triggerPos = new BlockLocation(0, 3, 0);
		    632 +     .startSequence()
		    633 +     .thenIdle(30)
		572     -     const outputPos = new BlockLocation(0, 3, 25);
		573     -     test.pullLever(triggerPos);
		574     - 
		    634 +     .thenWait(() => {
		    635 +       test.assertBlockTypeNotPresent(BlockTypes.redstoneLamp, lampFailPos);
		    636 +     })
		    637 +     .thenSucceed();
		    638 + }).tag(GameTest.Tags.suiteDefault);
		    639 + 
		    640 + GameTest.register("PistonTests", "redstone_matrix", (test) => {
		    641 +   const buttonPos = new BlockLocation(1, 3, 1);
		    642 +   const wirePos = new BlockLocation(1, 4, 2);
		    643 + 
		    644 +   test.pressButton(buttonPos);
		    645 +   test
		    646 +     .startSequence()
		    647 +     .thenIdle(30)
		    648 +     .thenWait(() => {
		    649 +       test.assertBlockTypePresent(BlockTypes.redstoneWire, wirePos);
		    650 +     })
		    651 +     .thenSucceed();
		    652 + }).tag(GameTest.Tags.suiteDefault);
		575     -     test.startSequence()
		576     -         .thenWaitWithDelay(1, () => {
		577     -             test.assertBlockState("redstone_signal", 1, outputPos);
		578     -         })
		579     -         .thenIdle(10) // relaxation time
		580     -         .thenExecute(() => {
		581     -             test.pullLever(triggerPos);
		582     -         })
		583     -         .thenWaitWithDelay(5, () => {
		584     -             test.assertBlockState("redstone_signal", 0, outputPos);
		585     -         })
		586     -         .thenSucceed();
		587     - })
		588     -     .tag("suite:java_parity")
		589     -     .tag(GameTest.Tags.suiteDisabled);  //Instant repeaters rely on block update detection due to quasi-connectivity and cannot be built in Bedrock.
		590     - 
		591     - GameTest.register("PistonTests", "entity_backside", (test) => {
		592     -     const buttonPos = new BlockLocation(2, 2, 0);
		593     -     const lampFailPos = new BlockLocation(4, 3, 2);
		594 653   
		    654 + GameTest.register("PistonTests", "one_tick_pulse", (test) => {
		    655 +   const retractedPos = new BlockLocation(1, 2, 3);
		595     -     test.pressButton(buttonPos);
		596     -     test.startSequence()
		    656 +   const extendedPos = new BlockLocation(0, 2, 3);
		    657 +   const pressButtonPos = new BlockLocation(2, 2, 0);
		    658 + 
		    659 +   test.pressButton(pressButtonPos);
		    660 + 
		    661 +   test
		    662 +     .startSequence()
		597     -         .thenIdle(30)
		598     -         .thenWait(() => {
		599     -             test.assertBlockNotPresent(Blocks.redstoneLamp(), lampFailPos);
		600     -         })
		601     -         .thenSucceed();
		602     - })
		603     -     .tag(GameTest.Tags.suiteDefault);
		604 663   
		    664 +     .thenWaitWithDelay(2, () => {
		    665 +       test.assertBlockTypePresent(BlockTypes.stainedGlass, extendedPos);
		605     - GameTest.register("PistonTests", "redstone_matrix", (test) => {
		    666 +     })
		    667 +     .thenIdle(30)
		    668 +     .thenWait(() => {
		    669 +       test.pressButton(pressButtonPos);
		    670 +     })
		    671 +     .thenWaitWithDelay(4, () => {
		    672 +       test.assertBlockTypePresent(BlockTypes.stainedGlass, retractedPos);
		    673 +       test.assertBlockTypePresent(BlockTypes.air, extendedPos);
		    674 +     })
		    675 +     .thenSucceed();
		606     -     const buttonPos = new BlockLocation(1, 3, 1);
		607     -     const wirePos = new BlockLocation(1, 4, 2);
		608     - 
		609     -     test.pressButton(buttonPos);
		610     -     test.startSequence()
		611     -         .thenIdle(30)
		612     -         .thenWait(() => {
		613     -             test.assertBlockPresent(Blocks.redstoneWire(), wirePos);
		614     -         })
		615     -         .thenSucceed();
		616 676   })
		617     -     .tag(GameTest.Tags.suiteDefault);
		618     - 
		619     - GameTest.register("PistonTests", "one_tick_pulse", (test) => {
		620     -     const retractedPos = new BlockLocation(1, 2, 3);
		    677 +   .tag("suite:java_parity")
		    678 +   .tag(GameTest.Tags.suiteDisabled); //It's Gameplay differences. In Java Edition, pistons finish extending early and start retracting if given a pulse shorter than 3 game ticks, this causes the block to end up in its final position earlier.
		621     -     const extendedPos = new BlockLocation(0, 2, 3);
		622     -     const pressButtonPos = new BlockLocation(2, 2, 0);
		623 679   
		    680 + GameTest.register("PistonTests", "one_tick_pulse_bedrock", (test) => {
		    681 +   const retractedPos = new BlockLocation(1, 2, 3);
		    682 +   const extendedPos = new BlockLocation(0, 2, 3);
		    683 +   const pressButtonPos = new BlockLocation(2, 2, 0);
		624     -     test.pressButton(pressButtonPos);
		625 684   
		    685 +   test.pressButton(pressButtonPos);
		626     -     test.startSequence()
		627 686   
		628     -         .thenWaitWithDelay(2, () => {
		629     -             test.assertBlockPresent(Blocks.stainedGlass(), extendedPos)
		630     -         })
		    687 +   test
		    688 +     .startSequence()
		    689 +     .thenIdle(2)
		    690 +     .thenWait(() => {
		    691 +       test.assertBlockTypePresent(BlockTypes.stainedGlass, extendedPos);
		    692 +     })
		    693 +     .thenIdle(30)
		    694 +     .thenWait(() => {
		    695 +       test.pressButton(pressButtonPos);
		    696 +     })
		    697 +     .thenIdle(4)
		    698 +     .thenWait(() => {
		    699 +       test.assertBlockTypePresent(BlockTypes.stainedGlass, retractedPos);
		    700 +       test.assertBlockTypePresent(BlockTypes.air, extendedPos);
		    701 +     })
		    702 +     .thenSucceed();
		    703 + }).tag(GameTest.Tags.suiteDefault);
		631     -         .thenIdle(30)
		632     -         .thenWait(() => {
		633     -             test.pressButton(pressButtonPos);
		634     -         })
		635     -         .thenWaitWithDelay(4, () => {
		636     -             test.assertBlockPresent(Blocks.stainedGlass(), retractedPos);
		637     -             test.assertBlockPresent(Blocks.air(), extendedPos);
		638     -         })
		639     -         .thenSucceed();
		640     - })
		641     -     .tag("suite:java_parity")
		642     -     .tag(GameTest.Tags.suiteDisabled);   //It's Gameplay differences. In Java Edition, pistons finish extending early and start retracting if given a pulse shorter than 3 game ticks, this causes the block to end up in its final position earlier.
		643     - 
		644     - GameTest.register("PistonTests", "one_tick_pulse_bedrock", (test) => {
		645     -     const retractedPos = new BlockLocation(1, 2, 3);
		646     -     const extendedPos = new BlockLocation(0, 2, 3);
		647     -     const pressButtonPos = new BlockLocation(2, 2, 0);
		648 704   
		    705 + GameTest.register("PistonTests", "backside", (test) => {
		    706 +   var buttonsBlockPos = [
		    707 +     new BlockLocation(3, 3, 0),
		    708 +     new BlockLocation(1, 2, 1),
		    709 +     new BlockLocation(4, 3, 3),
		    710 +     new BlockLocation(1, 4, 3),
		    711 +     new BlockLocation(3, 3, 6),
		    712 +     new BlockLocation(0, 3, 5),
		    713 +   ];
		    714 + 
		    715 +   for (const buttonPos of buttonsBlockPos) {
		    716 +     test.pressButton(buttonPos);
		    717 +   }
		    718 +   test
		    719 +     .startSequence()
		    720 +     .thenIdle(30)
		    721 +     .thenWait(() => {
		    722 +       for (const buttonPos of buttonsBlockPos) {
		    723 +         test.assertBlockTypePresent(BlockTypes.stoneButton, buttonPos);
		    724 +       }
		    725 +     })
		    726 +     .thenSucceed();
		    727 + }).tag(GameTest.Tags.suiteDefault);
		649     -     test.pressButton(pressButtonPos);
		650     - 
		651     -     test.startSequence()
		652     -         .thenIdle(2)
		653     -         .thenWait(() => {
		654     -             test.assertBlockPresent(Blocks.stainedGlass(), extendedPos)
		655     -         })
		656     -         .thenIdle(30)
		657     -         .thenWait(() => {
		658     -             test.pressButton(pressButtonPos);
		659     -         })
		660     -         .thenIdle(4)
		661     -         .thenWait(() => {
		662     -             test.assertBlockPresent(Blocks.stainedGlass(), retractedPos);
		663     -             test.assertBlockPresent(Blocks.air(), extendedPos);
		664     -         })
		665     -         .thenSucceed();
		666     - })
		667     -     .tag(GameTest.Tags.suiteDefault)
		668     - 
		669 728   
		    729 + GameTest.register("PistonTests", "observer_retraction_timing", (test) => {
		670     - GameTest.register("PistonTests", "backside", (test) => {
		671     -     var buttonsBlockPos = [
		672     -         new BlockLocation(3, 3, 0),
		    730 +   const levelPos = new BlockLocation(3, 2, 2);
		    731 +   const observerPos = new BlockLocation(2, 2, 1);
		    732 +   test.pullLever(levelPos);
		    733 +   test
		    734 +     .startSequence()
		    735 +     .thenIdle(2)
		    736 +     .thenExecute(() => {
		    737 +       test.assertBlockState("powered_bit", 0, observerPos);
		    738 +     })
		    739 +     .thenIdle(1)
		    740 +     .thenExecute(() => {
		    741 +       test.assertBlockState("powered_bit", 1, observerPos);
		    742 +     })
		    743 +     .thenSucceed();
		    744 + }).tag(GameTest.Tags.suiteDefault);
		    745 + 
		    746 + GameTest.register("PistonTests", "random_tick_forcer", (test) => {
		    747 +   const buttonPos = new BlockLocation(1, 3, 0);
		    748 +   const flower = new BlockLocation(1, 3, 6);
		    749 +   const aboveFlower = new BlockLocation(1, 4, 6);
		673     -         new BlockLocation(1, 2, 1),
		674     -         new BlockLocation(4, 3, 3),
		675     -         new BlockLocation(1, 4, 3),
		676     -         new BlockLocation(3, 3, 6),
		677     -         new BlockLocation(0, 3, 5)
		678     -     ];
		679     - 
		680     -     for (const buttonPos of buttonsBlockPos) {
		681     -         test.pressButton(buttonPos);
		682     -     };
		683     -     test.startSequence()
		684     -         .thenIdle(30)
		685     -         .thenWait(() => {
		686     -             for (const buttonPos of buttonsBlockPos) {
		687     -                 test.assertBlockPresent(Blocks.stoneButton(), buttonPos);
		688     -             }
		689     -         })
		690     -         .thenSucceed();
		691     - })
		692     -     .tag(GameTest.Tags.suiteDefault)
		693 750   
		694     - GameTest.register("PistonTests", "observer_retraction_timing", (test) => {
		695     -     const levelPos = new BlockLocation(3, 2, 2);
		696     -     const observerPos = new BlockLocation(2, 2, 1);
		    751 +   test.pressButton(buttonPos);
		    752 +   test
		    753 +     .startSequence()
		    754 +     .thenIdle(20)
		    755 +     .thenExecute(() => {
		    756 +       test.assertBlockTypePresent(BlockTypes.chorusFlower, flower);
		    757 +       test.assertBlockTypePresent(BlockTypes.air, aboveFlower);
		    758 +     })
		    759 +     .thenSucceed();
		697     -     test.pullLever(levelPos);
		698     -     test.startSequence()
		699     -         .thenIdle(2).thenExecute(() => {
		700     -             test.assertBlockState("powered_bit", 0, observerPos);
		701     -         })
		702     -         .thenIdle(1).thenExecute(() => {
		703     -             test.assertBlockState("powered_bit", 1, observerPos);
		704     -         })
		705     -         .thenSucceed();
		706 760   })
		707     -     .tag(GameTest.Tags.suiteDefault);
		708     - 
		709     - GameTest.register("PistonTests", "random_tick_forcer", (test) => {
		    761 +   .batch("no_random_ticks")
		    762 +   .tag("suite:java_parity")
		    763 +   .tag(GameTest.Tags.suiteDisabled); //The parity problem is still being solved
		710     -     const buttonPos = new BlockLocation(1, 3, 0);
		711     -     const flower = new BlockLocation(1, 3, 6);
		712     -     const aboveFlower = new BlockLocation(1, 4, 6);
		713 764   
		    765 + GameTest.register("PistonTests", "random_tick_forcer_bedrock", (test) => {
		714     -     test.pressButton(buttonPos);
		715     -     test.startSequence()
		716     -         .thenIdle(20)
		    766 +   const buttonPos = new BlockLocation(1, 3, 0);
		    767 +   const flower = new BlockLocation(1, 3, 6);
		    768 +   const aboveFlower = new BlockLocation(1, 4, 6);
		    769 + 
		    770 +   test.pressButton(buttonPos);
		    771 +   test
		    772 +     .startSequence()
		    773 +     .thenIdle(10)
		    774 +     .thenExecute(() => {
		    775 +       test.assertBlockTypePresent(BlockTypes.chorusFlower, flower);
		    776 +       test.assertBlockTypePresent(BlockTypes.air, aboveFlower);
		    777 +     })
		    778 +     .thenSucceed();
		    779 + }).tag(GameTest.Tags.suiteDisabled);
		717     -         .thenExecute(() => {
		718     -             test.assertBlockPresent(Blocks.chorusFlower(), flower);
		719     -             test.assertBlockPresent(Blocks.air(), aboveFlower);
		720     -         })
		721     -         .thenSucceed();
		722     - })
		723     -     .batch("no_random_ticks")
		724     -     .tag("suite:java_parity")
		725     -     .tag(GameTest.Tags.suiteDisabled); //The parity problem is still being solved
		726     - 
		727     - GameTest.register("PistonTests", "random_tick_forcer_bedrock", (test) => {
		728     -     const buttonPos = new BlockLocation(1, 3, 0);
		729     -     const flower = new BlockLocation(1, 3, 6);
		730     -     const aboveFlower = new BlockLocation(1, 4, 6);
		731 780   
		732     -     test.pressButton(buttonPos);
		733     -     test.startSequence()
		734     -         .thenIdle(10)
		735     -         .thenExecute(() => {
		    781 + GameTest.register("PistonTests", "honey_block_entity_drag_down", (test) => {
		    782 +   const leverPos = new BlockLocation(1, 1, 0);
		    783 +   const entityTypePos = new BlockLocation(1, 4, 1);
		    784 +   const cowId = "minecraft:cow<minecraft:ageable_grow_up>";
		    785 +   const entityTouchingPos = new Location(1.5, 4.5, 1.5);
		    786 +   const entityNotTouchingTypePos = new Location(1.5, 3.5, 1.5);
		736     -             test.assertBlockPresent(Blocks.chorusFlower(), flower);
		737     -             test.assertBlockPresent(Blocks.air(), aboveFlower);
		738     -         })
		739     -         .thenSucceed();
		740     - })
		741     -     .tag(GameTest.Tags.suiteDefault);
		742 787   
		743     - GameTest.register("PistonTests", "honey_block_entity_drag_down", (test) => {
		744     -     const leverPos = new BlockLocation(1, 1, 0);
		745     -     const entityTypePos = new BlockLocation(1, 4, 1);
		    788 +   test.spawn(cowId, entityTypePos);
		    789 +   test.assertEntityTouching(cowId, entityTouchingPos);
		    790 +   test.assertEntityNotTouching(cowId, entityNotTouchingTypePos);
		746     -     const cowId = "minecraft:cow<minecraft:ageable_grow_up>";
		747     -     const entityTouchingPos = new Location(1.5, 4.5, 1.5);
		748     -     const entityNotTouchingTypePos = new Location(1.5, 3.5, 1.5);
		749 791   
		    792 +   const timeBetweenEachLeverPull = 4;
		750     -     test.spawn(cowId, entityTypePos);
		751     -     test.assertEntityTouching(cowId, entityTouchingPos);
		752     -     test.assertEntityNotTouching(cowId, entityNotTouchingTypePos);
		753 793   
		    794 +   var startSequence = test
		    795 +     .startSequence()
		    796 +     .thenIdle(4)
		    797 +     .thenExecuteAfter(timeBetweenEachLeverPull, () => {
		    798 +       test.pullLever(leverPos);
		    799 +     });
		    800 +   startSequence;
		754     -     const timeBetweenEachLeverPull = 4;
		755     - 
		756     -     var startSequence = test.startSequence().thenIdle(4).thenExecuteAfter(timeBetweenEachLeverPull, () => { test.pullLever(leverPos); })
		757     -     startSequence
		758 801   
		    802 +   for (var i = 0; i < 10; i++) {
		    803 +     startSequence.thenExecuteAfter(timeBetweenEachLeverPull, () => {
		    804 +       test.pullLever(leverPos);
		759     -     for (var i = 0; i < 10; i++) {
		    805 +     });
		    806 +   }
		760     -         startSequence.thenExecuteAfter(timeBetweenEachLeverPull, () => { test.pullLever(leverPos); })
		761     -     }
		762 807   
		    808 +   startSequence
		    809 +     .thenExecuteAfter(timeBetweenEachLeverPull, () => {
		763     -     startSequence
		    810 +       test.pullLever(leverPos);
		    811 +     })
		    812 +     .thenWait(() => {
		    813 +       test.assertEntityTouching(cowId, entityTouchingPos);
		    814 +       test.assertEntityNotTouching(cowId, entityNotTouchingTypePos);
		    815 +     })
		    816 +     .thenSucceed();
		    817 + }).tag(GameTest.Tags.suiteDefault);
		764     -         .thenExecuteAfter(timeBetweenEachLeverPull, () => { test.pullLever(leverPos); })
		765     -         .thenWait(() => {
		766     -             test.assertEntityTouching(cowId, entityTouchingPos);
		767     -             test.assertEntityNotTouching(cowId, entityNotTouchingTypePos);
		768     -         })
		769     -         .thenSucceed();
		770     - })
		771     -     .tag(GameTest.Tags.suiteDefault);
		          '''
	Added script "SmallMobTests.js":
		'''
		import * as GameTest from "GameTest";
		import { BlockLocation } from "Minecraft";
		
		GameTest.register("SmallMobTests", "fence_corner", (test) => {
		    const piglinEntityType = "minecraft:piglin<minecraft:entity_born>";
		    const entityLoc = new BlockLocation(1, 2, 1);
		    const piglin = test.spawnWithoutBehaviors(piglinEntityType, entityLoc);
				
		    const targetPos = new BlockLocation(3, 2, 3);
		    test.walkTo(piglin, targetPos, 1);
		    test.succeedWhenEntityPresent(piglinEntityType, targetPos);
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("SmallMobTests", "fence_side", (test) => {
		    const piglinEntityType = "minecraft:piglin<minecraft:entity_born>";
		    const entityLoc = new BlockLocation(2, 2, 2);
		    const piglin = test.spawnWithoutBehaviors(piglinEntityType, entityLoc);
			
		    const targetPos = new BlockLocation(0, 2, 2);
		    test.walkTo(piglin, targetPos, 1);
		    test.succeedWhenEntityPresent(piglinEntityType, targetPos);
		    test.runAfterDelay(10, () => {
		        test.succeedWhenEntityNotPresent(piglinEntityType, targetPos);
		    })
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("SmallMobTests", "fence_post", (test) => { 
		    const chickenEntityType = "minecraft:chicken";
		    const entityLoc = new BlockLocation(1, 2, 1);
		    const chicken = test.spawnWithoutBehaviors(chickenEntityType, entityLoc);
		
		    const targetPos = new BlockLocation(3, 2, 3);
		    test.walkTo(chicken, targetPos, 1);
		    test.succeedWhenEntityPresent(chickenEntityType, targetPos);
		})
		  .tag("suite:java_parity")
		  .tag(GameTest.Tags.suiteDisabled); //game parity,the chicken cannot walk between the fenceposts
		'''
	Added script "TntTests.js":
		'''
		import * as GameTest from "GameTest";
		import { BlockLocation, BlockTypes } from "Minecraft";
		
		
		function locToStr(loc) {
		    return [loc.x.toFixed(3), loc.y.toFixed(3), loc.z.toFixed(3)].join(', ');
		}
		
		function locationToBlockLocation(loc) {
		    return new BlockLocation(Math.floor(loc.x), Math.floor(loc.y), Math.floor(loc.z));;
		}
		
		// because of the barrier blocks, these positions are offset (2, 0, 40) from the Java tests
		GameTest.register("TntTests", "cannon", (test) => {
		    const projectilePosition = new BlockLocation(3, 10, 41);
		    const chargePosition = new BlockLocation(3, 10, 43);
		
		    for (var i = 0; i < 5; i++) {
		        var chargeTnt = test.spawn("minecraft:tnt", chargePosition);
		        test.setTntFuse(chargeTnt, 20);
		    }
		
		    var projectiles = new Array(5)
		
		    test.startSequence()
		        .thenExecuteAfter(10, () => {
		            for (var projectile of projectiles) {
		                projectile = test.spawn("minecraft:tnt", projectilePosition);
		                test.setTntFuse(projectile, 30);
		            }
		        })
		        .thenExecuteAfter(1, () => {
		            test.setBlockType(BlockTypes.air, new BlockLocation(2, 10, 40));
		        })
		        .thenExecuteFor(19, () => {
		            const expectedBlockLocation = locationToBlockLocation(projectiles[0].location);
		            const expectedVelocity = projectiles[0].velocity;
		
		            for (var i = 1; i < projectiles.length; i++) {
		                const blockLoc = locationToBlockLocation(projectiles[i].location);
		                if (!blockLoc.equals(expectedBlockLocation)) {
		                    test.fail("All projectile tnt should be in the same location, but they have spread apart. Expected " + locToStr(expectedBlockLocation) + ", but got " + locToStr(blockLoc));
		                }
		
		                if (!projectiles[i].velocity.equals(expectedVelocity)) {
		                    test.fail("All projectile tnt should have the same velocity, but they do not. Expected " + locToStr(expectedVelocity) + ", but got " + locToStr(projectiles[i].velocity));
		                }
		
		                // java tests the projectiles are still "alive". This seems unecessary because the TNT shouldn't be moving unless it is alive.
		            };
		        })
		        .thenExecute(() => {
		            const expectedLocation = new BlockLocation(3, 14, 4);
		            for (const projectile of projectiles) {
		                test.assertEntityInstancePresent(projectile, expectedLocation);
		            }
		
		        })
		        .thenSucceed();
		})
		  .maxTicks(30)
		  .tag("suite:java_parity");
		
		GameTest.register("TntTests", "bedrock_cannon", (test) => {
		    const projectilePosition = new BlockLocation(3, 9, 19);
		    const chargePosition = new BlockLocation(3, 9, 22);
		
		    for (var i = 0; i < 5; i++) {
		        var chargeTnt = test.spawn("minecraft:tnt", chargePosition);
		        test.setTntFuse(chargeTnt, 20);
		    }
		
		    var projectile = null
		
		    test.startSequence()
		        .thenExecuteAfter(10, () => {
		            for (var i = 0; i < 5; i++) {
		                projectile = test.spawn("minecraft:tnt", projectilePosition);
		                test.setTntFuse(projectile, 15);
		            }
		        })
		        .thenExecuteAfter(10, () => {
		            test.setBlockType(BlockTypes.air, new BlockLocation(3, 9, 18));
		        })
		        .thenExecuteAfter(5, () => {
		            const expectedLocation = new BlockLocation(3, 9, 7);
		
		            test.assertEntityInstancePresent(projectile, expectedLocation);
		        })
		        .thenSucceed();
		})
		  .maxTicks(26)
		  .tag(GameTest.Tags.suiteDefault);
		'''