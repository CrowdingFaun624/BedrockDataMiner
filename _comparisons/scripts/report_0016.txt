Difference of "scripts" between "1.17.20.23" (beta of "1.17.30") and "1.17.30.20" (beta of "1.17.30").

Changed behavior pack "vanilla_gametest":
	Total script: 23 (+1, -0)
	Changed script "BlockTests.js":
		Total line: 265 (+91, -78)
		          '''
		  1   1   import * as GameTest from "mojang-gametest";
		  2   2   import { BlockLocation, MinecraftBlockTypes, MinecraftItemTypes, BlockProperties, Direction } from "mojang-minecraft";
		      3 + import GameTestExtensions from "./GameTestExtensions.js";
		      4 + 
		      5 + const TicksPerSecond = 20;
		      6 + const FiveSecondsInTicks = 5 * TicksPerSecond;
		      7 + 
		      8 + const FALLING_SAND_TEMPLATE_NAME = "BlockTests:falling_sand_template";
		      9 + const FALLING_SAND_STARTUP_TICKS = 1;
		     10 + const FALLING_SAND_TIMEOUT_TICKS = 20;
		     11 + 
		     12 + const BLOCKS_THAT_POP_SAND = [
		     13 +   [MinecraftBlockTypes.woodenSlab, MinecraftBlockTypes.air], //replace missing oakSlab() with woodenSlab()
		     14 +   [MinecraftBlockTypes.chest, MinecraftBlockTypes.stone],
		     15 +   [MinecraftBlockTypes.rail, MinecraftBlockTypes.stone],
		     16 +   [MinecraftBlockTypes.stoneButton, MinecraftBlockTypes.stone],
		     17 +   [MinecraftBlockTypes.woodenPressurePlate, MinecraftBlockTypes.stone], //replace missing OakPressurePlate() with woodenPressurePlate()
		     18 +   [MinecraftBlockTypes.torch, MinecraftBlockTypes.stone],
		     19 +   [MinecraftBlockTypes.soulSand, MinecraftBlockTypes.air],
		     20 + ];
		     21 + 
		     22 + const BLOCKS_REPLACED_BY_SAND = [
		     23 +   MinecraftBlockTypes.water,
		     24 +   MinecraftBlockTypes.air,
		     25 +   MinecraftBlockTypes.tallgrass, //replace grass() with tallgrass(). It needs grass, not grass block, MinecraftBlockTypes.grass is actually grass block.
		     26 + ];
		     27 + 
		     28 + const BLOCKS_THAT_SUPPORT_SAND = [
		     29 +   MinecraftBlockTypes.stone,
		     30 +   MinecraftBlockTypes.fence, //replace missing oakFence() with fence()
		     31 +   MinecraftBlockTypes.oakStairs,
		     32 +   MinecraftBlockTypes.scaffolding,
		     33 + ];
		  3  34   
		     35 + function testThatFallingSandPopsIntoItem(test) {
		     36 +   test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		  4     - const TicksPerSecond = 20;
		     37 +   const targetPos = new BlockLocation(1, 2, 1);
		  5     - const FiveSecondsInTicks = 5 * TicksPerSecond;
		  6  38   
		     39 +   test.succeedWhen(() => {
		     40 +     test.assertEntityPresentInArea("minecraft:item", true);
		     41 +     test.assertEntityPresent("minecraft:falling_block", targetPos, false);
		  7     - const FALLING_SAND_TEMPLATE_NAME = "BlockTests:falling_sand_template";
		     42 +   });
		     43 + }
		  8     - const FALLING_SAND_STARTUP_TICKS = 1;
		  9     - const FALLING_SAND_TIMEOUT_TICKS = 20;
		 10  44   
		     45 + function testThatFallingSandReplaces(test) {
		     46 +   test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		 11     - const BLOCKS_THAT_POP_SAND = [
		 12     -   [MinecraftBlockTypes.woodenSlab, MinecraftBlockTypes.air], //replace missing oakSlab() with woodenSlab()
		     47 +   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.sand, new BlockLocation(1, 2, 1), true);
		     48 + }
		     49 + 
		     50 + function testThatFallingSandLandsOnTop(test) {
		     51 +   test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		     52 +   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.sand, new BlockLocation(1, 3, 1), true);
		     53 + }
		 13     -   [MinecraftBlockTypes.chest, MinecraftBlockTypes.stone],
		 14     -   [MinecraftBlockTypes.rail, MinecraftBlockTypes.stone],
		 15     -   [MinecraftBlockTypes.stoneButton, MinecraftBlockTypes.stone],
		 16     -   [MinecraftBlockTypes.woodenPressurePlate, MinecraftBlockTypes.stone], //replace missing OakPressurePlate() with woodenPressurePlate()
		 17     -   [MinecraftBlockTypes.torch, MinecraftBlockTypes.stone],
		 18     -   [MinecraftBlockTypes.soulSand, MinecraftBlockTypes.air],
		 19     - ];
		 20  54   
		     55 + ///
		     56 + // Concrete Tests
		     57 + ///
		     58 + for (let i = 0; i < BLOCKS_THAT_POP_SAND.length; i++) {
		     59 +   const topBlock = BLOCKS_THAT_POP_SAND[i][0];
		     60 +   const bottomBlock = BLOCKS_THAT_POP_SAND[i][1];
		     61 +   const testName = "blocktests.falling_sand_pops_on_" + topBlock.getName();
		     62 +   let tag = null;
		 21     - const BLOCKS_REPLACED_BY_SAND = [
		 22     -   MinecraftBlockTypes.water,
		 23     -   MinecraftBlockTypes.air,
		 24     -   MinecraftBlockTypes.tallgrass, //replace grass() with tallgrass(). It needs grass, not grass block, MinecraftBlockTypes.grass is actually grass block.
		 25     - ];
		 26  63   
		     64 +   GameTest.register("BlockTests", testName, (test) => {
		 27     - const BLOCKS_THAT_SUPPORT_SAND = [
		 28     -   MinecraftBlockTypes.stone,
		 29     -   MinecraftBlockTypes.fence, //replace missing oakFence() with fence()
		     65 +     if (topBlock.getName() == "minecraft:stone_button") {
		     66 +       const buttonPermutation = MinecraftBlockTypes.stoneButton.createDefaultBlockPermutation();
		     67 +       buttonPermutation.getProperty(BlockProperties.facingDirection).value = Direction.north;
		 30     -   MinecraftBlockTypes.oakStairs,
		 31     -   MinecraftBlockTypes.scaffolding,
		 32     - ];
		 33     - 
		     68 +       test.setBlockPermutation(buttonPermutation, new BlockLocation(1, 2, 1));
		     69 +     } else {
		     70 +       test.setBlockType(topBlock, new BlockLocation(1, 2, 1));
		     71 +     }
		     72 +     test.setBlockType(bottomBlock, new BlockLocation(1, 1, 1));
		     73 +     testThatFallingSandPopsIntoItem(test);
		     74 +   })
		     75 +     .batch("day")
		     76 +     .structureName(FALLING_SAND_TEMPLATE_NAME)
		     77 +     .maxTicks(FALLING_SAND_TIMEOUT_TICKS)
		     78 +     .setupTicks(FALLING_SAND_STARTUP_TICKS)
		     79 +     .required(true)
		     80 +     .tag(GameTest.Tags.suiteDefault);
		 34     - function testThatFallingSandPopsIntoItem(test) {
		 35     -   test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		 36     -   const targetPos = new BlockLocation(1, 2, 1);
		 37     - 
		 38     -   test.succeedWhen(() => {
		 39     -     test.assertEntityPresentInArea("minecraft:item", true);
		 40     -     test.assertEntityPresent("minecraft:falling_block", targetPos, false);
		 41     -   });
		 42     - }
		 43     - 
		 44     - function testThatFallingSandReplaces(test) {
		 45     -   test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		 46     -   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.sand, new BlockLocation(1, 2, 1), true);
		 47  81   }
		     82 + 
		     83 + for (const block of BLOCKS_REPLACED_BY_SAND) {
		     84 +   const testName = "blocktests.falling_sand_replaces_" + block.getName();
		 48  85   
		     86 +   GameTest.register("BlockTests", testName, (test) => {
		     87 +     //SetBlock will fail if set a block to what it already is. Skip to call setblock() for test falling_sand_replaces_air because it's just air block in initial structure.
		 49     - function testThatFallingSandLandsOnTop(test) {
		     88 +     if (block.getName() != "minecraft:air") {
		     89 +       test.setBlockType(block, new BlockLocation(1, 2, 1));
		     90 +     }
		     91 +     testThatFallingSandReplaces(test);
		     92 +   })
		     93 +     .batch("day")
		     94 +     .structureName(FALLING_SAND_TEMPLATE_NAME)
		     95 +     .maxTicks(FALLING_SAND_TIMEOUT_TICKS)
		     96 +     .setupTicks(FALLING_SAND_STARTUP_TICKS)
		     97 +     .required(true)
		     98 +     .tag(GameTest.Tags.suiteDefault);
		     99 + }
		 50     -   test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		 51     -   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.sand, new BlockLocation(1, 3, 1), true);
		 52     - }
		 53     - 
		 54     - ///
		 55     - // Concrete Tests
		 56     - ///
		 57     - for (let i = 0; i < BLOCKS_THAT_POP_SAND.length; i++) {
		 58     -   const topBlock = BLOCKS_THAT_POP_SAND[i][0];
		 59     -   const bottomBlock = BLOCKS_THAT_POP_SAND[i][1];
		 60     -   const testName = "blocktests.falling_sand_pops_on_" + topBlock.getName();
		 61     -   let tag = null;
		 62 100   
		 63     -   GameTest.register("BlockTests", testName, (test) => {
		 64     -     if (topBlock.getName() == "minecraft:stone_button") {
		 65     -       const buttonPermutation = MinecraftBlockTypes.stoneButton.createDefaultBlockPermutation();
		    101 + for (const block of BLOCKS_THAT_SUPPORT_SAND) {
		    102 +   const testName = "blocktests.falling_sand_lands_on_" + block.getName();
		    103 +   let tag = null;
		    104 + 
		    105 +   GameTest.register("BlockTests", testName, (test) => {
		    106 +     test.setBlockType(block, new BlockLocation(1, 2, 1));
		    107 +     testThatFallingSandLandsOnTop(test);
		 66     -       buttonPermutation.getProperty(BlockProperties.facingDirection).value = Direction.north;
		 67     -       test.setBlockPermutation(buttonPermutation, new BlockLocation(1, 2, 1));
		 68     -     } else {
		 69     -       test.setBlockType(topBlock, new BlockLocation(1, 2, 1));
		 70     -     }
		 71     -     test.setBlockType(bottomBlock, new BlockLocation(1, 1, 1));
		 72     -     testThatFallingSandPopsIntoItem(test);
		 73 108     })
		 74 109       .batch("day")
		 75 110       .structureName(FALLING_SAND_TEMPLATE_NAME)
		 76 111       .maxTicks(FALLING_SAND_TIMEOUT_TICKS)
		 77 112       .setupTicks(FALLING_SAND_STARTUP_TICKS)
		 78 113       .required(true)
		 79 114       .tag(GameTest.Tags.suiteDefault);
		 80 115   }
		 81     - 
		 82     - for (const block of BLOCKS_REPLACED_BY_SAND) {
		 83     -   const testName = "blocktests.falling_sand_replaces_" + block.getName();
		 84 116   
		    117 + GameTest.register("BlockTests", "concrete_solidifies_in_shallow_water", (test) => {
		 85     -   GameTest.register("BlockTests", testName, (test) => {
		 86     -     //SetBlock will fail if set a block to what it already is. Skip to call setblock() for test falling_sand_replaces_air because it's just air block in initial structure.
		 87     -     if (block.getName() != "minecraft:air") {
		    118 +   test.setBlockType(MinecraftBlockTypes.concretepowder, new BlockLocation(1, 3, 1));
		    119 + 
		    120 +   test.succeedWhen(() => {
		    121 +     test.assertBlockPresent(MinecraftBlockTypes.concrete, new BlockLocation(1, 2, 1), true);
		    122 +   });
		    123 + })
		    124 +   .maxTicks(FiveSecondsInTicks)
		    125 +   .tag(GameTest.Tags.suiteDefault);
		    126 + 
		    127 + GameTest.register("BlockTests", "concrete_solidifies_in_deep_water", (test) => {
		    128 +   test.setBlockType(MinecraftBlockTypes.concretepowder, new BlockLocation(1, 4, 1));
		 88     -       test.setBlockType(block, new BlockLocation(1, 2, 1));
		 89     -     }
		 90     -     testThatFallingSandReplaces(test);
		 91     -   })
		 92     -     .batch("day")
		 93     -     .structureName(FALLING_SAND_TEMPLATE_NAME)
		 94     -     .maxTicks(FALLING_SAND_TIMEOUT_TICKS)
		 95     -     .setupTicks(FALLING_SAND_STARTUP_TICKS)
		 96     -     .required(true)
		 97     -     .tag(GameTest.Tags.suiteDefault);
		 98     - }
		 99 129   
		    130 +   test.succeedWhen(() => {
		    131 +     test.assertBlockPresent(MinecraftBlockTypes.concrete, new BlockLocation(1, 2, 1), true);
		    132 +   });
		    133 + })
		    134 +   .maxTicks(FiveSecondsInTicks)
		    135 +   .tag(GameTest.Tags.suiteDefault);
		100     - for (const block of BLOCKS_THAT_SUPPORT_SAND) {
		101     -   const testName = "blocktests.falling_sand_lands_on_" + block.getName();
		102     -   let tag = null;
		103 136   
		    137 + GameTest.register("BlockTests", "concrete_solidifies_next_to_water", (test) => {
		104     -   GameTest.register("BlockTests", testName, (test) => {
		105     -     test.setBlockType(block, new BlockLocation(1, 2, 1));
		106     -     testThatFallingSandLandsOnTop(test);
		    138 +   test.setBlockType(MinecraftBlockTypes.concretepowder, new BlockLocation(1, 3, 1));
		    139 + 
		    140 +   test.succeedWhen(() => {
		    141 +     test.assertBlockPresent(MinecraftBlockTypes.concrete, new BlockLocation(1, 2, 1), true);
		    142 +   });
		    143 + })
		    144 +   .maxTicks(FiveSecondsInTicks)
		    145 +   .tag(GameTest.Tags.suiteDefault);
		107     -   })
		108     -     .batch("day")
		109     -     .structureName(FALLING_SAND_TEMPLATE_NAME)
		110     -     .maxTicks(FALLING_SAND_TIMEOUT_TICKS)
		111     -     .setupTicks(FALLING_SAND_STARTUP_TICKS)
		112     -     .required(true)
		113     -     .tag(GameTest.Tags.suiteDefault);
		114     - }
		115 146   
		    147 + GameTest.register("BlockTests", "sand_fall_boats", (test) => {
		    148 +   test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		116     - GameTest.register("BlockTests", "concrete_solidifies_in_shallow_water", (test) => {
		117     -   test.setBlockType(MinecraftBlockTypes.concretepowder, new BlockLocation(1, 3, 1));
		118 149   
		119 150     test.succeedWhen(() => {
		    151 +     test.assertBlockPresent(MinecraftBlockTypes.sand, new BlockLocation(1, 2, 1), true);
		120     -     test.assertBlockPresent(MinecraftBlockTypes.concrete, new BlockLocation(1, 2, 1), true);
		121 152     });
		122 153   })
		123 154     .maxTicks(FiveSecondsInTicks)
		124 155     .tag(GameTest.Tags.suiteDefault);
		125 156   
		    157 + GameTest.register("BlockTests", "sand_fall_shulker", (test) => {
		    158 +   const EntitySpawnType = "minecraft:shulker";
		126     - GameTest.register("BlockTests", "concrete_solidifies_in_deep_water", (test) => {
		    159 +   const spawnPos = new BlockLocation(1, 2, 1);
		127     -   test.setBlockType(MinecraftBlockTypes.concretepowder, new BlockLocation(1, 4, 1));
		128 160   
		    161 +   test.spawn(EntitySpawnType, spawnPos);
		129     -   test.succeedWhen(() => {
		130     -     test.assertBlockPresent(MinecraftBlockTypes.concrete, new BlockLocation(1, 2, 1), true);
		    162 +   testThatFallingSandPopsIntoItem(test);
		131     -   });
		132 163   })
		133 164     .maxTicks(FiveSecondsInTicks)
		134 165     .tag(GameTest.Tags.suiteDefault);
		135     - 
		136     - GameTest.register("BlockTests", "concrete_solidifies_next_to_water", (test) => {
		137     -   test.setBlockType(MinecraftBlockTypes.concretepowder, new BlockLocation(1, 3, 1));
		138 166   
		    167 + ///
		139     -   test.succeedWhen(() => {
		140     -     test.assertBlockPresent(MinecraftBlockTypes.concrete, new BlockLocation(1, 2, 1), true);
		141     -   });
		    168 + // Turtle Egg Tests
		    169 + ///
		142     - })
		143     -   .maxTicks(FiveSecondsInTicks)
		144     -   .tag(GameTest.Tags.suiteDefault);
		145 170   
		    171 + GameTest.register("BlockTests", "turtle_eggs_survive_xp", (test) => {
		    172 +   const xpOrb = "minecraft:xp_orb";
		146     - GameTest.register("BlockTests", "sand_fall_boats", (test) => {
		    173 +   const spawnPos = new BlockLocation(1, 3, 1);
		147     -   test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		148 174   
		149     -   test.succeedWhen(() => {
		150     -     test.assertBlockPresent(MinecraftBlockTypes.sand, new BlockLocation(1, 2, 1), true);
		151     -   });
		    175 +   for (let i = 0; i < 8; i++) {
		    176 +     test.spawn(xpOrb, spawnPos);
		    177 +   }
		152     - })
		153     -   .maxTicks(FiveSecondsInTicks)
		154     -   .tag(GameTest.Tags.suiteDefault);
		155 178   
		    179 +   // Fail if the turtle egg dies
		    180 +   test.failIf(() => {
		156     - GameTest.register("BlockTests", "sand_fall_shulker", (test) => {
		    181 +     test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1), true);
		    182 +   });
		157     -   const EntitySpawnType = "minecraft:shulker";
		158     -   const spawnPos = new BlockLocation(1, 2, 1);
		159 183   
		    184 +   // Succeed after 4 seconds
		    185 +   test.startSequence().thenIdle(80).thenSucceed();
		160     -   test.spawn(EntitySpawnType, spawnPos);
		161     -   testThatFallingSandPopsIntoItem(test);
		162 186   })
		163 187     .maxTicks(FiveSecondsInTicks)
		164 188     .tag(GameTest.Tags.suiteDefault);
		165     - 
		166     - ///
		167     - // Turtle Egg Tests
		168     - ///
		169 189   
		    190 + GameTest.register("BlockTests", "turtle_eggs_survive_item", (test) => {
		170     - GameTest.register("BlockTests", "turtle_eggs_survive_xp", (test) => {
		171     -   const xpOrb = "minecraft:xp_orb";
		    191 +   test.pressButton(new BlockLocation(2, 4, 0));
		172     -   const spawnPos = new BlockLocation(1, 3, 1);
		173 192   
		    193 +   // Fail if the turtle egg dies
		    194 +   test.failIf(() => {
		174     -   for (let i = 0; i < 8; i++) {
		    195 +     test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1), true);
		    196 +   });
		175     -     test.spawn(xpOrb, spawnPos);
		176     -   }
		177 197   
		    198 +   // Succeed after 4 seconds
		    199 +   test.startSequence().thenIdle(80).thenSucceed();
		178     -   // Fail if the turtle egg dies
		    200 + })
		    201 +   .maxTicks(FiveSecondsInTicks)
		    202 +   .tag(GameTest.Tags.suiteDefault);
		179     -   test.failIf(() => {
		180     -     test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1), true);
		181     -   });
		182 203   
		    204 + GameTest.register("BlockTests", "turtle_eggs_squished_by_mob", (test) => {
		    205 +   const zombieEntityType = "minecraft:husk";
		    206 +   const zombiePosition = new BlockLocation(1, 5, 1);
		    207 +   test.spawn(zombieEntityType, zombiePosition);
		    208 +   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1), true);
		183     -   // Succeed after 4 seconds
		184     -   test.startSequence().thenIdle(80).thenSucceed();
		185 209   })
		    210 +   .required(false)
		    211 +   .maxTicks(TicksPerSecond * 20)
		186     -   .maxTicks(FiveSecondsInTicks)
		187 212     .tag(GameTest.Tags.suiteDefault);
		188     - 
		189     - GameTest.register("BlockTests", "turtle_eggs_survive_item", (test) => {
		190     -   test.pressButton(new BlockLocation(2, 4, 0));
		191 213   
		    214 + GameTest.register("BlockTests", "explosion_drop_location", (test) => {
		192     -   // Fail if the turtle egg dies
		193     -   test.failIf(() => {
		194     -     test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1), true);
		    215 +   test.pressButton(new BlockLocation(4, 3, 4));
		195     -   });
		196 216   
		    217 +   test.succeedWhen(() => {
		197     -   // Succeed after 4 seconds
		198     -   test.startSequence().thenIdle(80).thenSucceed();
		199     - })
		    218 +     const redSandstonePos = new BlockLocation(6, 2, 4);
		    219 +     const sandstonePos = new BlockLocation(2, 2, 4);
		200     -   .maxTicks(FiveSecondsInTicks)
		201     -   .tag(GameTest.Tags.suiteDefault);
		202 220   
		    221 +     test.assertBlockPresent(MinecraftBlockTypes.redSandstone, redSandstonePos, false);
		    222 +     test.assertBlockPresent(MinecraftBlockTypes.sandstone, sandstonePos, false);
		203     - GameTest.register("BlockTests", "turtle_eggs_squished_by_mob", (test) => {
		204     -   const zombieEntityType = "minecraft:husk";
		    223 +     test.assertItemEntityPresent(MinecraftItemTypes.redSandstone, redSandstonePos, 2.0, true);
		    224 +     test.assertItemEntityPresent(MinecraftItemTypes.sandstone, sandstonePos, 2.0, true);
		    225 +   });
		205     -   const zombiePosition = new BlockLocation(1, 5, 1);
		206     -   test.spawn(zombieEntityType, zombiePosition);
		207     -   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1), true);
		208 226   })
		    227 +   .maxTicks(TicksPerSecond * 10)
		209     -   .required(false)
		210     -   .maxTicks(TicksPerSecond * 20)
		211     -   .tag(GameTest.Tags.suiteDefault);
		    228 +   .tag("suite:java_parity")
		    229 +   .tag(GameTest.Tags.suiteDisabled) //redSandstone and sandstone items should be present.
		    230 +   .maxAttempts(3);
		212     - 
		213     - GameTest.register("BlockTests", "explosion_drop_location", (test) => {
		214     -   test.pressButton(new BlockLocation(4, 3, 4));
		215 231   
		    232 + GameTest.register("BlockTests", "concrete_pops_off_waterlogged_chest", (test) => {
		    233 +   test.setBlockType(MinecraftBlockTypes.concretepowder, new BlockLocation(1, 4, 1));
		216 234     test.succeedWhen(() => {
		217     -     const redSandstonePos = new BlockLocation(6, 2, 4);
		218     -     const sandstonePos = new BlockLocation(2, 2, 4);
		219     - 
		    235 +     const chestPos = new BlockLocation(1, 2, 1);
		    236 +     test.assertBlockPresent(MinecraftBlockTypes.chest, chestPos, true);
		    237 +     test.assertItemEntityPresent(MinecraftItemTypes.concretePowder, chestPos, 2, true);
		    238 +     test.assertEntityPresentInArea("falling_block", false);
		220     -     test.assertBlockPresent(MinecraftBlockTypes.redSandstone, redSandstonePos, false);
		221     -     test.assertBlockPresent(MinecraftBlockTypes.sandstone, sandstonePos, false);
		222     -     test.assertItemEntityPresent(MinecraftItemTypes.redSandstone, redSandstonePos, 2.0, true);
		223     -     test.assertItemEntityPresent(MinecraftItemTypes.sandstone, sandstonePos, 2.0, true);
		224 239     });
		225 240   })
		    241 +   .maxTicks(TicksPerSecond * 5)
		226     -   .maxTicks(TicksPerSecond * 10)
		227     -   .tag("suite:java_parity")
		228     -   .tag(GameTest.Tags.suiteDisabled) //redSandstone and sandstone items should be present.
		    242 +   .tag(GameTest.Tags.suiteDefault);
		229     -   .maxAttempts(3);
		230 243   
		    244 + GameTest.register("BlockTests", "waterlogged_slab", (test) => {
		    245 +   const slabPos = new BlockLocation(1, 1, 1);
		231     - GameTest.register("BlockTests", "concrete_pops_off_waterlogged_chest", (test) => {
		    246 +   test.assertIsWaterlogged(slabPos, false);
		232     -   test.setBlockType(MinecraftBlockTypes.concretepowder, new BlockLocation(1, 4, 1));
		233 247     test.succeedWhen(() => {
		    248 +     test.assertIsWaterlogged(slabPos, true);
		    249 +   });
		    250 + })
		    251 +   .tag("suite:java_parity")
		    252 +   .tag(GameTest.Tags.suiteDisabled) // Slab should be waterlogged
		    253 +   .maxTicks(TicksPerSecond * 2);
		    254 + 
		    255 + GameTest.register("BlockTests", "dispenser_light_candles", (test) => {
		    256 +   const testEx = new GameTestExtensions(test);
		    257 +   test.pressButton(new BlockLocation(1, 3, 0));
		    258 +   test.pressButton(new BlockLocation(1, 3, 2));
		234     -     const chestPos = new BlockLocation(1, 2, 1);
		235     -     test.assertBlockPresent(MinecraftBlockTypes.chest, chestPos, true);
		236     -     test.assertItemEntityPresent(MinecraftItemTypes.concretePowder, chestPos, 2, true);
		237     -     test.assertEntityPresentInArea("falling_block", false);
		238     -   });
		239     - })
		240     -   .maxTicks(TicksPerSecond * 5)
		241     -   .tag(GameTest.Tags.suiteDefault);
		242 259   
		243     - GameTest.register("BlockTests", "waterlogged_slab", (test) => {
		244     -   const slabPos = new BlockLocation(1, 1, 1);
		245     -   test.assertIsWaterlogged(slabPos, false);
		246 260     test.succeedWhen(() => {
		    261 +     testEx.assertBlockProperty("lit", 1, new BlockLocation(0, 2, 0));
		    262 +     testEx.assertBlockProperty("lit", 1, new BlockLocation(0, 2, 2));
		247     -     test.assertIsWaterlogged(slabPos, true);
		248 263     });
		249 264   })
		    265 +   .tag(GameTest.Tags.suiteDefault)
		250     -   .tag("suite:java_parity")
		251     -   .tag(GameTest.Tags.suiteDisabled) // Slab should be waterlogged
		252     -   .maxTicks(TicksPerSecond * 2);
		          '''
	Changed script "DoorTests.js":
		Total line: 175 (+85, -27)
		          '''
		  1   1   import * as GameTest from "mojang-gametest";
		  2   2   import { BlockLocation } from "mojang-minecraft";
		      3 + import GameTestExtensions from "./GameTestExtensions.js";
		      4 + 
		      5 + const DOOR_TEST_PADDING = 100; // The padding for the door tests will need to be increased some more to prevent the interference
		      6 + 
		      7 + GameTest.register("DoorTests", "four_villagers_one_door", (test) => {
		      8 +   const villagerEntityType = "minecraft:villager_v2";
		      9 +   const villagerEntitySpawnType = "minecraft:villager_v2<minecraft:spawn_farmer>"; // Attempt to spawn the villagers as farmers
		     10 + 
		     11 +   test.spawn(villagerEntitySpawnType, new BlockLocation(5, 2, 4));
		     12 +   test.spawn(villagerEntitySpawnType, new BlockLocation(4, 2, 5));
		     13 +   test.spawn(villagerEntitySpawnType, new BlockLocation(2, 2, 5));
		     14 +   test.spawn(villagerEntitySpawnType, new BlockLocation(1, 2, 4));
		     15 + 
		     16 +   test.succeedWhen(() => {
		     17 +     test.assertEntityPresent(villagerEntityType, new BlockLocation(5, 2, 2), true);
		     18 +     test.assertEntityPresent(villagerEntityType, new BlockLocation(5, 2, 1), true);
		     19 +     test.assertEntityPresent(villagerEntityType, new BlockLocation(1, 2, 2), true);
		     20 +     test.assertEntityPresent(villagerEntityType, new BlockLocation(1, 2, 1), true);
		     21 +   });
		     22 + })
		     23 +   .tag(GameTest.Tags.suiteDisabled) // Villagers can get stuck on the door or on sleeping villagers
		     24 +   .padding(DOOR_TEST_PADDING) // Space out villager tests to stop them from confusing each other
		     25 +   .batch("night") // This should be a constant at some point
		     26 +   .maxTicks(600);
		     27 + 
		     28 + GameTest.register("DoorTests", "villagers_can_pass_open_iron_door", (test) => {
		     29 +   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		     30 + 
		     31 +   test.spawn(villagerActor, new BlockLocation(2, 2, 5));
		     32 + 
		     33 +   test.succeedWhenEntityPresent(villagerActor, new BlockLocation(1, 2, 1), true);
		     34 + })
		     35 +   .maxTicks(900) //Increase max ticks from 200 to 900 (same value as in PathFindingTests), to make sure villager can find and go to bed
		     36 +   .batch("night")
		     37 +   .required(false)
		     38 +   .padding(DOOR_TEST_PADDING)
		     39 +   .tag(GameTest.Tags.suiteDefault);
		     40 + 
		     41 + GameTest.register("DoorTests", "villagers_cant_pass_closed_iron_door", (test) => {
		     42 +   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		     43 + 
		     44 +   test.spawn(villagerActor, new BlockLocation(2, 2, 5));
		     45 + 
		     46 +   test
		     47 +     .startSequence()
		     48 +     .thenExecute(() => {
		     49 +       test.assertEntityPresent(villagerActor, new BlockLocation(1, 2, 1), false);
		     50 +     })
		     51 +     .thenIdle(200)
		     52 +     .thenSucceed();
		     53 + })
		     54 +   .maxTicks(220)
		     55 +   .padding(DOOR_TEST_PADDING)
		     56 +   .batch("night")
		     57 +   .required(false)
		     58 +   .tag(GameTest.Tags.suiteDefault);
		  3     - 
		  4     - const DOOR_TEST_PADDING = 100; // The padding for the door tests will need to be increased some more to prevent the interference
		  5     - 
		  6     - GameTest.register("DoorTests", "four_villagers_one_door", (test) => {
		  7     -   const villagerEntityType = "minecraft:villager_v2";
		  8     -   const villagerEntitySpawnType = "minecraft:villager_v2<minecraft:spawn_farmer>"; // Attempt to spawn the villagers as farmers
		  9  59   
		     60 + GameTest.register("DoorTests", "door_maze", (test) => {
		 10     -   test.spawn(villagerEntitySpawnType, new BlockLocation(5, 2, 4));
		 11     -   test.spawn(villagerEntitySpawnType, new BlockLocation(4, 2, 5));
		 12     -   test.spawn(villagerEntitySpawnType, new BlockLocation(2, 2, 5));
		     61 +   const villagerActor = "minecraft:villager_v2";
		 13     -   test.spawn(villagerEntitySpawnType, new BlockLocation(1, 2, 4));
		 14  62   
		 15     -   test.succeedWhen(() => {
		 16     -     test.assertEntityPresent(villagerEntityType, new BlockLocation(5, 2, 2), true);
		 17     -     test.assertEntityPresent(villagerEntityType, new BlockLocation(5, 2, 1), true);
		     63 +   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		     64 + 
		     65 +   test.succeedWhenEntityPresent(villagerActor, new BlockLocation(7, 2, 7), true);
		 18     -     test.assertEntityPresent(villagerEntityType, new BlockLocation(1, 2, 2), true);
		 19     -     test.assertEntityPresent(villagerEntityType, new BlockLocation(1, 2, 1), true);
		 20     -   });
		 21  66   })
		     67 +   .maxTicks(400)
		     68 +   .padding(DOOR_TEST_PADDING)
		 22     -   .tag(GameTest.Tags.suiteDisabled) // Villagers can get stuck on the door or on sleeping villagers
		     69 +   .batch("night")
		     70 +   .required(false)
		     71 +   .tag(GameTest.Tags.suiteDisabled); // Both of Java and Bedrock are failed villager is stuck and doesn't find the good way.
		 23     -   .padding(DOOR_TEST_PADDING) // Space out villager tests to stop them from confusing each other
		 24     -   .batch("night") // This should be a constant at some point
		 25     -   .maxTicks(600);
		 26  72   
		     73 + GameTest.register("DoorTests", "door_maze_3d", (test) => {
		 27     - GameTest.register("DoorTests", "villagers_can_pass_open_iron_door", (test) => {
		 28  74     const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		 29  75   
		     76 +   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		 30     -   test.spawn(villagerActor, new BlockLocation(2, 2, 5));
		 31  77   
		     78 +   test.succeedWhenEntityPresent(villagerActor, new BlockLocation(7, 2, 7), true);
		 32     -   test.succeedWhenEntityPresent(villagerActor, new BlockLocation(1, 2, 1), true);
		 33  79   })
		     80 +   .maxTicks(400)
		     81 +   .padding(DOOR_TEST_PADDING)
		 34     -   .maxTicks(900) //Increase max ticks from 200 to 900 (same value as in PathFindingTests), to make sure villager can find and go to bed
		 35  82     .batch("night")
		 36  83     .required(false)
		     84 +   .tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed looks like he doesn't cross obstacle and doesn't find the good way.
		     85 + 
		     86 + GameTest.register("DoorTests", "door_maze_crowded", (test) => {
		 37     -   .padding(DOOR_TEST_PADDING)
		     87 +   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		 38     -   .tag(GameTest.Tags.suiteDefault);
		 39  88   
		     89 +   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		     90 +   test.spawn(villagerActor, new BlockLocation(3, 2, 2));
		     91 +   test.spawn(villagerActor, new BlockLocation(5, 2, 1));
		 40     - GameTest.register("DoorTests", "villagers_cant_pass_closed_iron_door", (test) => {
		     92 +   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		 41     -   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		 42  93   
		     94 +   test.succeedWhen(() => {
		     95 +     test.assertEntityPresent(villagerActor, new BlockLocation(7, 2, 7), true);
		     96 +     test.assertEntityPresent(villagerActor, new BlockLocation(4, 2, 8), true);
		     97 +     test.assertEntityPresent(villagerActor, new BlockLocation(2, 2, 7), true);
		 43     -   test.spawn(villagerActor, new BlockLocation(2, 2, 5));
		 44     - 
		     98 +     test.assertEntityPresent(villagerActor, new BlockLocation(1, 2, 8), true);
		     99 +   });
		    100 + })
		    101 +   .maxTicks(400)
		    102 +   .padding(DOOR_TEST_PADDING)
		    103 +   .batch("night")
		    104 +   .required(false)
		    105 +   .tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed, some villiages are stuck behind the door and doesn't find the path.
		    106 + 
		    107 + GameTest.register("DoorTests", "inverted_door", (test) => {
		    108 +   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		    109 + 
		    110 +   test.spawn(villagerActor, new BlockLocation(3, 2, 1));
		 45     -   test
		 46     -     .startSequence()
		 47     -     .thenExecute(() => {
		 48     -       test.assertEntityPresent(villagerActor, new BlockLocation(1, 2, 1), false);
		 49     -     })
		 50     -     .thenIdle(200)
		 51     -     .thenSucceed();
		 52     - })
		 53     -   .maxTicks(220)
		 54     -   .padding(DOOR_TEST_PADDING)
		 55     -   .batch("night")
		 56     -   .required(false)
		 57     -   .tag(GameTest.Tags.suiteDefault);
		 58 111   
		    112 +   test.succeedWhenEntityPresent(villagerActor, new BlockLocation(3, 2, 5), true);
		    113 + })
		    114 +   .maxTicks(200)
		    115 +   .padding(DOOR_TEST_PADDING)
		    116 +   .batch("night")
		    117 +   .required(false)
		    118 +   .tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed, village is stuck behind the door, at there all time.
		 59     - GameTest.register("DoorTests", "door_maze", (test) => {
		 60     -   const villagerActor = "minecraft:villager_v2";
		 61     - 
		 62     -   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		 63 119   
		 64     -   test.succeedWhenEntityPresent(villagerActor, new BlockLocation(7, 2, 7), true);
		 65     - })
		 66     -   .maxTicks(400)
		    120 + GameTest.register("DoorTests", "close_door_after_passing_through", (test) => {
		    121 +   const testEx = new GameTestExtensions(test);
		 67     -   .padding(DOOR_TEST_PADDING)
		 68     -   .batch("night")
		 69     -   .required(false)
		    122 +   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		 70     -   .tag(GameTest.Tags.suiteDisabled); // Both of Java and Bedrock are failed villager is stuck and doesn't find the good way.
		 71 123   
		    124 +   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		    125 +   test.spawn(villagerActor, new BlockLocation(4, 2, 1));
		    126 +   test.spawn(villagerActor, new BlockLocation(5, 2, 1));
		 72     - GameTest.register("DoorTests", "door_maze_3d", (test) => {
		    127 +   test.spawn(villagerActor, new BlockLocation(7, 2, 1));
		    128 +   test.spawn(villagerActor, new BlockLocation(9, 2, 1));
		 73     -   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		 74     - 
		 75     -   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		 76 129   
		    130 +   test.succeedWhen(() => {
		 77     -   test.succeedWhenEntityPresent(villagerActor, new BlockLocation(7, 2, 7), true);
		 78     - })
		    131 +     test.assertEntityPresent(villagerActor, new BlockLocation(1, 2, 8), true);
		    132 +     test.assertEntityPresent(villagerActor, new BlockLocation(3, 2, 8), true);
		    133 +     test.assertEntityPresent(villagerActor, new BlockLocation(5, 2, 8), true);
		    134 +     test.assertEntityPresent(villagerActor, new BlockLocation(7, 2, 8), true);
		    135 +     test.assertEntityPresent(villagerActor, new BlockLocation(9, 2, 8), true);
		 79     -   .maxTicks(400)
		 80     -   .padding(DOOR_TEST_PADDING)
		 81     -   .batch("night")
		 82     -   .required(false)
		 83     -   .tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed looks like he doesn't cross obstacle and doesn't find the good way.
		 84 136   
		    137 +     testEx.assertBlockProperty("open_bit", 0, new BlockLocation(9, 2, 4));
		    138 +     testEx.assertBlockProperty("open_bit", 0, new BlockLocation(7, 2, 4));
		    139 +     testEx.assertBlockProperty("open_bit", 0, new BlockLocation(5, 2, 4));
		    140 +     testEx.assertBlockProperty("open_bit", 0, new BlockLocation(4, 2, 4));
		    141 +     testEx.assertBlockProperty("open_bit", 0, new BlockLocation(2, 2, 4));
		    142 +     testEx.assertBlockProperty("open_bit", 0, new BlockLocation(1, 2, 4));
		    143 +     testEx.assertBlockProperty("open_bit", 0, new BlockLocation(2, 2, 5));
		    144 +     testEx.assertBlockProperty("open_bit", 0, new BlockLocation(1, 2, 5));
		    145 +   })
		    146 + })
		    147 +   .maxTicks(900)
		    148 +   .padding(DOOR_TEST_PADDING)
		    149 +   .batch("night")
		    150 +   .required(false)
		    151 +   .tag("suite:java_parity")
		    152 +   .tag(GameTest.Tags.suiteDisabled); //Unstable, Villager sometimes cannot find the bed. Also, Sometimes when multiple villagers passing through the door, the door cannot close. Fail rate: 44%.
		    153 + 
		    154 + GameTest.register("DoorTests", "close_door_even_if_near_bed", (test) => {
		    155 +   const testEx = new GameTestExtensions(test);
		    156 +   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		    157 + 
		    158 +   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		    159 +   test.spawn(villagerActor, new BlockLocation(3, 2, 1));
		 85     - GameTest.register("DoorTests", "door_maze_crowded", (test) => {
		 86     -   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		 87     - 
		 88     -   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		 89     -   test.spawn(villagerActor, new BlockLocation(3, 2, 2));
		 90     -   test.spawn(villagerActor, new BlockLocation(5, 2, 1));
		 91     -   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		 92     - 
		 93     -   test.succeedWhen(() => {
		 94     -     test.assertEntityPresent(villagerActor, new BlockLocation(7, 2, 7), true);
		 95     -     test.assertEntityPresent(villagerActor, new BlockLocation(4, 2, 8), true);
		 96     -     test.assertEntityPresent(villagerActor, new BlockLocation(2, 2, 7), true);
		 97     -     test.assertEntityPresent(villagerActor, new BlockLocation(1, 2, 8), true);
		 98     -   });
		 99     - })
		100     -   .maxTicks(400)
		101     -   .padding(DOOR_TEST_PADDING)
		102     -   .batch("night")
		103     -   .required(false)
		104     -   .tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed, some villiages are stuck behind the door and doesn't find the path.
		105 160   
		    161 +   test.succeedWhen(() => {
		    162 +     test.assertEntityPresent(villagerActor, new BlockLocation(1, 2, 4), true);
		106     - GameTest.register("DoorTests", "inverted_door", (test) => {
		    163 +     test.assertEntityPresent(villagerActor, new BlockLocation(3, 2, 5), true);
		107     -   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		108 164   
		    165 +     testEx.assertBlockProperty("open_bit", 0, new BlockLocation(1, 2, 3));
		    166 +     testEx.assertBlockProperty("open_bit", 0, new BlockLocation(3, 2, 3));
		109     -   test.spawn(villagerActor, new BlockLocation(3, 2, 1));
		110 167   
		    168 +   })
		111     -   test.succeedWhenEntityPresent(villagerActor, new BlockLocation(3, 2, 5), true);
		112 169   })
		    170 +   .maxTicks(900)
		113     -   .maxTicks(200)
		114 171     .padding(DOOR_TEST_PADDING)
		115 172     .batch("night")
		116 173     .required(false)
		    174 +   .tag("suite:java_parity")
		    175 +   .tag(GameTest.Tags.suiteDisabled); //Unstable, Villager sometimes cannot find the bed. Fail rate: 5%
		117     -   .tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed, village is stuck behind the door, at there all time.
		          '''
	Added script "DripstoneTests.js":
		'''
		import * as GameTest from "mojang-gametest";
		import {
		  BlockLocation,
		  MinecraftBlockTypes,
		  MinecraftItemTypes,
		  World,
		} from "mojang-minecraft";
		import GameTestExtensions from "./GameTestExtensions.js";
		
		function placeDripstoneTip(test, pos, hanging, waterlogged = false) {
		  const pointedDripstonePermutation = MinecraftBlockTypes.pointedDripstone.createDefaultBlockPermutation();
		  pointedDripstonePermutation.getProperty("hanging").value = hanging;
		  pointedDripstonePermutation.getProperty("dripstone_thickness").value = "tip";
		
		  const pointedDripstoneBlock = World.getDimension("overworld").getBlock(test.worldBlockLocation(pos));
		  pointedDripstoneBlock.setPermutation(pointedDripstonePermutation);
		  pointedDripstoneBlock.setWaterlogged(waterlogged);
		}
		
		function assertDripstone(test, pos, hanging, thickness, waterlogged = false) {
		  const testEx = new GameTestExtensions(test);
		  test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, pos, true);
		  test.assertIsWaterlogged(pos, waterlogged);
		  testEx.assertBlockProperty("hanging", hanging, pos);
		  testEx.assertBlockProperty("dripstone_thickness", thickness, pos);
		}
		
		function assertColumnBaseToTip(test, basePos, hanging, ...thicknesses) {
		  let checkPos = basePos;
		  for (const thickness of thicknesses) {
		    assertDripstone(test, checkPos, hanging, thickness);
		    if (hanging == true) {
		      checkPos = checkPos.offset(0, -1, 0);
		    }
		    else {
		      checkPos = checkPos.offset(0, 1, 0);
		    }
		  }
		}
		
		///
		// Concrete Tests
		///
		GameTest.register("DripstoneTests", "thickness_update", (test) => {
		  // Check that each stalactite got loaded correctly
		  assertColumnBaseToTip(test, new BlockLocation(0, 12, 0), true, "base", "middle", "frustum", "tip");
		  assertColumnBaseToTip(test, new BlockLocation(1, 12, 0), true, "base", "frustum", "tip");
		  assertColumnBaseToTip(test, new BlockLocation(2, 12, 0), true, "frustum", "tip");
		  assertColumnBaseToTip(test, new BlockLocation(3, 12, 0), true, "tip");
		
		  // Check that each stalagmite got loaded correctly
		  assertColumnBaseToTip(test, new BlockLocation(0, 2, 0), false, "base", "middle", "frustum", "tip");
		  assertColumnBaseToTip(test, new BlockLocation(1, 2, 0), false, "base", "frustum", "tip");
		  assertColumnBaseToTip(test, new BlockLocation(2, 2, 0), false, "frustum", "tip");
		  assertColumnBaseToTip(test, new BlockLocation(3, 2, 0), false, "tip");
		
		  // Extend each stalactite
		  placeDripstoneTip(test, new BlockLocation(0, 8, 0), true);
		  placeDripstoneTip(test, new BlockLocation(1, 9, 0), true);
		  placeDripstoneTip(test, new BlockLocation(2, 10, 0), true);
		  placeDripstoneTip(test, new BlockLocation(3, 11, 0), true);
		
		  // Extend each stalagmite
		  placeDripstoneTip(test, new BlockLocation(0, 6, 0), false);
		  placeDripstoneTip(test, new BlockLocation(1, 5, 0), false);
		  placeDripstoneTip(test, new BlockLocation(2, 4, 0), false);
		  placeDripstoneTip(test, new BlockLocation(3, 3, 0), false);
		
		  test.succeedIf(() => {
		    // Check the shape of each stalactite
		    assertColumnBaseToTip(test, new BlockLocation(0, 12, 0), true, "base", "middle", "middle", "frustum", "tip");
		    assertColumnBaseToTip(test, new BlockLocation(1, 12, 0), true, "base", "middle", "frustum", "tip");
		    assertColumnBaseToTip(test, new BlockLocation(2, 12, 0), true, "base", "frustum", "tip");
		    assertColumnBaseToTip(test, new BlockLocation(3, 12, 0), true, "frustum", "tip");
		
		    // Check the shape of each stalagmite
		    assertColumnBaseToTip(test, new BlockLocation(0, 2, 0), false, "base", "middle", "middle", "frustum", "tip");
		    assertColumnBaseToTip(test, new BlockLocation(1, 2, 0), false, "base", "middle", "frustum", "tip");
		    assertColumnBaseToTip(test, new BlockLocation(2, 2, 0), false, "base", "frustum", "tip");
		    assertColumnBaseToTip(test, new BlockLocation(3, 2, 0), false, "frustum", "tip");
		  });
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("DripstoneTests", "stalactite_fall", (test) => {
		  const landingPos = new BlockLocation(1, 2, 1);
		  test.assertEntityPresent("minecraft:item", landingPos, false);
		
		  test.pressButton(new BlockLocation(0, 3, 0));
		  test.succeedWhenEntityPresent("minecraft:item", landingPos, true);
		
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("DripstoneTests", "stalactite_hurt", (test) => {
		  const poorInnocentVictimPos = new BlockLocation(1, 2, 1);
		  const poorInnocentVictim = test.spawnWithoutBehaviors("minecraft:pig", poorInnocentVictimPos);
		
		  test.pressButton(new BlockLocation(0, 6, 0));
		
		  const healthComponent = poorInnocentVictim.getComponent("minecraft:health");
		
		  test.succeedWhen(() => {
		    test.assert(healthComponent.current < healthComponent.value, "Mob should be hurt!");
		  })
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("DripstoneTests", "stalagmite_break", (test) => {
		  test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 2, 1), true);
		  test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 3, 1), true);
		  test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 4, 1), true);
		
		  test.pressButton(new BlockLocation(0, 3, 0));
		
		  test.succeedWhen(() => {
		    test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 2, 1), false);
		    test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 3, 1), false);
		    test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 4, 1), false);
		  })
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("DripstoneTests", "stalagmite_stalactite_separation", (test) => {
		  assertColumnBaseToTip(test, new BlockLocation(1, 2, 1), false, "frustum", "merge");
		  assertColumnBaseToTip(test, new BlockLocation(1, 5, 1), true, "frustum", "merge");
		  assertColumnBaseToTip(test, new BlockLocation(2, 2, 1), false, "frustum", "merge");
		  assertColumnBaseToTip(test, new BlockLocation(2, 5, 1), true, "frustum", "merge");
		
		  test.pressButton(new BlockLocation(0, 3, 0));
		  test.pressButton(new BlockLocation(3, 4, 0));
		
		  test.succeedWhen(() => {
		    // the right-hand stalagmite should be gone
		    test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 2, 1), false);
		    test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 3, 1), false);
		
		    // the right-hand stalactite should be intact, but the tip should no longer be a merged tip
		    assertColumnBaseToTip(test, new BlockLocation(1, 5, 1), true, "frustum", "tip");
		
		    // the left-hand stalagmite should be intact, but the tip should no longer be a merged tip
		    assertColumnBaseToTip(test, new BlockLocation(2, 2, 1), false, "frustum", "tip");
		
		    // the left-hand stalactite should be gone
		    test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(2, 5, 1), false);
		    test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(2, 4, 1), false);
		  })
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("DripstoneTests", "stalagmite_hurt", (test) => {
		  const unluckyPig = test.spawn("minecraft:pig", new BlockLocation(1, 4, 1));
		  const luckyPig = test.spawn("minecraft:pig", new BlockLocation(3, 4, 1));
		
		  const unluckyPigHealthComponent = unluckyPig.getComponent("minecraft:health");
		  const luckyPigHealthComponent = luckyPig.getComponent("minecraft:health");
		
		  test.succeedWhen(() => {
		    test.assert(unluckyPigHealthComponent.current < unluckyPigHealthComponent.value, "This pig should be hurt!");
		    test.assert(luckyPigHealthComponent.current == luckyPigHealthComponent.value, "This pig shouldn't be hurt!");
		  })
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("DripstoneTests", "stalactite_fall_no_dupe", (test) => {
		  test.pressButton(new BlockLocation(4, 9, 0));
		  test.pressButton(new BlockLocation(8, 8, 0));
		  test.pressButton(new BlockLocation(12, 6, 0));
		  test.pressButton(new BlockLocation(16, 5, 0))
		
		  test.startSequence()
		    .thenExecuteAfter(60, () => {
		      test.assertItemEntityCountIs(MinecraftItemTypes.pointedDripstone, new BlockLocation(2, 2, 2), 1, 5);
		      test.assertItemEntityCountIs(MinecraftItemTypes.pointedDripstone, new BlockLocation(6, 2, 2), 1, 5);
		      test.assertItemEntityCountIs(MinecraftItemTypes.pointedDripstone, new BlockLocation(10, 2, 2), 1, 2);
		      test.assertItemEntityCountIs(MinecraftItemTypes.pointedDripstone, new BlockLocation(14, 2, 2), 1, 2);
		    })
		    .thenSucceed();
		}).tag(GameTest.Tags.suiteDefault);
		'''
	Changed script "GameTestExtensions.js":
		Total line: 32 (+1, -1)
		        '''
		        ...
		24 24       breathableComp.setAirSupply(0);
		25 25     }
		26 26   
		27 27     assertBlockProperty(propertyName, value, blockLocation) {
		28 28       this.test.assertBlockState(blockLocation, (block) => {
		   29 +       return block.getBlockData().getProperty(propertyName).value == value;
		29    -       return block.getBlockData().getProperty(propertyName) == value;
		30 30       });
		31 31     }
		32 32   }
		        '''
	Changed script "Main.js":
		Total line: 22 (+1, -0)
		        '''
		        ...
		 2  2   import "scripts/BlockTests.js";
		 3  3   import "scripts/ComponentTests.js";
		 4  4   import "scripts/DebugTests.js";
		 5  5   import "scripts/DispenserTests.js";
		 6  6   import "scripts/DoorTests.js";
		    7 + import "scripts/DripstoneTests.js";
		 7  8   import "scripts/DuplicationTests.js";
		 8  9   import "scripts/EntityTests.js";
		 9 10   import "scripts/ExtensionTests.js";
		10 11   import "scripts/FireAvoidTests.js";
		11 12   import "scripts/GameTestExtensions.js";
		        ...
		        '''
	Changed script "MinecartTests.js":
		Total line: 277 (+40, -11)
		          '''
		          ...
		 58  58       });
		 59  59     });
		 60  60   })
		 61  61     .rotateTest(true)
		 62  62     .tag(GameTest.Tags.suiteDefault);
		     63 +   
		     64 +  GameTest.register("MinecartTests", "detector_rail_piston", (test) => {
		     65 +   const pistonRight = new BlockLocation(5, 3, 0);
		     66 +   const pistonLeft = new BlockLocation(0, 3, 0);
		     67 +   const torchRight = new BlockLocation(3, 2, 0);
		     68 +   const torchLeft = new BlockLocation(2, 2, 0);
		     69 + 
		     70 +   let minecart = undefined;
		     71 +   test
		     72 +     .startSequence()
		     73 +     .thenExecute(() => test.pulseRedstone(pistonRight, 1))
		     74 +     .thenExecuteAfter(3, () => test.pulseRedstone(pistonLeft, 1))
		     75 +     .thenExecuteAfter(3, () => {
		     76 +       test.assertRedstonePower(torchRight, 15);
		     77 +       test.assertRedstonePower(torchLeft, 15);
		     78 +       minecart = test.spawn("minecart", new BlockLocation(3, 3, 1));
		     79 +     })
		     80 +     .thenExecuteAfter(3, () => {
		     81 +       test.assertRedstonePower(torchRight, 0);
		     82 +       test.pulseRedstone(pistonRight, 1);
		     83 +     })
		     84 +     .thenExecuteAfter(7, () => {
		     85 +       test.assertRedstonePower(torchRight, 15);
		     86 +       test.assertRedstonePower(torchLeft, 0);
		     87 +       test.pulseRedstone(pistonLeft, 1);
		     88 +     })
		     89 +     .thenExecuteAfter(7, () => {
		     90 +       test.assertRedstonePower(torchRight, 0);
		     91 +       test.assertRedstonePower(torchLeft, 15);
		     92 +       minecart.kill();
		     93 +     })
		     94 +     .thenExecuteAfter(6, () => {
		     95 +       test.assertRedstonePower(torchRight, 15);
		     96 +       test.assertRedstonePower(torchLeft, 15);
		     97 +     })
		     98 +     .thenSucceed();
		     99 + })
		    100 +   .required(false)
		    101 +   .tag("suite:java_parity") //Redstone timing inconsistencies between java and bedrock.
		    102 +   .tag(GameTest.Tags.suiteDisabled); 
		    103 + 
		    104 + GameTest.register("MinecartTests", "detector_rail_piston_bedrock", (test) => {
		    105 +   const pistonRight = new BlockLocation(5, 3, 0);
		    106 +   const pistonLeft = new BlockLocation(0, 3, 0);
		    107 +   const torchRight = new BlockLocation(3, 2, 0);
		    108 +   const torchLeft = new BlockLocation(2, 2, 0);
		 63     - 
		 64     - GameTest.register("MinecartTests", "detector_rail_piston", (test) => {
		 65     -   const testEx = new GameTestExtensions(test);
		 66     -   const pistonRight = new BlockLocation(5, 3, 0);
		 67     -   const pistonLeft = new BlockLocation(0, 3, 0);
		 68     -   const torchRight = new BlockLocation(3, 2, 0);
		 69     -   const torchLeft = new BlockLocation(2, 2, 0);
		 70     -   let torchValue = null;
		 71     -   switch (test.getTestDirection()) {
		 72     -     case Direction.east:
		 73     -       torchValue = 2;
		 74     -       break;
		 75     -     case Direction.west:
		 76     -       torchValue = 1;
		 77     -       break;
		 78     -     case Direction.north:
		 79     -       torchValue = 3;
		 80     -       break;
		 81     -     case Direction.south:
		 82     -       torchValue = 4;
		 83     -       break;
		 84     -   }
		 85 109   
		 86 110     let minecart = undefined;
		 87 111     test
		 88 112       .startSequence()
		    113 +     .thenExecute(() => test.pulseRedstone(pistonRight, 4))
		    114 +     .thenIdle(2)
		    115 +     .thenExecuteAfter(3, () => test.pulseRedstone(pistonLeft, 4))
		 89     -     .thenExecute(() => test.pulseRedstone(pistonRight, 1))
		    116 +     .thenIdle(2)
		    117 +     .thenWait(() => {
		    118 +       test.assertRedstonePower(torchRight, 15);
		    119 +       test.assertRedstonePower(torchLeft, 15);
		    120 +       minecart = test.spawnAtLocation("minecart", new Location(3, 3.35, 1));
		 90     -     .thenExecuteAfter(3, () => test.pulseRedstone(pistonLeft, 1))
		 91     -     .thenExecuteAfter(3, () => {
		 92     -       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchRight);
		 93     -       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchLeft);
		 94     -       minecart = test.spawn("minecart", new BlockLocation(3, 3, 1));
		 95 121       })
		    122 +     .thenExecuteAfter(6, () => {
		    123 +       test.assertRedstonePower(torchRight, 0);
		 96     -     .thenExecuteAfter(3, () => {
		 97     -       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchRight);
		    124 +       test.pulseRedstone(pistonRight, 4);
		 98     -       test.pulseRedstone(pistonRight, 1);
		 99 125       })
		    126 +     .thenIdle(2)
		100 127       .thenExecuteAfter(7, () => {
		    128 +       test.assertRedstonePower(torchRight, 15);
		    129 +       test.assertRedstonePower(torchLeft, 0);
		101     -       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchRight);
		102     -       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchLeft);
		    130 +       test.pulseRedstone(pistonLeft, 4);
		103     -       test.pulseRedstone(pistonLeft, 1);
		104 131       })
		    132 +     .thenIdle(2)
		105 133       .thenExecuteAfter(7, () => {
		    134 +       test.assertRedstonePower(torchRight, 0);
		    135 +       test.assertRedstonePower(torchLeft, 15);
		106     -       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchRight);
		107     -       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchLeft);
		108 136         minecart.kill();
		109 137       })
		110 138       .thenExecuteAfter(6, () => {
		    139 +       test.assertRedstonePower(torchRight, 15);
		    140 +       test.assertRedstonePower(torchLeft, 15);
		111     -       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchRight);
		112     -       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchLeft);
		113 141       })
		114 142       .thenSucceed();
		115 143   })
		    144 +   .setupTicks(20)
		116     -   .rotateTest(true)
		117 145     .required(false)
		    146 +   .tag("suite:java_parity") //Failed due to two game parity issues: 1.When the piston pushes the minecart, the minecart will overlap with the stone. 2.After the piston pushes the minecart back and forth several times, kill the minecart, the powered status of detector rail doesn't disappear.
		    147 +   .tag(GameTest.Tags.suiteDisabled);
		118     -   .tag(GameTest.Tags.suiteDefault);
		119 148   
		120 149   function runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, entityType) {
		121 150     test.assertEntityPresent(entityType, dryTrackEndPos, false);
		122 151     test.assertEntityPresent(entityType, wetTrackEndPos, false);
		123 152   
		          ...
		          '''