Addition of "shaders" at "1.2.0.2" (beta of "1.2.0").

file "ShaderConstantsGNM.h":
	'''
	#ifndef __SHADER_CONSTANTS_GNM_H
	#define __SHADER_CONSTANTS_GNM_H
	
	#define FANCY
	#define ALPHA_TEST
	#define FOG
	#define ENABLE_FOG
	#define END_PORTAL
	#define ALWAYS_LIT
	//#define EFFECTS_OFFSET	- Enable this later (to see animating fire) when can turn these on/off based on material.
	
	Texture2D TEXTURE_0 : register(t0);
	Texture2D TEXTURE_1 : register(t1);
	Texture2D TEXTURE_2 : register(t2);
	Texture2D TEXTURE_3 : register(t3);
	Texture2D TEXTURE_4 : register(t4);
	Texture2D TEXTURE_5 : register(t5);
	Texture2D TEXTURE_6 : register(t6);
	Texture2D TEXTURE_7 : register(t7);
	
	SamplerState TextureSampler0 : register(s0);
	SamplerState TextureSampler1 : register(s1);
	SamplerState TextureSampler2 : register(s2);
	SamplerState TextureSampler3 : register(s3);
	SamplerState TextureSampler4 : register(s4);
	SamplerState TextureSampler5 : register(s5);
	SamplerState TextureSampler6 : register(s6);
	SamplerState TextureSampler7 : register(s7);
	
	ConstantBuffer RenderChunkConstants : register(c0) {
		float4 CHUNK_ORIGIN_AND_SCALE;
	}
	
	ConstantBuffer EntityConstants : register(c1) {
		float4 OVERLAY_COLOR;
		float4 TILE_LIGHT_COLOR;
		float4 CHANGE_COLOR;
		float4 GLINT_COLOR;
		float4 UV_ANIM;
		float2 UV_OFFSET;
		float2 UV_ROTATION;
		float2 GLINT_UV_SCALE;
	}
	
	ConstantBuffer PerFrameConstants : register(c2) {
	
		float3 VIEW_POS;
		float TIME;
		float4 FOG_COLOR;
		float2 FOG_CONTROL;
		float RENDER_DISTANCE;
		float FAR_CHUNKS_DISTANCE;
	}
	
	ConstantBuffer WorldConstants : register(c3) {
		column_major float4x4 WORLDVIEWPROJ;
		column_major float4x4 WORLD;
		column_major float4x4 WORLDVIEW;
		column_major float4x4 PROJ;
	}
	
	ConstantBuffer ShaderConstants : register(c4) {
		float4 CURRENT_COLOR;
		float4 DARKEN;
		float3 TEXTURE_DIMENSIONS;
		column_major float4x4 UV_TRANSFORM;
	}
	
	ConstantBuffer WeatherConstants : register(c5) {
		float4	POSITION_OFFSET;
		float4	VELOCITY;
		float4	ALPHA;
		float4	VIEW_POSITION;
		float4	SIZE_SCALE;
		float4	FORWARD;
		float4	UV_INFO;
		float4  PARTICLE_BOX;
	}
	
	ConstantBuffer FlipbookTextureConstants : register(c6) {
		float1 V_OFFSET;
		float1 V_BLEND_OFFSET;
	}
	
	ConstantBuffer EffectsConstants : register(c7) {
		float2 EFFECT_UV_OFFSET;
	}
	
	ConstantBuffer BannerConstants : register(c8) {
		float4 BANNER_COLORS[7];
		float4 BANNER_UV_OFFSETS[7];
	}
	
	ConstantBuffer InterFrameConstants : register(c9) {
		// in secs. This is reset every 1 hour. so the range is [0, 3600]
		// make sure your shader handles the case when it transitions from 3600 to 0
		float TOTAL_REAL_WORLD_TIME;
	}
	
	#endif
	'''
file "Template_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float4 color : COLOR;
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
	    return PSInput.color;
	}
	'''
file "Template_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
	    float4 position : POSITION;
	    float4 color : COLOR;
	};
	
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float4 color : COLOR;
	};
	
	
	PS_Input main( in VS_Input VSInput )
	{
		PS_Input PSInput = (PS_Input)0;
	
	    PSInput.color = VSInput.color;
		PSInput.position = mul(WORLDVIEWPROJ, VSInput.position);
	
		return PSInput;
	}
	'''
file "banner_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input {
		float4 position : S_POSITION;
	#ifdef ENABLE_LIGHT
		float4 light : LIGHT;
	#endif
	#ifdef ENABLE_FOG
		float4 fogColor : FOG_COLOR;
	#endif
	
	#ifndef DISABLE_TINTING
		float4 color : COLOR;
	#endif
	
		float2 texCoords : TEXCOORD_0_FB_MSAA;
	};
	
	float4 main(in PS_Input PSInput) : S_TARGET_OUTPUT
	{
		float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.texCoords);
	
	#ifndef DISABLE_TINTING
		diffuse.a = lerp(diffuse.r * diffuse.a, diffuse.a, PSInput.color.a);
		diffuse.rgb *= PSInput.color.rgb;
	#endif
	
	#ifdef ENABLE_LIGHT
		diffuse.rgb *= PSInput.light.rgb;
	#endif
	
	#ifdef ENABLE_FOG
		//apply fog
		diffuse.rgb = lerp(diffuse.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a );
	#endif
	
		//WARNING do not refactor this 
		//PSOutput.color = diffuse;
		float4 outputColor = diffuse;
	
	#ifdef VR_FEATURE
		// On Rift, the transition from 0 brightness to the lowest 8 bit value is abrupt, so clamp to 
		// the lowest 8 bit value.
		//PSOutput.color = max(PSOutput.color, 1 / 255.0f);
		outputColor =  max(outputColor, 1 / 255.0f);
	#endif
	
		return outputColor;
	}
	'''
file "banner_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input {
		float3 position : POSITION;
		float4 normal : NORMAL;
		float2 texCoords : TEXCOORD_0;
		float4 color : COLOR;
	};
	
	
	struct PS_Input {
		float4 position : S_POSITION;
	
	#ifdef ENABLE_LIGHT
		float4 light : LIGHT;
	#endif
	#ifdef ENABLE_FOG
		float4 fogColor : FOG_COLOR;
	#endif
	
	#ifndef DISABLE_TINTING
		float4 color : COLOR;
	#endif
		float2 texCoords : TEXCOORD_0_FB_MSAA;
	};
	
	static const float AMBIENT = 0.45;
	
	static const float XFAC = -0.1;
	static const float ZFAC = 0.1;
	
	
	float4 TransformRGBA8_SNORM(const float4 RGBA8_SNORM) {
	#ifdef R8G8B8A8_SNORM_UNSUPPORTED
		return RGBA8_SNORM * float(2.0).xxxx - float(1.0).xxxx;
	#else
		return RGBA8_SNORM;
	#endif
	}
	
	
	float lightIntensity(const float4 position, const float4 normal) {
	#ifdef FANCY
	
		float3 N = normalize(mul(WORLD, normal)).xyz;
	
		N.y *= TILE_LIGHT_COLOR.a;
	
		//take care of double sided polygons on materials without culling
	#ifdef FLIP_BACKFACES
		float3 viewDir = normalize((mul(WORLD, position)).xyz);
		if (dot(N, viewDir) > 0.0) {
			N *= -1.0;
		}
	#endif
	
		float yLight = (1.0 + N.y) * 0.5;
		return yLight * (1.0 - AMBIENT) + N.x*N.x * XFAC + N.z*N.z * ZFAC + AMBIENT;
	#else
		return 1.0;
	#endif
	}
	
	PS_Input main(in VS_Input VSInput) {
		PS_Input PSInput = (PS_Input)0;
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	
	#ifdef ENABLE_LIGHT
		float4 normal = TransformRGBA8_SNORM(VSInput.normal);
	
		float L = lightIntensity(float4(VSInput.position, 1), normal);
	
		PSInput.light = float4(L.xxx * TILE_LIGHT_COLOR.rgb, 1.0);
	#endif
	
		int frameIndex = int(VSInput.color.a * 255.0f);
		PSInput.texCoords.xy = VSInput.texCoords.xy + BANNER_UV_OFFSETS[frameIndex].xy;
	
	#ifndef DISABLE_TINTING
		PSInput.color = BANNER_COLORS[frameIndex];
		PSInput.color.a = 1.0f;
		if (frameIndex > 0) {
			PSInput.color.a = 0.0f;
		}
	#endif
	
	#ifdef ENABLE_FOG
		//fog
		PSInput.fogColor.rgb = FOG_COLOR.rgb;
		PSInput.fogColor.a = clamp(((PSInput.position.z / RENDER_DISTANCE) - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	#endif
	
		return PSInput;
	}
	'''
file "cloud_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	    float4 color : COLOR;
	};
	
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float4 color : COLOR;
	};
	
	static const float fogNear = 0.9;
	
	static const float3 inverseLightDirection = float3( 0.62, 0.78, 0.0 );
	static const float ambient = 0.7;
	
	PS_Input main( in VS_Input VSInput )
	{
		PS_Input PSInput = (PS_Input)0;
	
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
		float3 worldPos = float3(mul(WORLD, float4(VSInput.position, 1)));
	
	    PSInput.color = VSInput.color * CURRENT_COLOR;
	
		float depth = length(worldPos) / RENDER_DISTANCE;
	
	    float fog = max( depth - fogNear, 0.0 );
	
	    PSInput.color.a *= 1.0 - fog;
	
		return PSInput;
	}
	'''
file "color_ex_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float4 color : COLOR;
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
	    return PSInput.color * CURRENT_COLOR;
	}
	'''
file "color_grayscale_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	// be sure to change the shader type to pertex shader and shader model to ps_40 (in visual studio)
	
	struct PS_Input {
		float4 position : S_POSITION;
		float2 uv : TEXCOORD_0;
	};
	
	float4 main(in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
		float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	
	#ifdef ALPHA_TEST
		if (diffuse.a < 0.5) {
			discard;
		}
	#endif
	
		float grayscale = (CURRENT_COLOR.r * diffuse.r * 0.3 + CURRENT_COLOR.g * diffuse.g * 0.59 + CURRENT_COLOR.b * diffuse.b * 0.11);
		float4 gray_color = float4(grayscale, grayscale, grayscale, CURRENT_COLOR.a * diffuse.a);
		return gray_color;
	}
	
	'''
file "color_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float4 color : COLOR;
	}; 
	   
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
	    return PSInput.color;
	}
	 
	'''
file "color_texture_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	float4 glintBlend(float4 dest, float4 source) {
		return float4(source.rgb * source.rgb, 0.0) + dest;
	}
	
	struct PS_Input
	{
		float4 position : S_Position;
		float4 color : COLOR;
		float2 uv : TEXCOORD_0;
	
	#ifdef ENABLE_FOG
		float4 fogColor : FOG_COLOR;
	#endif
	
	#ifdef GLINT
		float2 layer1UV : TEXCOORD_1;
		float2 layer2UV : TEXCOORD_2;
	#endif
	
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
	#ifdef EFFECTS_OFFSET
		float4 diffuse = TEXTURE_0.Sample( TextureSampler0, PSInput.uv + EFFECT_UV_OFFSET );
	#else
		float4 diffuse = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	#endif
	
	#ifdef ALPHA_TEST
		#ifdef ENABLE_VERTEX_TINT_MASK
			if( diffuse.a <= 0.0f )
		#else
			if (diffuse.a <= 0.5f)
		#endif
			{
				discard;
			}
	#endif
	
	#ifdef ENABLE_VERTEX_TINT_MASK
		diffuse.rgb = lerp(diffuse.rgb, diffuse.rgb * PSInput.color.rgb, diffuse.a);
		if (PSInput.color.a > 0.0f) {
			diffuse.a = diffuse.a > 0.0f ? 1.0f : 0.0f;
		}
	#endif
	
	#ifdef GLINT
		float4 layer1 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layer1UV)).rgbr * GLINT_COLOR;
		float4 layer2 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layer2UV)).rgbr * GLINT_COLOR;
		float4 glint = (layer1 + layer2);
	
		#ifdef INVENTORY
			diffuse.rgb = glint.rgb;
		#else
			diffuse.rgb = glintBlend(diffuse, glint).rgb;
		#endif
	#endif
	
	#ifdef USE_OVERLAY
			//use either the diffuse or the OVERLAY_COLOR
		diffuse.rgb = lerp( diffuse, OVERLAY_COLOR, OVERLAY_COLOR.a ).rgb;
	#endif
	
	#ifdef ENABLE_FOG
		diffuse.rgb = lerp(diffuse.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a);
	#endif
	
	#ifdef ENABLE_VERTEX_TINT_MASK
		return diffuse;
	#else
		return diffuse * PSInput.color;
	#endif
	}
	'''
file "color_uv_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	    float4 color : COLOR;
	    float2 texCoords : TEXCOORD_0;
	};
	 
	struct PS_Input
	{
	    float4 position : S_Position;
	    float4 color : COLOR;
	    float2 texCoords : TEXCOORD_0;
	
	#ifdef ENABLE_FOG
		float4 fogColor : FOG_COLOR;
	#endif
	
	#ifdef GLINT
		float2 layer1UV : TEXCOORD_1;
		float2 layer2UV : TEXCOORD_2;
	#endif
	};
	
	#ifdef GLINT
	float2 calculateLayerUV(float2 origUV, float offset, float rotation) {
		float2 uv = origUV;
		uv -= 0.5;
		float rsin = 0.f;
		float rcos = 0.f;
		sincos(rotation, rsin, rcos);
		uv = mul(uv, float2x2(rcos, -rsin, rsin, rcos));
		uv.x += offset;
		uv += 0.5;
	
		return uv * GLINT_UV_SCALE;
	}
	#endif
	
	PS_Input main( in VS_Input VSInput )
	{
		PS_Input PSInput = (PS_Input)0;
	
	    PSInput.color = VSInput.color;
	
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	    PSInput.texCoords = VSInput.texCoords;
	
	#ifdef ENABLE_FOG
		//fog
		PSInput.fogColor.rgb = FOG_COLOR.rgb;
		PSInput.fogColor.a = clamp(((PSInput.position.z / RENDER_DISTANCE) - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	#endif
	
	#ifdef USE_LIGHTING
		PSInput.color *= float4(TILE_LIGHT_COLOR.rgb, 1.0);
	#endif
	
	#ifdef GLINT
		PSInput.layer1UV = calculateLayerUV(VSInput.texCoords, UV_OFFSET.x, UV_ROTATION.x);
		PSInput.layer2UV = calculateLayerUV(VSInput.texCoords, UV_OFFSET.y, UV_ROTATION.y);
	#endif
	
		return PSInput;
	}
	'''
file "color_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	    float4 color : COLOR;
	};
	 
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float4 color : COLOR;
	};
	   
	    
	PS_Input main( in VS_Input VSInput )
	{
		PS_Input PSInput = (PS_Input)0;
	
	    PSInput.color = VSInput.color;
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	
		return PSInput;
	}
	'''
file "current_color_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
		float4 position : S_POSITION;
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
		return CURRENT_COLOR;
	}
	'''
file "end_portal_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input {
		float4 position : S_POSITION;
	
	#ifndef BYPASS_PIXEL_SHADER
		float2 colorLookupUV : TEXCOORD_0;
		float2 parallaxUV : TEXCOORD_1;
		float4 encodedPlane : PLANE_INFO;
	
		#ifdef FOG
			float4 fogColor : FOG_COLOR;
		#endif
	
	#endif
	};
	
	static const float MAX_LAYER_DEPTH = 32.0;
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
		float4 outColor;
	#ifdef BYPASS_PIXEL_SHADER
		outColor = float4(0.0f, 0.0f, 0.0f, 0.0f);
	#else
		///// Decode Input Values
		// Decode parallax plane data
		// Using round() because normals should all be in the standard basis
		const float planeDistance = PSInput.encodedPlane.a * MAX_LAYER_DEPTH;
	
		///// Color Assembly
		float4 colorSample = TEXTURE_1.Sample(TextureSampler1, PSInput.colorLookupUV);
		float4 textureSample = TEXTURE_0.Sample(TextureSampler0, PSInput.parallaxUV);
		const float3 brightness = textureSample.rgb * (1.0 - PSInput.encodedPlane.w);
		colorSample.rgb *= brightness;
	
		// Look for hard-coded value to clear the portal first
		#ifdef FOG
			if(planeDistance > MAX_LAYER_DEPTH - 1.0) {
				outColor = float4(PSInput.fogColor.rgb * PSInput.fogColor.a, 0.0f);
			}
			else {
				outColor = float4(colorSample.rgb * (1.0 - PSInput.fogColor.a), 1.0f);
			}
		#else
			if(planeDistance > MAX_LAYER_DEPTH - 1.0) {
				outColor = float4(0.0f, 0.0f, 0.0f, 0.0f);
			}
			else {
				outColor = float4(colorSample.rgb, 1);
			}
		#endif
	
	#endif
	
		return outColor;
	}
	'''
file "end_portal_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input {
		float3 position : POSITION;
		float4 color : COLOR;
		float2 uv0 : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	};
	
	
	struct PS_Input {
		float4 position : S_POSITION;
	
	#ifndef BYPASS_PIXEL_SHADER
		float2 colorLookupUV : TEXCOORD_0;
		float2 parallaxUV : TEXCOORD_1;
		float4 encodedPlane : PLANE_INFO;
	
		// lpfloat4 color : COLOR;
	
		// float3 eyePositionInWorld : EYE_POS;
		// float3 surfacePositionInWorld : SURFACE_POS;
	
		#ifdef FOG
			float4 fogColor : FOG_COLOR;
		#endif
	
	#endif
	};
	
	static const float DIST_DESATURATION = 56.0 / 255.0; //WARNING this value is also hardcoded in the water color, don'tchange
	static const float MAX_LAYER_DEPTH = 32.0;
	
	PS_Input main(in VS_Input VSInput ) 
	{
		PS_Input PSInput = (PS_Input)0;
	
		///// Vertex Transformation
		float3 worldPos = (VSInput.position.xyz * CHUNK_ORIGIN_AND_SCALE.w) + CHUNK_ORIGIN_AND_SCALE.xyz;
		float3 viewRay = worldPos.xyz;
	
		PSInput.position = mul(WORLDVIEW, float4( worldPos, 1 ));
		PSInput.position = mul(PROJ, PSInput.position);
	
	
	#ifndef BYPASS_PIXEL_SHADER
		PSInput.encodedPlane = VSInput.color;
		PSInput.colorLookupUV = VSInput.uv0;
	
		///// Decode Input Values
		// Decode parallax plane data
		const float4 planeData = (PSInput.encodedPlane - float4(0.5, 0.5, 0.5, 0.0)) * float4(2.0, 2.0, 2.0, MAX_LAYER_DEPTH);
		const float3 planeNormal = planeData.rgb;
		const float planeDistance = planeData.a;
			
	
		///// Ray-cast for parallax-offset UV
		// Perform ray-plane intersection to find the position on the parallax plane
		float t = dot(viewRay - (planeNormal * planeDistance), planeNormal) / dot(viewRay, planeNormal);
		float3 parallaxPositionInWorld = (t * viewRay) + VIEW_POS;
	
		///// Ridiculous UV-remapping
		const float3 normalMask = abs(planeNormal);
		// Since all normals are orthonormal on <x,y,z>, mask out the correct uv result
		float2 raycastUV = parallaxPositionInWorld.yz * normalMask[0];
		raycastUV += parallaxPositionInWorld.xz * normalMask[1];
		raycastUV += parallaxPositionInWorld.xy * normalMask[2];
		// Scale the UVs to Minecraft pixel size
		raycastUV = raycastUV / 16.0;
	
		///// Color Lookup
		const float rotor = 3.1415926535897 * (5.0 / 7.0);
		float rotS = sin(planeDistance * rotor);
		float rotC = cos(planeDistance * rotor);
	
		PSInput.parallaxUV = mul(float2x2(float2(rotC, rotS), float2(-rotS, rotC)), raycastUV);
	
		///// UV Scrolling
		// Offset rotation based on a value unique to the layer
		PSInput.parallaxUV += float2(rotC, rotS) * planeDistance;
		PSInput.parallaxUV.y += TIME / 256.0;
	
		const float modVal = 64.0;
		PSInput.parallaxUV = fmod(PSInput.parallaxUV, modVal);
	
		///// Fog
		#ifdef FOG
			#ifdef FANCY
				float3 relPos = -worldPos;
				float cameraDepth = length(relPos);
			#else
				float cameraDepth = PSInput.position.z;
			#endif
			float len = cameraDepth / RENDER_DISTANCE;
			#ifdef ALLOW_FADE
				len += CURRENT_COLOR.r;
			#endif
			PSInput.fogColor.rgb = FOG_COLOR.rgb;
			PSInput.fogColor.a = clamp((len - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
		#endif
	#endif
	
		return PSInput;
	}
	'''
file "entity_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input {
		float4 position : S_POSITION;
		float4 light : LIGHT;
		float4 fogColor : FOG_COLOR;
	
	#ifdef GLINT
		// there is some alignment issue on the Windows Phone 1320 that causes the position
		// to get corrupted if this is two floats and last in the struct memory wise
		float4 layerUV : GLINT_UVS;
	#endif
	
	#ifdef USE_OVERLAY
		float4 overlayColor : OVERLAY_COLOR;
	#endif
	
	#ifdef TINTED_ALPHA_TEST
		float4 alphaTestMultiplier : ALPHA_MULTIPLIER;
	#endif
	
		float2 uv : TEXCOORD_0;
	};
	#ifdef USE_EMISSIVE
		#define NEEDS_DISCARD(C)	(C.a + C.r + C.g + C.b == 0.0)
	#else
		#ifndef USE_COLOR_MASK
			#define NEEDS_DISCARD(C)	(C.a < 0.5)
		#else
			#define NEEDS_DISCARD(C)	(C.a <= 0.0)
		#endif
	#endif
	
	float4 glintBlend(float4 dest, float4 source) {
		// glBlendFuncSeparate(GL_SRC_COLOR, GL_ONE, GL_ONE, GL_ZERO)
		return float4(source.rgb * source.rgb, source.a) + float4(dest.rgb, 0.0);
	}
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
		float4 color = float4( 1.0f, 1.0f, 1.0f, 1.0f );
	
	#if( !defined(NO_TEXTURE) || !defined(COLOR_BASED) || defined(USE_COLOR_BLEND) )
	//MSAA
		color = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	
	#ifdef ALPHA_TEST
		if( NEEDS_DISCARD( color ) )
		{
			discard;
		}
	#endif
	
	#ifdef TINTED_ALPHA_TEST
		float4 testColor = color;
		testColor.a = testColor.a * PSInput.alphaTestMultiplier.r;
		if( NEEDS_DISCARD( testColor ) )
		{
			discard;
		}
	#endif
	
	#endif
	
	#ifdef USE_COLOR_MASK
		color.rgb = lerp( color, color * CHANGE_COLOR, color.a ).rgb;
		color.a *= CHANGE_COLOR.a;
	#endif
	
	#ifdef ITEM_IN_HAND
		color.rgb = lerp(color, color * CHANGE_COLOR, PSInput.light.a).rgb;
	#endif
	
	#ifdef USE_MULTITEXTURE
		float4 tex1 = TEXTURE_1.Sample(TextureSampler1, PSInput.uv);
		float4 tex2 = TEXTURE_2.Sample(TextureSampler2, PSInput.uv);
		color.rgb = lerp(color.rgb, tex1, tex1.a);
	#ifdef COLOR_SECOND_TEXTURE
		if (tex2.a > 0.0f) {
			color.rgb = lerp(tex2.rgb, tex2 * CHANGE_COLOR, tex2.a);
		}
	#else
		color.rgb = lerp(color.rgb, tex2, tex2.a);
	#endif
	#endif
	
	#ifdef USE_OVERLAY
		//use either the diffuse or the OVERLAY_COLOR
		color.rgb = lerp( color, PSInput.overlayColor, PSInput.overlayColor.a ).rgb;
	#endif
	
	#ifdef USE_EMISSIVE
		//make glowy stuff
		color *= lerp( float( 1.0 ).xxxx, PSInput.light, color.a );
	#else
		color *= PSInput.light;
	#endif
	
		//apply fog
		color.rgb = lerp( color.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a );
	
	#ifdef GLINT
		// Applies color mask to glint texture instead and blends with original color
		float4 layer1 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layerUV.xy)).rgbr * GLINT_COLOR;
		float4 layer2 = TEXTURE_1.Sample(TextureSampler1, frac(PSInput.layerUV.zw)).rgbr * GLINT_COLOR;
		float4 glint = (layer1 + layer2) * TILE_LIGHT_COLOR;
		color = glintBlend(color, glint);
	#endif
	
		return color;
	}
	'''
file "entity_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input {
		float3 position : POSITION;
	#ifdef COLOR_BASED
		float4 color : COLOR;
	#endif
		float4 normal : NORMAL;
		float2 texCoords : TEXCOORD_0;
	};
	
	struct PS_Input {
		float4 position : S_POSITION;
	
		float4 light : LIGHT;
		float4 fogColor : FOG_COLOR;
	
	#ifdef GLINT
		// there is some alignment issue on the Windows Phone 1320 that causes the position
		// to get corrupted if this is two floats and last in the struct memory wise
		float4 layerUV : GLINT_UVS;
	#endif
	
	#ifdef USE_OVERLAY
		float4 overlayColor : OVERLAY_COLOR;
	#endif
	
	#ifdef TINTED_ALPHA_TEST
		float4 alphaTestMultiplier : ALPHA_MULTIPLIER;
	#endif
	
		float2 uv : TEXCOORD_0;
	};
	
	static const float AMBIENT = 0.45;
	
	static const float XFAC = -0.1;
	static const float ZFAC = 0.1;
	
	
	float4 TransformRGBA8_SNORM(const float4 RGBA8_SNORM) {
	#ifdef R8G8B8A8_SNORM_UNSUPPORTED
		return RGBA8_SNORM * float(2.0).xxxx - float(1.0).xxxx;
	#else
		return RGBA8_SNORM;
	#endif
	}
	
	
	float lightIntensity(const float4 position, const float4 normal) {
	#ifdef FANCY
	
		float3 N = normalize(mul(WORLD, normal)).xyz;
	
		N.y *= TILE_LIGHT_COLOR.a;
	
		//take care of double sided polygons on materials without culling
	#ifdef FLIP_BACKFACES
		float3 viewDir = normalize((mul(WORLD, position)).xyz);
		if (dot(N, viewDir) > 0.0) {
			N *= -1.0;
		}
	#endif
	
		float yLight = (1.0 + N.y) * 0.5;
		return yLight * (1.0 - AMBIENT) + N.x*N.x * XFAC + N.z*N.z * ZFAC + AMBIENT;
	#else
		return 1.0;
	#endif
	}
	
	#ifdef GLINT
	float2 calculateLayerUV(float2 origUV, float offset, float rotation) {
		float2 uv = origUV;
		uv -= 0.5;
		float rsin = 0.f;
		float rcos = 0.f;
		sincos(rotation, rsin, rcos);
		uv = mul(uv, float2x2(rcos, -rsin, rsin, rcos));
		uv.x += offset;
		uv += 0.5;
	
		return uv * GLINT_UV_SCALE;
	}
	#endif
	
	PS_Input main(in VS_Input VSInput) 
	{
		PS_Input PSInput = (PS_Input)0;
	
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
		float4 normal = TransformRGBA8_SNORM(VSInput.normal);
	
		float L = lightIntensity(float4(VSInput.position, 1), normal);
	
	#ifdef USE_OVERLAY
		L += OVERLAY_COLOR.a * 0.35;
		PSInput.overlayColor = OVERLAY_COLOR;
	#endif
	
	#ifdef TINTED_ALPHA_TEST
		PSInput.alphaTestMultiplier = OVERLAY_COLOR.aaaa;
	#endif
	
		PSInput.light = float4(L.xxx * TILE_LIGHT_COLOR.rgb, 1.0);
	
	#ifdef COLOR_BASED
		PSInput.light *= VSInput.color;
	#endif
	
	#if( !defined(NO_TEXTURE) || !defined(COLOR_BASED) || defined(USE_COLOR_BLEND) )
		PSInput.uv = VSInput.texCoords;
	#endif
	
	#ifdef USE_UV_ANIM
		PSInput.uv.xy = UV_ANIM.xy + (PSInput.uv.xy * UV_ANIM.zw);
	#endif
	
	#ifdef GLINT
		PSInput.layerUV.xy = calculateLayerUV(VSInput.texCoords, UV_OFFSET.x, UV_ROTATION.x);
		PSInput.layerUV.zw = calculateLayerUV(VSInput.texCoords, UV_OFFSET.y, UV_ROTATION.y);
	#endif
	
		//fog
		PSInput.fogColor.rgb = FOG_COLOR.rgb;
		PSInput.fogColor.a = clamp(((PSInput.position.z / RENDER_DISTANCE) - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	
		return PSInput;
	}
	
	'''
file "flat_white_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
	    return float4(1,1,1,1);
	}
	'''
file "hologram_texture_stereo_p.pssl":
	'''
	// DO NOT HAVE THIS INCLUDE BE THE FIRST LINE!  we need a #define to be respected in the .fxh file
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
		float4	position		: S_POSITION;
		float2	uv				: TEXCOORD_0; // the stereo texture uses a texture array
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
		return TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	}
	'''
file "iteminhand_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float4 light : LIGHT;
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
	    float4 color = lerp( float4( 1, 1, 1, 1 ), PSInput.light, PSInput.light.a );
	
	    color.rgb = lerp( color, OVERLAY_COLOR, OVERLAY_COLOR.a ).rgb;
	
	    return color;
	}
	'''
file "levelstage_copy_vr_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
		// when copying the levelstage texture for the rift overlay, we need to ensure alpha is 1, and
		// convert from linear space to SRGB
		float4 outColor;
	    outColor = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
		outColor.a = 1.0;
		outColor = pow(outColor, 2.2); // conversion to srgb
		return outColor;
	}
	'''
file "normal_as_color_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	    float4 normal : NORMAL;
	};
	
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float4 color : COLOR;
	};
	
	PS_Input main( in VS_Input VSInput )
	{
		PS_Input PSInput = (PS_Input)0;
	
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	    PSInput.color.rgb = ( VSInput.normal.xyz / 2 ) + 0.5;
	    PSInput.color.a = 1.0;
	
		return PSInput;
	}
	'''
file "position_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
		float3 position : POSITION;
	};
	
	struct PS_Input
	{
		float4 position : S_POSITION;
	};
	
	PS_Input main( in VS_Input VSInput )
	{
		PS_Input PSInput;
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	
		return PSInput;
	}
	'''
file "rain_snow_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input {
		float4 position : S_POSITION;
		float2 uv : TEXCOORD_0;
		float4 color : COLOR;
		float4 worldPosition : TEXCOORD_1;
		float4 fogColor : FOG_COLOR;
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
		float4 outputColor = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	
		outputColor.a *= PSInput.color.a;
	
		float2 uv = PSInput.worldPosition.xz;
		float4 occlusionTexture = TEXTURE_1.Sample(TextureSampler1, uv);
	
		// clamp the uvs
		if (uv.x >= 0.0f && uv.x <= 1.0f && 
			uv.y >= 0.0f && uv.y <= 1.0f && 
			PSInput.worldPosition.y < occlusionTexture.a) {
			outputColor.a = 0.0f;
		}
	
		float mixAmount = saturate((PSInput.worldPosition.y - occlusionTexture.a)*10.0f);
		float3 lighting = lerp(occlusionTexture.rgb, PSInput.color.rgb, mixAmount);
		outputColor.rgb *= lighting.rgb;
	
		//apply fog
		outputColor.rgb = lerp(outputColor.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a);
	
		return outputColor;
	}
	
	'''
file "rain_snow_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input {
		float3 position : POSITION;
		float2 uv0 : TEXCOORD_0;
		float4 color : COLOR;
	};
	
	struct PS_Input {
		float4 position : S_POSITION;
		float2 uv : TEXCOORD_0;
		float4 color : COLOR;
		float4 worldPosition : TEXCOORD_1;
		float4 fogColor : FOG_COLOR;
	};
	
	PS_Input main(in VS_Input VSInput)
	{
		PS_Input PSInput = (PS_Input)0;
	
		float spriteSelector = VSInput.color.x*255.0f;
		PSInput.uv = UV_INFO.xy + (VSInput.uv0 * UV_INFO.zw);
		PSInput.uv.x += spriteSelector * UV_INFO.z;
	
		float3 position = VSInput.position.xyz;
			
		// subtract the offset then fmod into (0.0f, PARTICLE_BOX)
		position.xyz += POSITION_OFFSET.xyz;
		position.xyz = fmod(position.xyz, PARTICLE_BOX.xxx);
		
		// centre box on origin
		position.xyz -= PARTICLE_BOX.xxx * 0.5f;
		
		// push along view vector so box is positioned more infront of camera
		position.xyz += FORWARD.xyz;
		
		// get world position
		float4 worldPositionBottom = float4(position.xyz, 1.0f);
		float4 worldPositionTop = float4(worldPositionBottom.xyz + (VELOCITY.xyz * SIZE_SCALE.y), 1.0f);
	
		// get projected positions of top and bottom of particle, and top of particle in previous frame
		float4 bottom = mul(WORLDVIEWPROJ, worldPositionBottom);
		float4 top = mul(WORLDVIEWPROJ, worldPositionTop);
		
		// get 2d vector in screenspace between top and bottom of particle
		float2 dir = (top.xy/top.w) - (bottom.xy/bottom.w);
		
		// get 2d vector perpendicular to velocity
		float2 dirPerp = normalize(float2(-dir.y, dir.x));
	
		// choose either the top or bottom projected position using uv.y
		PSInput.position = lerp(top, bottom, VSInput.uv0.y);
		 	
		// offset the position of each side of the particle using uv.x 
		PSInput.position.xy += (0.5f - VSInput.uv0.x) * dirPerp * SIZE_SCALE.x;
		
		// get the final colour including the lighting, distance and length scales, and per instance alpha
		PSInput.color = ALPHA;
	
		//fog
		PSInput.fogColor.rgb = FOG_COLOR.rgb;
		PSInput.fogColor.a = clamp(((PSInput.position.z / RENDER_DISTANCE) - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	
		worldPositionBottom.xz *= 1.0f / 64.0f;	// Scale by 1/TextureDimensions to get values between
		worldPositionBottom.xz += 0.5f;			// Offset so that center of view is in the center of occlusion texture
		worldPositionBottom.y += VIEW_POSITION.y - 0.5f;
		worldPositionBottom.y *= 1.0f / 255.0f;
		PSInput.worldPosition = worldPositionBottom;
	
		return PSInput;
	}
	'''
file "renderchunk_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
		float4 position : S_POSITION;
	
	#ifndef BYPASS_PIXEL_SHADER
		float4 color : COLOR;
		float2 uv0 : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	#endif
	
	#ifdef NEAR_WATER
		float cameraDist : TEXCOORD_2;
	#endif
	
	#ifdef FOG
		float4 fogColor : FOG_COLOR;
	#endif
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
	#ifdef BYPASS_PIXEL_SHADER
	    return float4(0.0f, 0.0f, 0.0f, 0.0f);
	#else
	
	#if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE)
		float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv0);
	#else
		float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv0);	//TODO support TEXEL_AA
	#endif
	
	#ifdef SEASONS_FAR
		diffuse.a = 1.0f;
		PSInput.color.b = 1.0f;
	#endif
	
	#ifdef ALPHA_TEST
	//If we know that all the verts in a triangle will have the same alpha, we should cull there first.
		#ifdef ALPHA_TO_COVERAGE
			float alphaThreshold = .05f;
		#else
			float alphaThreshold = .5f;
		#endif
		if(diffuse.a < alphaThreshold)
			discard;
	#endif
	
	#if !defined(ALWAYS_LIT)
		diffuse = diffuse * TEXTURE_1.Sample(TextureSampler1, PSInput.uv1);
	#endif
	
	#ifndef SEASONS
	
		#if !defined(ALPHA_TEST) && !defined(BLEND)
			diffuse.a = PSInput.color.a;
		#elif defined(BLEND)
			diffuse.a *= PSInput.color.a;
	
			#ifdef NEAR_WATER
				float alphaFadeOut = saturate(PSInput.cameraDist.x);
				diffuse.a = lerp(diffuse.a, 1.0f, alphaFadeOut);
			#endif
		#endif	
	
		diffuse.rgb *= PSInput.color.rgb;
	
	#else
		float2 uv = PSInput.color.xy;
		diffuse.rgb *= lerp(1.0f, TEXTURE_2.Sample(TextureSampler2, uv).rgb*2.0f, PSInput.color.b);
		diffuse.rgb *= PSInput.color.aaa;
		diffuse.a = 1.0f;
	#endif
	
	#ifdef FOG
		diffuse.rgb = lerp( diffuse.rgb, PSInput.fogColor.rgb, PSInput.fogColor.a );
	#endif
	
		return diffuse;
	
	#endif
	}
	'''
file "renderchunk_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input {
		float3 position : POSITION;
		float4 color : COLOR;
		float2 uv0 : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	};
	
	
	struct PS_Input {
		float4 position : S_POSITION;
	
	#ifndef BYPASS_PIXEL_SHADER
		float4 color : COLOR;
		float2 uv0 : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	#endif
	
	#ifdef NEAR_WATER
		float cameraDist : TEXCOORD_2;
	#endif
	
	#ifdef FOG
		float4 fogColor : FOG_COLOR;
	#endif
	};
	
	
	static const float rA = 1.0;
	static const float rB = 1.0;
	static const float3 UNIT_Y = float3(0, 1, 0);
	static const float DIST_DESATURATION = 56.0 / 255.0; //WARNING this value is also hardcoded in the water color, don'tchange
	
	
	PS_Input main(in VS_Input VSInput) 
	{
		PS_Input PSInput = (PS_Input)0;
	
	#ifndef BYPASS_PIXEL_SHADER
		PSInput.uv0 = VSInput.uv0;
		PSInput.uv1 = VSInput.uv1;
		PSInput.color = VSInput.color;
	#endif
	
	#ifdef AS_ENTITY_RENDERER
			PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
			float3 worldPos = PSInput.position.xyz;
	#else
			float3 worldPos = (VSInput.position.xyz * CHUNK_ORIGIN_AND_SCALE.w) + CHUNK_ORIGIN_AND_SCALE.xyz;
			PSInput.position = mul(WORLDVIEW, float4( worldPos, 1 ));
			PSInput.position = mul(PROJ, PSInput.position);
	#endif
	
	///// find distance from the camera
	
	#if defined(FOG) || defined(NEAR_WATER)
		#ifdef FANCY
			float3 relPos = -worldPos;
			float cameraDepth = length(relPos);
			#ifdef NEAR_WATER
				PSInput.cameraDist = cameraDepth / FAR_CHUNKS_DISTANCE;
			#endif
		#else
			float cameraDepth = PSInput.position.z;
			#ifdef NEAR_WATER
				float3 relPos = -worldPos;
				float cameraDist = length(relPos);
				PSInput.cameraDist = cameraDist / FAR_CHUNKS_DISTANCE;
			#endif
		#endif
	#endif
	
		///// apply fog
	
	#ifdef FOG
		float len = cameraDepth / RENDER_DISTANCE;
	#ifdef ALLOW_FADE
		len += CURRENT_COLOR.r;
	#endif
	
		PSInput.fogColor.rgb = FOG_COLOR.rgb;
		PSInput.fogColor.a = clamp((len - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
	
	#endif
	
		///// water magic
	#ifdef NEAR_WATER
	#ifdef FANCY  /////enhance water
		float F = dot(normalize(relPos), UNIT_Y);
		F = 1.0 - max(F, 0.1);
		F = 1.0 - lerp(F*F*F*F, 1.0, min(1.0, cameraDepth / FAR_CHUNKS_DISTANCE));
	
		PSInput.color.rg -= float2(float(F * DIST_DESATURATION).xx);
	
		float4 depthColor = float4(PSInput.color.rgb * 0.5, 1.0);
		float4 traspColor = float4(PSInput.color.rgb * 0.45, 0.8);
		float4 surfColor = float4(PSInput.color.rgb, 1.0);
	
		float4 nearColor = lerp(traspColor, depthColor, PSInput.color.a);
		PSInput.color = lerp(surfColor, nearColor, F);
	#else
		PSInput.color.a = PSInput.position.z / FAR_CHUNKS_DISTANCE + 0.5;
	#endif //FANCY
	#endif
		
		return PSInput;
	}
	'''
file "selection_box_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
		float3 position : POSITION;
	};
	
	struct PS_Input
	{
		float4 position : S_POSITION;
	};
	
	PS_Input main( in VS_Input VSInput )
	{
		PS_Input PSInput;
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	
	    //this is to make it come closer to the camera and avoid z-fighting
	    PSInput.position.z -= 0.0001;
	
		return PSInput;
	}
	'''
file "shadow_stencil_overlay_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float4 color : COLOR;
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
		float4 PSOutputColor;
		PSOutputColor.rgb = lerp(PSInput.color.rgb, CURRENT_COLOR.rgb, PSInput.color.a);
		PSOutputColor.a = 1;
		return PSOutputColor;
	}
	'''
file "simple_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	};
	 
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float4 color : COLOR;
	};
	   
	    
	PS_Input main( in VS_Input VSInput )
	{
		PS_Input PSInput = (PS_Input)0;
	
	    PSInput.color = CURRENT_COLOR;
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	
		return PSInput;
	}
	'''
file "sky_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	    float4 color : COLOR;
	};
	
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float4 color : COLOR;
	};
	
	
	PS_Input main( in VS_Input VSInput )
	{
		PS_Input PSInput = (PS_Input)0;
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	    PSInput.color = lerp( CURRENT_COLOR, FOG_COLOR, VSInput.color.r );
	
		return PSInput;
	}
	'''
file "stars_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float4 color : COLOR;
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
	    float4 outColor = PSInput.color;
	    outColor.rgb *= CURRENT_COLOR.rgb * PSInput.color.a;
	
		return outColor;
	}
	'''
file "text_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float4 color : COLOR;
	    float2 uv : TEXCOORD_0;
	};
	
	float4 main(in PS_Input PSInput) : S_TARGET_OUTPUT
	{
	    float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	
	#ifdef SMOOTH
	    const float center = 0.4f;
	    const float radius = 0.1f;
	
	    diffuse = smoothstep(center - radius, center + radius, diffuse);
	#endif
	
	#ifdef ALPHA_TEST
	    if (diffuse.a < 0.5)
	    {
	        discard;
	    }
	#endif
	
	    return diffuse * PSInput.color * DARKEN;
	}
	'''
file "texture_blend_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
		float4 position : S_POSITION;
		float2 uv : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	};
	
	float4 main(in PS_Input PSInput) : S_TARGET_OUTPUT
	{
		float4 color = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
		float4 color1 = TEXTURE_0.Sample(TextureSampler0, PSInput.uv1);
	
		if (color.a < 0.01f)
		{
			color = color1;
		}
		else if (color.b > 0.01f) {
			color = lerp(color, color1, CURRENT_COLOR.a);
		}
	
		return color;
	}
	'''
file "texture_ccolor_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	float4 main(in PS_Input PSInput) : S_TARGET_OUTPUT
	{
	
	#if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE)
		float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	#else
		float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);	//TODO support TEXEL_AA
	#endif
	
	#ifdef ALPHA_TEST
	    if( diffuse.a < 0.5 )
	    {
	        discard;
	    }
	#endif
	
	    return CURRENT_COLOR * diffuse;
	}
	'''
file "texture_cutout_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
	    float4 diffuse = TEXTURE_0.Sample( TextureSampler0, PSInput.uv );
	
	    if( diffuse.a < 0.5 )
	    {
	        discard;
	    }
	
	    return CURRENT_COLOR;
	}
	'''
file "texture_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
	    float4 outColor = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	
	#ifdef ALPHA_TEST
	    if( outColor.a < 0.5 )
	    {
	        discard;
	    }
	#endif
	
	#ifdef NO_ALPHA
		outColor.a = 1.f;
	#endif
	
		return outColor;
	}
	'''
file "texture_raw_alphatest_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	float4 main(in PS_Input PSInput) : S_TARGET_OUTPUT
	{
	
	#if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE)
		float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv);
	#else
		float4 diffuse = texture2D_AA(TEXTURE_0, TextureSampler0, PSInput.uv);
	#endif
	
	#ifdef ALPHA_TEST
	    if( diffuse.a < 0.0625 )
	    {
	        discard;
	    }
	#endif
	
	    return diffuse;
	}
	'''
file "uv_as_color_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	float4 main( in PS_Input PSInput ) : S_TARGET_OUTPUT
	{
	    return float4( PSInput.uv.xy, 0, 1 );
	}
	'''
file "uv_blend_flipbook_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input {
		float3 position : POSITION;
		float2 uv : TEXCOORD_0;
	};
	
	
	struct PS_Input {
		float4 position : S_POSITION;
		float2 uv : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	};
	
	
	PS_Input main(in VS_Input VSInput)
	{
		PS_Input PSInput = (PS_Input)0;
	
		PSInput.uv = VSInput.uv;
		PSInput.uv.y += V_OFFSET;
		PSInput.uv1 = VSInput.uv;
		PSInput.uv1.y += V_BLEND_OFFSET;
	
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	
		return PSInput;
	}
	'''
file "uv_blend_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
		float3 position : POSITION;
		float2 uv : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	};
	
	
	struct PS_Input
	{
		float4 position : S_POSITION;
		float2 uv : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	};
	
	
	PS_Input main(in VS_Input VSInput)
	{
		PS_Input PSInput = (PS_Input)0;
	
		PSInput.uv = VSInput.uv;
		PSInput.uv1 = VSInput.uv1;
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	
		return PSInput;
	}
	'''
file "uv_repeat_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	
	PS_Input main(in VS_Input VSInput)
	{
		PS_Input PSInput = (PS_Input)0;
	    float4 transformedUV = mul(UV_TRANSFORM, float4(VSInput.uv, 0, 1));
	    PSInput.uv = transformedUV.xy;
	    PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	
		return PSInput;
	}
	'''
file "uv_scale_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	
	PS_Input main( in VS_Input VSInput )
	{
		PS_Input PSInput = (PS_Input)0;
	
	    PSInput.uv = VSInput.uv * GLINT_UV_SCALE.xy;
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	
		return PSInput;
	}
	'''
file "uv_selection_overlay_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	
	PS_Input main( in VS_Input VSInput )
	{
		PS_Input PSInput = (PS_Input)0;
	
	    PSInput.uv = VSInput.uv;
		float4 pos = mul(WORLDVIEW, float4(VSInput.position, 1));
		PSInput.position = mul(PROJ, pos);
	
		return PSInput;
	}
	'''
file "uv_time_rotate_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	PS_Input main( in VS_Input VSInput )
	{
		PS_Input PSInput = (PS_Input)0;
	    PSInput.uv = VSInput.uv;
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	
		return PSInput;
	}
	'''
file "uv_vv.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input
	{
	    float3 position : POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	struct PS_Input
	{
	    float4 position : S_POSITION;
	    float2 uv : TEXCOORD_0;
	};
	
	PS_Input main( in VS_Input VSInput )
	{
		PS_Input PSInput = (PS_Input)0;
	    PSInput.uv = VSInput.uv;
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
	
		return PSInput;
	}
	'''
file "weather_p.pssl":
	'''
	#include "ShaderConstantsGNM.h"
	
	struct PS_Input {
		float4 position : S_POSITION;
		float4 color : COLOR;
		float2 uv0 : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	};
	
	float4 main(in PS_Input PSInput) 
	{
		float4 diffuse = TEXTURE_0.Sample(TextureSampler0, PSInput.uv0) * TEXTURE_1.Sample(TextureSampler1, PSInput.uv1);
	
	#ifdef ALPHA_TEST
		if(diffuse.a < 0.5)
		 	discard;
	#endif
		diffuse *= PSInput.color;
	
		return diffuse;
	}
	'''
file "weather_vv.pssl":
	'''
	
	#include "ShaderConstantsGNM.h"
	
	struct VS_Input {
		float3 position : POSITION;
		float4 color : COLOR;
		float2 uv0 : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	};
	
	struct PS_Input {
		float4 position : S_POSITION;
		float4 color : COLOR;
		float2 uv0 : TEXCOORD_0;
		float2 uv1 : TEXCOORD_1;
	};
	
	PS_Input main(in VS_Input VSInput)
	{
		PS_Input PSInput = (PS_Input)0;
	
		PSInput.position = mul(WORLDVIEWPROJ, float4(VSInput.position, 1));
		PSInput.color = VSInput.color;
		PSInput.uv0.x = VSInput.uv0.x*2.0f;
		PSInput.uv0.y = VSInput.uv0.y*10.0f;
		PSInput.uv1 = VSInput.uv1;
	
		return PSInput;
	}
	'''