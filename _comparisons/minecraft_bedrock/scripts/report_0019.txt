Difference of "scripts" between "1.17.34" and "1.17.40.20" (beta of "1.17.40").

Changed behavior pack "vanilla_gametest":
	Total script: 24 (+1, -0)
	Changed script "APITests.js":
		Total line: 908 (+234, -199)
		          '''
		          ...
		  4   4     BlockProperties,
		  5   5     MinecraftBlockTypes,
		  6   6     Color,
		  7   7     Direction,
		  8   8     ExplosionOptions,
		      9 +   FluidContainer,
		     10 +   MinecraftEffectTypes,
		     11 +   MinecraftItemTypes,
		     12 +   ItemStack,
		     13 +   Location,
		     14 +   World,
		     15 + } from "mojang-minecraft";
		     16 + 
		     17 + GameTest.register("APITests", "on_entity_created", (test) => {
		     18 +   const entityCreatedCallback = World.events.entityCreate.subscribe((entity) => {
		     19 +     if (entity) {
		     20 +       test.succeed();
		     21 +     } else {
		     22 +       test.fail("Expected entity");
		     23 +     }
		     24 +   });
		     25 +   test.spawn("minecraft:horse<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		     26 +   World.events.entityCreate.unsubscribe(entityCreatedCallback);
		     27 + })
		     28 +   .structureName("ComponentTests:animal_pen")
		     29 +   .tag(GameTest.Tags.suiteDefault);
		     30 + 
		     31 + GameTest.register("APITests", "assert_is_waterlogged", (test) => {
		     32 +   const waterChestLoc = new BlockLocation(5, 2, 1);
		     33 +   const waterLoc = new BlockLocation(4, 2, 1);
		     34 +   const chestLoc = new BlockLocation(2, 2, 1);
		     35 +   const airLoc = new BlockLocation(1, 2, 1);
		     36 + 
		     37 +   test.assertIsWaterlogged(waterChestLoc, true);
		     38 +   test.assertIsWaterlogged(waterLoc, false);
		     39 +   test.assertIsWaterlogged(chestLoc, false);
		     40 +   test.assertIsWaterlogged(airLoc, false);
		     41 +   test.succeed();
		     42 + }).tag(GameTest.Tags.suiteDefault);
		     43 + 
		     44 + GameTest.register("APITests", "assert_redstone_power", (test) => {
		     45 +   const redstoneBlockLoc = new BlockLocation(3, 2, 1);
		     46 +   const redstoneTorchLoc = new BlockLocation(2, 2, 1);
		     47 +   const poweredLampLoc = new BlockLocation(1, 2, 1);
		     48 +   const unpoweredLampLoc = new BlockLocation(0, 2, 1);
		     49 +   const airLoc = new BlockLocation(3, 2, 0);
		     50 +   const redstoneWireLoc = new BlockLocation(0, 1, 0);
		     51 + 
		     52 +   test.succeedWhen(() => {
		     53 +     test.assertRedstonePower(redstoneBlockLoc, 15);
		     54 +     test.assertRedstonePower(redstoneTorchLoc, 15);
		     55 +     test.assertRedstonePower(poweredLampLoc, 15);
		     56 +     test.assertRedstonePower(unpoweredLampLoc, 0);
		     57 +     test.assertRedstonePower(airLoc, -1);
		     58 +     test.assertRedstonePower(redstoneWireLoc, 13); // 3 length wire
		     59 +   });
		     60 + })
		     61 +   .maxTicks(20)
		     62 +   .tag(GameTest.Tags.suiteDefault);
		     63 + 
		     64 + GameTest.register("APITests", "spawn_item", (test) => {
		     65 +   const featherItem = new ItemStack(MinecraftItemTypes.feather, 1, 0);
		     66 +   test.spawnItem(featherItem, new Location(1.5, 3.5, 1.5));
		     67 +   test.succeedWhen(() => {
		     68 +     test.assertEntityPresent("minecraft:item", new BlockLocation(1, 2, 1), true);
		     69 +   });
		     70 + }).tag(GameTest.Tags.suiteDefault);
		     71 + 
		     72 + GameTest.register("APITests", "assert_entity_data", (test) => {
		     73 +   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		     74 +   const pigLoc = new BlockLocation(1, 2, 1);
		     75 +   test.spawn(pigId, pigLoc);
		     76 +   test.succeedWhen(() => {
		     77 +     test.assertEntityState(pigLoc, pigId, (entity) => entity.id !== undefined);
		     78 +   });
		     79 + })
		     80 +   .structureName("ComponentTests:animal_pen")
		     81 +   .tag(GameTest.Tags.suiteDefault);
		     82 + 
		     83 + GameTest.register("APITests", "add_effect", (test) => {
		     84 +   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		     85 +   const villagerLoc = new BlockLocation(1, 2, 1);
		     86 +   const villager = test.spawn(villagerId, villagerLoc);
		     87 +   const duration = 20;
		     88 +   villager.addEffect(MinecraftEffectTypes.poison, duration, 1);
		  9     -     FluidContainer,
		 10     -   MinecraftEffectTypes,
		 11     -   MinecraftItemTypes,
		 12     -   ItemStack,
		 13     -   Location,
		 14     -   World,
		 15     - } from "mojang-minecraft";
		 16  89   
		 17     - GameTest.register("APITests", "on_entity_created", (test) => {
		 18     -   const entityCreatedCallback = World.events.entityCreate.subscribe((entity) => {
		 19     -     if (entity) {
		     90 +   test.assertEntityState(
		     91 +     villagerLoc,
		     92 +     villagerId,
		     93 +     (entity) => entity.getEffect(MinecraftEffectTypes.poison).duration == duration
		     94 +   );
		     95 +   test.assertEntityState(
		     96 +     villagerLoc,
		     97 +     villagerId,
		     98 +     (entity) => entity.getEffect(MinecraftEffectTypes.poison).amplifier == 1
		     99 +   );
		 20     -       test.succeed();
		 21     -     } else {
		 22     -       test.fail("Expected entity");
		 23     -     }
		 24     -   });
		 25     -   test.spawn("minecraft:horse<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		 26     -   World.events.entityCreate.unsubscribe(entityCreatedCallback);
		 27     - })
		 28     -   .structureName("ComponentTests:animal_pen")
		 29     -   .tag(GameTest.Tags.suiteDefault);
		 30 100   
		    101 +   test.runAfterDelay(duration, () => {
		 31     - GameTest.register("APITests", "assert_is_waterlogged", (test) => {
		 32     -   const waterChestLoc = new BlockLocation(5, 2, 1);
		    102 +     test.assertEntityState(
		    103 +       villagerLoc,
		    104 +       villagerId,
		    105 +       (entity) => entity.getEffect(MinecraftEffectTypes.poison) === undefined
		    106 +     );
		    107 +     test.succeed();
		    108 +   });
		    109 + })
		    110 +   .structureName("ComponentTests:animal_pen")
		    111 +   .tag(GameTest.Tags.suiteDefault);
		 33     -   const waterLoc = new BlockLocation(4, 2, 1);
		 34     -   const chestLoc = new BlockLocation(2, 2, 1);
		 35     -   const airLoc = new BlockLocation(1, 2, 1);
		 36     - 
		 37     -   test.assertIsWaterlogged(waterChestLoc, true);
		 38     -   test.assertIsWaterlogged(waterLoc, false);
		 39     -   test.assertIsWaterlogged(chestLoc, false);
		 40     -   test.assertIsWaterlogged(airLoc, false);
		 41     -   test.succeed();
		 42     - }).tag(GameTest.Tags.suiteDefault);
		 43 112   
		    113 + GameTest.register("APITests", "assert_entity_present", (test) => {
		    114 +   const villagerId = "minecraft:villager_v2";
		    115 +   const villagerLoc = new BlockLocation(1, 2, 3);
		 44     - GameTest.register("APITests", "assert_redstone_power", (test) => {
		    116 +   const emeraldItem = new ItemStack(MinecraftItemTypes.emerald, 1, 0);
		    117 +   const emeraldItemLoc = new BlockLocation(3, 2, 3);
		    118 +   const minecartId = "minecraft:minecart";
		    119 +   const minecartLoc = new BlockLocation(3, 2, 1);
		    120 +   const armorStandId = "minecraft:armor_stand";
		    121 +   const armorStandLoc = new BlockLocation(1, 2, 1);
		 45     -   const redstoneBlockLoc = new BlockLocation(3, 2, 1);
		 46     -   const redstoneTorchLoc = new BlockLocation(2, 2, 1);
		 47     -   const poweredLampLoc = new BlockLocation(1, 2, 1);
		 48     -   const unpoweredLampLoc = new BlockLocation(0, 2, 1);
		 49     -   const airLoc = new BlockLocation(3, 2, 0);
		 50     -   const redstoneWireLoc = new BlockLocation(0, 1, 0);
		 51 122   
		 52     -   test.succeedWhen(() => {
		 53     -     test.assertRedstonePower(redstoneBlockLoc, 15);
		 54     -     test.assertRedstonePower(redstoneTorchLoc, 15);
		 55     -     test.assertRedstonePower(poweredLampLoc, 15);
		    123 +   test.spawn(villagerId, villagerLoc);
		    124 +   test.spawnItem(emeraldItem, new Location(3.5, 4.5, 3.5));
		    125 + 
		    126 +   test.succeedWhen(() => {
		    127 +     test.assertEntityPresent(villagerId, villagerLoc, true);
		    128 +     test.assertItemEntityPresent(MinecraftItemTypes.emerald, emeraldItemLoc, 0, true);
		    129 +     test.assertEntityPresent(armorStandId, armorStandLoc, true);
		 56     -     test.assertRedstonePower(unpoweredLampLoc, 0);
		 57     -     test.assertRedstonePower(airLoc, -1);
		 58     -     test.assertRedstonePower(redstoneWireLoc, 13); // 3 length wire
		 59     -   });
		 60     - })
		 61     -   .maxTicks(20)
		 62     -   .tag(GameTest.Tags.suiteDefault);
		 63 130   
		 64     - GameTest.register("APITests", "spawn_item", (test) => {
		 65     -   const featherItem = new ItemStack(MinecraftItemTypes.feather, 1, 0);
		 66     -   test.spawnItem(featherItem, new Location(1.5, 3.5, 1.5));
		    131 +     // Check all blocks surrounding the minecart
		    132 +     for (let x = -1; x <= 1; x++) {
		    133 +       for (let z = -1; z <= 1; z++) {
		    134 +         let offsetLoc = new BlockLocation(minecartLoc.x + x, minecartLoc.y, minecartLoc.z + z);
		    135 +         if (x == 0 && z == 0) {
		    136 +           test.assertEntityPresent(minecartId, offsetLoc, true);
		    137 +         } else {
		    138 +           test.assertEntityPresent(minecartId, offsetLoc, false);
		    139 +         }
		    140 +       }
		    141 +     }
		 67     -   test.succeedWhen(() => {
		 68     -     test.assertEntityPresent("minecraft:item", new BlockLocation(1, 2, 1), true);
		 69     -   });
		 70     - }).tag(GameTest.Tags.suiteDefault);
		 71     - 
		 72     - GameTest.register("APITests", "assert_entity_data", (test) => {
		 73     -   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		 74     -   const pigLoc = new BlockLocation(1, 2, 1);
		 75     -   test.spawn(pigId, pigLoc);
		 76     -   test.succeedWhen(() => {
		 77     -     test.assertEntityState(pigLoc, pigId, (entity) => entity.id !== undefined);
		 78 142     });
		    143 + }).tag(GameTest.Tags.suiteDefault);
		 79     - })
		 80     -   .structureName("ComponentTests:animal_pen")
		 81     -   .tag(GameTest.Tags.suiteDefault);
		 82 144   
		    145 + GameTest.register("APITests", "assert_entity_not_present", (test) => {
		 83     - GameTest.register("APITests", "add_effect", (test) => {
		 84     -   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		    146 +   const armorStandId = "minecraft:armor_stand";
		    147 +   const pigId = "minecraft:pig";
		    148 +   const armorStandLoc = new BlockLocation(1, 2, 1);
		    149 +   const airLoc = new BlockLocation(0, 2, 1);
		 85     -   const villagerLoc = new BlockLocation(1, 2, 1);
		 86     -   const villager = test.spawn(villagerId, villagerLoc);
		 87     -   const duration = 20;
		 88     -   villager.addEffect(MinecraftEffectTypes.poison, duration, 1);
		 89 150   
		    151 +   try {
		 90     -   test.assertEntityState(
		 91     -     villagerLoc,
		    152 +     test.assertEntityPresentInArea(armorStandId, false);
		    153 +     test.fail(); // this assert should throw
		    154 +   } catch (e) {}
		    155 + 
		    156 +   try {
		    157 +     test.assertEntityPresent(armorStandId, armorStandLoc, false);
		    158 +     test.fail(); // this assert should throw
		    159 +   } catch (e) {}
		 92     -     villagerId,
		 93     -     (entity) => entity.getEffect(MinecraftEffectTypes.poison).duration == duration
		 94     -   );
		 95     -   test.assertEntityState(
		 96     -     villagerLoc,
		 97     -     villagerId,
		 98     -     (entity) => entity.getEffect(MinecraftEffectTypes.poison).amplifier == 1
		 99     -   );
		100 160   
		101     -   test.runAfterDelay(duration, () => {
		102     -     test.assertEntityState(
		103     -       villagerLoc,
		104     -       villagerId,
		    161 +   test.assertEntityPresent(armorStandId, airLoc, false);
		    162 +   test.assertEntityPresentInArea(pigId, false);
		    163 + 
		    164 +   test.succeed();
		105     -       (entity) => entity.getEffect(MinecraftEffectTypes.poison) === undefined
		106     -     );
		107     -     test.succeed();
		108     -   });
		109 165   })
		    166 +   .structureName("APITests:armor_stand")
		110     -   .structureName("ComponentTests:animal_pen")
		111 167     .tag(GameTest.Tags.suiteDefault);
		112 168   
		113     - GameTest.register("APITests", "assert_entity_present", (test) => {
		114     -   const villagerId = "minecraft:villager_v2";
		115     -   const villagerLoc = new BlockLocation(1, 2, 3);
		116     -   const emeraldItem = new ItemStack(MinecraftItemTypes.emerald, 1, 0);
		    169 + GameTest.register("APITests", "assert_item_entity_count_is", (test) => {
		    170 +   let oneItemLoc = new BlockLocation(3, 2, 1);
		    171 +   let fiveItemsLoc = new BlockLocation(1, 2, 1);
		    172 +   let noItemsLoc = new BlockLocation(2, 2, 1);
		    173 +   let diamondPickaxeLoc = new BlockLocation(2, 2, 4);
		117     -   const emeraldItemLoc = new BlockLocation(3, 2, 3);
		118     -   const minecartId = "minecraft:minecart";
		119     -   const minecartLoc = new BlockLocation(3, 2, 1);
		120     -   const armorStandId = "minecraft:armor_stand";
		121     -   const armorStandLoc = new BlockLocation(1, 2, 1);
		122 174   
		    175 +   const oneEmerald = new ItemStack(MinecraftItemTypes.emerald, 1, 0);
		    176 +   const onePickaxe = new ItemStack(MinecraftItemTypes.diamondPickaxe, 1, 0);
		123     -   test.spawn(villagerId, villagerLoc);
		    177 +   const fiveEmeralds = new ItemStack(MinecraftItemTypes.emerald, 5, 0);
		124     -   test.spawnItem(emeraldItem, new Location(3.5, 4.5, 3.5));
		125 178   
		    179 +   test.spawnItem(oneEmerald, new Location(3.5, 3, 1.5));
		126     -   test.succeedWhen(() => {
		127     -     test.assertEntityPresent(villagerId, villagerLoc, true);
		128     -     test.assertItemEntityPresent(MinecraftItemTypes.emerald, emeraldItemLoc, 0, true);
		    180 +   test.spawnItem(fiveEmeralds, new Location(1.5, 3, 1.5));
		129     -     test.assertEntityPresent(armorStandId, armorStandLoc, true);
		130 181   
		    182 +   // spawn 9 pickaxes in a 3x3 grid
		    183 +   for (let x = 1.5; x <= 3.5; x++) {
		131     -     // Check all blocks surrounding the minecart
		132     -     for (let x = -1; x <= 1; x++) {
		    184 +     for (let z = 3.5; z <= 5.5; z++) {
		    185 +       test.spawnItem(onePickaxe, new Location(x, 3, z));
		    186 +     }
		    187 +   }
		    188 + 
		    189 +   test.assertItemEntityCountIs(MinecraftItemTypes.emerald, noItemsLoc, 0, 0);
		    190 + 
		    191 +   test.succeedWhen(() => {
		    192 +     test.assertItemEntityCountIs(MinecraftItemTypes.feather, oneItemLoc, 0, 0);
		    193 +     test.assertItemEntityCountIs(MinecraftItemTypes.emerald, oneItemLoc, 0, 1);
		    194 +     test.assertItemEntityCountIs(MinecraftItemTypes.feather, fiveItemsLoc, 0, 0);
		    195 +     test.assertItemEntityCountIs(MinecraftItemTypes.emerald, fiveItemsLoc, 0, 5);
		    196 +     test.assertItemEntityCountIs(MinecraftItemTypes.emerald, fiveItemsLoc, 0, 5);
		    197 +     test.assertItemEntityCountIs(MinecraftItemTypes.diamondPickaxe, diamondPickaxeLoc, 1, 9);
		    198 +     test.assertItemEntityCountIs(MinecraftItemTypes.diamondPickaxe, diamondPickaxeLoc, 0, 1);
		    199 +   });
		    200 + }).tag(GameTest.Tags.suiteDefault);
		133     -       for (let z = -1; z <= 1; z++) {
		134     -         let offsetLoc = new BlockLocation(minecartLoc.x + x, minecartLoc.y, minecartLoc.z + z);
		135     -         if (x == 0 && z == 0) {
		136     -           test.assertEntityPresent(minecartId, offsetLoc, true);
		137     -         } else {
		138     -           test.assertEntityPresent(minecartId, offsetLoc, false);
		139     -         }
		140     -       }
		141     -     }
		142     -   });
		143     - }).tag(GameTest.Tags.suiteDefault);
		144     - 
		145     - GameTest.register("APITests", "assert_entity_not_present", (test) => {
		146     -   const armorStandId = "minecraft:armor_stand";
		147     -   const pigId = "minecraft:pig";
		148     -   const armorStandLoc = new BlockLocation(1, 2, 1);
		149     -   const airLoc = new BlockLocation(0, 2, 1);
		150 201   
		    202 + GameTest.register("APITests", "assert_entity_touching", (test) => {
		151     -   try {
		152     -     test.assertEntityPresentInArea(armorStandId, false);
		153     -     test.fail(); // this assert should throw
		    203 +   const armorStandId = "minecraft:armor_stand";
		154     -   } catch (e) {}
		155 204   
		    205 +   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.5), true);
		    206 +   test.assertEntityTouching(armorStandId, new Location(1.5, 3.5, 1.5), true);
		156     -   try {
		157     -     test.assertEntityPresent(armorStandId, armorStandLoc, false);
		    207 +   test.assertEntityTouching(armorStandId, new Location(1.0, 2.5, 1.5), false);
		    208 +   test.assertEntityTouching(armorStandId, new Location(2.0, 2.5, 1.5), false);
		158     -     test.fail(); // this assert should throw
		159     -   } catch (e) {}
		160     - 
		    209 +   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.0), false);
		    210 +   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 2.0), false);
		161     -   test.assertEntityPresent(armorStandId, airLoc, false);
		162     -   test.assertEntityPresentInArea(pigId, false);
		163 211   
		164 212     test.succeed();
		165 213   })
		166 214     .structureName("APITests:armor_stand")
		167 215     .tag(GameTest.Tags.suiteDefault);
		168 216   
		    217 + GameTest.register("APITests", "pulse_redstone", (test) => {
		    218 +   const pulseLoc = new BlockLocation(1, 2, 2);
		169     - GameTest.register("APITests", "assert_item_entity_count_is", (test) => {
		170     -   let oneItemLoc = new BlockLocation(3, 2, 1);
		    219 +   const lampLoc = new BlockLocation(1, 2, 1);
		    220 +   test.assertRedstonePower(lampLoc, 0);
		    221 +   test.pulseRedstone(pulseLoc, 2);
		171     -   let fiveItemsLoc = new BlockLocation(1, 2, 1);
		172     -   let noItemsLoc = new BlockLocation(2, 2, 1);
		173     -   let diamondPickaxeLoc = new BlockLocation(2, 2, 4);
		174 222   
		    223 +   test
		    224 +     .startSequence()
		    225 +     .thenIdle(2)
		175     -   const oneEmerald = new ItemStack(MinecraftItemTypes.emerald, 1, 0);
		    226 +     .thenExecute(() => test.assertRedstonePower(lampLoc, 15))
		    227 +     .thenIdle(2)
		    228 +     .thenExecute(() => test.assertRedstonePower(lampLoc, 0))
		    229 +     .thenSucceed();
		    230 + }).tag(GameTest.Tags.suiteDefault);
		176     -   const onePickaxe = new ItemStack(MinecraftItemTypes.diamondPickaxe, 1, 0);
		177     -   const fiveEmeralds = new ItemStack(MinecraftItemTypes.emerald, 5, 0);
		178     - 
		179     -   test.spawnItem(oneEmerald, new Location(3.5, 3, 1.5));
		180     -   test.spawnItem(fiveEmeralds, new Location(1.5, 3, 1.5));
		181 231   
		    232 + GameTest.register("APITests", "block_location", (test) => {
		    233 +   let testLoc = new BlockLocation(1, 1, 1);
		    234 +   let worldLoc = test.worldBlockLocation(testLoc);
		182     -   // spawn 9 pickaxes in a 3x3 grid
		    235 +   let relativeLoc = test.relativeBlockLocation(worldLoc);
		    236 +   test.assert(!relativeLoc.equals(worldLoc), "Expected relativeLoc and worldLoc to be different");
		    237 +   test.assert(relativeLoc.equals(testLoc), "Expected relativeLoc to match testLoc");
		    238 +   test.succeed();
		    239 + })
		    240 +   .structureName("ComponentTests:platform")
		    241 +   .tag(GameTest.Tags.suiteDefault);
		183     -   for (let x = 1.5; x <= 3.5; x++) {
		184     -     for (let z = 3.5; z <= 5.5; z++) {
		185     -       test.spawnItem(onePickaxe, new Location(x, 3, z));
		186     -     }
		187     -   }
		188     - 
		189     -   test.assertItemEntityCountIs(MinecraftItemTypes.emerald, noItemsLoc, 0, 0);
		190 242   
		191     -   test.succeedWhen(() => {
		192     -     test.assertItemEntityCountIs(MinecraftItemTypes.feather, oneItemLoc, 0, 0);
		193     -     test.assertItemEntityCountIs(MinecraftItemTypes.emerald, oneItemLoc, 0, 1);
		    243 + GameTest.register("APITests", "location", (test) => {
		    244 +   let testLoc = new Location(1.2, 1.2, 1.2);
		    245 +   let worldLoc = test.worldLocation(testLoc);
		    246 +   let relativeLoc = test.relativeLocation(worldLoc);
		    247 +   test.assert(!relativeLoc.isNear(worldLoc, 0.01), "Expected relativeLoc and worldLoc to be different");
		    248 +   test.assert(relativeLoc.isNear(testLoc, 0.01), "Expected relativeLoc to match testLoc");
		    249 +   test.succeed();
		    250 + })
		    251 +   .structureName("ComponentTests:platform")
		    252 +   .tag(GameTest.Tags.suiteDefault);
		194     -     test.assertItemEntityCountIs(MinecraftItemTypes.feather, fiveItemsLoc, 0, 0);
		195     -     test.assertItemEntityCountIs(MinecraftItemTypes.emerald, fiveItemsLoc, 0, 5);
		196     -     test.assertItemEntityCountIs(MinecraftItemTypes.emerald, fiveItemsLoc, 0, 5);
		197     -     test.assertItemEntityCountIs(MinecraftItemTypes.diamondPickaxe, diamondPickaxeLoc, 1, 9);
		198     -     test.assertItemEntityCountIs(MinecraftItemTypes.diamondPickaxe, diamondPickaxeLoc, 0, 1);
		199     -   });
		200     - }).tag(GameTest.Tags.suiteDefault);
		201     - 
		202     - GameTest.register("APITests", "assert_entity_touching", (test) => {
		203     -   const armorStandId = "minecraft:armor_stand";
		204 253   
		    254 + GameTest.register("APITests", "create_explosion_basic", (test) => {
		205     -   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.5), true);
		206     -   test.assertEntityTouching(armorStandId, new Location(1.5, 3.5, 1.5), true);
		    255 +   let overworld = World.getDimension("overworld");
		    256 +   const center = new BlockLocation(2, 3, 2);
		    257 + 
		    258 +   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		207     -   test.assertEntityTouching(armorStandId, new Location(1.0, 2.5, 1.5), false);
		208     -   test.assertEntityTouching(armorStandId, new Location(2.0, 2.5, 1.5), false);
		209     -   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.0), false);
		210     -   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 2.0), false);
		211 259   
		    260 +   const loc = test.worldBlockLocation(center);
		212     -   test.succeed();
		213     - })
		    261 +   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		    262 +   overworld.createExplosion(explosionLoc, 10, new ExplosionOptions());
		214     -   .structureName("APITests:armor_stand")
		215     -   .tag(GameTest.Tags.suiteDefault);
		216 263   
		    264 +   for (let x = 1; x <= 3; x++) {
		    265 +     for (let y = 2; y <= 4; y++) {
		    266 +       for (let z = 1; z <= 3; z++) {
		217     - GameTest.register("APITests", "pulse_redstone", (test) => {
		    267 +         test.assertBlockPresent(MinecraftBlockTypes.cobblestone, new BlockLocation(x, y, z), false);
		    268 +       }
		    269 +     }
		    270 +   }
		218     -   const pulseLoc = new BlockLocation(1, 2, 2);
		219     -   const lampLoc = new BlockLocation(1, 2, 1);
		220     -   test.assertRedstonePower(lampLoc, 0);
		221     -   test.pulseRedstone(pulseLoc, 2);
		222 271   
		    272 +   test.succeed();
		    273 + })
		223     -   test
		224     -     .startSequence()
		    274 +   .padding(10) // The blast can destroy nearby items and mobs
		    275 +   .tag(GameTest.Tags.suiteDefault);
		    276 + 
		    277 + GameTest.register("APITests", "create_explosion_advanced", (test) => {
		    278 +   let overworld = World.getDimension("overworld");
		    279 +   const center = new BlockLocation(3, 3, 3);
		225     -     .thenIdle(2)
		226     -     .thenExecute(() => test.assertRedstonePower(lampLoc, 15))
		227     -     .thenIdle(1)
		228     -     .thenExecute(() => test.assertRedstonePower(lampLoc, 0))
		229     -     .thenSucceed();
		230     - }).tag(GameTest.Tags.suiteDefault);
		231 280   
		232     - GameTest.register("APITests", "block_location", (test) => {
		233     -   let testLoc = new BlockLocation(1, 1, 1);
		234     -   let worldLoc = test.worldBlockLocation(testLoc);
		    281 +   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		    282 +   const pigLoc = new BlockLocation(3, 4, 3);
		    283 +   test.spawn(pigId, pigLoc);
		    284 + 
		    285 +   const loc = test.worldBlockLocation(center);
		    286 +   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		    287 +   let explosionOptions = new ExplosionOptions();
		235     -   let relativeLoc = test.relativeBlockLocation(worldLoc);
		236     -   test.assert(!relativeLoc.equals(worldLoc), "Expected relativeLoc and worldLoc to be different");
		237     -   test.assert(relativeLoc.equals(testLoc), "Expected relativeLoc to match testLoc");
		238     -   test.succeed();
		239     - })
		240     -   .structureName("ComponentTests:platform")
		241     -   .tag(GameTest.Tags.suiteDefault);
		242 288   
		243     - GameTest.register("APITests", "location", (test) => {
		244     -   let testLoc = new Location(1.2, 1.2, 1.2);
		245     -   let worldLoc = test.worldLocation(testLoc);
		    289 +   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		    290 + 
		    291 +   // Start by exploding without breaking blocks
		    292 +   explosionOptions.breaksBlocks = false;
		    293 +   const creeper = test.spawn("minecraft:creeper", new BlockLocation(1, 2, 1));
		    294 +   explosionOptions.source = creeper;
		    295 +   test.assertEntityPresent(pigId, pigLoc, true);
		    296 +   overworld.createExplosion(explosionLoc, 10, explosionOptions);
		    297 +   creeper.kill();
		    298 +   test.assertEntityPresent(pigId, pigLoc, false);
		    299 +   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		246     -   let relativeLoc = test.relativeLocation(worldLoc);
		247     -   test.assert(!relativeLoc.isNear(worldLoc, 0.01), "Expected relativeLoc and worldLoc to be different");
		248     -   test.assert(relativeLoc.isNear(testLoc, 0.01), "Expected relativeLoc to match testLoc");
		249     -   test.succeed();
		250     - })
		251     -   .structureName("ComponentTests:platform")
		252     -   .tag(GameTest.Tags.suiteDefault);
		253     - 
		254     - GameTest.register("APITests", "create_explosion_basic", (test) => {
		255     -   let overworld = World.getDimension("overworld");
		256     -   const center = new BlockLocation(2, 3, 2);
		257 300   
		    301 +   // Next, explode with fire
		    302 +   explosionOptions = new ExplosionOptions();
		    303 +   explosionOptions.causesFire = true;
		258     -   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		259 304   
		    305 +   let findFire = () => {
		    306 +     let foundFire = false;
		260     -   const loc = test.worldBlockLocation(center);
		    307 +     for (let x = 0; x <= 6; x++) {
		    308 +       for (let z = 0; z <= 6; z++) {
		    309 +         try {
		    310 +           test.assertBlockPresent(MinecraftBlockTypes.fire, new BlockLocation(x, 3, z), true);
		    311 +           foundFire = true;
		    312 +           break;
		    313 +         } catch (e) {}
		261     -   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		262     -   overworld.createExplosion(explosionLoc, 10, new ExplosionOptions());
		263     - 
		264     -   for (let x = 1; x <= 3; x++) {
		265     -     for (let y = 2; y <= 4; y++) {
		266     -       for (let z = 1; z <= 3; z++) {
		267     -         test.assertBlockPresent(MinecraftBlockTypes.cobblestone, new BlockLocation(x, y, z), false);
		268 314         }
		269 315       }
		270     -   }
		271     - 
		272     -   test.succeed();
		273     - })
		    316 +     return foundFire;
		    317 +   };
		274     -   .padding(10) // The blast can destroy nearby items and mobs
		275     -   .tag(GameTest.Tags.suiteDefault);
		276 318   
		    319 +   test.assert(!findFire(), "Unexpected fire");
		    320 +   overworld.createExplosion(explosionLoc, 15, explosionOptions);
		277     - GameTest.register("APITests", "create_explosion_advanced", (test) => {
		    321 +   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, false);
		    322 +   test.assert(findFire(), "No fire found");
		278     -   let overworld = World.getDimension("overworld");
		279     -   const center = new BlockLocation(3, 3, 3);
		280 323   
		    324 +   // Finally, explode in water
		    325 +   explosionOptions.allowUnderwater = true;
		    326 +   const belowWaterLoc = new BlockLocation(3, 1, 3);
		    327 +   test.assertBlockPresent(MinecraftBlockTypes.air, belowWaterLoc, false);
		    328 +   overworld.createExplosion(explosionLoc, 10, explosionOptions);
		    329 +   test.assertBlockPresent(MinecraftBlockTypes.air, belowWaterLoc, true);
		    330 +   test.succeed();
		    331 + })
		    332 +   .padding(10) // The blast can destroy nearby items and mobs
		    333 +   .tag(GameTest.Tags.suiteDefault);
		281     -   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		282     -   const pigLoc = new BlockLocation(3, 4, 3);
		283     -   test.spawn(pigId, pigLoc);
		284     - 
		285     -   const loc = test.worldBlockLocation(center);
		286     -   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		287     -   let explosionOptions = new ExplosionOptions();
		288 334   
		    335 + GameTest.register("APITests", "triggerEvent", (test) => {
		    336 +   const creeper = test.spawn("creeper", new BlockLocation(1, 2, 1));
		    337 +   creeper.triggerEvent("minecraft:start_exploding_forced");
		289     -   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		290 338   
		291     -   // Start by exploding without breaking blocks
		292     -   explosionOptions.breaksBlocks = false;
		293     -   const creeper = test.spawn("minecraft:creeper", new BlockLocation(1, 2, 1));
		    339 +   test.succeedWhen(() => {
		    340 +     test.assertEntityPresentInArea("creeper", false);
		    341 +   });
		    342 + })
		    343 +   .structureName("ComponentTests:glass_cage")
		    344 +   .tag(GameTest.Tags.suiteDefault);
		294     -   explosionOptions.source = creeper;
		295     -   test.assertEntityPresent(pigId, pigLoc, true);
		296     -   overworld.createExplosion(explosionLoc, 10, explosionOptions);
		297     -   creeper.kill();
		298     -   test.assertEntityPresent(pigId, pigLoc, false);
		299     -   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		300 345   
		    346 + GameTest.register("APITests", "chat", (test) => {
		301     -   // Next, explode with fire
		302     -   explosionOptions = new ExplosionOptions();
		    347 +   test.print("subscribing");
		303     -   explosionOptions.causesFire = true;
		304 348   
		    349 +   const chatCallback = World.events.beforeChat.subscribe((eventData) => {
		305     -   let findFire = () => {
		306     -     let foundFire = false;
		    350 +     if (eventData.message === "!killme") {
		    351 +       eventData.sender.kill();
		    352 +       eventData.cancel = true;
		    353 +     } else if (eventData.message === "!players") {
		    354 +       test.print(`There are ${eventData.targets.length} players in the server.`);
		    355 +       for (const target of eventData.targets) {
		    356 +         test.print("Player: " + target.name);
		307     -     for (let x = 0; x <= 6; x++) {
		308     -       for (let z = 0; z <= 6; z++) {
		309     -         try {
		310     -           test.assertBlockPresent(MinecraftBlockTypes.fire, new BlockLocation(x, 3, z), true);
		311     -           foundFire = true;
		312     -           break;
		313     -         } catch (e) {}
		314 357         }
		315     -     }
		316     -     return foundFire;
		317     -   };
		318     - 
		    358 +     } else {
		    359 +       eventData.message = `Modified '${eventData.message}'`;
		    360 +     }
		    361 +   });
		319     -   test.assert(!findFire(), "Unexpected fire");
		320     -   overworld.createExplosion(explosionLoc, 15, explosionOptions);
		321     -   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, false);
		322     -   test.assert(findFire(), "No fire found");
		323 362   
		    363 +   test
		    364 +     .startSequence()
		324     -   // Finally, explode in water
		    365 +     .thenIdle(200)
		    366 +     .thenExecute(() => {
		    367 +       World.events.beforeChat.unsubscribe(chatCallback);
		    368 +       test.print("unsubscribed");
		    369 +     })
		    370 +     .thenSucceed();
		325     -   explosionOptions.allowUnderwater = true;
		326     -   const belowWaterLoc = new BlockLocation(3, 1, 3);
		327     -   test.assertBlockPresent(MinecraftBlockTypes.air, belowWaterLoc, false);
		328     -   overworld.createExplosion(explosionLoc, 10, explosionOptions);
		329     -   test.assertBlockPresent(MinecraftBlockTypes.air, belowWaterLoc, true);
		330     -   test.succeed();
		331 371   })
		    372 +   .structureName("ComponentTests:platform")
		    373 +   .maxTicks(1000)
		332     -   .padding(10) // The blast can destroy nearby items and mobs
		    374 +   .tag(GameTest.Tags.suiteDisabled);
		333     -   .tag(GameTest.Tags.suiteDefault);
		334 375   
		    376 + GameTest.register("APITests", "add_effect_event", (test) => {
		    377 +   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		335     - GameTest.register("APITests", "triggerEvent", (test) => {
		336     -   const creeper = test.spawn("creeper", new BlockLocation(1, 2, 1));
		    378 +   const villager = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		337     -   creeper.triggerEvent("minecraft:start_exploding_forced");
		338 379   
		    380 +   const effectAddCallback = World.events.effectAdd.subscribe((eventData) => {
		    381 +     test.assert(eventData.entity.id === "minecraft:villager_v2", "Unexpected id");
		    382 +     test.assert(eventData.effect.displayName === "Poison II", "Unexpected display name");
		    383 +     test.assert(eventData.effectState === 1, "Unexpected effect state");
		    384 +     test.succeed();
		339     -   test.succeedWhen(() => {
		340     -     test.assertEntityPresentInArea("creeper", false);
		341 385     });
		    386 + 
		    387 +   villager.addEffect(MinecraftEffectTypes.poison, 5, 1);
		    388 +   World.events.effectAdd.unsubscribe(effectAddCallback);
		342 389   })
		    390 +   .structureName("ComponentTests:animal_pen")
		343     -   .structureName("ComponentTests:glass_cage")
		344 391     .tag(GameTest.Tags.suiteDefault);
		345 392   
		    393 + GameTest.register("APITests", "piston", (test) => {
		    394 +   const overworld = World.getDimension("overworld");
		    395 +   const pistonLoc = new BlockLocation(1, 2, 1);
		    396 +   const redstoneLoc = new BlockLocation(1, 2, 0);
		    397 +   const pistonComp = overworld.getBlock(test.worldBlockLocation(pistonLoc)).getComponent("piston");
		346     - GameTest.register("APITests", "chat", (test) => {
		347     -   test.print("subscribing");
		348 398   
		349     -   const chatCallback = World.events.beforeChat.subscribe((eventData) => {
		350     -     if (eventData.message === "!killme") {
		351     -       eventData.sender.kill();
		352     -       eventData.cancel = true;
		    399 +   test.assert(pistonComp != undefined, "Expected piston component");
		    400 + 
		    401 +   let assertPistonState = (isMoving, isExpanded, isExpanding, isRetracted, isRetracting) => {
		    402 +     test.assert(pistonComp.isMoving === isMoving, "Unexpected isMoving");
		    403 +     test.assert(pistonComp.isExpanded === isExpanded, "Unexpected isExpanded");
		    404 +     test.assert(pistonComp.isExpanding === isExpanding, "Unexpected isExpanding");
		    405 +     test.assert(pistonComp.isRetracted === isRetracted, "Unexpected isRetracted");
		    406 +     test.assert(pistonComp.isRetracting === isRetracting, "Unexpected isRetracting");
		    407 +   };
		353     -     } else if (eventData.message === "!players") {
		354     -       test.print(`There are ${eventData.targets.length} players in the server.`);
		355     -       for (const target of eventData.targets) {
		356     -         test.print("Player: " + target.name);
		357     -       }
		358     -     } else {
		359     -       eventData.message = `Modified '${eventData.message}'`;
		360     -     }
		361     -   });
		362 408   
		363 409     test
		364 410       .startSequence()
		365     -     .thenIdle(200)
		366 411       .thenExecute(() => {
		    412 +       test.assert(pistonComp.attachedBlocks.length === 0, "Expected 0 attached blocks");
		    413 +       assertPistonState(false, false, false, true, false); // isRetracted
		367     -       World.events.beforeChat.unsubscribe(chatCallback);
		    414 +       test.setBlockType(MinecraftBlockTypes.redstoneBlock, redstoneLoc);
		368     -       test.print("unsubscribed");
		369 415       })
		    416 +     .thenIdle(4)
		370     -     .thenSucceed();
		371     - })
		    417 +     .thenExecute(() => {
		    418 +       test.assert(pistonComp.attachedBlocks.length === 3, "Expected 3 attached blocks");
		    419 +       assertPistonState(true, false, true, false, false); // isMoving, isExpanding
		    420 +     })
		    421 +     .thenIdle(2)
		    422 +     .thenExecute(() => {
		    423 +       assertPistonState(false, true, false, false, false); // isExpanded
		372     -   .structureName("ComponentTests:platform")
		373     -   .maxTicks(1000)
		374     -   .tag(GameTest.Tags.suiteDisabled);
		375     - 
		376     - GameTest.register("APITests", "add_effect_event", (test) => {
		377     -   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		378     -   const villager = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		379 424   
		    425 +       test.setBlockType(MinecraftBlockTypes.air, redstoneLoc);
		    426 +     })
		380     -   const effectAddCallback = World.events.effectAdd.subscribe((eventData) => {
		381     -     test.assert(eventData.entity.id === "minecraft:villager_v2", "Unexpected id");
		    427 +     .thenIdle(4)
		    428 +     .thenExecute(() => {
		    429 +       assertPistonState(true, false, false, false, true); // isMoving, isRetracting
		    430 +     })
		    431 +     .thenIdle(2)
		    432 +     .thenExecute(() => {
		    433 +       assertPistonState(false, false, false, true, false); // isRetracted
		    434 +     })
		    435 +     .thenSucceed();
		    436 + }).tag(GameTest.Tags.suiteDefault);
		382     -     test.assert(eventData.effect.displayName === "Poison II", "Unexpected display name");
		383     -     test.assert(eventData.effectState === 1, "Unexpected effect state");
		384     -     test.succeed();
		385     -   });
		386     - 
		387     -   villager.addEffect(MinecraftEffectTypes.poison, 5, 1);
		388     -   World.events.effectAdd.unsubscribe(effectAddCallback);
		389     - })
		390     -   .structureName("ComponentTests:animal_pen")
		391     -   .tag(GameTest.Tags.suiteDefault);
		392 437   
		    438 + GameTest.register("APITests", "piston_event", (test) => {
		    439 +   let expanded = false;
		    440 +   let retracted = false;
		393     - GameTest.register("APITests", "piston", (test) => {
		    441 +   const redstoneLoc = new BlockLocation(1, 2, 0);
		394     -   const overworld = World.getDimension("overworld");
		395 442     const pistonLoc = new BlockLocation(1, 2, 1);
		396     -   const redstoneLoc = new BlockLocation(1, 2, 0);
		397     -   const pistonComp = overworld.getBlock(test.worldBlockLocation(pistonLoc)).getComponent("piston");
		398     - 
		    443 +   const planksLoc = new BlockLocation(2, 2, 1);
		399     -   test.assert(pistonComp != undefined, "Expected piston component");
		400 444   
		    445 +   const pistonCallback = World.events.pistonActivate.subscribe((pistonEvent) => {
		    446 +     test.assert(pistonEvent.piston !== undefined, "Expected piston");
		    447 +     if (pistonEvent.piston.location.equals(test.worldBlockLocation(pistonLoc))) {
		    448 +       if (pistonEvent.isExpanding) {
		    449 +         expanded = true;
		    450 +       } else {
		    451 +         retracted = true;
		    452 +       }
		    453 +     }
		    454 +   });
		401     -   let assertPistonState = (isMoving, isExpanded, isExpanding, isRetracted, isRetracting) => {
		402     -     test.assert(pistonComp.isMoving === isMoving, "Unexpected isMoving");
		403     -     test.assert(pistonComp.isExpanded === isExpanded, "Unexpected isExpanded");
		404     -     test.assert(pistonComp.isExpanding === isExpanding, "Unexpected isExpanding");
		405     -     test.assert(pistonComp.isRetracted === isRetracted, "Unexpected isRetracted");
		406     -     test.assert(pistonComp.isRetracting === isRetracting, "Unexpected isRetracting");
		407     -   };
		408 455   
		409 456     test
		410 457       .startSequence()
		411 458       .thenExecute(() => {
		    459 +       test.pulseRedstone(redstoneLoc, 2);
		412     -       test.assert(pistonComp.attachedBlocks.length === 0, "Expected 0 attached blocks");
		413     -       assertPistonState(false, false, false, true, false); // isRetracted
		414     -       test.setBlockType(MinecraftBlockTypes.redstoneBlock, redstoneLoc);
		415 460       })
		    461 +     .thenExecuteAfter(8, () => {
		    462 +       test.assertBlockPresent(MinecraftBlockTypes.air, planksLoc, true);
		416     -     .thenIdle(4)
		    463 +       test.assert(expanded, "Expected piston expanding event");
		    464 +       test.assert(retracted, "Expected piston retracting event");
		    465 +       World.events.beforePistonActivate.unsubscribe(pistonCallback);
		417     -     .thenExecute(() => {
		418     -       test.assert(pistonComp.attachedBlocks.length === 3, "Expected 3 attached blocks");
		419     -       assertPistonState(true, false, true, false, false); // isMoving, isExpanding
		420 466       })
		    467 +     .thenSucceed();
		    468 + })
		421     -     .thenIdle(2)
		    469 +   .structureName("APITests:piston")
		    470 +   .tag(GameTest.Tags.suiteDefault);
		422     -     .thenExecute(() => {
		423     -       assertPistonState(false, true, false, false, false); // isExpanded
		424 471   
		    472 + GameTest.register("APITests", "piston_event_canceled", (test) => {
		    473 +   let canceled = false;
		425     -       test.setBlockType(MinecraftBlockTypes.air, redstoneLoc);
		    474 +   const redstoneLoc = new BlockLocation(1, 2, 0);
		    475 +   const pistonLoc = new BlockLocation(1, 2, 1);
		    476 +   const planksLoc = new BlockLocation(2, 2, 1);
		    477 + 
		    478 +   const pistonCallback = World.events.beforePistonActivate.subscribe((pistonEvent) => {
		    479 +     test.assert(pistonEvent.piston !== undefined, "Expected piston");
		    480 +     if (pistonEvent.piston.location.equals(test.worldBlockLocation(pistonLoc))) {
		    481 +       pistonEvent.cancel = true;
		    482 +       canceled = true;
		    483 +     }
		    484 +   });
		426     -     })
		427     -     .thenIdle(4)
		428     -     .thenExecute(() => {
		429     -       assertPistonState(true, false, false, false, true); // isMoving, isRetracting
		430     -     })
		431     -     .thenIdle(2)
		432     -     .thenExecute(() => {
		433     -       assertPistonState(false, false, false, true, false); // isRetracted
		434     -     })
		435     -     .thenSucceed();
		436     - }).tag(GameTest.Tags.suiteDefault);
		437 485   
		    486 +   test
		    487 +     .startSequence()
		    488 +     .thenExecute(() => {
		438     - GameTest.register("APITests", "piston_event", (test) => {
		    489 +       test.pulseRedstone(redstoneLoc, 2);
		    490 +     })
		    491 +     .thenExecuteAfter(8, () => {
		    492 +       test.assert(canceled, "Expected canceled beforePistonActivate event");
		    493 +       test.assertBlockPresent(MinecraftBlockTypes.planks, planksLoc, true);
		    494 +       World.events.beforePistonActivate.unsubscribe(pistonCallback);
		    495 +     })
		    496 +     .thenSucceed();
		    497 + })
		    498 +   .structureName("APITests:piston")
		    499 +   .tag(GameTest.Tags.suiteDefault);
		    500 + 
		    501 + GameTest.register("APITests", "sneaking", (test) => {
		    502 +   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		    503 +   const pigLoc = new BlockLocation(1, 2, 1);
		    504 +   const pig = test.spawn(pigId, pigLoc);
		    505 +   pig.isSneaking = true;
		439     -   let expanded = false;
		440     -   let retracted = false;
		441     -   const redstoneLoc = new BlockLocation(1, 2, 0);
		442     -   const pistonLoc = new BlockLocation(1, 2, 1);
		443     -   const planksLoc = new BlockLocation(2, 2, 1);
		444     - 
		445     -   const pistonCallback = World.events.pistonActivate.subscribe((pistonEvent) => {
		446     -     test.assert(pistonEvent.piston !== undefined, "Expected piston");
		447     -     if (pistonEvent.piston.location.equals(test.worldBlockLocation(pistonLoc))) {
		448     -       if (pistonEvent.isExpanding) {
		449     -         expanded = true;
		450     -       } else {
		451     -         retracted = true;
		452     -       }
		453     -     }
		454     -   });
		455     - 
		456 506     test
		457 507       .startSequence()
		    508 +     .thenExecuteAfter(120, () => {
		    509 +       test.assertEntityPresent(pigId, pigLoc, true);
		458     -     .thenExecute(() => {
		459     -       test.pulseRedstone(redstoneLoc, 2);
		460 510       })
		    511 +     .thenSucceed();
		461     -     .thenExecuteAfter(8, () => {
		462     -       test.assertBlockPresent(MinecraftBlockTypes.air, planksLoc, true);
		    512 + })
		    513 +   .maxTicks(130)
		    514 +   .tag(GameTest.Tags.suiteDefault);
		    515 + 
		    516 + GameTest.register("APITests", "assert_can_reach_location", (test) => {
		    517 +   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		    518 +   const villager1 = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		    519 +   const villager2 = test.spawn(villagerId, new BlockLocation(1, 2, 3));
		    520 +   const villager3 = test.spawn(villagerId, new BlockLocation(1, 2, 5));
		    521 +   test.assertCanReachLocation(villager1, new BlockLocation(4, 2, 1), true);
		    522 +   test.assertCanReachLocation(villager2, new BlockLocation(4, 2, 3), false);
		    523 +   test.assertCanReachLocation(villager3, new BlockLocation(4, 2, 5), false);
		    524 +   test.succeed();
		    525 + }).tag(GameTest.Tags.suiteDefault);
		463     -       test.assert(expanded, "Expected piston expanding event");
		464     -       test.assert(retracted, "Expected piston retracting event");
		465     -       World.events.beforePistonActivate.unsubscribe(pistonCallback);
		466     -     })
		467     -     .thenSucceed();
		468     - })
		469     -   .structureName("APITests:piston")
		470     -   .tag(GameTest.Tags.suiteDefault);
		471     - 
		472     - GameTest.register("APITests", "piston_event_canceled", (test) => {
		473     -   let canceled = false;
		474     -   const redstoneLoc = new BlockLocation(1, 2, 0);
		475     -   const pistonLoc = new BlockLocation(1, 2, 1);
		476     -   const planksLoc = new BlockLocation(2, 2, 1);
		477 526   
		    527 + const isLocationInTest = (test, worldLoc) => {
		478     -   const pistonCallback = World.events.beforePistonActivate.subscribe((pistonEvent) => {
		479     -     test.assert(pistonEvent.piston !== undefined, "Expected piston");
		480     -     if (pistonEvent.piston.location.equals(test.worldBlockLocation(pistonLoc))) {
		    528 +   const size = 4;
		    529 +   let loc = test.relativeBlockLocation(worldLoc);
		    530 +   return loc.x >= 0 && loc.y >= 0 && loc.z >= 0 && loc.x < size && loc.y < size && loc.z < size;
		    531 + };
		481     -       pistonEvent.cancel = true;
		482     -       canceled = true;
		483     -     }
		484     -   });
		485 532   
		    533 + GameTest.register("APITests", "explosion_event", (test) => {
		486     -   test
		487     -     .startSequence()
		    534 +   let exploded = false;
		    535 +   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		    536 +   const polishedAndesiteLoc = new BlockLocation(1, 1, 1);
		    537 + 
		    538 +   const beforeExplosionCallback = World.events.beforeExplosion.subscribe((explosionEvent) => {
		    539 +     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		    540 +     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		    541 +     test.assert(explosionEvent.source !== undefined, "Expected source");
		    542 +     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		    543 +     test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		    544 +     explosionEvent.impactedBlocks = [test.worldBlockLocation(cobblestoneLoc)];
		    545 +   });
		488     -     .thenExecute(() => {
		489     -       test.pulseRedstone(redstoneLoc, 2);
		490     -     })
		491     -     .thenExecuteAfter(8, () => {
		492     -       test.assert(canceled, "Expected canceled beforePistonActivate event");
		493     -       test.assertBlockPresent(MinecraftBlockTypes.planks, planksLoc, true);
		494     -       World.events.beforePistonActivate.unsubscribe(pistonCallback);
		495     -     })
		496     -     .thenSucceed();
		497     - })
		498     -   .structureName("APITests:piston")
		499     -   .tag(GameTest.Tags.suiteDefault);
		500 546   
		    547 +   const explosionCallback = World.events.explosion.subscribe((explosionEvent) => {
		    548 +     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		    549 +     test.assert(explosionEvent.source !== undefined, "Expected source");
		501     - GameTest.register("APITests", "sneaking", (test) => {
		    550 +     test.assert(explosionEvent.impactedBlocks.length === 1, "Unexpected number of impacted blocks");
		    551 +     exploded = true;
		    552 +   });
		    553 + 
		502     -   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		503     -   const pigLoc = new BlockLocation(1, 2, 1);
		504     -   const pig = test.spawn(pigId, pigLoc);
		505     -   pig.isSneaking = true;
		506 554     test
		507 555       .startSequence()
		    556 +     .thenExecute(() => {
		    557 +       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		508     -     .thenExecuteAfter(120, () => {
		    558 +       test.spawn("tnt", new BlockLocation(1, 2, 1));
		509     -       test.assertEntityPresent(pigId, pigLoc, true);
		510 559       })
		    560 +     .thenExecuteAfter(85, () => {
		    561 +       test.assert(exploded, "Expected explosion event");
		511     -     .thenSucceed();
		    562 +       test.assertBlockPresent(MinecraftBlockTypes.stone, polishedAndesiteLoc, true);
		    563 +       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, false);
		    564 +       World.events.beforeExplosion.unsubscribe(beforeExplosionCallback);
		    565 +       World.events.explosion.unsubscribe(explosionCallback);
		    566 +     })
		    567 +     .thenSucceed();
		    568 + })
		    569 +   .padding(10) // The blast can destroy nearby items and mobs
		    570 +   .structureName("ComponentTests:platform")
		    571 +   .tag(GameTest.Tags.suiteDefault);
		    572 + 
		    573 + GameTest.register("APITests", "explosion_event_canceled", (test) => {
		    574 +   let canceled = false;
		    575 +   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		512     - })
		513     -   .maxTicks(130)
		514     -   .tag(GameTest.Tags.suiteDefault);
		515     - 
		516     - GameTest.register("APITests", "assert_can_reach_location", (test) => {
		517     -   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		518     -   const villager1 = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		519     -   const villager2 = test.spawn(villagerId, new BlockLocation(1, 2, 3));
		520     -   const villager3 = test.spawn(villagerId, new BlockLocation(1, 2, 5));
		521     -   test.assertCanReachLocation(villager1, new BlockLocation(4, 2, 1), true);
		522     -   test.assertCanReachLocation(villager2, new BlockLocation(4, 2, 3), false);
		523     -   test.assertCanReachLocation(villager3, new BlockLocation(4, 2, 5), false);
		524     -   test.succeed();
		525     - }).tag(GameTest.Tags.suiteDefault);
		526 576   
		    577 +   const explosionCallback = World.events.beforeExplosion.subscribe((explosionEvent) => {
		527     - const isLocationInTest = (test, worldLoc) => {
		528     -   const size = 4;
		    578 +     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		    579 +     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		    580 +     test.assert(explosionEvent.source !== undefined, "Expected source");
		529     -   let loc = test.relativeBlockLocation(worldLoc);
		530     -   return loc.x >= 0 && loc.y >= 0 && loc.z >= 0 && loc.x < size && loc.y < size && loc.z < size;
		531     - };
		532     - 
		    581 +     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		    582 +     explosionEvent.cancel = true;
		    583 +     canceled = true;
		    584 +   });
		533     - GameTest.register("APITests", "explosion_event", (test) => {
		534     -   let exploded = false;
		535     -   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		536     -   const polishedAndesiteLoc = new BlockLocation(1, 1, 1);
		537 585   
		    586 +   test
		    587 +     .startSequence()
		538     -   const beforeExplosionCallback = World.events.beforeExplosion.subscribe((explosionEvent) => {
		    588 +     .thenExecute(() => {
		    589 +       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		    590 +       test.spawn("tnt", new BlockLocation(1, 2, 1));
		    591 +     })
		    592 +     .thenExecuteAfter(85, () => {
		    593 +       test.assert(canceled, "Expected canceled beforeExplosionEvent event");
		    594 +       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		    595 +       World.events.beforeExplosion.unsubscribe(explosionCallback);
		    596 +     })
		    597 +     .thenSucceed();
		    598 + })
		    599 +   .padding(10) // The blast can destroy nearby items and mobs
		    600 +   .structureName("ComponentTests:platform")
		    601 +   .tag(GameTest.Tags.suiteDefault);
		539     -     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		540     -     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		541     -     test.assert(explosionEvent.source !== undefined, "Expected source");
		542     -     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		543     -     test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		544     -     explosionEvent.impactedBlocks = [test.worldBlockLocation(cobblestoneLoc)];
		545     -   });
		546     - 
		547     -   const explosionCallback = World.events.explosion.subscribe((explosionEvent) => {
		548     -     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		549     -     test.assert(explosionEvent.source !== undefined, "Expected source");
		550     -     test.assert(explosionEvent.impactedBlocks.length === 1, "Unexpected number of impacted blocks");
		551     -     exploded = true;
		552     -   });
		553 602   
		554     -   test
		555     -     .startSequence()
		556     -     .thenExecute(() => {
		    603 + GameTest.register("APITests", "explode_block_event", (test) => {
		    604 +   let explodedCount = 0;
		    605 +   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		    606 + 
		    607 +   const blockExplodeCallback = World.events.blockExplode.subscribe((blockExplodeEvent) => {
		    608 +     if (!isLocationInTest(test, blockExplodeEvent.destroyedBlock.location)) return;
		    609 +     test.assert(blockExplodeEvent.source !== undefined, "Expected source");
		    610 +     explodedCount++;
		    611 +   });
		    612 + 
		    613 +   test
		    614 +     .startSequence()
		    615 +     .thenExecute(() => {
		    616 +       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		    617 +       test.spawn("tnt", new BlockLocation(1, 2, 1));
		    618 +     })
		    619 +     .thenExecuteAfter(85, () => {
		    620 +       test.assert(explodedCount === 10, "Unexpected number of exploded blocks");
		    621 +       World.events.blockExplode.unsubscribe(blockExplodeCallback);
		    622 +     })
		    623 +     .thenSucceed();
		    624 + })
		    625 +   .padding(10) // The blast can destroy nearby items and mobs
		    626 +   .structureName("ComponentTests:platform")
		    627 +   .tag(GameTest.Tags.suiteDefault);
		    628 + 
		    629 + GameTest.register("APITests", "connectivity", (test) => {
		    630 +   const centerLoc = new BlockLocation(1, 2, 1);
		557     -       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		558     -       test.spawn("tnt", new BlockLocation(1, 2, 1));
		559     -     })
		560     -     .thenExecuteAfter(60, () => {
		561     -       test.assert(exploded, "Expected explosion event");
		562     -       test.assertBlockPresent(MinecraftBlockTypes.stone, polishedAndesiteLoc, true);
		563     -       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, false);
		564     -       World.events.beforeExplosion.unsubscribe(beforeExplosionCallback);
		565     -       World.events.explosion.unsubscribe(explosionCallback);
		566     -     })
		567     -     .thenSucceed();
		568     - })
		569     -   .padding(10) // The blast can destroy nearby items and mobs
		570     -   .structureName("ComponentTests:platform")
		571     -   .tag(GameTest.Tags.suiteDefault);
		572     - 
		573     - GameTest.register("APITests", "explosion_event_canceled", (test) => {
		574     -   let canceled = false;
		575     -   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		576     - 
		577     -   const explosionCallback = World.events.beforeExplosion.subscribe((explosionEvent) => {
		578     -     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		579     -     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		580     -     test.assert(explosionEvent.source !== undefined, "Expected source");
		581     -     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		582     -     explosionEvent.cancel = true;
		583     -     canceled = true;
		584     -   });
		585 631   
		586     -   test
		587     -     .startSequence()
		588     -     .thenExecute(() => {
		589     -       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		    632 +   let connectivity = test.getFenceConnectivity(centerLoc);
		    633 + 
		    634 +   test.assert(!connectivity.north, "The stair is not oriented the right way to connect");
		    635 +   test.assert(connectivity.east, "Should connect to another fence");
		    636 +   test.assert(connectivity.south, "Should connect to another fence");
		    637 +   test.assert(connectivity.west, "Should connect to the back of the stairs");
		    638 + 
		    639 +   test.succeed();
		590     -       test.spawn("tnt", new BlockLocation(1, 2, 1));
		591     -     })
		592     -     .thenExecuteAfter(60, () => {
		593     -       test.assert(canceled, "Expected canceled beforeExplosionEvent event");
		594     -       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		595     -       World.events.beforeExplosion.unsubscribe(explosionCallback);
		596     -     })
		597     -     .thenSucceed();
		598 640   })
		    641 +   .rotateTest(true)
		599     -   .padding(10) // The blast can destroy nearby items and mobs
		600     -   .structureName("ComponentTests:platform")
		601 642     .tag(GameTest.Tags.suiteDefault);
		602     - 
		603     - GameTest.register("APITests", "explode_block_event", (test) => {
		604     -   let explodedCount = 0;
		605     -   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		606 643   
		    644 + GameTest.register("APITests", "spawn_at_location", (test) => {
		607     -   const blockExplodeCallback = World.events.blockExplode.subscribe((blockExplodeEvent) => {
		608     -     if (!isLocationInTest(test, blockExplodeEvent.destroyedBlock.getLocation())) return;
		609     -     test.assert(blockExplodeEvent.source !== undefined, "Expected source");
		    645 +   const spawnLoc = new Location(1.3, 2, 1.3);
		    646 +   const chicken = test.spawnAtLocation("chicken", spawnLoc);
		610     -     explodedCount++;
		611     -   });
		612 647   
		613 648     test
		614 649       .startSequence()
		615 650       .thenExecute(() => {
		616     -       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		617     -       test.spawn("tnt", new BlockLocation(1, 2, 1));
		618     -     })
		    651 +       const chickenLoc = chicken.location;
		    652 +       const relativeChickenLoc = test.relativeLocation(chickenLoc);
		    653 +       test.assert(relativeChickenLoc.isNear(spawnLoc, 0.01), "Unexpected spawn location");
		619     -     .thenExecuteAfter(60, () => {
		620     -       test.assert(explodedCount === 10, "Unexpected number of exploded blocks");
		621     -       World.events.blockExplode.unsubscribe(blockExplodeCallback);
		622 654       })
		623 655       .thenSucceed();
		624 656   })
		    657 +   .structureName("ComponentTests:animal_pen")
		    658 +   .rotateTest(true)
		625     -   .padding(10) // The blast can destroy nearby items and mobs
		626     -   .structureName("ComponentTests:platform")
		627 659     .tag(GameTest.Tags.suiteDefault);
		628 660   
		    661 + GameTest.register("APITests", "walk_to_location", (test) => {
		    662 +   const spawnLoc = new BlockLocation(1, 2, 1);
		629     - GameTest.register("APITests", "connectivity", (test) => {
		    663 +   const chicken = test.spawnWithoutBehaviors("chicken", spawnLoc);
		630     -   const centerLoc = new BlockLocation(1, 2, 1);
		631 664   
		    665 +   const targetLoc = new Location(2.2, 2, 3.2);
		    666 +   test.walkToLocation(chicken, targetLoc, 1);
		632     -   let connectivity = test.getFenceConnectivity(centerLoc);
		633 667   
		    668 +   test.succeedWhen(() => {
		    669 +     const chickenLoc = chicken.location;
		634     -   test.assert(!connectivity.north, "The stair is not oriented the right way to connect");
		635     -   test.assert(connectivity.east, "Should connect to another fence");
		    670 +     const relativeChickenLoc = test.relativeLocation(chickenLoc);
		    671 +     // Mobs will stop navigating as soon as they intersect the target location
		    672 +     test.assert(relativeChickenLoc.isNear(targetLoc, 0.65), "Chicken did not reach the target location");
		    673 +   });
		636     -   test.assert(connectivity.south, "Should connect to another fence");
		637     -   test.assert(connectivity.west, "Should connect to the back of the stairs");
		638     - 
		639     -   test.succeed();
		640 674   })
		    675 +   .structureName("ComponentTests:large_animal_pen")
		641     -   .rotateTest(true)
		642 676     .tag(GameTest.Tags.suiteDefault);
		643 677   
		    678 + GameTest.register("APITests", "spread_from_face_toward_direction", (test) => {
		    679 +   let multifaceLoc = new BlockLocation(1, 4, 0);
		644     - GameTest.register("APITests", "spawn_at_location", (test) => {
		645     -   const spawnLoc = new Location(1.3, 2, 1.3);
		    680 +   let spreadLoc = new BlockLocation(1, 3, 0);
		646     -   const chicken = test.spawnAtLocation("chicken", spawnLoc);
		647 681   
		    682 +   const glowLichenPermutation = MinecraftBlockTypes.glowLichen.createDefaultBlockPermutation();
		648     -   test
		649     -     .startSequence()
		    683 +   glowLichenPermutation.getProperty(BlockProperties.multiFaceDirectionBits).value = 1 << test.getTestDirection();
		    684 +   test.setBlockPermutation(glowLichenPermutation, multifaceLoc);
		    685 + 
		    686 +   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, multifaceLoc, true);
		    687 +   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, false);
		    688 + 
		    689 +   test.spreadFromFaceTowardDirection(multifaceLoc, test.getTestDirection(), Direction.down);
		    690 +   test
		    691 +     .startSequence()
		    692 +     .thenExecuteAfter(1, () => {
		650     -     .thenExecute(() => {
		651     -       const chickenLoc = chicken.location;
		652     -       const relativeChickenLoc = test.relativeLocation(chickenLoc);
		653     -       test.assert(relativeChickenLoc.isNear(spawnLoc, 0.01), "Unexpected spawn location");
		654     -     })
		655     -     .thenSucceed();
		656     - })
		657     -   .structureName("ComponentTests:animal_pen")
		658     -   .rotateTest(true)
		659     -   .tag(GameTest.Tags.suiteDefault);
		660     - 
		    693 +       test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, true);
		    694 +     })
		    695 +     .thenSucceed();
		    696 + })
		    697 +   .rotateTest(true)
		    698 +   .tag(GameTest.Tags.suiteDefault);
		661     - GameTest.register("APITests", "walk_to_location", (test) => {
		662     -   const spawnLoc = new BlockLocation(1, 2, 1);
		663     -   const chicken = test.spawnWithoutBehaviors("chicken", spawnLoc);
		664     - 
		665     -   const targetLoc = new Location(2.2, 2, 3.2);
		666     -   test.walkToLocation(chicken, targetLoc, 1);
		667 699   
		668     -   test.succeedWhen(() => {
		669     -     const chickenLoc = chicken.location;
		670     -     const relativeChickenLoc = test.relativeLocation(chickenLoc);
		671     -     // Mobs will stop navigating as soon as they intersect the target location
		    700 + GameTest.register("APITests", "rotate_direction", (test) => {
		    701 +   test.assert(
		    702 +     test.rotateDirection(Direction.south) == test.getTestDirection(),
		    703 +     "Expected rotated south direction to match test direction"
		    704 +   );
		672     -     test.assert(relativeChickenLoc.isNear(targetLoc, 0.65), "Chicken did not reach the target location");
		673     -   });
		674     - })
		675     -   .structureName("ComponentTests:large_animal_pen")
		676     -   .tag(GameTest.Tags.suiteDefault);
		677 705   
		    706 +   switch (test.getTestDirection()) {
		    707 +     case Direction.north:
		    708 +       test.assert(
		678     - GameTest.register("APITests", "spread_from_face_toward_direction", (test) => {
		    709 +         test.rotateDirection(Direction.north) === Direction.south,
		    710 +         "Unexpected rotated direction for Direction.north with testDirection Direction.north"
		    711 +       );
		    712 +       test.assert(
		    713 +         test.rotateDirection(Direction.east) === Direction.west,
		    714 +         "Unexpected rotated direction for Direction.east with testDirection Direction.north"
		    715 +       );
		    716 +       test.assert(
		    717 +         test.rotateDirection(Direction.south) === Direction.north,
		    718 +         "Unexpected rotated direction for Direction.south with testDirection Direction.north"
		    719 +       );
		    720 +       test.assert(
		    721 +         test.rotateDirection(Direction.west) === Direction.east,
		    722 +         "Unexpected rotated direction for Direction.west with testDirection Direction.north"
		    723 +       );
		    724 +       break;
		    725 +     case Direction.east:
		    726 +       test.assert(
		    727 +         test.rotateDirection(Direction.north) === Direction.west,
		    728 +         "Unexpected rotated direction for Direction.north with testDirection Direction.east"
		    729 +       );
		    730 +       test.assert(
		    731 +         test.rotateDirection(Direction.east) === Direction.north,
		    732 +         "Unexpected rotated direction for Direction.east with testDirection Direction.east"
		    733 +       );
		    734 +       test.assert(
		    735 +         test.rotateDirection(Direction.south) === Direction.east,
		    736 +         "Unexpected rotated direction for Direction.south with testDirection Direction.east"
		    737 +       );
		679     -   let multifaceLoc = new BlockLocation(1, 4, 0);
		680     -   let spreadLoc = new BlockLocation(1, 3, 0);
		681     - 
		682     -   const glowLichenPermutation = MinecraftBlockTypes.glowLichen.createDefaultBlockPermutation();
		683     -   glowLichenPermutation.getProperty(BlockProperties.multiFaceDirectionBits).value = 1 << test.getTestDirection();
		684     -   test.setBlockPermutation(glowLichenPermutation, multifaceLoc);
		685     - 
		686     -   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, multifaceLoc, true);
		687     -   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, false);
		688     - 
		689     -   test.spreadFromFaceTowardDirection(multifaceLoc, test.getTestDirection(), Direction.down);
		690     -   test
		691     -     .startSequence()
		692     -     .thenExecuteAfter(1, () => {
		693     -       test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, true);
		694     -     })
		695     -     .thenSucceed();
		696     - })
		697     -   .rotateTest(true)
		698     -   .tag(GameTest.Tags.suiteDefault);
		699     - 
		700     - GameTest.register("APITests", "rotate_direction", (test) => {
		701     -   test.assert(
		702     -     test.rotateDirection(Direction.south) == test.getTestDirection(),
		703     -     "Expected rotated south direction to match test direction"
		704     -   );
		705     - 
		706     -   switch (test.getTestDirection()) {
		707     -     case Direction.north:
		708 738         test.assert(
		    739 +         test.rotateDirection(Direction.west) === Direction.south,
		    740 +         "Unexpected rotated direction for Direction.west with testDirection Direction.east"
		709     -         test.rotateDirection(Direction.north) === Direction.south,
		710     -         "Unexpected rotated direction for Direction.north with testDirection Direction.north"
		711 741         );
		    742 +       break;
		    743 +     case Direction.south:
		712 744         test.assert(
		    745 +         test.rotateDirection(Direction.north) === Direction.north,
		    746 +         "Unexpected rotated direction for Direction.north with testDirection Direction.south"
		713     -         test.rotateDirection(Direction.east) === Direction.west,
		714     -         "Unexpected rotated direction for Direction.east with testDirection Direction.north"
		715 747         );
		716 748         test.assert(
		    749 +         test.rotateDirection(Direction.east) === Direction.east,
		    750 +         "Unexpected rotated direction for Direction.east with testDirection Direction.south"
		717     -         test.rotateDirection(Direction.south) === Direction.north,
		718     -         "Unexpected rotated direction for Direction.south with testDirection Direction.north"
		719 751         );
		720 752         test.assert(
		    753 +         test.rotateDirection(Direction.south) === Direction.south,
		    754 +         "Unexpected rotated direction for Direction.south with testDirection Direction.south"
		721     -         test.rotateDirection(Direction.west) === Direction.east,
		722     -         "Unexpected rotated direction for Direction.west with testDirection Direction.north"
		723 755         );
		724     -       break;
		725     -     case Direction.east:
		726 756         test.assert(
		    757 +         test.rotateDirection(Direction.west) === Direction.west,
		    758 +         "Unexpected rotated direction for Direction.west with testDirection Direction.south"
		727     -         test.rotateDirection(Direction.north) === Direction.west,
		728     -         "Unexpected rotated direction for Direction.north with testDirection Direction.east"
		729 759         );
		    760 +       break;
		    761 +     case Direction.west:
		730 762         test.assert(
		    763 +         test.rotateDirection(Direction.north) === Direction.east,
		    764 +         "Unexpected rotated direction for Direction.north with testDirection Direction.west"
		731     -         test.rotateDirection(Direction.east) === Direction.north,
		732     -         "Unexpected rotated direction for Direction.east with testDirection Direction.east"
		733 765         );
		734 766         test.assert(
		    767 +         test.rotateDirection(Direction.east) === Direction.south,
		    768 +         "Unexpected rotated direction for Direction.east with testDirection Direction.west"
		735     -         test.rotateDirection(Direction.south) === Direction.east,
		736     -         "Unexpected rotated direction for Direction.south with testDirection Direction.east"
		737 769         );
		738 770         test.assert(
		    771 +         test.rotateDirection(Direction.south) === Direction.west,
		    772 +         "Unexpected rotated direction for Direction.south with testDirection Direction.west"
		739     -         test.rotateDirection(Direction.west) === Direction.south,
		740     -         "Unexpected rotated direction for Direction.west with testDirection Direction.east"
		741 773         );
		742     -       break;
		743     -     case Direction.south:
		744 774         test.assert(
		    775 +         test.rotateDirection(Direction.west) === Direction.north,
		    776 +         "Unexpected rotated direction for Direction.west with testDirection Direction.west"
		745     -         test.rotateDirection(Direction.north) === Direction.north,
		746     -         "Unexpected rotated direction for Direction.north with testDirection Direction.south"
		747 777         );
		    778 +       break;
		    779 +     default:
		    780 +       test.assert(false, "Invalid test direction");
		    781 +   }
		    782 + 
		    783 +   const buttonLoc = new BlockLocation(1, 2, 1);
		    784 +   const buttonPermutation = MinecraftBlockTypes.stoneButton.createDefaultBlockPermutation();
		    785 +   buttonPermutation.getProperty(BlockProperties.facingDirection).value = test.rotateDirection(Direction.north);
		    786 +   test.setBlockPermutation(buttonPermutation, buttonLoc);
		    787 + 
		    788 +   test
		    789 +     .startSequence()
		    790 +     .thenExecuteAfter(2, () => {
		    791 +       test.assertBlockPresent(MinecraftBlockTypes.stoneButton, buttonLoc, true);
		    792 +     })
		    793 +     .thenSucceed();
		    794 + })
		    795 +   .rotateTest(true)
		    796 +   .tag(GameTest.Tags.suiteDefault);
		    797 + 
		    798 + function isNear(a, b) {
		    799 +   return Math.abs(a - b) < 0.001;
		    800 + }
		    801 + 
		    802 + GameTest.register("APITests", "cauldron", (test) => {
		    803 +   const loc = new BlockLocation(0, 1, 0);
		    804 +   var block = test.getBlock(loc);
		    805 + 
		    806 +   test.setFluidContainer(loc, GameTest.FluidType.water);
		    807 +   test.assert(block.getComponent("waterContainer") != null, "This is a water container");
		    808 +   test.assert(
		    809 +     block.getComponent("lavaContainer") == null,
		    810 +     "A water container should not have a lavaContainer component"
		    811 +   );
		    812 +   test.assert(
		    813 +     block.getComponent("snowContainer") == null,
		    814 +     "A water container should not have a snowContainer component"
		    815 +   );
		    816 +   test.assert(
		    817 +     block.getComponent("potionContainer") == null,
		    818 +     "A water container should not have a potionContainer component"
		    819 +   );
		748     -       test.assert(
		749     -         test.rotateDirection(Direction.east) === Direction.east,
		750     -         "Unexpected rotated direction for Direction.east with testDirection Direction.south"
		751     -       );
		752     -       test.assert(
		753     -         test.rotateDirection(Direction.south) === Direction.south,
		754     -         "Unexpected rotated direction for Direction.south with testDirection Direction.south"
		755     -       );
		756     -       test.assert(
		757     -         test.rotateDirection(Direction.west) === Direction.west,
		758     -         "Unexpected rotated direction for Direction.west with testDirection Direction.south"
		759     -       );
		760     -       break;
		761     -     case Direction.west:
		762     -       test.assert(
		763     -         test.rotateDirection(Direction.north) === Direction.east,
		764     -         "Unexpected rotated direction for Direction.north with testDirection Direction.west"
		765     -       );
		766     -       test.assert(
		767     -         test.rotateDirection(Direction.east) === Direction.south,
		768     -         "Unexpected rotated direction for Direction.east with testDirection Direction.west"
		769     -       );
		770     -       test.assert(
		771     -         test.rotateDirection(Direction.south) === Direction.west,
		772     -         "Unexpected rotated direction for Direction.south with testDirection Direction.west"
		773     -       );
		774     -       test.assert(
		775     -         test.rotateDirection(Direction.west) === Direction.north,
		776     -         "Unexpected rotated direction for Direction.west with testDirection Direction.west"
		777     -       );
		778     -       break;
		779     -     default:
		780     -       test.assert(false, "Invalid test direction");
		781     -   }
		782     - 
		783     -   const buttonLoc = new BlockLocation(1, 2, 1);
		784     -   const buttonPermutation = MinecraftBlockTypes.stoneButton.createDefaultBlockPermutation();
		785     -   buttonPermutation.getProperty(BlockProperties.facingDirection).value = test.rotateDirection(Direction.north);
		786     -   test.setBlockPermutation(buttonPermutation, buttonLoc);
		787 820   
		    821 +   block.getComponent("waterContainer").fillLevel = FluidContainer.maxFillLevel;
		    822 +   test.assert(
		788     -   test
		    823 +     block.getComponent("waterContainer").fillLevel == FluidContainer.maxFillLevel,
		    824 +     "The fill level should match with what it was set to"
		    825 +   );
		    826 + 
		    827 +   block.getComponent("waterContainer").customColor = new Color(1, 0, 0, 1);
		    828 +   test.assert(block.getComponent("waterContainer").customColor.red == 1, "red component should be set");
		    829 +   test.assert(block.getComponent("waterContainer").customColor.green == 0, "green component should be set");
		    830 +   test.assert(block.getComponent("waterContainer").customColor.blue == 0, "blue component should be set");
		789     -     .startSequence()
		790     -     .thenExecuteAfter(2, () => {
		791     -       test.assertBlockPresent(MinecraftBlockTypes.stoneButton, buttonLoc, true);
		792     -     })
		793     -     .thenSucceed();
		794     - })
		795     -   .rotateTest(true)
		796     -   .tag(GameTest.Tags.suiteDefault);
		797 831   
		    832 +   block.getComponent("waterContainer").addDye(MinecraftItemTypes.blueDye);
		    833 +   test.assert(isNear(block.getComponent("waterContainer").customColor.red, 0.616), "red component should be set");
		798     - function isNear(a, b) {
		    834 +   test.assert(isNear(block.getComponent("waterContainer").customColor.green, 0.133), "green component should be set");
		    835 +   test.assert(isNear(block.getComponent("waterContainer").customColor.blue, 0.333), "blue component should be set");
		799     -     return Math.abs(a - b) < 0.001;
		800     - }
		801 836   
		    837 +   test.setFluidContainer(loc, GameTest.FluidType.lava);
		    838 +   test.assert(
		    839 +     block.getComponent("waterContainer") == null,
		802     - GameTest.register("APITests", "cauldron", (test) => {
		    840 +     "A lava container should not have a waterContainer component"
		    841 +   );
		    842 +   test.assert(block.getComponent("lavaContainer") != null, "This is a lava component");
		    843 +   test.assert(
		    844 +     block.getComponent("snowContainer") == null,
		    845 +     "A lava container should not have a snowContainer component"
		    846 +   );
		    847 +   test.assert(
		    848 +     block.getComponent("potionContainer") == null,
		    849 +     "A lava container should not have a potionContainer component"
		    850 +   );
		803     -     const loc = new BlockLocation(0, 1, 0);
		804     -     var block = test.getBlock(loc);
		805     - 
		806     -     test.setFluidContainer(loc, GameTest.FluidType.water);
		807     -     test.assert(block.getComponent("waterContainer") != null, "This is a water container");
		808     -     test.assert(block.getComponent("lavaContainer") == null, "A water container should not have a lavaContainer component");
		809     -     test.assert(block.getComponent("snowContainer") == null, "A water container should not have a snowContainer component");
		810     -     test.assert(block.getComponent("potionContainer") == null, "A water container should not have a potionContainer component");
		811     - 
		812     -     block.getComponent("waterContainer").fillLevel = FluidContainer.maxFillLevel;
		813     -     test.assert(block.getComponent("waterContainer").fillLevel == FluidContainer.maxFillLevel, "The fill level should match with what it was set to")
		814 851   
		    852 +   test.setFluidContainer(loc, GameTest.FluidType.powderSnow);
		    853 +   test.assert(
		815     -     block.getComponent("waterContainer").customColor = new Color(1, 0, 0, 1);
		816     -     test.assert(block.getComponent("waterContainer").customColor.red == 1, "red component should be set")
		    854 +     block.getComponent("waterContainer") == null,
		    855 +     "A snow container should not have a waterContainer component"
		817     -     test.assert(block.getComponent("waterContainer").customColor.green == 0, "green component should be set")
		818     -     test.assert(block.getComponent("waterContainer").customColor.blue == 0, "blue component should be set")
		819     - 
		    856 +   );
		    857 +   test.assert(
		    858 +     block.getComponent("lavaContainer") == null,
		    859 +     "A snow container should not have a lavaContainer component"
		    860 +   );
		    861 +   test.assert(block.getComponent("snowContainer") != null, "This is a snow container");
		    862 +   test.assert(
		    863 +     block.getComponent("potionContainer") == null,
		    864 +     "A snow container should not have a potionContainer component"
		    865 +   );
		820     -     block.getComponent("waterContainer").addDye(MinecraftItemTypes.blueDye);
		821     -     test.assert(isNear(block.getComponent("waterContainer").customColor.red, .616), "red component should be set")
		822     -     test.assert(isNear(block.getComponent("waterContainer").customColor.green, .133), "green component should be set")
		823     -     test.assert(isNear(block.getComponent("waterContainer").customColor.blue, .333), "blue component should be set")
		824     - 
		825     -     test.setFluidContainer(loc, GameTest.FluidType.lava);
		826     -     test.assert(block.getComponent("waterContainer") == null, "A lava container should not have a waterContainer component");
		827     -     test.assert(block.getComponent("lavaContainer") != null, "This is a lava component");
		828     -     test.assert(block.getComponent("snowContainer") == null, "A lava container should not have a snowContainer component");
		829     -     test.assert(block.getComponent("potionContainer") == null, "A lava container should not have a potionContainer component");
		830 866   
		    867 +   test.setFluidContainer(loc, GameTest.FluidType.potion);
		    868 +   test.assert(
		    869 +     block.getComponent("snowContainer") == null,
		    870 +     "A potion container should not have a waterContainer component"
		    871 +   );
		    872 +   test.assert(
		    873 +     block.getComponent("lavaContainer") == null,
		    874 +     "A potion container should not have a lavaContainer component"
		    875 +   );
		    876 +   test.assert(
		    877 +     block.getComponent("snowContainer") == null,
		    878 +     "A potion container should not have a snowContainer component"
		    879 +   );
		    880 +   test.assert(block.getComponent("potionContainer") != null, "This is a potion container");
		831     -     test.setFluidContainer(loc, GameTest.FluidType.powderSnow);
		832     -     test.assert(block.getComponent("waterContainer") == null, "A snow container should not have a waterContainer component");
		833     -     test.assert(block.getComponent("lavaContainer") == null, "A snow container should not have a lavaContainer component");
		834     -     test.assert(block.getComponent("snowContainer") != null, "This is a snow container");
		835     -     test.assert(block.getComponent("potionContainer") == null, "A snow container should not have a potionContainer component");
		836     - 
		837     -     test.setFluidContainer(loc, GameTest.FluidType.potion);
		838     -     test.assert(block.getComponent("snowContainer") == null, "A potion container should not have a waterContainer component");
		839     -     test.assert(block.getComponent("lavaContainer") == null, "A potion container should not have a lavaContainer component");
		840     -     test.assert(block.getComponent("snowContainer") == null, "A potion container should not have a snowContainer component");
		841     -     test.assert(block.getComponent("potionContainer") != null, "This is a potion container");
		842 881   
		    882 +   test.succeed();
		843     -     test.succeed();
		844     - })
		    883 + }).tag(GameTest.Tags.suiteDefault);
		845     -     .tag(GameTest.Tags.suiteDefault);
		846 884   
		847 885   GameTest.register("APITests", "jukebox", (test) => {
		    886 +   var jukeboxBlock = test.getBlock(new BlockLocation(0, 1, 0));
		    887 +   var musicPlayerComp = jukeboxBlock.getComponent("recordPlayer");
		848     -     var jukeboxBlock = test.getBlock(new BlockLocation(0, 1, 0));
		849     -     var musicPlayerComp = jukeboxBlock.getComponent("recordPlayer");
		850 888   
		    889 +   try {
		851     -     try {
		852     -         musicPlayerComp.setRecord(MinecraftItemTypes.apple);
		853     -         test.fail("An exception should be thrown when playing an item that is not a music disk");
		    890 +     musicPlayerComp.setRecord(MinecraftItemTypes.apple);
		    891 +     test.fail("An exception should be thrown when playing an item that is not a music disk");
		    892 +   } catch (e) {}
		854     -     }
		855     -     catch (e) {
		856     -     }
		857 893   
		    894 +   test.assert(musicPlayerComp.isPlaying() === false, "Should be stopped");
		    895 +   musicPlayerComp.setRecord(MinecraftItemTypes.musicDiscMellohi);
		858     -     test.assert(musicPlayerComp.isPlaying() === false, "Should be stopped");
		859     -     musicPlayerComp.setRecord(MinecraftItemTypes.musicDiscMellohi);
		    896 +   test.assert(musicPlayerComp.isPlaying() === true, "Should be playing");
		860     -     test.assert(musicPlayerComp.isPlaying() === true, "Should be playing");
		861 897   
		    898 +   test
		    899 +     .startSequence()
		862     -     test
		863     -         .startSequence()
		    900 +     .thenExecuteAfter(20, () => {
		    901 +       test.assert(musicPlayerComp.isPlaying() === true, "Disk should not be finished yet");
		    902 +       musicPlayerComp.clearRecord();
		    903 +       test.assert(musicPlayerComp.isPlaying() === false, "Disk should be stopped now");
		    904 +     })
		    905 +     .thenSucceed();
		864     -         .thenExecuteAfter(20, () => {
		865     -             test.assert(musicPlayerComp.isPlaying() === true, "Disk should not be finished yet");
		866     -             musicPlayerComp.clearRecord();
		867     -             test.assert(musicPlayerComp.isPlaying() === false, "Disk should be stopped now");
		868     -         })
		869     -         .thenSucceed();
		870 906   })
		    907 +   .maxTicks(25)
		871     -     .maxTicks(25)
		872     -     .tag(GameTest.Tags.suiteDefault);
		    908 +   .tag(GameTest.Tags.suiteDefault);
		873     - 
		          '''
	Changed script "BigMobTests.js":
		Total line: 90 (+6, -5)
		        '''
		        ...
		 6  6   const BIGMOB_REQUIRE = false;
		 7  7   
		 8  8   const MOBTOTEST = ["zoglin", "ravager", "iron_golem", "spider", "horse"];
		 9  9   
		10 10   function _descending(test, wallSide, entityType) {
		   11 +   const zOffset = wallSide == "RIGHT" ? -0.55 : 0.55;
		11    -   const zOffset = wallSide == "RIGHT" ? -0.25 : 0.25;
		12 12     const spawnType = "minecraft:" + entityType;
		   13 +   const mob = test.spawnWithoutBehaviorsAtLocation(spawnType, new Location(0.75, 6, 1.65 + zOffset));
		13    -   const mob = test.spawnWithoutBehaviorsAtLocation(spawnType, new Location(0.5, 6, 1.5 + zOffset));
		14 14     const targetPos = new BlockLocation(7, 2, 1);
		15 15     test.walkTo(mob, targetPos, 1);
		16 16     test.succeedWhenEntityPresent(spawnType, targetPos, true);
		17 17   }
		18 18   
		19 19   function createDescendingTest(wallSide, entityType) {
		20 20     const structureName = "BigMobTests:altitude_change_wall_on_" + wallSide.toLowerCase();
		21 21     const testName = "altitude_change_wall_on_" + wallSide.toLowerCase() + "_descend_" + entityType;
		22 22   
		   23 +   // Iron golems every so often get stucks when they are spawned
		   24 +   if (entityType == "horse" || entityType == "iron_golem") {
		23    -   if (entityType == "horse") {
		24 25       GameTest.register("BigMobTests", testName, (test) => {
		25 26         _descending(test, wallSide, entityType);
		26 27       })
		27 28         .structureName(structureName)
		28 29         .maxTicks(BIGMOB_TEST_MAX_TICKS)
		        ...
		45 46   
		46 47   function _ascending(test, wallSide, entityType) {
		47 48     const spawnType = "minecraft:" + entityType;
		48 49     const targetPos = new BlockLocation(0, 6, 1);
		49 50     const targetLocPos = new Location(0.5, 6, 1.5);
		   51 +   const zOffset = wallSide == "RIGHT" ? 0.0 : 0.20;
		   52 +   const mob = test.spawnWithoutBehaviorsAtLocation(spawnType, new Location(7.75, 2, 2.0 + zOffset));
		50    -   const zOffset = wallSide == "RIGHT" ? -0.25 : 0.25;
		51    -   const mob = test.spawnWithoutBehaviorsAtLocation(spawnType, new Location(7, 2, 1.5 + zOffset));
		52 53     test.walkToLocation(mob, targetLocPos, 1);
		53 54     test.succeedWhenEntityPresent(spawnType, targetPos, true);
		54 55   }
		55 56   
		56 57   function createAscendingTest(wallSide, entityType) {
		        ...
		        '''
	Changed script "BlockTests.js":
		Total line: 264 (+9, -10)
		          '''
		          ...
		 42  42     });
		 43  43   }
		 44  44   
		 45  45   function testThatFallingSandReplaces(test) {
		 46  46     test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		     47 +   test.succeedWhenBlockPresent(MinecraftBlockTypes.sand, new BlockLocation(1, 2, 1), true);
		 47     -   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.sand, new BlockLocation(1, 2, 1), true);
		 48  48   }
		 49  49   
		 50  50   function testThatFallingSandLandsOnTop(test) {
		 51  51     test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		     52 +   test.succeedWhenBlockPresent(MinecraftBlockTypes.sand, new BlockLocation(1, 3, 1), true);
		 52     -   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.sand, new BlockLocation(1, 3, 1), true);
		 53  53   }
		 54  54   
		 55  55   ///
		 56  56   // Concrete Tests
		 57  57   ///
		 58  58   for (let i = 0; i < BLOCKS_THAT_POP_SAND.length; i++) {
		 59  59     const topBlock = BLOCKS_THAT_POP_SAND[i][0];
		 60  60     const bottomBlock = BLOCKS_THAT_POP_SAND[i][1];
		     61 +   const testName = "blocktests.falling_sand_pops_on_" + topBlock.id;
		 61     -   const testName = "blocktests.falling_sand_pops_on_" + topBlock.getName();
		 62  62     let tag = null;
		 63  63   
		 64  64     GameTest.register("BlockTests", testName, (test) => {
		     65 +     if (topBlock.id == "minecraft:stone_button") {
		 65     -     if (topBlock.getName() == "minecraft:stone_button") {
		 66  66         const buttonPermutation = MinecraftBlockTypes.stoneButton.createDefaultBlockPermutation();
		 67  67         buttonPermutation.getProperty(BlockProperties.facingDirection).value = Direction.north;
		 68  68         test.setBlockPermutation(buttonPermutation, new BlockLocation(1, 2, 1));
		 69  69       } else {
		 70  70         test.setBlockType(topBlock, new BlockLocation(1, 2, 1));
		          ...
		 79  79       .required(true)
		 80  80       .tag(GameTest.Tags.suiteDefault);
		 81  81   }
		 82  82   
		 83  83   for (const block of BLOCKS_REPLACED_BY_SAND) {
		     84 +   const testName = "blocktests.falling_sand_replaces_" + block.id;
		 84     -   const testName = "blocktests.falling_sand_replaces_" + block.getName();
		 85  85   
		 86  86     GameTest.register("BlockTests", testName, (test) => {
		 87  87       //SetBlock will fail if set a block to what it already is. Skip to call setblock() for test falling_sand_replaces_air because it's just air block in initial structure.
		     88 +     if (block.id != "minecraft:air") {
		 88     -     if (block.getName() != "minecraft:air") {
		 89  89         test.setBlockType(block, new BlockLocation(1, 2, 1));
		 90  90       }
		 91  91       testThatFallingSandReplaces(test);
		 92  92     })
		 93  93       .batch("day")
		          ...
		 97  97       .required(true)
		 98  98       .tag(GameTest.Tags.suiteDefault);
		 99  99   }
		100 100   
		101 101   for (const block of BLOCKS_THAT_SUPPORT_SAND) {
		    102 +   const testName = "blocktests.falling_sand_lands_on_" + block.id;
		102     -   const testName = "blocktests.falling_sand_lands_on_" + block.getName();
		103 103     let tag = null;
		104 104   
		105 105     GameTest.register("BlockTests", testName, (test) => {
		106 106       test.setBlockType(block, new BlockLocation(1, 2, 1));
		107 107       testThatFallingSandLandsOnTop(test);
		          ...
		203 203   
		204 204   GameTest.register("BlockTests", "turtle_eggs_squished_by_mob", (test) => {
		205 205     const zombieEntityType = "minecraft:husk";
		206 206     const zombiePosition = new BlockLocation(1, 5, 1);
		207 207     test.spawn(zombieEntityType, zombiePosition);
		    208 +   test.succeedWhenBlockPresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1), true);
		208     -   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1), true);
		209 209   })
		210 210     .required(false)
		211 211     .maxTicks(TicksPerSecond * 20)
		212 212     .tag(GameTest.Tags.suiteDefault);
		213 213   
		          ...
		259 259   
		260 260     test.succeedWhen(() => {
		261 261       testEx.assertBlockProperty("lit", 1, new BlockLocation(0, 2, 0));
		262 262       testEx.assertBlockProperty("lit", 1, new BlockLocation(0, 2, 2));
		263 263     });
		    264 + }).tag(GameTest.Tags.suiteDefault);
		264     - })
		265     -   .tag(GameTest.Tags.suiteDefault)
		          '''
	Changed script "ComponentTests.js":
		Total line: 463 (+7, -7)
		          '''
		          ...
		390 390   })
		391 391     .structureName("ComponentTests:glass_cage")
		392 392     .tag(GameTest.Tags.suiteDefault);
		393 393   
		394 394   GameTest.register("ComponentTests", "inventory_component", (test) => {
		    395 +   const rightChestCart = test.spawn("chest_minecart", new BlockLocation(1, 3, 1));
		    396 +   const leftChestCart = test.spawn("chest_minecart", new BlockLocation(2, 3, 1));
		395     -   const rightChestCart = test.spawn("chest_minecart", new BlockLocation(1, 2, 1));
		396     -   const leftChestCart = test.spawn("chest_minecart", new BlockLocation(2, 2, 1));
		397 397   
		398 398     const rightInventoryComp = rightChestCart.getComponent("inventory");
		399 399     test.assert(rightInventoryComp !== undefined, "Expected inventory component");
		400 400   
		401 401     const leftInventoryComp = leftChestCart.getComponent("inventory");
		          ...
		412 412   
		413 413     const leftContainer = leftInventoryComp.container;
		414 414     test.assert(leftContainer !== undefined, "Expected container");
		415 415   
		416 416     rightContainer.setItem(0, new ItemStack(MinecraftItemTypes.apple, 10, 0));
		    417 +   test.assert(rightContainer.getItem(0).id === "minecraft:apple", "Expected apple in right container slot index 0");
		417     -   test.assert(rightContainer.getItem(0).id === "apple", "Expected apple in right container slot index 0");
		418 418   
		419 419     rightContainer.setItem(1, new ItemStack(MinecraftItemTypes.emerald, 10, 0));
		    420 +   test.assert(rightContainer.getItem(1).id === "minecraft:emerald", "Expected emerald in right container slot index 1");
		420     -   test.assert(rightContainer.getItem(1).id === "emerald", "Expected emerald in right container slot index 1");
		421 421   
		422 422     test.assert(rightContainer.size === 27, "Unexpected size");
		423 423     test.assert(rightContainer.emptySlotsCount === 25, "Unexpected emptySlotsCount");
		424 424   
		425 425     const itemStack = rightContainer.getItem(0);
		    426 +   test.assert(itemStack.id === "minecraft:apple", "Expected apple");
		426     -   test.assert(itemStack.id === "apple", "Expected apple");
		427 427     test.assert(itemStack.amount === 10, "Expected 10 apples");
		428 428     test.assert(itemStack.data === 0, "Expected 0 data");
		429 429   
		430 430     leftContainer.setItem(0, new ItemStack(MinecraftItemTypes.cake, 10, 0));
		431 431   
		432 432     test.assert(rightContainer.transferItem(0, 4, leftContainer), "Expected transferItem to succeed"); // transfer the apple from the right container to the left container
		433 433     test.assert(rightContainer.swapItems(1, 0, leftContainer), "Expected swapItems to succeed"); // swap the cake and emerald
		434 434   
		    435 +   test.assert(leftContainer.getItem(4).id === "minecraft:apple", "Expected apple in left container slot index 4");
		    436 +   test.assert(leftContainer.getItem(0).id === "minecraft:emerald", "Expected emerald in left container slot index 0");
		435     -   test.assert(leftContainer.getItem(4).id === "apple", "Expected apple in left container slot index 4");
		436     -   test.assert(leftContainer.getItem(0).id === "emerald", "Expected emerald in left container slot index 0");
		    437 +   test.assert(rightContainer.getItem(1).id === "minecraft:cake", "Expected cake in right container slot index 1");
		437     -   test.assert(rightContainer.getItem(1).id === "cake", "Expected cake in right container slot index 1");
		438 438   
		439 439     test.succeed();
		440 440   })
		441 441     .structureName("ComponentTests:platform")
		442 442     .tag(GameTest.Tags.suiteDefault);
		          ...
		          '''
	Changed script "DispenserTests.js":
		Total line: 246 (+9, -10)
		          '''
		  1   1   import * as GameTest from "mojang-gametest";
		  2   2   import { BlockLocation, MinecraftBlockTypes, MinecraftItemTypes, ItemStack } from "mojang-minecraft";
		  3   3   import GameTestExtensions from "./GameTestExtensions.js";
		  4   4   
		  5     - const dispenserDelay = 5; // Number of ticks to wait for the dispenser to use or dispense an item
		  6   5   const armorSlotTorso = 1;
		  7   6   const pinkCarpet = 6;
		  8   7   const tameMountComponentName = "minecraft:tamemount";
		  9   8   const threeSecondsInTicks = 60;
		 10   9   
		          ...
		 63  62     test.assertEntityHasArmor(horseId, armorSlotTorso, "", 0, entityLoc, false);
		 64  63   
		 65  64     test.pressButton(new BlockLocation(0, 2, 0));
		 66  65   
		 67  66     test.assertEntityPresent(horseId, entityLoc, true);
		     67 +   test.succeedWhen(() => {
		 68     -   test.succeedOnTickWhen(dispenserDelay, () => {
		 69  68       test.assertContainerEmpty(new BlockLocation(0, 2, 1));
		 70  69       test.assertEntityHasArmor(horseId, armorSlotTorso, "diamond_horse_armor", 0, entityLoc, true);
		 71  70     });
		 72  71   })
		 73  72     .maxTicks(threeSecondsInTicks)
		          ...
		 81  80     test.assertEntityHasComponent(pigId, "minecraft:is_saddled", entityLoc, false);
		 82  81   
		 83  82     test.pressButton(new BlockLocation(0, 2, 0));
		 84  83   
		 85  84     test.assertEntityPresent(pigId, entityLoc, true);
		     85 +   test.succeedWhen(() => {
		 86     -   test.succeedOnTickWhen(dispenserDelay, () => {
		 87  86       test.assertContainerEmpty(new BlockLocation(0, 2, 1));
		 88  87       test.assertEntityHasComponent(pigId, "minecraft:is_saddled", entityLoc, true);
		 89  88     });
		 90  89   })
		 91  90     .maxTicks(threeSecondsInTicks)
		          ...
		101 100     test.assertEntityHasComponent(horseId, "minecraft:is_saddled", entityLoc, false);
		102 101   
		103 102     test.pressButton(new BlockLocation(0, 2, 0));
		104 103   
		105 104     test.assertEntityPresent(horseId, entityLoc, true);
		    105 +   test.succeedWhen(() => {
		106     -   test.succeedOnTickWhen(dispenserDelay, () => {
		107 106       test.assertContainerEmpty(new BlockLocation(0, 2, 1));
		108 107       test.assertEntityHasComponent(horseId, "minecraft:is_saddled", entityLoc, true);
		109 108     });
		110 109   })
		111 110     .maxTicks(threeSecondsInTicks)
		          ...
		121 120     test.assertEntityHasArmor(llamaId, armorSlotTorso, "", 0, entityLoc, false);
		122 121   
		123 122     test.pressButton(new BlockLocation(0, 2, 0));
		124 123   
		125 124     test.assertEntityPresent(llamaId, entityLoc, true);
		    125 +   test.succeedWhen(() => {
		126     -   test.succeedOnTickWhen(dispenserDelay, () => {
		127 126       test.assertContainerEmpty(new BlockLocation(0, 2, 1));
		128 127       test.assertEntityHasComponent(llamaId, "minecraft:is_chested", entityLoc, true);
		129 128     });
		130 129   })
		131 130     .maxTicks(threeSecondsInTicks)
		          ...
		140 139     test.assertEntityHasArmor(llamaId, armorSlotTorso, "", 0, entityLoc, false);
		141 140   
		142 141     test.pressButton(new BlockLocation(0, 2, 0));
		143 142   
		144 143     test.assertEntityPresent(llamaId, entityLoc, true);
		    144 +   test.succeedWhen(() => {
		145     -   test.succeedOnTickWhen(dispenserDelay, () => {
		146 145       test.assertContainerEmpty(new BlockLocation(0, 2, 1));
		147 146       test.assertEntityHasArmor(llamaId, armorSlotTorso, "minecraft:carpet", pinkCarpet, entityLoc, true);
		148 147     });
		149 148   })
		150 149     .maxTicks(threeSecondsInTicks)
		          ...
		155 154     const minecartPos = new BlockLocation(1, 2, 1);
		156 155     test.assertEntityPresent(entityId, minecartPos, false);
		157 156   
		158 157     test.pressButton(new BlockLocation(0, 2, 0));
		159 158   
		    159 +   test.succeedWhen(() => {
		160     -   test.succeedOnTickWhen(dispenserDelay, () => {
		161 160       test.assertContainerEmpty(new BlockLocation(0, 2, 1));
		162 161       test.assertEntityPresent(entityId, minecartPos, true);
		163 162     });
		164 163   }
		165 164   
		          ...
		181 180     test.assertBlockPresent(MinecraftBlockTypes.water, waterPos, false);
		182 181     test.assertContainerContains(new ItemStack(MinecraftItemTypes.waterBucket, 1, 0), dispenserPos);
		183 182   
		184 183     test.pressButton(new BlockLocation(0, 2, 0));
		185 184   
		    185 +   test.succeedWhen(() => {
		186     -   test.succeedOnTickWhen(dispenserDelay, () => {
		187 186       test.assertContainerContains(new ItemStack(MinecraftItemTypes.bucket, 1, 0), dispenserPos);
		188 187       test.assertBlockPresent(MinecraftBlockTypes.water, waterPos, true);
		189 188     });
		190 189   })
		191 190     .maxTicks(threeSecondsInTicks)
		          ...
		227 226       new BlockLocation(0, 5, 1),
		228 227       new BlockLocation(2, 5, 3),
		229 228       new BlockLocation(2, 7, 1),
		230 229     ];
		231 230   
		    231 +   test.succeedWhen(() => {
		232     -   test.succeedOnTickWhen(dispenserDelay, () => {
		233 232       for (const pos of firePositions) {
		234 233         test.assertBlockPresent(MinecraftBlockTypes.fire, pos, true);
		235 234       }
		236 235     });
		237 236   })
		          ...
		239 238     .tag(GameTest.Tags.suiteDefault);
		240 239   
		241 240   // Regression test for crash when dispensing fire MC-210622
		242 241   GameTest.register("DispenserTests", "dispenser_fire_crash", (test) => {
		243 242     test.pullLever(new BlockLocation(0, 2, 0));
		    243 +   test.succeedOnTick(50);
		244     -   test.succeedOnTick(dispenserDelay);
		245 244   })
		246 245     .maxTicks(threeSecondsInTicks)
		247 246     .tag(GameTest.Tags.suiteDefault);
		          '''
	Changed script "DripstoneTests.js":
		Total line: 177 (+11, -17)
		          '''
		  1   1   import * as GameTest from "mojang-gametest";
		  2     - import {
		  3     -   BlockLocation,
		  4     -   MinecraftBlockTypes,
		  5     -   MinecraftItemTypes,
		  6     -   World,
		      2 + import { BlockLocation, MinecraftBlockTypes, MinecraftItemTypes, World } from "mojang-minecraft";
		  7     - } from "mojang-minecraft";
		  8   3   import GameTestExtensions from "./GameTestExtensions.js";
		  9   4   
		 10   5   function placeDripstoneTip(test, pos, hanging, waterlogged = false) {
		 11   6     const pointedDripstonePermutation = MinecraftBlockTypes.pointedDripstone.createDefaultBlockPermutation();
		 12   7     pointedDripstonePermutation.getProperty("hanging").value = hanging;
		 13   8     pointedDripstonePermutation.getProperty("dripstone_thickness").value = "tip";
		 14   9   
		 15  10     const pointedDripstoneBlock = World.getDimension("overworld").getBlock(test.worldBlockLocation(pos));
		 16  11     pointedDripstoneBlock.setPermutation(pointedDripstonePermutation);
		     12 +   pointedDripstoneBlock.isWaterlogged = waterlogged;
		 17     -   pointedDripstoneBlock.setWaterlogged(waterlogged);
		 18  13   }
		 19  14   
		 20  15   function assertDripstone(test, pos, hanging, thickness, waterlogged = false) {
		 21  16     const testEx = new GameTestExtensions(test);
		 22  17     test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, pos, true);
		          ...
		 29  24     let checkPos = basePos;
		 30  25     for (const thickness of thicknesses) {
		 31  26       assertDripstone(test, checkPos, hanging, thickness);
		 32  27       if (hanging == true) {
		 33  28         checkPos = checkPos.offset(0, -1, 0);
		     29 +     } else {
		 34     -     }
		 35     -     else {
		 36  30         checkPos = checkPos.offset(0, 1, 0);
		 37  31       }
		 38  32     }
		 39  33   }
		 40  34   
		          ...
		 85  79     const landingPos = new BlockLocation(1, 2, 1);
		 86  80     test.assertEntityPresent("minecraft:item", landingPos, false);
		 87  81   
		 88  82     test.pressButton(new BlockLocation(0, 3, 0));
		 89  83     test.succeedWhenEntityPresent("minecraft:item", landingPos, true);
		     84 + })
		     85 +   .tag("suite:java_parity")
		 90     - 
		 91     - }).tag("suite:java_parity")
		 92  86     .tag(GameTest.Tags.suiteDisabled); //Test failed occasionally due to bug 587521: Collision box of pointed dripstone becomes larger and offsets when falling.
		 93  87   
		 94  88   GameTest.register("DripstoneTests", "stalactite_fall_bedrock", (test) => {
		 95  89     const landingPos = new BlockLocation(1, 2, 1);
		 96  90     test.assertEntityPresent("minecraft:item", landingPos, false);
		 97  91   
		 98  92     test.pressButton(new BlockLocation(0, 3, 0));
		 99  93     test.succeedWhenEntityPresent("minecraft:item", landingPos, true);
		100     - 
		101  94   }).tag(GameTest.Tags.suiteDefault);
		102  95   
		103  96   GameTest.register("DripstoneTests", "stalactite_hurt", (test) => {
		104  97     const poorInnocentVictimPos = new BlockLocation(1, 2, 1);
		105  98     const poorInnocentVictim = test.spawnWithoutBehaviors("minecraft:pig", poorInnocentVictimPos);
		          ...
		108 101   
		109 102     const healthComponent = poorInnocentVictim.getComponent("minecraft:health");
		110 103   
		111 104     test.succeedWhen(() => {
		112 105       test.assert(healthComponent.current < healthComponent.value, "Mob should be hurt!");
		    106 +   });
		113     -   })
		114 107   }).tag(GameTest.Tags.suiteDefault);
		115 108   
		116 109   GameTest.register("DripstoneTests", "stalagmite_break", (test) => {
		117 110     test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 2, 1), true);
		118 111     test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 3, 1), true);
		          ...
		122 115   
		123 116     test.succeedWhen(() => {
		124 117       test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 2, 1), false);
		125 118       test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 3, 1), false);
		126 119       test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 4, 1), false);
		    120 +   });
		127     -   })
		128 121   }).tag(GameTest.Tags.suiteDefault);
		129 122   
		130 123   GameTest.register("DripstoneTests", "stalagmite_stalactite_separation", (test) => {
		131 124     assertColumnBaseToTip(test, new BlockLocation(1, 2, 1), false, "frustum", "merge");
		132 125     assertColumnBaseToTip(test, new BlockLocation(1, 5, 1), true, "frustum", "merge");
		          ...
		148 141       assertColumnBaseToTip(test, new BlockLocation(2, 2, 1), false, "frustum", "tip");
		149 142   
		150 143       // the left-hand stalactite should be gone
		151 144       test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(2, 5, 1), false);
		152 145       test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(2, 4, 1), false);
		    146 +   });
		153     -   })
		154 147   }).tag(GameTest.Tags.suiteDefault);
		155 148   
		156 149   GameTest.register("DripstoneTests", "stalagmite_hurt", (test) => {
		157 150     const unluckyPig = test.spawn("minecraft:pig", new BlockLocation(1, 4, 1));
		158 151     const luckyPig = test.spawn("minecraft:pig", new BlockLocation(3, 4, 1));
		          ...
		161 154     const luckyPigHealthComponent = luckyPig.getComponent("minecraft:health");
		162 155   
		163 156     test.succeedWhen(() => {
		164 157       test.assert(unluckyPigHealthComponent.current < unluckyPigHealthComponent.value, "This pig should be hurt!");
		165 158       test.assert(luckyPigHealthComponent.current == luckyPigHealthComponent.value, "This pig shouldn't be hurt!");
		    159 +   });
		166     -   })
		167 160   }).tag(GameTest.Tags.suiteDefault);
		168 161   
		169 162   GameTest.register("DripstoneTests", "stalactite_fall_no_dupe", (test) => {
		170 163     test.pressButton(new BlockLocation(4, 9, 0));
		171 164     test.pressButton(new BlockLocation(8, 8, 0));
		172 165     test.pressButton(new BlockLocation(12, 6, 0));
		    166 +   test.pressButton(new BlockLocation(16, 5, 0));
		173     -   test.pressButton(new BlockLocation(16, 5, 0))
		174 167   
		    168 +   test
		    169 +     .startSequence()
		175     -   test.startSequence()
		176 170       .thenExecuteAfter(60, () => {
		177 171         test.assertItemEntityCountIs(MinecraftItemTypes.pointedDripstone, new BlockLocation(2, 2, 2), 1, 5);
		178 172         test.assertItemEntityCountIs(MinecraftItemTypes.pointedDripstone, new BlockLocation(6, 2, 2), 1, 5);
		179 173         test.assertItemEntityCountIs(MinecraftItemTypes.pointedDripstone, new BlockLocation(10, 2, 2), 1, 2);
		180 174         test.assertItemEntityCountIs(MinecraftItemTypes.pointedDripstone, new BlockLocation(14, 2, 2), 1, 2);
		          ...
		          '''
	Changed script "DuplicationTests.js":
		Total line: 70 (+2, -2)
		        '''
		        ...
		 4  4   function poweredRailTest(test, pulseTicks) {
		 5  5     test.pulseRedstone(new BlockLocation(1, 2, 3), pulseTicks);
		 6  6   
		 7  7     test
		 8  8       .startSequence()
		    9 +     .thenIdle(8)
		 9    -     .thenIdle(3)
		10 10       .thenExecute(() => test.assertItemEntityCountIs(MinecraftItemTypes.goldenRail, new BlockLocation(1, 2, 1), 1.0, 1)) // powered rail
		11 11       .thenSucceed();
		12 12   }
		13 13   
		14 14   GameTest.register("DuplicationTests", "powered_rail_twist_bedrock", (test) => {
		        ...
		38 38   GameTest.register("DuplicationTests", "detector_rail", (test) => {
		39 39     test.spawn("minecraft:minecart", new BlockLocation(1, 3, 2));
		40 40   
		41 41     test
		42 42       .startSequence()
		   43 +     .thenIdle(8)
		43    -     .thenIdle(3)
		44 44       .thenExecute(() =>
		45 45         test.assertItemEntityCountIs(MinecraftItemTypes.detectorRail, new BlockLocation(1, 2, 1), 1.0, 1)
		46 46       )
		47 47       .thenSucceed();
		48 48   }).tag(GameTest.Tags.suiteDefault);
		        ...
		        '''
	Changed script "FlyingMachineTests.js":
		Total line: 258 (+3, -9)
		          '''
		          ...
		208 208       .thenExecute(() => {
		209 209         test.assertBlockPresent(MinecraftBlockTypes.slime, sourcePos, true);
		210 210         test.assertBlockPresent(MinecraftBlockTypes.slime, targetPos, false);
		211 211         test.setBlockType(MinecraftBlockTypes.redstoneBlock, triggerPos);
		212 212       })
		    213 +     .thenWait(() => {
		213     -     .thenExecuteAfter(10, () => {
		214 214         test.assertBlockPresent(MinecraftBlockTypes.slime, sourcePos, false);
		215     -     })
		216     -     .thenExecuteAfter(10, () => {
		217 215         test.assertBlockPresent(MinecraftBlockTypes.slime, targetPos, true);
		218 216       })
		219 217       .thenSucceed();
		220 218   }).tag(GameTest.Tags.suiteDefault);
		221 219   
		          ...
		230 228       .thenExecute(() => {
		231 229         test.assertBlockPresent(MinecraftBlockTypes.slime, sourcePos, true);
		232 230         test.assertBlockPresent(MinecraftBlockTypes.slime, targetPos, false);
		233 231         test.setBlockType(MinecraftBlockTypes.redstoneBlock, triggerPos);
		234 232       })
		    233 +     .thenWait(() => {
		235     -     .thenExecuteAfter(10, () => {
		236 234         test.assertBlockPresent(MinecraftBlockTypes.slime, sourcePos, false);
		237     -     })
		238     -     .thenExecuteAfter(10, () => {
		239 235         test.assertBlockPresent(MinecraftBlockTypes.slime, targetPos, true);
		240 236       })
		241 237       .thenSucceed();
		242 238   }).tag(GameTest.Tags.suiteDefault);
		243 239   
		          ...
		252 248       .thenExecute(() => {
		253 249         test.assertBlockPresent(MinecraftBlockTypes.slime, sourcePos, true);
		254 250         test.assertBlockPresent(MinecraftBlockTypes.slime, targetPos, false);
		255 251         test.setBlockType(MinecraftBlockTypes.redstoneBlock, triggerPos);
		256 252       })
		    253 +     .thenWait(() => {
		257     -     .thenExecuteAfter(10, () => {
		258 254         test.assertBlockPresent(MinecraftBlockTypes.slime, sourcePos, false);
		259     -     })
		260     -     .thenExecuteAfter(10, () => {
		261 255         test.assertBlockPresent(MinecraftBlockTypes.slime, targetPos, true);
		262 256       })
		263 257       .thenSucceed();
		264 258   }).tag(GameTest.Tags.suiteDefault);
		          '''
	Changed script "GameTestExtensions.js":
		Total line: 32 (+1, -1)
		        '''
		        ...
		24 24       breathableComp.setAirSupply(0);
		25 25     }
		26 26   
		27 27     assertBlockProperty(propertyName, value, blockLocation) {
		28 28       this.test.assertBlockState(blockLocation, (block) => {
		   29 +       return block.permutation.getProperty(propertyName).value == value;
		29    -       return block.getBlockData().getProperty(propertyName).value == value;
		30 30       });
		31 31     }
		32 32   }
		        '''
	Changed script "Main.js":
		Total line: 23 (+1, -0)
		        '''
		        ...
		15 15   import "scripts/MultifaceTests.js";
		16 16   import "scripts/PathFindingTests.js";
		17 17   import "scripts/FlyingMachineTests.js";
		18 18   import "scripts/PistonTests.js";
		19 19   import "scripts/TntTests.js";
		   20 + import "scripts/WaterPathfindingTests.js";
		20 21   import "scripts/SmallMobTests.js";
		21 22   import "scripts/BigMobTests.js";
		22 23   import "scripts/RedstoneTests.js";
		        '''
	Changed script "MobTests.js":
		Total line: 183 (+2, -1)
		          '''
		          ...
		150 150     testEx.makeAboutToDrown(swimmer);
		151 151     testEx.makeAboutToDrown(drowner);
		152 152   
		153 153     test
		154 154       .startSequence()
		    155 +     .thenWaitAfter(40, () => {
		    156 +       test.assertEntityPresent("minecraft:silverfish", swimmerPos, true);
		155     -     .thenIdle(40)
		    157 +       test.assertEntityPresent("minecraft:silverfish", drownerPos, false);
		    158 +     })
		156     -     .thenExecute(() => test.assertEntityPresent("minecraft:silverfish", swimmerPos, true))
		157     -     .thenExecute(() => test.assertEntityPresent("minecraft:silverfish", drownerPos, false))
		158 159       .thenSucceed();
		159 160   }).tag(GameTest.Tags.suiteDefault);
		160 161   
		161 162   GameTest.register("MobTests", "small_mobs_breathe_in_boats", (test) => {
		162 163     const testEx = new GameTestExtensions(test);
		          ...
		          '''
	Changed script "MultifaceTests.js":
		Total line: 285 (+1, -1)
		          '''
		          ...
		 30  30     test.assertBlockPresent(MinecraftBlockTypes.glowLichen, pos, true);
		 31  31     test.assertIsWaterlogged(pos, waterlogged);
		 32  32   
		 33  33     const glowLichenWorldPos = test.worldBlockLocation(pos);
		 34  34     const glowLichenBlock = World.getDimension("overworld").getBlock(glowLichenWorldPos);
		     35 +   const glowLichenPermutation = glowLichenBlock.permutation;
		 35     -   const glowLichenPermutation = glowLichenBlock.getBlockData();
		 36  36     const glowLichenmultiFaceDirectionBits = glowLichenPermutation.getProperty(
		 37  37       BlockProperties.multiFaceDirectionBits
		 38  38     ).value;
		 39  39   
		 40  40     for (const face of DIRECTIONS) {
		          ...
		          '''
	Changed script "PistonTests.js":
		Total line: 837 (+36, -41)
		          '''
		          ...
		 29  29     const pullLeverPos = new BlockLocation(0, 4, 0);
		 30  30   
		 31  31     test.pullLever(pullLeverPos);
		 32  32     test
		 33  33       .startSequence()
		     34 +     .thenWaitAfter(3, () => {
		 34     -     .thenWaitWithDelay(3, () => {
		 35  35         test.assertBlockPresent(MinecraftBlockTypes.stone, topStartPos, true);
		 36  36         test.assertBlockPresent(MinecraftBlockTypes.stone, bottomStartPos, true);
		 37  37       })
		 38  38       .thenExecute(() => {
		 39  39         test.pullLever(pullLever);
		 40  40       })
		     41 +     .thenWaitAfter(3, () => {
		 41     -     .thenWaitWithDelay(3, () => {
		 42  42         test.assertBlockPresent(MinecraftBlockTypes.stone, topEndPos, true);
		 43  43         test.assertBlockPresent(MinecraftBlockTypes.stone, bottomEndPos, true);
		 44  44       })
		 45  45       .thenSucceed();
		 46  46   })
		          ...
		 99  99     const retractedPos = new BlockLocation(2, 2, 0);
		100 100     test.setBlockType(MinecraftBlockTypes.stone, new BlockLocation(0, 1, 0));
		101 101   
		102 102     test
		103 103       .startSequence()
		    104 +     .thenWaitAfter(3, () => {
		104     -     .thenWaitWithDelay(3, () => {
		105 105         test.assertBlockPresent(MinecraftBlockTypes.redstoneBlock, extendedPos, true);
		106 106         test.assertBlockPresent(MinecraftBlockTypes.air, retractedPos, true);
		107 107       })
		    108 +     .thenWaitAfter(3, () => {
		108     -     .thenWaitWithDelay(3, () => {
		109 109         test.assertBlockPresent(MinecraftBlockTypes.air, extendedPos, true);
		110 110         test.assertBlockPresent(MinecraftBlockTypes.redstoneBlock, retractedPos, true);
		111 111       })
		112 112       .thenSucceed();
		113 113   })
		          ...
		118 118     const blockPos = new BlockLocation(0, 3, 5);
		119 119     const pullLeverPos = new BlockLocation(0, 4, 0);
		120 120     test.pullLever(pullLeverPos);
		121 121     test
		122 122       .startSequence()
		    123 +     .thenWaitAfter(3, () => {
		123     -     .thenWaitWithDelay(3, () => {
		124 124         test.assertBlockPresent(MinecraftBlockTypes.redstoneBlock, blockPos, true);
		125 125       })
		    126 +     .thenWaitAfter(5, () => {
		126     -     .thenWaitWithDelay(5, () => {
		127 127         test.assertBlockPresent(MinecraftBlockTypes.air, blockPos, true);
		128 128       })
		129 129       .thenWait(() => {
		130 130         test.pullLever(pullLeverPos);
		131 131       })
		    132 +     .thenWaitAfter(3, () => {
		132     -     .thenWaitWithDelay(3, () => {
		133 133         test.assertBlockPresent(MinecraftBlockTypes.redstoneBlock, blockPos, true);
		134 134       })
		    135 +     .thenWaitAfter(5, () => {
		135     -     .thenWaitWithDelay(5, () => {
		136 136         test.assertBlockPresent(MinecraftBlockTypes.air, blockPos, true);
		137 137       })
		138 138       .thenSucceed();
		139 139   })
		140 140     .setupTicks(10)
		          ...
		145 145     const targetPos = new BlockLocation(3, 3, 0);
		146 146     const pullLeverPos = new BlockLocation(0, 4, 0);
		147 147   
		148 148     test.assertBlockPresent(MinecraftBlockTypes.planks, targetPos, false);
		149 149     test.pullLever(pullLeverPos);
		    150 +   test.succeedWhenBlockPresent(MinecraftBlockTypes.planks, targetPos, true);
		150     -   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.planks, targetPos, true);
		151 151   }).tag(GameTest.Tags.suiteDefault);
		152 152   
		153 153   GameTest.register("PistonTests", "normal_extend", (test) => {
		154 154     const targetPos = new BlockLocation(3, 2, 0);
		155 155     const pullLeverPos = new BlockLocation(0, 3, 0);
		156 156   
		157 157     test.assertBlockPresent(MinecraftBlockTypes.stone, targetPos, false);
		158 158     test.pullLever(pullLeverPos);
		    159 +   test.succeedWhen(() => {
		159     -   test.succeedOnTickWhen(3, () => {
		160 160       test.assertBlockPresent(MinecraftBlockTypes.stone, targetPos, true);
		161 161     });
		162 162   }).tag(GameTest.Tags.suiteDefault);
		163 163   
		164 164   GameTest.register("PistonTests", "normal_extend_retract", (test) => {
		          ...
		169 169     test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, false);
		170 170     test.pullLever(pullLeverPos);
		171 171   
		172 172     test
		173 173       .startSequence()
		    174 +     .thenWaitAfter(3, () => {
		174     -     .thenWaitWithDelay(3, () => {
		175 175         test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, true);
		176 176         test.assertBlockPresent(MinecraftBlockTypes.pistonarmcollision, retractedPos, true);
		177 177       })
		178 178       .thenExecute(() => {
		179 179         test.pullLever(pullLeverPos);
		180 180       })
		    181 +     .thenWaitAfter(1, () => {
		181     -     .thenWaitWithDelay(1, () => {
		182 182         test.assertBlockPresent(MinecraftBlockTypes.air, retractedPos, true);
		183 183         test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, true);
		184 184       })
		185 185       .thenSucceed();
		186 186   })
		          ...
		221 221     const targetPos = new BlockLocation(3, 2, 0);
		222 222     const pullLeverPos = new BlockLocation(0, 3, 0);
		223 223   
		224 224     test.assertBlockPresent(MinecraftBlockTypes.stone, targetPos, false);
		225 225     test.pullLever(pullLeverPos);
		    226 +   test.succeedWhen(() => {
		226     -   test.succeedOnTickWhen(3, () => {
		227 227       test.assertBlockPresent(MinecraftBlockTypes.stone, targetPos, true);
		228 228     });
		229 229   }).tag(GameTest.Tags.suiteDefault);
		230 230   
		231 231   GameTest.register("PistonTests", "sticky_extend_retract", (test) => {
		          ...
		236 236     test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, false);
		237 237     test.pullLever(pullLeverPos);
		238 238   
		239 239     test
		240 240       .startSequence()
		    241 +     .thenWaitAfter(3, () => {
		241     -     .thenWaitWithDelay(3, () => {
		242 242         test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, true);
		243 243         test.assertBlockPresent(MinecraftBlockTypes.stickypistonarmcollision, retractedPos, true);
		244 244       })
		245 245       .thenExecute(() => {
		246 246         test.pullLever(pullLeverPos);
		247 247       })
		    248 +     .thenWaitAfter(3, () => {
		248     -     .thenWaitWithDelay(3, () => {
		249 249         test.assertBlockPresent(MinecraftBlockTypes.stone, retractedPos, true);
		250 250         test.assertBlockPresent(MinecraftBlockTypes.air, extendedPos, true);
		251 251       })
		252 252       .thenSucceed();
		253 253   })
		          ...
		292 292   
		293 293     test.assertBlockPresent(MinecraftBlockTypes.goldBlock, underLimitTip, true);
		294 294     test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, overLimitTip, true);
		295 295     test.pullLever(pullLeverPos);
		296 296   
		    297 +   test.succeedWhen(() => {
		297     -   test.succeedOnTickWhen(3, () => {
		298 298       test.assertBlockPresent(MinecraftBlockTypes.goldBlock, underLimitExtendedTip, true);
		299 299       test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, overLimitTip, true);
		300 300     });
		301 301   }).tag(GameTest.Tags.suiteDefault);
		302 302   
		          ...
		306 306     const extended = new BlockLocation(0, 1, 1);
		307 307   
		308 308     test.pulseRedstone(trigger, 2);
		309 309     test
		310 310       .startSequence()
		    311 +     .thenWaitAfter(3, () => {
		311     -     .thenWaitWithDelay(3, () => {
		312 312         test.assertBlockPresent(MinecraftBlockTypes.concrete, extended, true);
		313 313         test.assertBlockPresent(MinecraftBlockTypes.air, retracted, true);
		314 314       })
		315 315       .thenExecuteAfter(3, () => {
		316 316         test.pulseRedstone(trigger, 2);
		317 317       })
		    318 +     .thenWaitAfter(5, () => {
		318     -     .thenWaitWithDelay(5, () => {
		319 319         test.assertBlockPresent(MinecraftBlockTypes.concrete, retracted, true);
		320 320         test.assertBlockPresent(MinecraftBlockTypes.air, extended, true);
		321 321       })
		322 322       .thenSucceed();
		323 323   })
		          ...
		357 357     const trigger = new BlockLocation(6, 2, 2);
		358 358     test.setBlockType(trigger, MinecraftBlockTypes.greenWool);
		359 359   
		360 360     test
		361 361       .startSequence()
		    362 +     .thenWaitAfter(4, () => {
		362     -     .thenWaitWithDelay(4, () => {
		363 363         test.assertBlockPresent(MinecraftBlockTypes.yellowWool, posB, true);
		364 364       })
		365 365       .thenExecuteAfter(4, () => {
		366 366         test.setBlockType(trigger, MinecraftBlockTypes.blueWool);
		367 367       })
		    368 +     .thenWaitAfter(6, () => {
		368     -     .thenWaitWithDelay(6, () => {
		369 369         test.assertBlockPresent(MinecraftBlockTypes.yellowWool, posC, true);
		370 370       })
		371 371       .thenExecuteAfter(4, () => {
		372 372         test.setBlockType(trigger, MinecraftBlockTypes.purpleWool);
		373 373       })
		    374 +     .thenWaitAfter(6, () => {
		374     -     .thenWaitWithDelay(6, () => {
		375 375         test.assertBlockPresent(MinecraftBlockTypes.yellowWool, posD, true);
		376 376       })
		377 377       .thenExecuteAfter(4, () => {
		378 378         test.setBlockType(trigger, MinecraftBlockTypes.cyanWool);
		379 379       })
		    380 +     .thenWaitAfter(6, () => {
		380     -     .thenWaitWithDelay(6, () => {
		381 381         test.assertBlockPresent(MinecraftBlockTypes.yellowWool, posA, true);
		382 382       })
		383 383       .thenSucceed();
		384 384   })
		385 385     .required(false)
		          ...
		438 438     test.pullLever(pullLeverPos);
		439 439     test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosA, true);
		440 440   
		441 441     test
		442 442       .startSequence()
		    443 +     .thenWaitAfter(11, () => {
		443     -     .thenWaitWithDelay(11, () => {
		444 444         test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosB, true);
		445 445         test.pullLever(pullLeverPos);
		446 446       })
		    447 +     .thenWaitAfter(12, () => {
		447     -     .thenWaitWithDelay(12, () => {
		448 448         test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosA, true);
		449 449       })
		450 450       .thenSucceed();
		451 451   })
		452 452     .tag("suite:java_parity")
		          ...
		461 461     test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosA, true);
		462 462   
		463 463     //it's not possible to time it exactly due to redstone differences, so just validate assert can pass before given delay.
		464 464     test
		465 465       .startSequence()
		    466 +     .thenWait(() => {
		466     -     .thenIdle(17)
		467     -     .thenExecute(() => {
		468 467         test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosB, true);
		469 468         test.pullLever(pullLeverPos);
		470 469       })
		    470 +     .thenWait(() => {
		471     -     .thenIdle(18)
		472     -     .thenExecute(() => {
		473 471         test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosA, true);
		474 472       })
		475 473       .thenSucceed();
		476 474   })
		477 475     .structureName("PistonTests:double_extender")
		          ...
		549 547     testEx.assertBlockProperty("redstone_signal", 0, lampPos);
		550 548     test.pullLever(pullLeverPos);
		551 549   
		552 550     test
		553 551       .startSequence()
		    552 +     .thenWaitAfter(2, () => {
		554     -     .thenWaitWithDelay(2, () => {
		555 553         testEx.assertBlockProperty("redstone_signal", 1, lampPos);
		556 554       })
		    555 +     .thenWaitAfter(4, () => {
		557     -     .thenWaitWithDelay(4, () => {
		558 556         testEx.assertBlockProperty("redstone_signal", 0, lampPos);
		559 557       })
		560 558       .thenSucceed();
		561 559   })
		562 560     .tag("suite:java_parity")
		          ...
		572 570       .startSequence()
		573 571       .thenIdle(10)
		574 572       .thenExecute(() => {
		575 573         test.pullLever(pullLeverPos);
		576 574       })
		    575 +     .thenExecuteAfter(8, () => {
		577     -     .thenIdle(5)
		578     -     .thenExecute(() => {
		579 576         test.assertRedstonePower(lampPos, 15);
		580 577       })
		    578 +     .thenExecuteAfter(8, () => {
		581     -     .thenIdle(9)
		582     -     .thenExecute(() => {
		583 579         test.assertRedstonePower(lampPos, 0);
		584 580       })
		585 581       .thenSucceed();
		586 582   })
		587 583     .maxTicks(100)
		          ...
		590 586   GameTest.register("PistonTests", "instant_retraction", (test) => {
		591 587     const airPos = new BlockLocation(2, 1, 1);
		592 588     const concretePos = new BlockLocation(0, 1, 3);
		593 589   
		594 590     test.setBlockType(MinecraftBlockTypes.air, airPos);
		    591 +   test.succeedOnTickWhen(14, () => {
		595     -   test.succeedOnTickWhen(3, () => {
		596 592       test.assertBlockPresent(MinecraftBlockTypes.concrete, concretePos, true);
		597 593     });
		598 594   }).tag(GameTest.Tags.suiteDefault);
		599 595   
		600 596   GameTest.register("PistonTests", "instant_repeater", (test) => {
		          ...
		603 599     const outputPos = new BlockLocation(0, 3, 25);
		604 600     test.pullLever(triggerPos);
		605 601   
		606 602     test
		607 603       .startSequence()
		    604 +     .thenWaitAfter(1, () => {
		608     -     .thenWaitWithDelay(1, () => {
		609 605         testEx.assertBlockProperty("redstone_signal", 1, outputPos);
		610 606       })
		611 607       .thenIdle(10) // relaxation time
		612 608       .thenExecute(() => {
		613 609         test.pullLever(triggerPos);
		614 610       })
		    611 +     .thenWaitAfter(5, () => {
		615     -     .thenWaitWithDelay(5, () => {
		616 612         testEx.assertBlockProperty("redstone_signal", 0, outputPos);
		617 613       })
		618 614       .thenSucceed();
		619 615   })
		620 616     .tag("suite:java_parity")
		          ...
		656 652     test.pressButton(pressButtonPos);
		657 653   
		658 654     test
		659 655       .startSequence()
		660 656   
		    657 +     .thenWaitAfter(2, () => {
		661     -     .thenWaitWithDelay(2, () => {
		662 658         test.assertBlockPresent(MinecraftBlockTypes.stainedGlass, extendedPos, true);
		663 659       })
		664 660       .thenIdle(30)
		665 661       .thenWait(() => {
		666 662         test.pressButton(pressButtonPos);
		667 663       })
		    664 +     .thenWaitAfter(4, () => {
		668     -     .thenWaitWithDelay(4, () => {
		669 665         test.assertBlockPresent(MinecraftBlockTypes.stainedGlass, retractedPos, true);
		670 666         test.assertBlockPresent(MinecraftBlockTypes.air, extendedPos, true);
		671 667       })
		672 668       .thenSucceed();
		673 669   })
		          ...
		728 724     const levelPos = new BlockLocation(3, 2, 2);
		729 725     const observerPos = new BlockLocation(2, 2, 1);
		730 726     test.pullLever(levelPos);
		731 727     test
		732 728       .startSequence()
		733     -     .thenIdle(2)
		734 729       .thenExecute(() => {
		735 730         testEx.assertBlockProperty("powered_bit", 0, observerPos);
		736 731       })
		    732 +     .thenIdle(2)
		737     -     .thenIdle(1)
		738 733       .thenExecute(() => {
		739 734         testEx.assertBlockProperty("powered_bit", 1, observerPos);
		740 735       })
		741 736       .thenSucceed();
		742 737   }).tag(GameTest.Tags.suiteDefault);
		          ...
		          '''
	Changed script "RedstoneTests.js":
		Total line: 1031 (+272, -187)
		            '''
		   1    1   import * as GameTest from "mojang-gametest";
		        2 + import { BlockLocation, MinecraftBlockTypes, MinecraftItemTypes, BlockProperties, World } from "mojang-minecraft";
		        3 + import GameTestExtensions from "./GameTestExtensions.js";
		        4 + 
		        5 + const TicksPerSecond = 20;
		        6 + 
		        7 + const LEVEL_TO_RECORDS = new Map([
		        8 +   [0, MinecraftItemTypes.air],
		        9 +   [1, MinecraftItemTypes.musicDisc13],
		       10 +   [2, MinecraftItemTypes.musicDiscCat],
		       11 +   [3, MinecraftItemTypes.musicDiscBlocks],
		       12 +   [4, MinecraftItemTypes.musicDiscChirp],
		       13 +   [5, MinecraftItemTypes.musicDiscFar],
		       14 +   [6, MinecraftItemTypes.musicDiscMall],
		       15 +   [7, MinecraftItemTypes.musicDiscMellohi],
		       16 +   [8, MinecraftItemTypes.musicDiscStal],
		       17 +   [9, MinecraftItemTypes.musicDiscStrad],
		       18 +   [10, MinecraftItemTypes.musicDiscWard],
		       19 +   [11, MinecraftItemTypes.musicDisc11],
		       20 +   [12, MinecraftItemTypes.musicDiscWait],
		       21 +   [15, MinecraftItemTypes.musicDiscPigstep],
		       22 + ]);
		       23 + 
		       24 + GameTest.register("RedstoneTests", "itemframe_override", (test) => {
		       25 +   const itemFrameTest = new BlockLocation(3, 2, 5);
		       26 +   const itemFrameOverrideNoTest = new BlockLocation(3, 2, 10);
		       27 + 
		       28 +   const lever = new BlockLocation(1, 2, 0);
		       29 +   const leverOverrideTest = new BlockLocation(1, 2, 13);
		       30 + 
		       31 +   test.assertRedstonePower(itemFrameTest, 1);
		       32 +   test.assertRedstonePower(itemFrameOverrideNoTest, 1);
		       33 + 
		       34 +   test.pullLever(lever);
		       35 + 
		       36 +   test.succeedWhen(() => {
		       37 +     test.assertRedstonePower(leverOverrideTest, 1);
		       38 +   });
		       39 + })
		       40 +   .tag("suite:java_parity")
		       41 +   .tag(GameTest.Tags.suiteDisabled); // Torches can't be placed on item frames in Bedrock,When the bow and arrow are placed on the item frame, it cannot be linked with red stone. So I changed the location of the red stone link to bedrock
		       42 + 
		       43 + GameTest.register("RedstoneTests", "itemframe_override_bedrock", (test) => {
		       44 +   const itemFrameTest = new BlockLocation(3, 2, 5);
		       45 +   const itemFrameOverrideNoTest = new BlockLocation(2, 2, 10);
		       46 + 
		       47 +   const lever = new BlockLocation(1, 2, 0);
		       48 +   const leverOverrideTest = new BlockLocation(0, 2, 13);
		       49 + 
		       50 +   test
		       51 +     .startSequence()
		       52 +     .thenIdle(3)
		       53 +     .thenExecute(() => {
		       54 +       test.assertRedstonePower(itemFrameTest, 1);
		       55 +       test.assertRedstonePower(itemFrameOverrideNoTest, 1);
		       56 +     })
		       57 +     .thenExecute(() => {
		       58 +       test.pullLever(lever);
		       59 +     })
		       60 +     .thenIdle(10)
		       61 +     .thenExecute(() => {
		       62 +       test.assertRedstonePower(leverOverrideTest, 3);
		       63 +     })
		       64 +     .thenSucceed();
		       65 + }).tag(GameTest.Tags.suiteDefault);
		       66 + 
		       67 + GameTest.register("RedstoneTests", "comparator_container", (test) => {
		       68 +   const aLeft = new BlockLocation(6, 2, 2);
		       69 +   const aRight = new BlockLocation(1, 2, 2);
		       70 + 
		       71 +   test.assertRedstonePower(aLeft, 14);
		       72 +   test.assertRedstonePower(aRight, 15);
		       73 + 
		       74 +   const bLeft = new BlockLocation(6, 2, 7);
		       75 +   const bRight = new BlockLocation(1, 2, 7);
		       76 + 
		       77 +   test.assertRedstonePower(bLeft, 0);
		       78 +   test.assertRedstonePower(bRight, 15);
		       79 + 
		       80 +   const cLeft = new BlockLocation(6, 2, 13);
		       81 +   const cRight = new BlockLocation(1, 2, 13);
		       82 +   test.assertRedstonePower(cLeft, 1);
		       83 +   test.assertRedstonePower(cRight, 15);
		       84 + 
		       85 +   test.succeed();
		       86 + })
		       87 +   .tag("suite:java_parity")
		       88 +   .tag(GameTest.Tags.suiteDisabled); // In the bedrock version, the chest is next to the square, causing the red stone signal to fail to transmit
		       89 + 
		       90 + GameTest.register("RedstoneTests", "comparator_container_bedrock", (test) => {
		       91 +   const aLeft = new BlockLocation(6, 2, 2);
		       92 +   const aRight = new BlockLocation(1, 2, 2);
		       93 +   const bLeft = new BlockLocation(6, 2, 7);
		       94 +   const bRight = new BlockLocation(1, 2, 7);
		       95 +   const cLeft = new BlockLocation(6, 2, 13);
		       96 +   const cRight = new BlockLocation(1, 2, 13);
		       97 + 
		       98 +   test.succeedWhen(() => {
		       99 +     test.assertRedstonePower(aLeft, 14);
		      100 +     test.assertRedstonePower(aRight, 15);
		      101 +     test.assertRedstonePower(bLeft, 0);
		      102 +     test.assertRedstonePower(bRight, 0);
		      103 +     test.assertRedstonePower(cLeft, 0);
		      104 +     test.assertRedstonePower(cRight, 0);
		      105 +   });
		      106 + })
		      107 +   .structureName("RedstoneTests:comparator_container")
		      108 +   .tag(GameTest.Tags.suiteDefault);
		      109 + 
		      110 + GameTest.register("RedstoneTests", "wireredirect_nonconductor", (test) => {
		      111 +   const testEx = new GameTestExtensions(test);
		      112 +   const levers = [new BlockLocation(3, 2, 0), new BlockLocation(1, 2, 0)];
		      113 +   const fenceGatesClosed = [
		      114 +     new BlockLocation(2, 3, 0),
		      115 +     new BlockLocation(2, 3, 2),
		      116 +     new BlockLocation(1, 2, 2),
		      117 +     new BlockLocation(2, 2, 2),
		      118 +     new BlockLocation(3, 2, 2),
		      119 +     new BlockLocation(0, 2, 1),
		      120 +     new BlockLocation(4, 2, 1),
		      121 +   ];
		      122 +   const fenceGatesOpen = [new BlockLocation(3, 3, 1), new BlockLocation(1, 3, 1)];
		   2      - import { BlockLocation, MinecraftBlockTypes, BlockProperties, World } from "mojang-minecraft";
		   3      - import GameTestExtensions from "./GameTestExtensions.js";
		   4      - 
		   5      - const TicksPerSecond = 20;
		   6      - 
		   7      - GameTest.register("RedstoneTests", "itemframe_override", (test) => {
		   8      -   const itemFrameTest = new BlockLocation(3, 2, 5);
		   9      -   const itemFrameOverrideNoTest = new BlockLocation(3, 2, 10);
		  10  123   
		      124 +   test
		      125 +     .startSequence()
		      126 +     .thenExecute(() => {
		      127 +       for (const lever of levers) {
		      128 +         test.pullLever(lever);
		      129 +       }
		      130 +       for (const fenceGateC of fenceGatesClosed) {
		      131 +         testEx.assertBlockProperty("open_bit", 0, fenceGateC);
		      132 +       }
		      133 +       for (const fenceGateO of fenceGatesOpen) {
		      134 +         testEx.assertBlockProperty("open_bit", 1, fenceGateO);
		      135 +       }
		      136 +     })
		      137 +     .thenSucceed();
		  11      -   const lever = new BlockLocation(1, 2, 0);
		  12      -   const leverOverrideTest = new BlockLocation(1, 2, 13);
		  13      - 
		  14      -   test.assertRedstonePower(itemFrameTest, 1);
		  15      -   test.assertRedstonePower(itemFrameOverrideNoTest, 1);
		  16      - 
		  17      -   test.pullLever(lever);
		  18      - 
		  19      -   test.succeedWhen(() => {
		  20      -     test.assertRedstonePower(leverOverrideTest, 1);
		  21      -   });
		  22  138   })
		  23  139     .tag("suite:java_parity")
		  24      -   .tag(GameTest.Tags.suiteDisabled); // Torches can't be placed on item frames in Bedrock,When the bow and arrow are placed on the item frame, it cannot be linked with red stone. So I changed the location of the red stone link to bedrock
		  25      - 
		  26      - GameTest.register("RedstoneTests", "itemframe_override_bedrock", (test) => {
		  27      -   const itemFrameTest = new BlockLocation(3, 2, 5);
		      140 +   .tag(GameTest.Tags.suiteDisabled); // There is no way to judge the opening and closing state of the fence door, so in is used in open_bit
		  28      -   const itemFrameOverrideNoTest = new BlockLocation(2, 2, 10);
		  29  141   
		      142 + GameTest.register("RedstoneTests", "wireredirect_nonconductor_bedrock", (test) => {
		      143 +   const testEx = new GameTestExtensions(test);
		      144 +   const levers = [new BlockLocation(3, 2, 0), new BlockLocation(1, 2, 0)];
		      145 +   const fenceGatesClosed = [
		      146 +     new BlockLocation(2, 3, 0),
		      147 +     new BlockLocation(2, 3, 2),
		      148 +     new BlockLocation(1, 2, 2),
		      149 +     new BlockLocation(2, 2, 2),
		      150 +     new BlockLocation(3, 2, 2),
		      151 +     new BlockLocation(0, 2, 1),
		      152 +     new BlockLocation(4, 2, 1),
		      153 +   ];
		      154 +   const fenceGatesOpen = [new BlockLocation(3, 3, 1), new BlockLocation(1, 3, 1)];
		      155 + 
		      156 +   test
		      157 +     .startSequence()
		      158 +     .thenIdle(2)
		  30      -   const lever = new BlockLocation(1, 2, 0);
		  31      -   const leverOverrideTest = new BlockLocation(0, 2, 13);
		  32      - 
		  33      -   test
		  34      -     .startSequence()
		  35      -     .thenIdle(3)
		  36      -     .thenExecute(() => {
		  37      -       test.assertRedstonePower(itemFrameTest, 1);
		  38      -       test.assertRedstonePower(itemFrameOverrideNoTest, 1);
		  39      -     })
		  40      -     .thenExecute(() => {
		  41      -       test.pullLever(lever);
		  42      -     })
		  43      -     .thenIdle(10)
		  44  159       .thenExecute(() => {
		  45      -       test.assertRedstonePower(leverOverrideTest, 3);
		  46      -     })
		  47      -     .thenSucceed();
		  48      - }).tag(GameTest.Tags.suiteDefault);
		  49      - 
		      160 +       for (const lever of levers) {
		      161 +         test.pullLever(lever);
		      162 +       }
		      163 +     })
		      164 +     .thenIdle(6)
		      165 +     .thenExecute(() => {
		      166 +       for (const fenceGateC of fenceGatesClosed) {
		      167 +         testEx.assertBlockProperty("open_bit", 0, fenceGateC);
		      168 +       }
		      169 +     })
		      170 +     .thenExecute(() => {
		      171 +       for (const fenceGateO of fenceGatesOpen) {
		      172 +         testEx.assertBlockProperty("open_bit", 1, fenceGateO);
		      173 +       }
		      174 +     })
		      175 +     .thenSucceed();
		      176 + }).tag(GameTest.Tags.suiteDefault);
		  50      - GameTest.register("RedstoneTests", "comparator_container", (test) => {
		  51      -   const aLeft = new BlockLocation(6, 2, 2);
		  52      -   const aRight = new BlockLocation(1, 2, 2);
		  53      - 
		  54      -   test.assertRedstonePower(aLeft, 14);
		  55      -   test.assertRedstonePower(aRight, 15);
		  56      - 
		  57      -   const bLeft = new BlockLocation(6, 2, 7);
		  58      -   const bRight = new BlockLocation(1, 2, 7);
		  59      - 
		  60      -   test.assertRedstonePower(bLeft, 0);
		  61      -   test.assertRedstonePower(bRight, 15);
		  62      - 
		  63      -   const cLeft = new BlockLocation(6, 2, 13);
		  64      -   const cRight = new BlockLocation(1, 2, 13);
		  65      -   test.assertRedstonePower(cLeft, 1);
		  66      -   test.assertRedstonePower(cRight, 15);
		  67  177   
		      178 + GameTest.register("RedstoneTests", "repeater_regeneration", (test) => {
		      179 +   const testEx = new GameTestExtensions(test);
		  68      -   test.succeed();
		      180 +   const input = new BlockLocation(0, 2, 0);
		      181 +   const inactiveOutput = new BlockLocation(6, 3, 4);
		      182 +   const activeOutput = new BlockLocation(6, 3, 3);
		  69      - })
		  70      -   .tag("suite:java_parity")
		  71      -   .tag(GameTest.Tags.suiteDisabled); // In the bedrock version, the chest is next to the square, causing the red stone signal to fail to transmit
		  72  183   
		      184 +   test.setBlockType(MinecraftBlockTypes.redstoneBlock, input);
		  73      - GameTest.register("RedstoneTests", "comparator_container_bedrock", (test) => {
		  74      -   const aLeft = new BlockLocation(6, 2, 2);
		      185 +   test.succeedWhen(() => {
		      186 +     testEx.assertBlockProperty("open_bit", 0, inactiveOutput);
		      187 +     testEx.assertBlockProperty("open_bit", 1, activeOutput);
		      188 +   });
		      189 + }).tag(GameTest.Tags.suiteDefault);
		  75      -   const aRight = new BlockLocation(1, 2, 2);
		  76      -   const bLeft = new BlockLocation(6, 2, 7);
		  77      -   const bRight = new BlockLocation(1, 2, 7);
		  78      -   const cLeft = new BlockLocation(6, 2, 13);
		  79      -   const cRight = new BlockLocation(1, 2, 13);
		  80  190   
		      191 + GameTest.register("RedstoneTests", "repeater_lock", (test) => {
		      192 +   const testEx = new GameTestExtensions(test);
		  81      -   test
		      193 +   const input = new BlockLocation(0, 2, 2);
		      194 +   const lock = new BlockLocation(1, 2, 0);
		      195 +   const output = new BlockLocation(2, 2, 1);
		      196 + 
		      197 +   test.setBlockType(MinecraftBlockTypes.redstoneBlock, input);
		      198 + 
		      199 +   test
		      200 +     .startSequence()
		      201 +     .thenIdle(6)
		  82      -     .startSequence()
		  83      -     .thenExecute(() => {
		  84      -       test.assertRedstonePower(aLeft, 14);
		  85      -       test.assertRedstonePower(aRight, 15);
		  86      -     })
		  87      -     .thenExecute(() => {
		  88      -       test.assertRedstonePower(bLeft, 0);
		  89      -       test.assertRedstonePower(bRight, 0);
		  90      -     })
		  91  202       .thenExecute(() => {
		      203 +       testEx.assertBlockProperty("open_bit", 1, output);
		  92      -       test.assertRedstonePower(cLeft, 0);
		  93      -       test.assertRedstonePower(cRight, 0);
		  94  204       })
		  95      -     .thenSucceed();
		  96      - })
		  97      -   .structureName("RedstoneTests:comparator_container")
		  98      -   .tag(GameTest.Tags.suiteDefault);
		      205 +     .thenExecute(() => {
		      206 +       test.setBlockType(MinecraftBlockTypes.redstoneBlock, lock);
		      207 +       test.setBlockType(MinecraftBlockTypes.air, input);
		      208 +       testEx.assertBlockProperty("open_bit", 1, output);
		      209 +     })
		      210 +     .thenExecuteAfter(2, () => {
		      211 +       test.setBlockType(MinecraftBlockTypes.air, lock);
		      212 +     })
		      213 +     .thenIdle(4)
		      214 +     .thenExecute(() => {
		      215 +       testEx.assertBlockProperty("open_bit", 0, output);
		      216 +     })
		      217 +     .thenSucceed();
		      218 + }).tag(GameTest.Tags.suiteDefault);
		  99      - 
		 100      - GameTest.register("RedstoneTests", "wireredirect_nonconductor", (test) => {
		 101      -   const testEx = new GameTestExtensions(test);
		 102      -   const levers = [new BlockLocation(3, 2, 0), new BlockLocation(1, 2, 0)];
		 103      -   const fenceGatesClosed = [
		 104      -     new BlockLocation(2, 3, 0),
		 105      -     new BlockLocation(2, 3, 2),
		 106      -     new BlockLocation(1, 2, 2),
		 107      -     new BlockLocation(2, 2, 2),
		 108      -     new BlockLocation(3, 2, 2),
		 109      -     new BlockLocation(0, 2, 1),
		 110      -     new BlockLocation(4, 2, 1),
		 111      -   ];
		 112      -   const fenceGatesOpen = [new BlockLocation(3, 3, 1), new BlockLocation(1, 3, 1)];
		 113  219   
		      220 + GameTest.register("RedstoneTests", "torch_monostable", (test) => {
		 114      -   test
		 115      -     .startSequence()
		 116      -     .thenExecute(() => {
		      221 +   const testEx = new GameTestExtensions(test);
		      222 +   const input = new BlockLocation(0, 2, 0);
		      223 +   const output = new BlockLocation(2, 2, 1);
		      224 + 
		      225 +   test.pressButton(input);
		      226 +   test
		      227 +     .startSequence()
		      228 +     .thenWaitAfter(2, () => {
		      229 +       testEx.assertBlockProperty("open_bit", 0, output);
		 117      -       for (const lever of levers) {
		 118      -         test.pullLever(lever);
		 119      -       }
		 120      -       for (const fenceGateC of fenceGatesClosed) {
		 121      -         testEx.assertBlockProperty("open_bit", 0, fenceGateC);
		 122      -       }
		 123      -       for (const fenceGateO of fenceGatesOpen) {
		 124      -         testEx.assertBlockProperty("open_bit", 1, fenceGateO);
		 125      -       }
		 126  230       })
		 127      -     .thenSucceed();
		 128      - })
		 129      -   .tag("suite:java_parity")
		      231 +     .thenWaitAfter(2, () => {
		      232 +       testEx.assertBlockProperty("open_bit", 1, output);
		      233 +     })
		      234 +     .thenExecute(() => {
		      235 +       test.failIf(() => {
		      236 +         testEx.assertBlockProperty("open_bit", 0, output);
		      237 +       });
		      238 +     })
		      239 +     .thenWait(() => {
		      240 +       testEx.assertBlockProperty("button_pressed_bit", 0, input);
		      241 +     })
		      242 +     .thenSucceed();
		      243 + })
		      244 +   .tag("suite:java_parity")
		      245 +   .tag(GameTest.Tags.suiteDisabled); // there are tick delay differences between Java and Bedrock.
		 130      -   .tag(GameTest.Tags.suiteDisabled); // There is no way to judge the opening and closing state of the fence door, so in is used in open_bit
		 131      - 
		 132      - GameTest.register("RedstoneTests", "wireredirect_nonconductor_bedrock", (test) => {
		 133      -   const testEx = new GameTestExtensions(test);
		 134      -   const levers = [new BlockLocation(3, 2, 0), new BlockLocation(1, 2, 0)];
		 135      -   const fenceGatesClosed = [
		 136      -     new BlockLocation(2, 3, 0),
		 137      -     new BlockLocation(2, 3, 2),
		 138      -     new BlockLocation(1, 2, 2),
		 139      -     new BlockLocation(2, 2, 2),
		 140      -     new BlockLocation(3, 2, 2),
		 141      -     new BlockLocation(0, 2, 1),
		 142      -     new BlockLocation(4, 2, 1),
		 143      -   ];
		 144      -   const fenceGatesOpen = [new BlockLocation(3, 3, 1), new BlockLocation(1, 3, 1)];
		 145  246   
		      247 + GameTest.register("RedstoneTests", "torch_monostable_bedrock", (test) => {
		 146      -   test
		 147      -     .startSequence()
		 148      -     .thenIdle(2)
		      248 +   const testEx = new GameTestExtensions(test);
		      249 +   const input = new BlockLocation(0, 2, 0);
		      250 +   const output = new BlockLocation(2, 2, 1);
		      251 + 
		      252 +   test.pressButton(input);
		      253 + 
		      254 +   test
		      255 +     .startSequence()
		      256 +     .thenWait(() => {
		      257 +       testEx.assertBlockProperty("open_bit", 0, output);
		 149      -     .thenExecute(() => {
		 150      -       for (const lever of levers) {
		 151      -         test.pullLever(lever);
		 152      -       }
		 153      -     })
		 154      -     .thenIdle(6)
		 155      -     .thenExecute(() => {
		 156      -       for (const fenceGateC of fenceGatesClosed) {
		 157      -         testEx.assertBlockProperty("open_bit", 0, fenceGateC);
		 158      -       }
		 159  258       })
		      259 +     .thenWait(() => {
		 160      -     .thenExecute(() => {
		 161      -       for (const fenceGateO of fenceGatesOpen) {
		 162      -         testEx.assertBlockProperty("open_bit", 1, fenceGateO);
		      260 +       testEx.assertBlockProperty("open_bit", 1, output);
		 163      -       }
		 164  261       })
		 165      -     .thenSucceed();
		 166      - }).tag(GameTest.Tags.suiteDefault);
		 167      - 
		      262 +     .thenExecute(() => {
		      263 +       test.failIf(() => {
		      264 +         testEx.assertBlockProperty("open_bit", 0, output);
		      265 +       });
		      266 +     })
		      267 +     .thenWait(() => {
		      268 +       testEx.assertBlockProperty("button_pressed_bit", 0, input);
		      269 +     })
		      270 +     .thenSucceed();
		      271 + })
		      272 +   .setupTicks(2)
		      273 +   .tag(GameTest.Tags.suiteDefault);
		 168      - GameTest.register("RedstoneTests", "repeater_regeneration", (test) => {
		 169      -   const testEx = new GameTestExtensions(test);
		 170      -   const input = new BlockLocation(0, 2, 0);
		 171      -   const inactiveOutput = new BlockLocation(6, 3, 4);
		 172      -   const activeOutput = new BlockLocation(6, 3, 3);
		 173      - 
		 174      -   test.setBlockType(MinecraftBlockTypes.redstoneBlock, input);
		 175      -   test.succeedOnTickWhen(2, () => {
		 176      -     testEx.assertBlockProperty("open_bit", 0, inactiveOutput);
		 177      -     testEx.assertBlockProperty("open_bit", 1, activeOutput);
		 178      -   });
		 179      - }).tag(GameTest.Tags.suiteDefault);
		 180  274   
		      275 + GameTest.register("RedstoneTests", "wire_redirect", (test) => {
		 181      - GameTest.register("RedstoneTests", "repeater_lock", (test) => {
		 182  276     const testEx = new GameTestExtensions(test);
		      277 +   const levers = [new BlockLocation(6, 2, 1), new BlockLocation(3, 2, 0), new BlockLocation(0, 2, 1)];
		      278 +   const wires = [new BlockLocation(5, 2, 4), new BlockLocation(3, 2, 4), new BlockLocation(1, 2, 4)];
		      279 +   const fenceGates = [
		 183      -   const input = new BlockLocation(0, 2, 2);
		      280 +     new BlockLocation(5, 3, 1),
		      281 +     new BlockLocation(5, 3, 3),
		      282 +     new BlockLocation(3, 3, 1),
		      283 +     new BlockLocation(3, 3, 3),
		      284 +     new BlockLocation(1, 3, 1),
		      285 +     new BlockLocation(1, 3, 3),
		      286 +   ];
		 184      -   const lock = new BlockLocation(1, 2, 0);
		 185      -   const output = new BlockLocation(2, 2, 1);
		 186      - 
		 187      -   test.setBlockType(MinecraftBlockTypes.redstoneBlock, input);
		 188      - 
		 189      -   test
		 190      -     .startSequence()
		 191  287   
		      288 +   test
		 192      -     .thenIdle(2)
		 193      -     .thenExecute(() => {
		 194      -       testEx.assertBlockProperty("open_bit", 1, output);
		      289 +     .startSequence()
		 195      -     })
		 196  290       .thenExecute(() => {
		      291 +       for (const lever of levers) {
		      292 +         test.pullLever(lever);
		 197      -       test.setBlockType(MinecraftBlockTypes.redstoneBlock, lock);
		 198      -       test.setBlockType(MinecraftBlockTypes.air, input);
		      293 +       }
		 199      -       testEx.assertBlockProperty("open_bit", 1, output);
		 200  294       })
		      295 +     .thenIdle(6)
		      296 +     .thenExecute(() => {
		      297 +       for (const wire of wires) {
		      298 +         test.assertRedstonePower(wire, 0);
		      299 +       }
		 201      -     .thenExecuteAfter(2, () => {
		 202      -       test.setBlockType(MinecraftBlockTypes.air, lock);
		 203  300       })
		 204      -     .thenIdle(4)
		 205  301       .thenExecute(() => {
		      302 +       for (const fenceGate of fenceGates) {
		      303 +         testEx.assertBlockProperty("in_wall_bit", 0, fenceGate);
		      304 +       }
		 206      -       testEx.assertBlockProperty("open_bit", 0, output);
		 207  305       })
		 208  306       .thenSucceed();
		      307 + })
		      308 +   .tag("suite:java_parity")
		      309 +   .tag(GameTest.Tags.suiteDisabled); //Floating fence gates are powered differently
		 209      - }).tag(GameTest.Tags.suiteDefault);
		 210  310   
		      311 + GameTest.register("RedstoneTests", "wire_redirect_bedrock", (test) => {
		 211      - GameTest.register("RedstoneTests", "torch_monostable", (test) => {
		 212  312     const testEx = new GameTestExtensions(test);
		      313 +   const levers = [new BlockLocation(6, 2, 1), new BlockLocation(3, 2, 0), new BlockLocation(0, 2, 1)];
		      314 +   const wires = [new BlockLocation(5, 2, 4), new BlockLocation(3, 2, 4), new BlockLocation(1, 2, 4)];
		 213      -   const input = new BlockLocation(0, 2, 0);
		      315 +   const fenceGates = [
		      316 +     new BlockLocation(5, 3, 1),
		      317 +     new BlockLocation(5, 3, 3),
		      318 +     new BlockLocation(3, 3, 1),
		      319 +     new BlockLocation(3, 3, 3),
		      320 +     new BlockLocation(1, 3, 1),
		      321 +     new BlockLocation(1, 3, 3),
		      322 +   ];
		      323 + 
		      324 +   test
		      325 +     .startSequence()
		 214      -   const output = new BlockLocation(2, 2, 1);
		 215      - 
		 216      -   test.pressButton(input);
		 217      -   test
		 218      -     .startSequence()
		 219      -     .thenWaitUntil(2, () => {
		 220      -       testEx.assertBlockProperty("open_bit", 0, output);
		 221      -     })
		 222      -     .thenWaitUntil(2, () => {
		 223      -       testEx.assertBlockProperty("open_bit", 1, output);
		 224      -     })
		 225  326       .thenExecute(() => {
		      327 +       for (const lever of levers) {
		      328 +         test.pullLever(lever);
		 226      -       test.failIf(() => {
		 227      -         testEx.assertBlockProperty("open_bit", 0, output);
		      329 +       }
		 228      -       });
		 229  330       })
		      331 +     .thenIdle(6)
		      332 +     .thenExecute(() => {
		      333 +       for (const wire of wires) {
		      334 +         test.assertRedstonePower(wire, 0);
		      335 +       }
		 230      -     .thenWait(() => {
		 231      -       testEx.assertBlockProperty("button_pressed_bit", 0, input);
		 232  336       })
		      337 +     .thenExecute(() => {
		 233      -     .thenSucceed();
		 234      - })
		 235      -   .tag("suite:java_parity")
		      338 +       for (const fenceGate of fenceGates) {
		      339 +         testEx.assertBlockProperty("in_wall_bit", 0, fenceGate);
		      340 +       }
		      341 +     })
		      342 +     .thenSucceed();
		      343 + }).tag(GameTest.Tags.suiteDefault);
		 236      -   .tag(GameTest.Tags.suiteDisabled); // there are tick delay differences between Java and Bedrock.
		 237      - 
		 238      - GameTest.register("RedstoneTests", "torch_monostable_bedrock", (test) => {
		 239      -   const testEx = new GameTestExtensions(test);
		 240      -   const input = new BlockLocation(0, 2, 0);
		 241      -   const output = new BlockLocation(2, 2, 1);
		 242  344   
		 243      -   test
		 244      -     .startSequence()
		 245      -     .thenIdle(2)
		      345 + let observerClock = (test, initialOpenBit) => {
		      346 +   const testEx = new GameTestExtensions(test);
		      347 +   const outputPos = new BlockLocation(2, 2, 0);
		      348 + 
		      349 +   const blockPermutation = MinecraftBlockTypes.trapdoor.createDefaultBlockPermutation();
		      350 +   blockPermutation.getProperty(BlockProperties.openBit).value = initialOpenBit;
		      351 + 
		      352 +   test.setBlockPermutation(blockPermutation, outputPos);
		      353 + 
		      354 +   let sequence = test.startSequence();
		      355 + 
		      356 +   sequence.thenWait(() => {
		      357 +     testEx.assertBlockProperty("open_bit", 1, outputPos);
		      358 +   });
		      359 + 
		      360 +   for (let i = 0; i < 8; i++) {
		      361 +     sequence
		      362 +       .thenWait(() => {
		      363 +         testEx.assertBlockProperty("open_bit", 0, outputPos);
		      364 +       })
		      365 +       .thenWait(() => {
		      366 +         testEx.assertBlockProperty("open_bit", 1, outputPos);
		      367 +       });
		      368 +   }
		      369 +   sequence.thenSucceed();
		      370 + };
		      371 + 
		      372 + GameTest.register("RedstoneTests", "observer_clock", (test) => observerClock(test, false))
		      373 +   .tag("suite:java_parity") // Trapdoors do not always flip open from observer redstone signal when starting closed
		      374 +   .tag(GameTest.Tags.suiteDisabled);
		      375 + 
		      376 + GameTest.register("RedstoneTests", "observer_clock_bedrock", (test) => observerClock(test, true))
		      377 +   .structureName("RedstoneTests:observer_clock")
		      378 +   .tag(GameTest.Tags.suiteDefault);
		 246      -     .thenWait(() => {
		 247      -       test.pressButton(input);
		 248      -     })
		 249      -     .thenIdle(1)
		 250      -     .thenExecute(() => {
		 251      -       testEx.assertBlockProperty("open_bit", 0, output);
		 252      -     })
		 253      -     .thenIdle(2)
		 254      -     .thenWait(() => {
		 255      -       testEx.assertBlockProperty("open_bit", 1, output);
		 256      -     })
		 257      -     .thenExecute(() => {
		 258      -       test.failIf(() => {
		 259      -         testEx.assertBlockProperty("open_bit", 0, output);
		 260      -       });
		 261      -     })
		 262      -     .thenWait(() => {
		 263      -       testEx.assertBlockProperty("button_pressed_bit", 0, input);
		 264      -     })
		 265      -     .thenSucceed();
		 266      - }).tag(GameTest.Tags.suiteDefault);
		 267      - 
		 268      - GameTest.register("RedstoneTests", "wire_redirect", (test) => {
		 269      -   const testEx = new GameTestExtensions(test);
		 270      -   const levers = [new BlockLocation(6, 2, 1), new BlockLocation(3, 2, 0), new BlockLocation(0, 2, 1)];
		 271      -   const wires = [new BlockLocation(5, 2, 4), new BlockLocation(3, 2, 4), new BlockLocation(1, 2, 4)];
		 272      -   const fenceGates = [
		 273      -     new BlockLocation(5, 3, 1),
		 274      -     new BlockLocation(5, 3, 3),
		 275      -     new BlockLocation(3, 3, 1),
		 276      -     new BlockLocation(3, 3, 3),
		 277      -     new BlockLocation(1, 3, 1),
		 278      -     new BlockLocation(1, 3, 3),
		 279      -   ];
		 280  379   
		 281      -   test
		 282      -     .startSequence()
		 283      -     .thenExecute(() => {
		      380 + GameTest.register("RedstoneTests", "repeater_delay_lines", (test) => {
		      381 +   const inputPos = new BlockLocation(0, 2, 0);
		      382 + 
		      383 +   const linesPos = [
		      384 +     [new BlockLocation(4, 2, 1), new BlockLocation(4, 2, 2), new BlockLocation(4, 2, 3), new BlockLocation(4, 2, 4)], //4-tick delay
		      385 +     [new BlockLocation(3, 2, 1), new BlockLocation(3, 2, 2), new BlockLocation(3, 2, 3), new BlockLocation(3, 2, 4)], //3-tick delay
		      386 +     [new BlockLocation(2, 2, 1), new BlockLocation(2, 2, 2), new BlockLocation(2, 2, 3), new BlockLocation(2, 2, 4)], //2-tick delay
		      387 +     [new BlockLocation(1, 2, 1), new BlockLocation(1, 2, 2), new BlockLocation(1, 2, 3), new BlockLocation(1, 2, 4)], //1-tick delay
		      388 +   ];
		      389 + 
		      390 +   const states = [
		      391 +     "XXX0",
		      392 +     "XX01",
		      393 +     "X002",
		      394 +     "0013",
		      395 +     "001X",
		      396 +     "012X",
		      397 +     null,
		      398 +     "113X",
		      399 +     "123X",
		      400 +     "12XX",
		      401 +     null,
		      402 +     "23XX",
		      403 +     null,
		      404 +     null,
		      405 +     "2XXX",
		      406 +     "3XXX",
		      407 +     null,
		      408 +     null,
		      409 +     null,
		      410 +     "XXXX",
		 284      -       for (const lever of levers) {
		 285      -         test.pullLever(lever);
		 286      -       }
		 287      -     })
		 288      -     .thenIdle(6)
		 289      -     .thenExecute(() => {
		 290      -       for (const wire of wires) {
		 291      -         test.assertRedstonePower(wire, 0);
		 292      -       }
		 293      -     })
		 294      -     .thenExecute(() => {
		 295      -       for (const fenceGate of fenceGates) {
		 296      -         testEx.assertBlockProperty("in_wall_bit", 0, fenceGate);
		 297      -       }
		 298      -     })
		 299      -     .thenSucceed();
		 300      - })
		 301      -   .tag("suite:java_parity")
		 302      -   .tag(GameTest.Tags.suiteDisabled); //Floating fence gates are powered differently
		 303      - 
		 304      - GameTest.register("RedstoneTests", "wire_redirect_bedrock", (test) => {
		 305      -   const testEx = new GameTestExtensions(test);
		 306      -   const levers = [new BlockLocation(6, 2, 1), new BlockLocation(3, 2, 0), new BlockLocation(0, 2, 1)];
		 307      -   const wires = [new BlockLocation(5, 2, 4), new BlockLocation(3, 2, 4), new BlockLocation(1, 2, 4)];
		 308      -   const fenceGates = [
		 309      -     new BlockLocation(5, 3, 1),
		 310      -     new BlockLocation(5, 3, 3),
		 311      -     new BlockLocation(3, 3, 1),
		 312      -     new BlockLocation(3, 3, 3),
		 313      -     new BlockLocation(1, 3, 1),
		 314      -     new BlockLocation(1, 3, 3),
		 315  411     ];
		      412 + 
		      413 +   test.pulseRedstone(inputPos, 3);
		 316  414   
		      415 +   let sequence = test.startSequence();
		      416 +   for (const state of states) {
		      417 +     if (state == null) {
		      418 +       sequence = sequence.thenIdle(2);
		      419 +     } else {
		      420 +       sequence = sequence.thenWaitAfter(2, () => {
		      421 +         for (let line = 0; line < 4; line++) {
		      422 +           const expected = state.charAt(line);
		      423 +           const expectedPos = expected == "X" ? -1 : expected - "0";
		      424 +           for (let linePos = 0; linePos < 4; linePos++) {
		      425 +             const blockWorldPos = test.worldBlockLocation(linesPos[line][linePos]);
		      426 +             const block = World.getDimension("overworld").getBlock(blockWorldPos);
		      427 +             const blockId = block.id;
		      428 + 
		      429 +             if (linePos == expectedPos) {
		      430 +               test.assert(
		      431 +                 blockId == "minecraft:powered_repeater",
		      432 +                 "Unexpected Block State. Expected: powered. Actual: unpowered"
		      433 +               );
		      434 +             } else {
		      435 +               test.assert(
		      436 +                 blockId == "minecraft:unpowered_repeater",
		      437 +                 "Unexpected Block State. Expected: unpowered. Actual: powered"
		      438 +               );
		      439 +             }
		      440 +           }
		      441 +         }
		      442 +       });
		      443 +     }
		      444 +   }
		      445 +   sequence.thenSucceed();
		      446 + })
		      447 +   .tag("suite:java_parity")
		      448 +   .tag(GameTest.Tags.suiteDisabled); //The speed of the redstone pulse is different between Java and Bedrock.
		 317      -   test
		 318      -     .startSequence()
		 319      -     .thenExecute(() => {
		 320      -       for (const lever of levers) {
		 321      -         test.pullLever(lever);
		 322      -       }
		 323      -     })
		 324      -     .thenIdle(6)
		 325      -     .thenExecute(() => {
		 326      -       for (const wire of wires) {
		 327      -         test.assertRedstonePower(wire, 0);
		 328      -       }
		 329      -     })
		 330      -     .thenExecute(() => {
		 331      -       for (const fenceGate of fenceGates) {
		 332      -         testEx.assertBlockProperty("in_wall_bit", 0, fenceGate);
		 333      -       }
		 334      -     })
		 335      -     .thenSucceed();
		 336      - }).tag(GameTest.Tags.suiteDefault);
		 337      - 
		 338      - let observerClock = (test, initialOpenBit) => {
		 339      -   const testEx = new GameTestExtensions(test);
		 340      -   const outputPos = new BlockLocation(2, 2, 0);
		 341      - 
		 342      -   const blockPermutation = MinecraftBlockTypes.trapdoor.createDefaultBlockPermutation();
		 343      -   blockPermutation.getProperty(BlockProperties.openBit).value = initialOpenBit;
		 344      - 
		 345      -   test.setBlockPermutation(blockPermutation, outputPos);
		 346      - 
		 347      -   let sequence = test.startSequence();
		 348  449   
		      450 + GameTest.register("RedstoneTests", "repeater_delay_lines_bedrock", (test) => {
		 349      -   sequence.thenWait(() => {
		 350      -     testEx.assertBlockProperty("open_bit", 1, outputPos);
		      451 +   const inputPos = new BlockLocation(0, 2, 0);
		 351      -   });
		 352  452   
		      453 +   const linesPos = [
		      454 +     [new BlockLocation(4, 2, 1), new BlockLocation(4, 2, 2), new BlockLocation(4, 2, 3), new BlockLocation(4, 2, 4)], //4-tick delay
		 353      -   for (let i = 0; i < 8; i++) {
		 354      -     sequence
		      455 +     [new BlockLocation(3, 2, 1), new BlockLocation(3, 2, 2), new BlockLocation(3, 2, 3), new BlockLocation(3, 2, 4)], //3-tick delay
		      456 +     [new BlockLocation(2, 2, 1), new BlockLocation(2, 2, 2), new BlockLocation(2, 2, 3), new BlockLocation(2, 2, 4)], //2-tick delay
		      457 +     [new BlockLocation(1, 2, 1), new BlockLocation(1, 2, 2), new BlockLocation(1, 2, 3), new BlockLocation(1, 2, 4)], //1-tick delay
		      458 +   ];
		      459 + 
		      460 +   const states = [
		      461 +     "XXX0",
		      462 +     "XX01",
		      463 +     "X002",
		      464 +     "0013",
		      465 +     "001X",
		      466 +     "012X",
		      467 +     null,
		      468 +     "113X",
		      469 +     "123X",
		      470 +     "12XX",
		      471 +     null,
		      472 +     "23XX",
		      473 +     null,
		      474 +     null,
		      475 +     "2XXX",
		      476 +     "3XXX",
		      477 +     null,
		      478 +     null,
		      479 +     null,
		      480 +     "XXXX",
		 355      -       .thenWait(() => {
		 356      -         testEx.assertBlockProperty("open_bit", 0, outputPos);
		 357      -       })
		 358      -       .thenWait(() => {
		 359      -         testEx.assertBlockProperty("open_bit", 1, outputPos);
		 360      -       });
		 361      -   }
		 362      -   sequence.thenSucceed();
		 363      - };
		 364      - 
		 365      - GameTest.register("RedstoneTests", "observer_clock", (test) => observerClock(test, false))
		 366      -   .tag("suite:java_parity") // Trapdoors do not always flip open from observer redstone signal when starting closed
		 367      -   .tag(GameTest.Tags.suiteDisabled);
		 368      - 
		 369      - GameTest.register("RedstoneTests", "observer_clock_bedrock", (test) => observerClock(test, true))
		 370      -   .structureName("RedstoneTests:observer_clock")
		 371      -   .tag(GameTest.Tags.suiteDefault);
		 372      - 
		 373      - GameTest.register("RedstoneTests", "repeater_delay_lines", (test) => {
		 374      -   const inputPos = new BlockLocation(0, 2, 0);
		 375      - 
		 376      -   const linesPos = [
		 377      -     [new BlockLocation(4, 2, 1), new BlockLocation(4, 2, 2), new BlockLocation(4, 2, 3), new BlockLocation(4, 2, 4)], //4-tick delay
		 378      -     [new BlockLocation(3, 2, 1), new BlockLocation(3, 2, 2), new BlockLocation(3, 2, 3), new BlockLocation(3, 2, 4)], //3-tick delay
		 379      -     [new BlockLocation(2, 2, 1), new BlockLocation(2, 2, 2), new BlockLocation(2, 2, 3), new BlockLocation(2, 2, 4)], //2-tick delay
		 380      -     [new BlockLocation(1, 2, 1), new BlockLocation(1, 2, 2), new BlockLocation(1, 2, 3), new BlockLocation(1, 2, 4)], //1-tick delay
		 381  481     ];
		      482 + 
		      483 +   test.pulseRedstone(inputPos, 3); //Change redstone pulse form 2 ticks to 3.
		 382  484   
		      485 +   let sequence = test.startSequence();
		      486 +   for (const state of states) {
		 383      -   const states = [
		      487 +     if (state == null) {
		      488 +       sequence = sequence.thenIdle(2);
		      489 +     } else {
		      490 +       sequence = sequence.thenWait(() => {
		      491 +         for (let line = 0; line < 4; line++) {
		      492 +           const expected = state.charAt(line);
		      493 +           const expectedPos = expected == "X" ? -1 : expected - "0";
		      494 +           for (let linePos = 0; linePos < 4; linePos++) {
		      495 +             const blockWorldPos = test.worldBlockLocation(linesPos[line][linePos]);
		      496 +             const block = World.getDimension("overworld").getBlock(blockWorldPos);
		      497 +             const blockPerm = block.permutation;
		      498 +             const blockType = blockPerm.type;
		      499 + 
		      500 +             if (linePos == expectedPos) {
		      501 +               test.assert(
		      502 +                 blockType.id == "minecraft:powered_repeater",
		      503 +                 "Unexpected Block State. Expected: powered. Actual: unpowered"
		      504 +               );
		      505 +             } else {
		      506 +               test.assert(
		      507 +                 blockType.id == "minecraft:unpowered_repeater",
		      508 +                 "Unexpected Block State. Expected: unpowered. Actual: powered"
		      509 +               );
		      510 +             }
		      511 +           }
		      512 +         }
		      513 +       });
		      514 +     }
		      515 +   }
		      516 +   sequence.thenSucceed();
		      517 + })
		      518 +   .structureName("RedstoneTests:repeater_delay_lines")
		      519 +   .tag(GameTest.Tags.suiteDefault);
		      520 + 
		      521 + GameTest.register("RedstoneTests", "repeater_clock", (test) => {
		      522 +   const testEx = new GameTestExtensions(test);
		      523 +   const startPos = new BlockLocation(0, 4, 0);
		      524 +   const stagesPos = [
		      525 +     new BlockLocation(0, 1, 0),
		      526 +     new BlockLocation(2, 1, 0),
		      527 +     new BlockLocation(2, 1, 2),
		      528 +     new BlockLocation(0, 1, 2),
		      529 +   ];
		      530 + 
		      531 +   test.pulseRedstone(startPos, 3);
		      532 + 
		      533 +   let sequence = test.startSequence();
		      534 +   for (let i = 0; i < 32; i++) {
		      535 +     const active = i % 4;
		      536 +     sequence = sequence.thenWaitAfter(i == 0 ? 0 : 2, () => {
		      537 +       for (let b = 0; b < 4; b++) {
		      538 +         testEx.assertBlockProperty("open_bit", b == active ? 1 : 0, stagesPos[b]);
		      539 +       }
		      540 +     });
		 384      -     "XXX0",
		 385      -     "XX01",
		 386      -     "X002",
		 387      -     "0013",
		 388      -     "001X",
		 389      -     "012X",
		 390      -     null,
		 391      -     "113X",
		 392      -     "123X",
		 393      -     "12XX",
		 394      -     null,
		 395      -     "23XX",
		 396      -     null,
		 397      -     null,
		 398      -     "2XXX",
		 399      -     "3XXX",
		 400      -     null,
		 401      -     null,
		 402      -     null,
		 403      -     "XXXX",
		 404      -   ];
		 405      - 
		 406      -   test.pulseRedstone(inputPos, 3);
		 407      - 
		 408      -   let sequence = test.startSequence();
		 409      -   for (const state of states) {
		 410      -     if (state == null) {
		 411      -       sequence = sequence.thenIdle(2);
		 412      -     } else {
		 413      -       sequence = sequence.thenWaitWithDelay(2, () => {
		 414      -         for (let line = 0; line < 4; line++) {
		 415      -           const expected = state.charAt(line);
		 416      -           const expectedPos = expected == "X" ? -1 : expected - "0";
		 417      -           for (let linePos = 0; linePos < 4; linePos++) {
		 418      -             const blockWorldPos = test.worldBlockLocation(linesPos[line][linePos]);
		 419      -             const block = World.getDimension("overworld").getBlock(blockWorldPos);
		 420      -             const blockPerm = block.getBlockData();
		 421      -             const blockType = blockPerm.getType();
		 422      - 
		 423      -             if (linePos == expectedPos) {
		 424      -               test.assert(
		 425      -                 blockType.getName() == "minecraft:powered_repeater",
		 426      -                 "Unexpected Block State. Expected: powered. Actual: unpowered"
		 427      -               );
		 428      -             } else {
		 429      -               test.assert(
		 430      -                 blockType.getName() == "minecraft:unpowered_repeater",
		 431      -                 "Unexpected Block State. Expected: unpowered. Actual: powered"
		 432      -               );
		 433      -             }
		 434      -           }
		 435      -         }
		 436      -       });
		 437      -     }
		 438  541     }
		 439  542     sequence.thenSucceed();
		 440  543   })
		 441  544     .tag("suite:java_parity")
		 442  545     .tag(GameTest.Tags.suiteDisabled); //The speed of the redstone pulse is different between Java and Bedrock.
		 443      - 
		 444      - GameTest.register("RedstoneTests", "repeater_delay_lines_bedrock", (test) => {
		 445      -   const inputPos = new BlockLocation(0, 2, 0);
		 446  546   
		      547 + GameTest.register("RedstoneTests", "repeater_clock_bedrock", (test) => {
		      548 +   const testEx = new GameTestExtensions(test);
		      549 +   const startPos = new BlockLocation(0, 4, 0);
		      550 +   const stagesPos = [
		      551 +     new BlockLocation(0, 1, 0),
		      552 +     new BlockLocation(2, 1, 0),
		      553 +     new BlockLocation(2, 1, 2),
		      554 +     new BlockLocation(0, 1, 2),
		 447      -   const linesPos = [
		 448      -     [new BlockLocation(4, 2, 1), new BlockLocation(4, 2, 2), new BlockLocation(4, 2, 3), new BlockLocation(4, 2, 4)], //4-tick delay
		 449      -     [new BlockLocation(3, 2, 1), new BlockLocation(3, 2, 2), new BlockLocation(3, 2, 3), new BlockLocation(3, 2, 4)], //3-tick delay
		 450      -     [new BlockLocation(2, 2, 1), new BlockLocation(2, 2, 2), new BlockLocation(2, 2, 3), new BlockLocation(2, 2, 4)], //2-tick delay
		 451      -     [new BlockLocation(1, 2, 1), new BlockLocation(1, 2, 2), new BlockLocation(1, 2, 3), new BlockLocation(1, 2, 4)], //1-tick delay
		 452  555     ];
		      556 + 
		      557 +   test.pulseRedstone(startPos, 3); //Change redstone pulse form 2 ticks to 3.
		 453  558   
		      559 +   let sequence = test.startSequence();
		 454      -   const states = [
		 455      -     "XXX0",
		 456      -     "XX01",
		      560 +   for (let i = 0; i < 32; i++) {
		      561 +     const active = i % 4;
		      562 +     sequence = sequence.thenWait(() => {
		      563 +       for (let b = 0; b < 4; b++) {
		      564 +         testEx.assertBlockProperty("open_bit", b == active ? 1 : 0, stagesPos[b]);
		      565 +       }
		      566 +     });
		      567 +   }
		      568 +   sequence.thenSucceed();
		      569 + })
		      570 +   .structureName("RedstoneTests:repeater_clock")
		      571 +   .maxTicks(80)
		      572 +   .tag(GameTest.Tags.suiteDefault);
		      573 + 
		      574 + GameTest.register("RedstoneTests", "torch_nor", (test) => {
		      575 +   const testEx = new GameTestExtensions(test);
		      576 +   const inputA = new BlockLocation(4, 2, 0);
		      577 +   const inputB = new BlockLocation(0, 2, 0);
		      578 +   const output = new BlockLocation(2, 3, 0);
		      579 +   const FlatNorthSouth = 0;
		      580 +   const FlatEastWest = 1;
		 457      -     "X002",
		 458      -     "0013",
		 459      -     "001X",
		 460      -     "012X",
		 461      -     null,
		 462      -     "113X",
		 463      -     "123X",
		 464      -     "12XX",
		 465      -     null,
		 466      -     "23XX",
		 467      -     null,
		 468      -     null,
		 469      -     "2XXX",
		 470      -     "3XXX",
		 471      -     null,
		 472      -     null,
		 473      -     null,
		 474      -     "XXXX",
		 475      -   ];
		 476      - 
		 477      -   test.pulseRedstone(inputPos, 3); //Change redstone pulse form 2 ticks to 3.
		 478  581   
		      582 +   test
		      583 +     .startSequence()
		      584 +     .thenExecute(() => test.pullLever(inputA))
		      585 +     .thenIdle(2)
		      586 +     .thenWait(() => {
		      587 +       testEx.assertBlockProperty("open_bit", FlatEastWest, output);
		      588 +     })
		      589 +     .thenExecute(() => test.pullLever(inputA))
		      590 +     .thenIdle(2)
		      591 +     .thenWait(() => {
		      592 +       testEx.assertBlockProperty("open_bit", FlatEastWest, output);
		      593 +     })
		      594 + 
		      595 +     .thenExecute(() => test.pullLever(inputB))
		      596 +     .thenIdle(2)
		      597 +     .thenWait(() => {
		      598 +       testEx.assertBlockProperty("open_bit", FlatNorthSouth, output);
		      599 +     })
		      600 +     .thenExecute(() => test.pullLever(inputB))
		      601 +     .thenIdle(2)
		      602 +     .thenWait(() => {
		      603 +       testEx.assertBlockProperty("open_bit", FlatEastWest, output);
		      604 +     })
		      605 + 
		      606 +     .thenExecute(() => {
		      607 +       test.pullLever(inputA);
		      608 +       test.pullLever(inputB);
		      609 +     })
		      610 + 
		      611 +     .thenIdle(2)
		      612 +     .thenWait(() => {
		      613 +       testEx.assertBlockProperty("open_bit", FlatNorthSouth, output);
		      614 +     })
		      615 +     .thenExecute(() => {
		      616 +       test.pullLever(inputA);
		      617 +       test.pullLever(inputB);
		      618 +     })
		      619 +     .thenIdle(2)
		      620 +     .thenWait(() => {
		      621 +       testEx.assertBlockProperty("open_bit", FlatEastWest, output);
		      622 +     })
		      623 +     .thenSucceed();
		      624 + }).tag(GameTest.Tags.suiteDefault);
		      625 + 
		      626 + GameTest.register("RedstoneTests", "rs_latch", (test) => {
		      627 +   const testEx = new GameTestExtensions(test);
		      628 +   const r = new BlockLocation(1, 2, 0);
		      629 +   const s = new BlockLocation(2, 2, 5);
		 479      -   let sequence = test.startSequence();
		 480      -   for (const state of states) {
		 481      -     if (state == null) {
		 482      -       sequence = sequence.thenIdle(2);
		 483      -     } else {
		 484      -       sequence = sequence.thenIdle(2).thenExecute(() => {
		 485      -         for (let line = 0; line < 4; line++) {
		 486      -           const expected = state.charAt(line);
		 487      -           const expectedPos = expected == "X" ? -1 : expected - "0";
		 488      -           for (let linePos = 0; linePos < 4; linePos++) {
		 489      -             const blockWorldPos = test.worldBlockLocation(linesPos[line][linePos]);
		 490      -             const block = World.getDimension("overworld").getBlock(blockWorldPos);
		 491      -             const blockPerm = block.getBlockData();
		 492      -             const blockType = blockPerm.getType();
		 493      - 
		 494      -             if (linePos == expectedPos) {
		 495      -               test.assert(
		 496      -                 blockType.getName() == "minecraft:powered_repeater",
		 497      -                 "Unexpected Block State. Expected: powered. Actual: unpowered"
		 498      -               );
		 499      -             } else {
		 500      -               test.assert(
		 501      -                 blockType.getName() == "minecraft:unpowered_repeater",
		 502      -                 "Unexpected Block State. Expected: unpowered. Actual: powered"
		 503      -               );
		 504      -             }
		 505      -           }
		 506      -         }
		 507      -       });
		 508      -     }
		 509      -   }
		 510      -   sequence.thenSucceed();
		 511      - })
		 512      -   .structureName("RedstoneTests:repeater_delay_lines")
		 513      -   .tag(GameTest.Tags.suiteDefault);
		 514      - 
		 515      - GameTest.register("RedstoneTests", "repeater_clock", (test) => {
		 516      -   const testEx = new GameTestExtensions(test);
		 517      -   const startPos = new BlockLocation(0, 4, 0);
		 518      -   const stagesPos = [
		 519      -     new BlockLocation(0, 1, 0),
		 520      -     new BlockLocation(2, 1, 0),
		 521      -     new BlockLocation(2, 1, 2),
		 522      -     new BlockLocation(0, 1, 2),
		 523      -   ];
		 524  630   
		      631 +   const q = new BlockLocation(0, 4, 2);
		      632 +   const notQ = new BlockLocation(3, 4, 3);
		 525      -   test.pulseRedstone(startPos, 2);
		 526  633   
		      634 +   test
		      635 +     .startSequence()
		 527      -   let sequence = test.startSequence();
		 528      -   for (let i = 0; i < 32; i++) {
		      636 +     .thenExecute(() => test.pulseRedstone(r, 2))
		      637 +     .thenIdle(4)
		      638 +     .thenWait(() => {
		      639 +       testEx.assertBlockProperty("open_bit", 1, q);
		      640 +       testEx.assertBlockProperty("open_bit", 0, notQ);
		      641 +     })
		      642 +     .thenExecute(() => test.pulseRedstone(r, 2))
		      643 +     .thenExecuteAfter(4, () => {
		      644 +       testEx.assertBlockProperty("open_bit", 1, q);
		      645 +       testEx.assertBlockProperty("open_bit", 0, notQ);
		      646 +     })
		 529      -     const active = i % 4;
		 530      -     sequence = sequence.thenWaitWithDelay(i == 0 ? 0 : 2, () => {
		 531      -       for (let b = 0; b < 4; b++) {
		 532      -         testEx.assertBlockProperty("open_bit", b == active ? 1 : 0, stagesPos[b]);
		 533      -       }
		 534      -     });
		 535      -   }
		 536      -   sequence.thenSucceed();
		 537      - })
		 538      -   .tag("suite:java_parity")
		 539      -   .tag(GameTest.Tags.suiteDisabled); //The speed of the redstone pulse is different between Java and Bedrock.
		 540  647   
		 541      - GameTest.register("RedstoneTests", "repeater_clock_bedrock", (test) => {
		 542      -   const testEx = new GameTestExtensions(test);
		 543      -   const startPos = new BlockLocation(0, 4, 0);
		      648 +     .thenExecute(() => test.pulseRedstone(s, 2))
		      649 +     .thenIdle(4)
		      650 +     .thenWait(() => {
		      651 +       testEx.assertBlockProperty("open_bit", 0, q);
		      652 +       testEx.assertBlockProperty("open_bit", 1, notQ);
		      653 +     })
		 544      -   const stagesPos = [
		 545      -     new BlockLocation(0, 1, 0),
		 546      -     new BlockLocation(2, 1, 0),
		 547      -     new BlockLocation(2, 1, 2),
		 548      -     new BlockLocation(0, 1, 2),
		 549      -   ];
		 550  654   
		      655 +     .thenExecute(() => test.pulseRedstone(s, 2))
		      656 +     .thenExecuteAfter(4, () => {
		      657 +       testEx.assertBlockProperty("open_bit", 0, q);
		      658 +       testEx.assertBlockProperty("open_bit", 1, notQ);
		 551      -   test.pulseRedstone(startPos, 3); //Change redstone pulse form 2 ticks to 3.
		 552      - 
		      659 +     })
		      660 +     .thenSucceed();
		      661 + })
		      662 +   .tag("suite:java_parity")
		      663 +   .tag(GameTest.Tags.suiteDisabled); // Redstone timing inconsistencies between java and bedrock.
		      664 + 
		      665 + GameTest.register("RedstoneTests", "rs_latch_bedrock", (test) => {
		      666 +   const testEx = new GameTestExtensions(test);
		      667 +   const r = new BlockLocation(1, 2, 0);
		      668 +   const s = new BlockLocation(2, 2, 5);
		      669 + 
		      670 +   const q = new BlockLocation(0, 4, 2);
		      671 +   const notQ = new BlockLocation(3, 4, 3);
		 553      -   let sequence = test.startSequence();
		 554      -   for (let i = 0; i < 32; i++) {
		 555      -     const active = i % 4;
		 556      -     sequence = sequence.thenIdle(2).thenExecute(() => {
		 557      -       for (let b = 0; b < 4; b++) {
		 558      -         testEx.assertBlockProperty("open_bit", b == active ? 1 : 0, stagesPos[b]);
		 559      -       }
		 560      -     });
		 561      -   }
		 562      -   sequence.thenSucceed();
		 563      - })
		 564      -   .structureName("RedstoneTests:repeater_clock")
		 565      -   .tag(GameTest.Tags.suiteDefault);
		 566  672   
		      673 +   test
		 567      - GameTest.register("RedstoneTests", "torch_nor", (test) => {
		 568      -   const testEx = new GameTestExtensions(test);
		      674 +     .startSequence()
		      675 +     .thenIdle(2)
		      676 +     .thenExecute(() => test.pulseRedstone(r, 4))
		      677 +     .thenIdle(6)
		      678 +     .thenWait(() => {
		      679 +       testEx.assertBlockProperty("open_bit", 0, q);
		      680 +       testEx.assertBlockProperty("open_bit", 1, notQ);
		      681 +     })
		      682 +     .thenExecute(() => test.pulseRedstone(r, 4))
		      683 +     .thenExecuteAfter(6, () => {
		      684 +       testEx.assertBlockProperty("open_bit", 0, q);
		      685 +       testEx.assertBlockProperty("open_bit", 1, notQ);
		 569      -   const inputA = new BlockLocation(4, 2, 0);
		 570      -   const inputB = new BlockLocation(0, 2, 0);
		 571      -   const output = new BlockLocation(2, 3, 0);
		 572      -   const FlatNorthSouth = 0;
		 573      -   const FlatEastWest = 1;
		 574      - 
		 575      -   test
		 576      -     .startSequence()
		 577      -     .thenExecute(() => test.pullLever(inputA))
		 578      -     .thenIdle(2)
		 579      -     .thenWait(() => {
		 580      -       testEx.assertBlockProperty("open_bit", FlatEastWest, output);
		 581  686       })
		      687 + 
		      688 +     .thenExecute(() => test.pulseRedstone(s, 4))
		 582      -     .thenExecute(() => test.pullLever(inputA))
		      689 +     .thenIdle(6)
		 583      -     .thenIdle(2)
		 584  690       .thenWait(() => {
		      691 +       testEx.assertBlockProperty("open_bit", 1, q);
		      692 +       testEx.assertBlockProperty("open_bit", 0, notQ);
		 585      -       testEx.assertBlockProperty("open_bit", FlatEastWest, output);
		 586  693       })
		 587  694   
		      695 +     .thenExecute(() => test.pulseRedstone(s, 4))
		      696 +     .thenExecuteAfter(6, () => {
		 588      -     .thenExecute(() => test.pullLever(inputB))
		 589      -     .thenIdle(2)
		      697 +       testEx.assertBlockProperty("open_bit", 1, q);
		      698 +       testEx.assertBlockProperty("open_bit", 0, notQ);
		 590      -     .thenWait(() => {
		 591      -       testEx.assertBlockProperty("open_bit", FlatNorthSouth, output);
		 592  699       })
		      700 +     .thenSucceed();
		      701 + }).tag(GameTest.Tags.suiteDefault);
		 593      -     .thenExecute(() => test.pullLever(inputB))
		 594      -     .thenIdle(2)
		      702 + 
		      703 + GameTest.register("RedstoneTests", "repeater_delay", (test) => {
		      704 +   test.setBlockType(MinecraftBlockTypes.stone, new BlockLocation(0, 2, 5));
		 595      -     .thenWait(() => {
		 596      -       testEx.assertBlockProperty("open_bit", FlatEastWest, output);
		 597      -     })
		 598  705   
		      706 +   const lamp1 = new BlockLocation(1, 2, 0);
		 599      -     .thenExecute(() => {
		 600      -       test.pullLever(inputA);
		 601      -       test.pullLever(inputB);
		      707 +   const lamp2 = new BlockLocation(3, 2, 0);
		 602      -     })
		 603  708   
		      709 +   test
		      710 +     .startSequence()
		 604      -     .thenIdle(2)
		 605  711       .thenWait(() => {
		      712 +       test.assertRedstonePower(lamp1, 15);
		      713 +     })
		      714 +     .thenExecute(() => {
		      715 +       test.assertRedstonePower(lamp2, 15);
		 606      -       testEx.assertBlockProperty("open_bit", FlatNorthSouth, output);
		 607  716       })
		      717 +     .thenWait(() => {
		 608      -     .thenExecute(() => {
		 609      -       test.pullLever(inputA);
		      718 +       test.assertRedstonePower(lamp1, 0);
		 610      -       test.pullLever(inputB);
		 611  719       })
		      720 +     .thenExecute(() => {
		 612      -     .thenIdle(2)
		 613      -     .thenWait(() => {
		      721 +       test.assertRedstonePower(lamp2, 0);
		 614      -       testEx.assertBlockProperty("open_bit", FlatEastWest, output);
		 615  722       })
		 616  723       .thenSucceed();
		      724 + })
		      725 +   .maxTicks(TicksPerSecond * 10)
		      726 +   .tag("suite:java_parity")
		      727 +   .tag(GameTest.Tags.suiteDisabled); //The ticks of Redstone repeater is too short in structure, causing the Redstone lamp will not go out.
		 617      - }).tag(GameTest.Tags.suiteDefault);
		 618  728   
		      729 + GameTest.register("RedstoneTests", "repeater_delay_bedrock", (test) => {
		 619      - GameTest.register("RedstoneTests", "rs_latch", (test) => {
		 620      -   const testEx = new GameTestExtensions(test);
		 621      -   const r = new BlockLocation(1, 2, 0);
		      730 +   test.setBlockType(MinecraftBlockTypes.stone, new BlockLocation(0, 2, 5));
		 622      -   const s = new BlockLocation(2, 2, 5);
		 623  731   
		      732 +   const lamp1 = new BlockLocation(1, 2, 0);
		      733 +   const lamp2 = new BlockLocation(3, 2, 0);
		 624      -   const q = new BlockLocation(0, 4, 2);
		 625      -   const notQ = new BlockLocation(3, 4, 3);
		 626  734   
		 627  735     test
		 628  736       .startSequence()
		 629      -     .thenExecute(() => test.pulseRedstone(r, 2))
		 630      -     .thenIdle(4)
		 631  737       .thenWait(() => {
		      738 +       test.assertRedstonePower(lamp1, 15);
		 632      -       testEx.assertBlockProperty("open_bit", 1, q);
		 633      -       testEx.assertBlockProperty("open_bit", 0, notQ);
		 634  739       })
		      740 +     .thenExecute(() => {
		 635      -     .thenExecute(() => test.pulseRedstone(r, 2))
		 636      -     .thenExecuteAfter(4, () => {
		 637      -       testEx.assertBlockProperty("open_bit", 1, q);
		      741 +       test.assertRedstonePower(lamp2, 15);
		 638      -       testEx.assertBlockProperty("open_bit", 0, notQ);
		 639  742       })
		 640      - 
		 641      -     .thenExecute(() => test.pulseRedstone(s, 2))
		 642      -     .thenIdle(4)
		 643  743       .thenWait(() => {
		      744 +       test.assertRedstonePower(lamp1, 0);
		 644      -       testEx.assertBlockProperty("open_bit", 0, q);
		 645      -       testEx.assertBlockProperty("open_bit", 1, notQ);
		 646  745       })
		 647      - 
		 648      -     .thenExecute(() => test.pulseRedstone(s, 2))
		 649      -     .thenExecuteAfter(4, () => {
		      746 +     .thenExecute(() => {
		      747 +       test.assertRedstonePower(lamp2, 0);
		 650      -       testEx.assertBlockProperty("open_bit", 0, q);
		 651      -       testEx.assertBlockProperty("open_bit", 1, notQ);
		 652  748       })
		 653  749       .thenSucceed();
		 654      - }).tag(GameTest.Tags.suiteDisabled); // Redstone timing inconsistencies between java and bedrock.
		 655      - 
		 656      - GameTest.register("RedstoneTests", "rs_latch_bedrock", (test) => {
		      750 + })
		      751 +   .maxTicks(TicksPerSecond * 10)
		      752 +   .tag(GameTest.Tags.suiteDefault); //Change the ticks of Redstone repeater to the longest in structure.
		 657      -   const testEx = new GameTestExtensions(test);
		 658      -   const r = new BlockLocation(1, 2, 0);
		 659      -   const s = new BlockLocation(2, 2, 5);
		 660  753   
		      754 + function distManhattan(pos, loc) {
		      755 +   const xd = Math.abs(pos.x - loc.x);
		      756 +   const yd = Math.abs(pos.y - loc.y);
		 661      -   const q = new BlockLocation(0, 4, 2);
		      757 +   const zd = Math.abs(pos.z - loc.z);
		 662      -   const notQ = new BlockLocation(3, 4, 3);
		 663  758   
		      759 +   return xd + yd + zd;
		 664      -   test
		 665      -     .startSequence()
		 666      -     .thenIdle(2)
		      760 + }
		      761 + 
		      762 + GameTest.register("RedstoneTests", "dust_loop_depowering", (test) => {
		      763 +   const source = new BlockLocation(2, 2, 0);
		      764 +   const input = new BlockLocation(2, 2, 1);
		      765 +   const pointA = new BlockLocation(4, 2, 1);
		      766 +   const pointB = new BlockLocation(0, 2, 16);
		      767 +   const pointC = new BlockLocation(4, 2, 1);
		      768 +   const pointD = new BlockLocation(0, 2, 16);
		      769 + 
		      770 +   test.setBlockType(MinecraftBlockTypes.redstoneBlock, source);
		 667      -     .thenExecute(() => test.pulseRedstone(r, 4))
		 668      -     .thenIdle(6)
		 669      -     .thenWait(() => {
		 670      -       testEx.assertBlockProperty("open_bit", 0, q);
		 671      -       testEx.assertBlockProperty("open_bit", 1, notQ);
		 672      -     })
		 673      -     .thenExecute(() => test.pulseRedstone(r, 4))
		 674      -     .thenExecuteAfter(6, () => {
		 675      -       testEx.assertBlockProperty("open_bit", 0, q);
		 676      -       testEx.assertBlockProperty("open_bit", 1, notQ);
		 677      -     })
		 678  771   
		      772 +   pointA.blocksBetween(pointB).forEach((p) => {
		 679      -     .thenExecute(() => test.pulseRedstone(s, 4))
		 680      -     .thenIdle(6)
		      773 +     test.assertRedstonePower(p, Math.max(0, 15 - distManhattan(p, input)));
		      774 +   });
		      775 + 
		      776 +   test.setBlockType(MinecraftBlockTypes.air, source);
		 681      -     .thenWait(() => {
		 682      -       testEx.assertBlockProperty("open_bit", 1, q);
		 683      -       testEx.assertBlockProperty("open_bit", 0, notQ);
		 684      -     })
		 685  777   
		      778 +   test.succeedWhen(() => {
		      779 +     pointC.blocksBetween(pointD).forEach((p) => {
		 686      -     .thenExecute(() => test.pulseRedstone(s, 4))
		      780 +       test.assertRedstonePower(p, 0);
		      781 +     });
		      782 +   });
		      783 + })
		      784 +   .tag("suite:java_parity")
		      785 +   .tag(GameTest.Tags.suiteDisabled); //In Java the redstone signal is sent as soon as the redstone block is placed but in Bedrock it need to take a tick or two
		 687      -     .thenExecuteAfter(6, () => {
		 688      -       testEx.assertBlockProperty("open_bit", 1, q);
		 689      -       testEx.assertBlockProperty("open_bit", 0, notQ);
		 690      -     })
		 691      -     .thenSucceed();
		 692      - }).tag(GameTest.Tags.suiteDefault);
		 693  786   
		      787 + GameTest.register("RedstoneTests", "dust_loop_depowering_bedrock", (test) => {
		      788 +   const source = new BlockLocation(2, 2, 0);
		      789 +   const input = new BlockLocation(2, 2, 1);
		 694      - GameTest.register("RedstoneTests", "repeater_delay", (test) => {
		      790 +   const pointA = new BlockLocation(4, 2, 1);
		      791 +   const pointB = new BlockLocation(0, 2, 16);
		      792 +   const pointC = new BlockLocation(4, 2, 1);
		      793 +   const pointD = new BlockLocation(0, 2, 16);
		 695      -   test.setBlockType(MinecraftBlockTypes.stone, new BlockLocation(0, 2, 5));
		 696      - 
		 697      -   const lamp1 = new BlockLocation(1, 2, 0);
		 698      -   const lamp2 = new BlockLocation(3, 2, 0);
		 699  794   
		 700      -   test
		 701      -     .startSequence()
		 702      -     .thenWait(() => {
		 703      -       test.assertRedstonePower(lamp1, 15);
		      795 +   test.setBlockType(MinecraftBlockTypes.redstoneBlock, source);
		      796 + 
		      797 +   test.runAfterDelay(2, () => {
		      798 +     pointA.blocksBetween(pointB).forEach((p) => {
		      799 +       test.assertRedstonePower(p, Math.max(0, 15 - distManhattan(p, input)));
		      800 +     });
		      801 +   });
		      802 + 
		      803 +   test.setBlockType(MinecraftBlockTypes.air, source);
		      804 + 
		      805 +   test.succeedWhen(() => {
		      806 +     pointC.blocksBetween(pointD).forEach((p) => {
		      807 +       test.assertRedstonePower(p, 0);
		      808 +     });
		 704      -     })
		 705      -     .thenExecute(() => {
		 706      -       test.assertRedstonePower(lamp2, 15);
		 707      -     })
		 708      -     .thenWait(() => {
		 709      -       test.assertRedstonePower(lamp1, 0);
		 710      -     })
		 711      -     .thenExecute(() => {
		 712      -       test.assertRedstonePower(lamp2, 0);
		 713      -     })
		 714      -     .thenSucceed();
		 715      - })
		 716      -   .maxTicks(TicksPerSecond * 10)
		 717      -   .tag(GameTest.Tags.suiteDisabled); //The ticks of Redstone repeater is too short in structure, causing the Redstone lamp will not go out.
		 718      - 
		      809 +   });
		      810 + }).tag(GameTest.Tags.suiteDefault);
		 719      - GameTest.register("RedstoneTests", "repeater_delay_bedrock", (test) => {
		 720      -   test.setBlockType(MinecraftBlockTypes.stone, new BlockLocation(0, 2, 5));
		 721  811   
		      812 + GameTest.register("RedstoneTests", "lever_power", (test) => {
		      813 +   const powered = [
		      814 +     new BlockLocation(1, 2, 0),
		 722      -   const lamp1 = new BlockLocation(1, 2, 0);
		      815 +     new BlockLocation(1, 2, 3),
		 723      -   const lamp2 = new BlockLocation(3, 2, 0);
		 724  816   
		 725      -   test
		 726      -     .startSequence()
		 727      -     .thenWait(() => {
		 728      -       test.assertRedstonePower(lamp1, 15);
		      817 +     new BlockLocation(2, 2, 1),
		      818 +     new BlockLocation(2, 2, 2),
		      819 + 
		      820 +     new BlockLocation(0, 2, 1),
		      821 +     new BlockLocation(0, 2, 2),
		      822 + 
		      823 +     new BlockLocation(1, 3, 1),
		      824 +     new BlockLocation(1, 3, 2),
		      825 + 
		      826 +     new BlockLocation(1, 1, 1),
		      827 +     new BlockLocation(1, 1, 2),
		      828 + 
		      829 +     new BlockLocation(1, 2, 2),
		      830 +   ];
		 729      -     })
		 730      -     .thenExecute(() => {
		 731      -       test.assertRedstonePower(lamp2, 15);
		 732      -     })
		 733      -     .thenWait(() => {
		 734      -       test.assertRedstonePower(lamp1, 0);
		 735      -     })
		 736      -     .thenExecute(() => {
		 737      -       test.assertRedstonePower(lamp2, 0);
		 738      -     })
		 739      -     .thenSucceed();
		 740      - })
		 741      -   .maxTicks(TicksPerSecond * 10)
		 742      -   .tag(GameTest.Tags.suiteDefault); //Change the ticks of Redstone repeater to the longest in structure.
		 743  831   
		      832 +   const leverPos = new BlockLocation(1, 2, 1);
		 744      - function distManhattan(pos, loc) {
		 745      -   const xd = Math.abs(pos.x - loc.x);
		 746      -   const yd = Math.abs(pos.y - loc.y);
		      833 +   test.pullLever(leverPos);
		 747      -   const zd = Math.abs(pos.z - loc.z);
		 748  834   
		      835 +   const pointA = new BlockLocation(0, 1, 0);
		      836 +   const pointB = new BlockLocation(2, 3, 3);
		 749      -   return xd + yd + zd;
		 750      - }
		 751  837   
		      838 +   test.succeedIf(() => {
		      839 +     pointA
		 752      - GameTest.register("RedstoneTests", "dust_loop_depowering", (test) => {
		 753      -   const source = new BlockLocation(2, 2, 0);
		      840 +       .blocksBetween(pointB)
		      841 +       .filter((p) => !p.equals(leverPos))
		      842 +       .forEach((p) => test.assertRedstonePower(p, powered.includes(p) ? 15 : 0));
		      843 +   });
		      844 + }).tag(GameTest.Tags.suiteDefault);
		 754      -   const input = new BlockLocation(2, 2, 1);
		 755      -   const pointA = new BlockLocation(4, 2, 1);
		 756      -   const pointB = new BlockLocation(0, 2, 16);
		 757      -   const pointC = new BlockLocation(4, 2, 1);
		 758      -   const pointD = new BlockLocation(0, 2, 16);
		 759  845   
		      846 + GameTest.register("RedstoneTests", "dust_propagation", (test) => {
		      847 +   let levels = new Map();
		      848 +   const origin = new BlockLocation(2, 2, 1);
		 760      -   test.setBlockType(MinecraftBlockTypes.redstoneBlock, source);
		 761  849   
		      850 +   {
		      851 +     origin
		 762      -   pointA.blocksBetween(pointB).forEach((p) => {
		      852 +       .blocksBetween(new BlockLocation(2, 2, 17))
		      853 +       .forEach((p) => levels.set(p, Math.max(15 - distManhattan(origin, p), 0)));
		 763      -     test.assertRedstonePower(p, Math.max(0, 15 - distManhattan(p, input)));
		 764      -   });
		 765      - 
		      854 +   }
		 766      -   test.setBlockType(MinecraftBlockTypes.air, source);
		 767  855   
		      856 +   {
		      857 +     levels.set(new BlockLocation(3, 2, 2), 13);
		      858 +     levels.set(new BlockLocation(3, 2, 9), 6);
		 768      -   test.succeedWhen(() => {
		      859 +     const leftRoot = new BlockLocation(4, 2, 2);
		      860 +     leftRoot
		      861 +       .blocksBetween(new BlockLocation(4, 2, 14))
		      862 +       .forEach((p) => levels.set(p, Math.max(12 - distManhattan(leftRoot, p), 0)));
		      863 +   }
		 769      -     pointC.blocksBetween(pointD).forEach((p) => {
		 770      -       test.assertRedstonePower(p, 0);
		 771      -     });
		 772      -   });
		 773      - }).tag(GameTest.Tags.suiteDisabled); //In Java the redstone signal is sent as soon as the redstone block is placed but in Bedrock it need to take a tick or two
		 774  864   
		      865 +   {
		      866 +     levels.set(new BlockLocation(1, 2, 3), 12);
		 775      - GameTest.register("RedstoneTests", "dust_loop_depowering_bedrock", (test) => {
		 776      -   const source = new BlockLocation(2, 2, 0);
		      867 +     const rightRoot = new BlockLocation(0, 2, 3);
		      868 +     rightRoot
		      869 +       .blocksBetween(new BlockLocation(0, 2, 14))
		      870 +       .forEach((p) => levels.set(p, Math.max(11 - distManhattan(rightRoot, p), 0)));
		      871 +   }
		 777      -   const input = new BlockLocation(2, 2, 1);
		 778      -   const pointA = new BlockLocation(4, 2, 1);
		 779      -   const pointB = new BlockLocation(0, 2, 16);
		 780      -   const pointC = new BlockLocation(4, 2, 1);
		 781      -   const pointD = new BlockLocation(0, 2, 16);
		 782  872   
		      873 +   const source = new BlockLocation(2, 2, 0);
		 783  874     test.setBlockType(MinecraftBlockTypes.redstoneBlock, source);
		 784  875   
		      876 +   for (let [pos, level] of levels) {
		 785      -   test.runAfterDelay(2, () => {
		 786      -     pointA.blocksBetween(pointB).forEach((p) => {
		 787      -       test.assertRedstonePower(p, Math.max(0, 15 - distManhattan(p, input)));
		      877 +     test.assertRedstonePower(pos, level);
		      878 +   }
		 788      -     });
		 789      -   });
		 790  879   
		 791  880     test.setBlockType(MinecraftBlockTypes.air, source);
		 792  881   
		      882 +   test.succeedIf(() => {
		      883 +     for (let pos of levels.keys()) {
		 793      -   test.succeedWhen(() => {
		 794      -     pointC.blocksBetween(pointD).forEach((p) => {
		      884 +       test.assertRedstonePower(pos, 0);
		      885 +     }
		 795      -       test.assertRedstonePower(p, 0);
		 796      -     });
		 797  886     });
		 798      - }).tag(GameTest.Tags.suiteDefault);
		 799      - 
		 800      - GameTest.register("RedstoneTests", "lever_power", (test) => {
		      887 + })
		      888 +   .tag("suite:java_parity")
		      889 +   .tag(GameTest.Tags.suiteDisabled); //In Java the redstone signal is sent as soon as the redstone block is placed but in Bedrock it need to take a tick or two
		 801      -   const powered = [
		 802      -     new BlockLocation(1, 2, 0),
		 803      -     new BlockLocation(1, 2, 3),
		 804  890   
		      891 + GameTest.register("RedstoneTests", "dust_propagation_bedrock", (test) => {
		      892 +   let levels = new Map();
		 805      -     new BlockLocation(2, 2, 1),
		      893 +   const origin = new BlockLocation(2, 2, 1);
		 806      -     new BlockLocation(2, 2, 2),
		 807  894   
		      895 +   {
		      896 +     origin
		      897 +       .blocksBetween(new BlockLocation(2, 2, 17))
		      898 +       .forEach((p) => levels.set(p, Math.max(15 - distManhattan(origin, p), 0)));
		      899 +   }
		 808      -     new BlockLocation(0, 2, 1),
		 809      -     new BlockLocation(0, 2, 2),
		 810  900   
		      901 +   {
		      902 +     levels.set(new BlockLocation(3, 2, 2), 13);
		      903 +     levels.set(new BlockLocation(3, 2, 9), 6);
		      904 +     const leftRoot = new BlockLocation(4, 2, 2);
		      905 +     leftRoot
		      906 +       .blocksBetween(new BlockLocation(4, 2, 14))
		      907 +       .forEach((p) => levels.set(p, Math.max(12 - distManhattan(leftRoot, p), 0)));
		      908 +   }
		 811      -     new BlockLocation(1, 3, 1),
		 812      -     new BlockLocation(1, 3, 2),
		 813      - 
		 814      -     new BlockLocation(1, 1, 1),
		 815      -     new BlockLocation(1, 1, 2),
		 816  909   
		      910 +   {
		      911 +     levels.set(new BlockLocation(1, 2, 3), 12);
		      912 +     const rightRoot = new BlockLocation(0, 2, 3);
		 817      -     new BlockLocation(1, 2, 2),
		      913 +     rightRoot
		      914 +       .blocksBetween(new BlockLocation(0, 2, 14))
		      915 +       .forEach((p) => levels.set(p, Math.max(11 - distManhattan(rightRoot, p), 0)));
		      916 +   }
		 818      -   ];
		 819      - 
		 820      -   const leverPos = new BlockLocation(1, 2, 1);
		 821      -   test.pullLever(leverPos);
		 822  917   
		      918 +   const source = new BlockLocation(2, 2, 0);
		      919 +   test.setBlockType(MinecraftBlockTypes.redstoneBlock, source);
		 823      -   const pointA = new BlockLocation(0, 1, 0);
		 824      -   const pointB = new BlockLocation(2, 3, 3);
		 825  920   
		      921 +   test.runAfterDelay(2, () => {
		 826      -   test.succeedIf(() => {
		 827      -     pointA
		      922 +     for (let [pos, level] of levels) {
		      923 +       test.assertRedstonePower(pos, level);
		      924 +     }
		 828      -       .blocksBetween(pointB)
		 829      -       .filter((p) => !p.equals(leverPos))
		 830      -       .forEach((p) => test.assertRedstonePower(p, powered.includes(p) ? 15 : 0));
		 831  925     });
		 832      - }).tag(GameTest.Tags.suiteDefault);
		 833  926   
		      927 +   test.setBlockType(MinecraftBlockTypes.air, source);
		 834      - GameTest.register("RedstoneTests", "dust_propagation", (test) => {
		 835      -   let levels = new Map();
		 836      -   const origin = new BlockLocation(2, 2, 1);
		 837  928   
		      929 +   test.succeedIf(() => {
		      930 +     for (let pos of levels.keys()) {
		 838      -   {
		      931 +       test.assertRedstonePower(pos, 0);
		      932 +     }
		      933 +   });
		      934 + }).tag(GameTest.Tags.suiteDefault);
		 839      -     origin
		 840      -       .blocksBetween(new BlockLocation(2, 2, 17))
		 841      -       .forEach((p) => levels.set(p, Math.max(15 - distManhattan(origin, p), 0)));
		 842      -   }
		 843  935   
		 844      -   {
		 845      -     levels.set(new BlockLocation(3, 2, 2), 13);
		 846      -     levels.set(new BlockLocation(3, 2, 9), 6);
		      936 + GameTest.register("RedstoneTests", "torch_nand", (test) => {
		      937 +   const testEx = new GameTestExtensions(test);
		      938 +   const inputA = new BlockLocation(4, 2, 0);
		      939 +   const inputB = new BlockLocation(0, 2, 0);
		      940 +   const output = new BlockLocation(2, 2, 4);
		 847      -     const leftRoot = new BlockLocation(4, 2, 2);
		 848      -     leftRoot
		 849      -       .blocksBetween(new BlockLocation(4, 2, 14))
		 850      -       .forEach((p) => levels.set(p, Math.max(12 - distManhattan(leftRoot, p), 0)));
		 851      -   }
		 852  941   
		      942 +   test
		 853      -   {
		 854      -     levels.set(new BlockLocation(1, 2, 3), 12);
		      943 +     .startSequence()
		      944 +     .thenExecute(() => test.pullLever(inputA))
		      945 +     .thenIdle(2)
		      946 +     .thenExecute(() => testEx.assertBlockProperty("open_bit", 1, output))
		      947 +     .thenExecuteAfter(2, () => test.pullLever(inputA))
		 855      -     const rightRoot = new BlockLocation(0, 2, 3);
		 856      -     rightRoot
		 857      -       .blocksBetween(new BlockLocation(0, 2, 14))
		 858      -       .forEach((p) => levels.set(p, Math.max(11 - distManhattan(rightRoot, p), 0)));
		 859      -   }
		 860  948   
		      949 +     .thenExecuteAfter(2, () => test.pullLever(inputB))
		      950 +     .thenIdle(2)
		      951 +     .thenExecute(() => testEx.assertBlockProperty("open_bit", 1, output))
		 861      -   const source = new BlockLocation(2, 2, 0);
		      952 +     .thenExecuteAfter(2, () => test.pullLever(inputB))
		 862      -   test.setBlockType(MinecraftBlockTypes.redstoneBlock, source);
		 863  953   
		      954 +     .thenExecuteAfter(2, () => {
		      955 +       test.pullLever(inputA);
		      956 +       test.pullLever(inputB);
		      957 +     })
		      958 +     .thenIdle(4)
		      959 +     .thenExecute(() => testEx.assertBlockProperty("open_bit", 0, output))
		      960 +     .thenSucceed();
		      961 + }).tag(GameTest.Tags.suiteDefault);
		 864      -   for (let [pos, level] of levels) {
		 865      -     test.assertRedstonePower(pos, level);
		 866      -   }
		 867      - 
		 868      -   test.setBlockType(MinecraftBlockTypes.air, source);
		 869  962   
		      963 + GameTest.register("RedstoneTests", "comparator_logic", (test) => {
		 870      -   test.succeedIf(() => {
		 871      -     for (let pos of levels.keys()) {
		 872      -       test.assertRedstonePower(pos, 0);
		      964 +   const mainInput = new BlockLocation(3, 2, 2);
		      965 +   const sideInput = new BlockLocation(1, 2, 0);
		      966 +   const output = new BlockLocation(0, 2, 2);
		 873      -     }
		 874      -   });
		 875      - }).tag(GameTest.Tags.suiteDisabled); //In Java the redstone signal is sent as soon as the redstone block is placed but in Bedrock it need to take a tick or two
		 876  967   
		      968 +   const mainMusicPlayerComp = test.getBlock(mainInput).getComponent("recordPlayer");
		 877      - GameTest.register("RedstoneTests", "dust_propagation_bedrock", (test) => {
		 878      -   let levels = new Map();
		      969 +   const sideMusicPlayerComp = test.getBlock(sideInput).getComponent("recordPlayer");
		 879      -   const origin = new BlockLocation(2, 2, 1);
		 880  970   
		      971 +   let sequence = test.startSequence();
		      972 +   for (const [mainLevel, mainRecord] of LEVEL_TO_RECORDS) {
		 881      -   {
		 882      -     origin
		      973 +     for (const [sideLevel, sideRecord] of LEVEL_TO_RECORDS) {
		      974 +       let value = mainLevel >= sideLevel ? mainLevel : 0;
		      975 +       sequence = sequence
		      976 +         .thenExecute(() => {
		      977 +           if (mainLevel == 0) {
		      978 +             mainMusicPlayerComp.clearRecord();
		      979 +           } else {
		      980 +             mainMusicPlayerComp.setRecord(mainRecord);
		      981 +           }
		      982 +           if (sideLevel == 0) {
		      983 +             sideMusicPlayerComp.clearRecord();
		      984 +           } else {
		      985 +             sideMusicPlayerComp.setRecord(sideRecord);
		      986 +           }
		      987 +         })
		      988 +         .thenWaitAfter(4, () => {
		      989 +           test.assertRedstonePower(output, value);
		      990 +         });
		      991 +     }
		 883      -       .blocksBetween(new BlockLocation(2, 2, 17))
		 884      -       .forEach((p) => levels.set(p, Math.max(15 - distManhattan(origin, p), 0)));
		 885      -   }
		 886      - 
		 887      -   {
		 888      -     levels.set(new BlockLocation(3, 2, 2), 13);
		 889      -     levels.set(new BlockLocation(3, 2, 9), 6);
		 890      -     const leftRoot = new BlockLocation(4, 2, 2);
		 891      -     leftRoot
		 892      -       .blocksBetween(new BlockLocation(4, 2, 14))
		 893      -       .forEach((p) => levels.set(p, Math.max(12 - distManhattan(leftRoot, p), 0)));
		 894      -   }
		 895      - 
		 896      -   {
		 897      -     levels.set(new BlockLocation(1, 2, 3), 12);
		 898      -     const rightRoot = new BlockLocation(0, 2, 3);
		 899      -     rightRoot
		 900      -       .blocksBetween(new BlockLocation(0, 2, 14))
		 901      -       .forEach((p) => levels.set(p, Math.max(11 - distManhattan(rightRoot, p), 0)));
		 902  992     }
		 903      - 
		 904      -   const source = new BlockLocation(2, 2, 0);
		 905      -   test.setBlockType(MinecraftBlockTypes.redstoneBlock, source);
		 906      - 
		      993 +   sequence.thenSucceed();
		      994 + })
		      995 +   .maxTicks(TicksPerSecond * 60)
		 907      -   test.runAfterDelay(2, () => {
		 908      -     for (let [pos, level] of levels) {
		 909      -       test.assertRedstonePower(pos, level);
		 910      -     }
		      996 +   .tag(GameTest.Tags.suiteDefault);
		 911      -   });
		 912  997   
		      998 + GameTest.register("RedstoneTests", "subtractor_logic", (test) => {
		      999 +   const mainInput = new BlockLocation(3, 2, 2);
		     1000 +   const sideInput = new BlockLocation(1, 2, 0);
		     1001 +   const output = new BlockLocation(0, 2, 2);
		 913      -   test.setBlockType(MinecraftBlockTypes.air, source);
		 914 1002   
		 915      -   test.succeedIf(() => {
		 916      -     for (let pos of levels.keys()) {
		 917      -       test.assertRedstonePower(pos, 0);
		 918      -     }
		     1003 +   const mainMusicPlayerComp = test.getBlock(mainInput).getComponent("recordPlayer");
		     1004 +   const sideMusicPlayerComp = test.getBlock(sideInput).getComponent("recordPlayer");
		 919      -   });
		 920      - }).tag(GameTest.Tags.suiteDefault);
		 921 1005   
		     1006 +   let sequence = test.startSequence();
		     1007 +   for (const [mainLevel, mainRecord] of LEVEL_TO_RECORDS) {
		 922      - GameTest.register("RedstoneTests", "torch_nand", (test) => {
		     1008 +     for (const [sideLevel, sideRecord] of LEVEL_TO_RECORDS) {
		     1009 +       let value = Math.max(mainLevel - sideLevel, 0);
		     1010 +       sequence = sequence
		     1011 +         .thenExecute(() => {
		     1012 +           if (mainLevel == 0) {
		     1013 +             mainMusicPlayerComp.clearRecord();
		     1014 +           } else {
		     1015 +             mainMusicPlayerComp.setRecord(mainRecord);
		     1016 +           }
		     1017 +           if (sideLevel == 0) {
		     1018 +             sideMusicPlayerComp.clearRecord();
		     1019 +           } else {
		     1020 +             sideMusicPlayerComp.setRecord(sideRecord);
		     1021 +           }
		     1022 +         })
		     1023 +         .thenWaitAfter(4, () => {
		     1024 +           test.assertRedstonePower(output, value);
		     1025 +         });
		     1026 +     }
		     1027 +   }
		     1028 +   sequence.thenSucceed();
		     1029 + })
		     1030 +   .maxTicks(TicksPerSecond * 60)
		     1031 +   .tag(GameTest.Tags.suiteDefault);
		 923      -   const testEx = new GameTestExtensions(test);
		 924      -   const inputA = new BlockLocation(4, 2, 0);
		 925      -   const inputB = new BlockLocation(0, 2, 0);
		 926      -   const output = new BlockLocation(2, 2, 4);
		 927      - 
		 928      -   test.startSequence()
		 929      -     .thenExecute(() => test.pullLever(inputA))
		 930      - 	.thenIdle(2)
		 931      - 	.thenExecute(() => testEx.assertBlockProperty("open_bit", 1, output))
		 932      -     .thenExecuteAfter(2, () => test.pullLever(inputA))
		 933      - 
		 934      -     .thenExecuteAfter(2, () => test.pullLever(inputB))
		 935      - 	.thenIdle(2)
		 936      - 	.thenExecute(() => testEx.assertBlockProperty("open_bit", 1, output))
		 937      -     .thenExecuteAfter(2, () => test.pullLever(inputB))
		 938      - 
		 939      -     .thenExecuteAfter(2, () => {
		 940      -       test.pullLever(inputA);
		 941      -       test.pullLever(inputB);
		 942      -     })
		 943      - 	.thenIdle(2)
		 944      -     .thenExecute(() => testEx.assertBlockProperty("open_bit", 0, output))
		 945      -     .thenSucceed();
		 946      - }).tag(GameTest.Tags.suiteDefault);
		            '''
	Added script "WaterPathfindingTests.js":
		'''
		import * as GameTest from "mojang-gametest";
		import { BlockLocation, Location } from "mojang-minecraft";
		
		const TicksPerSecond = 20;
		
		GameTest.register("WaterPathfindingTests", "axolotl_lava_walkaround", (test) => {
		  const spawnType = "minecraft:axolotl";
		  const mob = test.spawnWithoutBehaviorsAtLocation(spawnType, new Location(0.0, 3.0, 2.0));
		  const targetPos = new BlockLocation(6, 3, 2);
		  test.walkTo(mob, targetPos, 1);
		  test.succeedWhenEntityPresent(spawnType, targetPos, true);
		})
		  .maxTicks(TicksPerSecond * 20)
		  .tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("WaterPathfindingTests", "fish_corner_swimaround", (test) => {
		  const spawnType = "minecraft:tropicalfish";
		  const mob = test.spawnWithoutBehaviorsAtLocation(spawnType, new Location(1.5, 2.0, 1.5));
		  const targetPos = new BlockLocation(3, 2, 3);
		  test.walkTo(mob, targetPos, 1);
		  test.succeedWhenEntityPresent(spawnType, targetPos, true);
		})
		  .maxTicks(TicksPerSecond * 20)
		  .tag(GameTest.Tags.suiteDefault);
		'''