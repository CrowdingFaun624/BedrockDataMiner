Difference of "scripts" between "1.18.2" and "1.18.10.20" (beta of "1.18.10").

Changed behavior pack "vanilla_gametest":
	Total script: 30 (+3, -0)
	Changed script "APITests.js":
		Total line: 1048 (+313, -173)
		            '''
		        1 + import GameTestExtensions from "./GameTestExtensions.js";
		        2 + import * as GameTest from "mojang-gametest";
		        3 + import {
		        4 +   BlockLocation,
		        5 +   BlockProperties,
		        6 +   MinecraftBlockTypes,
		        7 +   Color,
		        8 +   Direction,
		        9 +   ExplosionOptions,
		       10 +   FluidContainer,
		       11 +   MinecraftEffectTypes,
		       12 +   MinecraftItemTypes,
		       13 +   ItemStack,
		       14 +   Location,
		       15 +   world,
		       16 + } from "mojang-minecraft";
		       17 + 
		       18 + GameTest.register("APITests", "on_entity_created", (test) => {
		       19 +   const entityCreatedCallback = world.events.entityCreate.subscribe((entity) => {
		       20 +     if (entity) {
		       21 +       test.succeed();
		       22 +     } else {
		       23 +       test.fail("Expected entity");
		       24 +     }
		       25 +   });
		       26 +   test.spawn("minecraft:horse<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		       27 +   world.events.entityCreate.unsubscribe(entityCreatedCallback);
		       28 + })
		       29 +   .structureName("ComponentTests:animal_pen")
		       30 +   .tag(GameTest.Tags.suiteDefault);
		       31 + 
		       32 + GameTest.register("APITests", "assert_is_waterlogged", (test) => {
		       33 +   const waterChestLoc = new BlockLocation(5, 2, 1);
		       34 +   const waterLoc = new BlockLocation(4, 2, 1);
		       35 +   const chestLoc = new BlockLocation(2, 2, 1);
		       36 +   const airLoc = new BlockLocation(1, 2, 1);
		       37 + 
		       38 +   test.assertIsWaterlogged(waterChestLoc, true);
		       39 +   test.assertIsWaterlogged(waterLoc, false);
		       40 +   test.assertIsWaterlogged(chestLoc, false);
		       41 +   test.assertIsWaterlogged(airLoc, false);
		       42 +   test.succeed();
		       43 + }).tag(GameTest.Tags.suiteDefault);
		       44 + 
		       45 + GameTest.register("APITests", "assert_redstone_power", (test) => {
		       46 +   const redstoneBlockLoc = new BlockLocation(3, 2, 1);
		       47 +   const redstoneTorchLoc = new BlockLocation(2, 2, 1);
		       48 +   const poweredLampLoc = new BlockLocation(1, 2, 1);
		       49 +   const unpoweredLampLoc = new BlockLocation(0, 2, 1);
		       50 +   const airLoc = new BlockLocation(3, 2, 0);
		       51 +   const redstoneWireLoc = new BlockLocation(0, 1, 0);
		       52 + 
		       53 +   test.succeedWhen(() => {
		       54 +     test.assertRedstonePower(redstoneBlockLoc, 15);
		       55 +     test.assertRedstonePower(redstoneTorchLoc, 15);
		       56 +     test.assertRedstonePower(poweredLampLoc, 15);
		       57 +     test.assertRedstonePower(unpoweredLampLoc, 0);
		       58 +     test.assertRedstonePower(airLoc, -1);
		       59 +     test.assertRedstonePower(redstoneWireLoc, 13); // 3 length wire
		       60 +   });
		       61 + })
		       62 +   .maxTicks(20)
		       63 +   .tag(GameTest.Tags.suiteDefault);
		       64 + 
		       65 + GameTest.register("APITests", "spawn_item", (test) => {
		       66 +   const featherItem = new ItemStack(MinecraftItemTypes.feather, 1, 0);
		       67 +   test.spawnItem(featherItem, new Location(1.5, 3.5, 1.5));
		       68 +   test.succeedWhen(() => {
		       69 +     test.assertEntityPresent("minecraft:item", new BlockLocation(1, 2, 1), true);
		       70 +   });
		       71 + }).tag(GameTest.Tags.suiteDefault);
		       72 + 
		       73 + GameTest.register("APITests", "assert_entity_data", (test) => {
		       74 +   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		       75 +   const pigLoc = new BlockLocation(1, 2, 1);
		       76 +   test.spawn(pigId, pigLoc);
		       77 +   test.succeedWhen(() => {
		       78 +     test.assertEntityState(pigLoc, pigId, (entity) => entity.id !== undefined);
		       79 +   });
		       80 + })
		       81 +   .structureName("ComponentTests:animal_pen")
		       82 +   .tag(GameTest.Tags.suiteDefault);
		       83 + 
		       84 + GameTest.register("APITests", "add_effect", (test) => {
		       85 +   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		       86 +   const villagerLoc = new BlockLocation(1, 2, 1);
		       87 +   const villager = test.spawn(villagerId, villagerLoc);
		       88 +   const duration = 20;
		       89 +   villager.addEffect(MinecraftEffectTypes.poison, duration, 1);
		       90 + 
		       91 +   test.assertEntityState(
		       92 +     villagerLoc,
		       93 +     villagerId,
		       94 +     (entity) => entity.getEffect(MinecraftEffectTypes.poison).duration == duration
		       95 +   );
		       96 +   test.assertEntityState(
		       97 +     villagerLoc,
		       98 +     villagerId,
		       99 +     (entity) => entity.getEffect(MinecraftEffectTypes.poison).amplifier == 1
		      100 +   );
		      101 + 
		      102 +   test.runAfterDelay(duration, () => {
		      103 +     test.assertEntityState(
		      104 +       villagerLoc,
		      105 +       villagerId,
		      106 +       (entity) => entity.getEffect(MinecraftEffectTypes.poison) === undefined
		      107 +     );
		      108 +     test.succeed();
		      109 +   });
		      110 + })
		      111 +   .structureName("ComponentTests:animal_pen")
		      112 +   .tag(GameTest.Tags.suiteDefault);
		      113 + 
		      114 + GameTest.register("APITests", "assert_entity_present", (test) => {
		      115 +   const villagerId = "minecraft:villager_v2";
		      116 +   const villagerLoc = new BlockLocation(1, 2, 3);
		      117 +   const emeraldItem = new ItemStack(MinecraftItemTypes.emerald, 1, 0);
		      118 +   const emeraldItemLoc = new BlockLocation(3, 2, 3);
		      119 +   const minecartId = "minecraft:minecart";
		      120 +   const minecartLoc = new BlockLocation(3, 2, 1);
		      121 +   const armorStandId = "minecraft:armor_stand";
		      122 +   const armorStandLoc = new BlockLocation(1, 2, 1);
		      123 + 
		      124 +   test.spawn(villagerId, villagerLoc);
		      125 +   test.spawnItem(emeraldItem, new Location(3.5, 4.5, 3.5));
		      126 + 
		      127 +   test.succeedWhen(() => {
		      128 +     test.assertEntityPresent(villagerId, villagerLoc, true);
		      129 +     test.assertItemEntityPresent(MinecraftItemTypes.emerald, emeraldItemLoc, 0, true);
		      130 +     test.assertEntityPresent(armorStandId, armorStandLoc, true);
		      131 + 
		      132 +     // Check all blocks surrounding the minecart
		      133 +     for (let x = -1; x <= 1; x++) {
		      134 +       for (let z = -1; z <= 1; z++) {
		      135 +         let offsetLoc = new BlockLocation(minecartLoc.x + x, minecartLoc.y, minecartLoc.z + z);
		      136 +         if (x == 0 && z == 0) {
		      137 +           test.assertEntityPresent(minecartId, offsetLoc, true);
		      138 +         } else {
		      139 +           test.assertEntityPresent(minecartId, offsetLoc, false);
		      140 +         }
		      141 +       }
		      142 +     }
		      143 +   });
		      144 + }).tag(GameTest.Tags.suiteDefault);
		      145 + 
		      146 + GameTest.register("APITests", "assert_entity_not_present", (test) => {
		      147 +   const armorStandId = "minecraft:armor_stand";
		      148 +   const pigId = "minecraft:pig";
		      149 +   const armorStandLoc = new BlockLocation(1, 2, 1);
		      150 +   const airLoc = new BlockLocation(0, 2, 1);
		      151 + 
		      152 +   try {
		      153 +     test.assertEntityPresentInArea(armorStandId, false);
		      154 +     test.fail(); // this assert should throw
		      155 +   } catch (e) {}
		      156 + 
		      157 +   try {
		      158 +     test.assertEntityPresent(armorStandId, armorStandLoc, false);
		      159 +     test.fail(); // this assert should throw
		      160 +   } catch (e) {}
		      161 + 
		      162 +   test.assertEntityPresent(armorStandId, airLoc, false);
		      163 +   test.assertEntityPresentInArea(pigId, false);
		      164 + 
		      165 +   test.succeed();
		      166 + })
		      167 +   .structureName("APITests:armor_stand")
		      168 +   .tag(GameTest.Tags.suiteDefault);
		      169 + 
		      170 + GameTest.register("APITests", "assert_item_entity_count_is", (test) => {
		      171 +   let oneItemLoc = new BlockLocation(3, 2, 1);
		      172 +   let fiveItemsLoc = new BlockLocation(1, 2, 1);
		      173 +   let noItemsLoc = new BlockLocation(2, 2, 1);
		      174 +   let diamondPickaxeLoc = new BlockLocation(2, 2, 4);
		      175 + 
		      176 +   const oneEmerald = new ItemStack(MinecraftItemTypes.emerald, 1, 0);
		      177 +   const onePickaxe = new ItemStack(MinecraftItemTypes.diamondPickaxe, 1, 0);
		      178 +   const fiveEmeralds = new ItemStack(MinecraftItemTypes.emerald, 5, 0);
		      179 + 
		      180 +   test.spawnItem(oneEmerald, new Location(3.5, 3, 1.5));
		      181 +   test.spawnItem(fiveEmeralds, new Location(1.5, 3, 1.5));
		      182 + 
		      183 +   // spawn 9 pickaxes in a 3x3 grid
		      184 +   for (let x = 1.5; x <= 3.5; x++) {
		      185 +     for (let z = 3.5; z <= 5.5; z++) {
		      186 +       test.spawnItem(onePickaxe, new Location(x, 3, z));
		      187 +     }
		      188 +   }
		      189 + 
		      190 +   test.assertItemEntityCountIs(MinecraftItemTypes.emerald, noItemsLoc, 0, 0);
		   1      - import * as GameTest from "mojang-gametest";
		   2      - import {
		   3      -   BlockLocation,
		   4      -   BlockProperties,
		   5      -   MinecraftBlockTypes,
		   6      -   Color,
		   7      -   Direction,
		   8      -   ExplosionOptions,
		   9      -   FluidContainer,
		  10      -   MinecraftEffectTypes,
		  11      -   MinecraftItemTypes,
		  12      -   ItemStack,
		  13      -   Location,
		  14      -   World,
		  15      - } from "mojang-minecraft";
		  16  191   
		      192 +   test.succeedWhen(() => {
		      193 +     test.assertItemEntityCountIs(MinecraftItemTypes.feather, oneItemLoc, 0, 0);
		  17      - GameTest.register("APITests", "on_entity_created", (test) => {
		      194 +     test.assertItemEntityCountIs(MinecraftItemTypes.emerald, oneItemLoc, 0, 1);
		      195 +     test.assertItemEntityCountIs(MinecraftItemTypes.feather, fiveItemsLoc, 0, 0);
		      196 +     test.assertItemEntityCountIs(MinecraftItemTypes.emerald, fiveItemsLoc, 0, 5);
		      197 +     test.assertItemEntityCountIs(MinecraftItemTypes.emerald, fiveItemsLoc, 0, 5);
		      198 +     test.assertItemEntityCountIs(MinecraftItemTypes.diamondPickaxe, diamondPickaxeLoc, 1, 9);
		      199 +     test.assertItemEntityCountIs(MinecraftItemTypes.diamondPickaxe, diamondPickaxeLoc, 0, 1);
		  18      -   const entityCreatedCallback = World.events.entityCreate.subscribe((entity) => {
		  19      -     if (entity) {
		  20      -       test.succeed();
		  21      -     } else {
		  22      -       test.fail("Expected entity");
		  23      -     }
		  24  200     });
		      201 + }).tag(GameTest.Tags.suiteDefault);
		  25      -   test.spawn("minecraft:horse<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		  26      -   World.events.entityCreate.unsubscribe(entityCreatedCallback);
		      202 + 
		      203 + GameTest.register("APITests", "assert_entity_touching", (test) => {
		      204 +   const armorStandId = "minecraft:armor_stand";
		  27      - })
		  28      -   .structureName("ComponentTests:animal_pen")
		  29      -   .tag(GameTest.Tags.suiteDefault);
		  30  205   
		      206 +   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.5), true);
		      207 +   test.assertEntityTouching(armorStandId, new Location(1.5, 3.5, 1.5), true);
		  31      - GameTest.register("APITests", "assert_is_waterlogged", (test) => {
		      208 +   test.assertEntityTouching(armorStandId, new Location(1.0, 2.5, 1.5), false);
		      209 +   test.assertEntityTouching(armorStandId, new Location(2.0, 2.5, 1.5), false);
		      210 +   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.0), false);
		      211 +   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 2.0), false);
		  32      -   const waterChestLoc = new BlockLocation(5, 2, 1);
		  33      -   const waterLoc = new BlockLocation(4, 2, 1);
		  34      -   const chestLoc = new BlockLocation(2, 2, 1);
		  35      -   const airLoc = new BlockLocation(1, 2, 1);
		  36  212   
		  37      -   test.assertIsWaterlogged(waterChestLoc, true);
		  38      -   test.assertIsWaterlogged(waterLoc, false);
		  39      -   test.assertIsWaterlogged(chestLoc, false);
		  40      -   test.assertIsWaterlogged(airLoc, false);
		  41  213     test.succeed();
		      214 + })
		      215 +   .structureName("APITests:armor_stand")
		      216 +   .tag(GameTest.Tags.suiteDefault);
		  42      - }).tag(GameTest.Tags.suiteDefault);
		  43  217   
		      218 + GameTest.register("APITests", "pulse_redstone", (test) => {
		  44      - GameTest.register("APITests", "assert_redstone_power", (test) => {
		  45      -   const redstoneBlockLoc = new BlockLocation(3, 2, 1);
		  46      -   const redstoneTorchLoc = new BlockLocation(2, 2, 1);
		      219 +   const pulseLoc = new BlockLocation(1, 2, 2);
		      220 +   const lampLoc = new BlockLocation(1, 2, 1);
		      221 +   test.assertRedstonePower(lampLoc, 0);
		      222 +   test.pulseRedstone(pulseLoc, 2);
		  47      -   const poweredLampLoc = new BlockLocation(1, 2, 1);
		  48      -   const unpoweredLampLoc = new BlockLocation(0, 2, 1);
		  49      -   const airLoc = new BlockLocation(3, 2, 0);
		  50      -   const redstoneWireLoc = new BlockLocation(0, 1, 0);
		  51  223   
		  52      -   test.succeedWhen(() => {
		  53      -     test.assertRedstonePower(redstoneBlockLoc, 15);
		  54      -     test.assertRedstonePower(redstoneTorchLoc, 15);
		      224 +   test
		      225 +     .startSequence()
		      226 +     .thenIdle(2)
		      227 +     .thenExecute(() => test.assertRedstonePower(lampLoc, 15))
		      228 +     .thenIdle(2)
		      229 +     .thenExecute(() => test.assertRedstonePower(lampLoc, 0))
		      230 +     .thenSucceed();
		      231 + }).tag(GameTest.Tags.suiteDefault);
		  55      -     test.assertRedstonePower(poweredLampLoc, 15);
		  56      -     test.assertRedstonePower(unpoweredLampLoc, 0);
		  57      -     test.assertRedstonePower(airLoc, -1);
		  58      -     test.assertRedstonePower(redstoneWireLoc, 13); // 3 length wire
		  59      -   });
		  60      - })
		  61      -   .maxTicks(20)
		  62      -   .tag(GameTest.Tags.suiteDefault);
		  63  232   
		  64      - GameTest.register("APITests", "spawn_item", (test) => {
		  65      -   const featherItem = new ItemStack(MinecraftItemTypes.feather, 1, 0);
		  66      -   test.spawnItem(featherItem, new Location(1.5, 3.5, 1.5));
		      233 + GameTest.register("APITests", "block_location", (test) => {
		      234 +   let testLoc = new BlockLocation(1, 1, 1);
		      235 +   let worldLoc = test.worldBlockLocation(testLoc);
		      236 +   let relativeLoc = test.relativeBlockLocation(worldLoc);
		      237 +   test.assert(!relativeLoc.equals(worldLoc), "Expected relativeLoc and worldLoc to be different");
		      238 +   test.assert(relativeLoc.equals(testLoc), "Expected relativeLoc to match testLoc");
		      239 +   test.succeed();
		      240 + })
		      241 +   .structureName("ComponentTests:platform")
		      242 +   .tag(GameTest.Tags.suiteDefault);
		      243 + 
		      244 + GameTest.register("APITests", "location", (test) => {
		      245 +   let testLoc = new Location(1.2, 1.2, 1.2);
		      246 +   let worldLoc = test.worldLocation(testLoc);
		      247 +   let relativeLoc = test.relativeLocation(worldLoc);
		  67      -   test.succeedWhen(() => {
		  68      -     test.assertEntityPresent("minecraft:item", new BlockLocation(1, 2, 1), true);
		  69      -   });
		  70      - }).tag(GameTest.Tags.suiteDefault);
		  71      - 
		  72      - GameTest.register("APITests", "assert_entity_data", (test) => {
		  73      -   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		  74      -   const pigLoc = new BlockLocation(1, 2, 1);
		  75      -   test.spawn(pigId, pigLoc);
		  76      -   test.succeedWhen(() => {
		  77      -     test.assertEntityState(pigLoc, pigId, (entity) => entity.id !== undefined);
		  78      -   });
		  79      - })
		  80      -   .structureName("ComponentTests:animal_pen")
		  81      -   .tag(GameTest.Tags.suiteDefault);
		  82      - 
		      248 +   test.assert(!relativeLoc.isNear(worldLoc, 0.01), "Expected relativeLoc and worldLoc to be different");
		      249 +   test.assert(relativeLoc.isNear(testLoc, 0.01), "Expected relativeLoc to match testLoc");
		      250 +   test.succeed();
		      251 + })
		      252 +   .structureName("ComponentTests:platform")
		      253 +   .tag(GameTest.Tags.suiteDefault);
		  83      - GameTest.register("APITests", "add_effect", (test) => {
		  84      -   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		  85      -   const villagerLoc = new BlockLocation(1, 2, 1);
		  86      -   const villager = test.spawn(villagerId, villagerLoc);
		  87      -   const duration = 20;
		  88      -   villager.addEffect(MinecraftEffectTypes.poison, duration, 1);
		  89  254   
		      255 + GameTest.register("APITests", "create_explosion_basic", (test) => {
		  90      -   test.assertEntityState(
		  91      -     villagerLoc,
		  92      -     villagerId,
		      256 +   const center = new BlockLocation(2, 3, 2);
		      257 + 
		      258 +   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		      259 + 
		      260 +   const loc = test.worldBlockLocation(center);
		      261 +   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		      262 +   test.getDimension().createExplosion(explosionLoc, 10, new ExplosionOptions());
		  93      -     (entity) => entity.getEffect(MinecraftEffectTypes.poison).duration == duration
		  94      -   );
		  95      -   test.assertEntityState(
		  96      -     villagerLoc,
		  97      -     villagerId,
		  98      -     (entity) => entity.getEffect(MinecraftEffectTypes.poison).amplifier == 1
		  99      -   );
		 100  263   
		      264 +   for (let x = 1; x <= 3; x++) {
		      265 +     for (let y = 2; y <= 4; y++) {
		 101      -   test.runAfterDelay(duration, () => {
		      266 +       for (let z = 1; z <= 3; z++) {
		      267 +         test.assertBlockPresent(MinecraftBlockTypes.cobblestone, new BlockLocation(x, y, z), false);
		      268 +       }
		      269 +     }
		      270 +   }
		      271 + 
		      272 +   test.succeed();
		 102      -     test.assertEntityState(
		 103      -       villagerLoc,
		 104      -       villagerId,
		 105      -       (entity) => entity.getEffect(MinecraftEffectTypes.poison) === undefined
		 106      -     );
		 107      -     test.succeed();
		 108      -   });
		 109  273   })
		      274 +   .padding(10) // The blast can destroy nearby items and mobs
		 110      -   .structureName("ComponentTests:animal_pen")
		 111  275     .tag(GameTest.Tags.suiteDefault);
		 112  276   
		      277 + GameTest.register("APITests", "create_explosion_advanced", (test) => {
		 113      - GameTest.register("APITests", "assert_entity_present", (test) => {
		 114      -   const villagerId = "minecraft:villager_v2";
		 115      -   const villagerLoc = new BlockLocation(1, 2, 3);
		      278 +   const dimension = test.getDimension();
		      279 +   const center = new BlockLocation(3, 3, 3);
		      280 + 
		      281 +   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		      282 +   const pigLoc = new BlockLocation(3, 4, 3);
		      283 +   test.spawn(pigId, pigLoc);
		 116      -   const emeraldItem = new ItemStack(MinecraftItemTypes.emerald, 1, 0);
		 117      -   const emeraldItemLoc = new BlockLocation(3, 2, 3);
		 118      -   const minecartId = "minecraft:minecart";
		 119      -   const minecartLoc = new BlockLocation(3, 2, 1);
		 120      -   const armorStandId = "minecraft:armor_stand";
		 121      -   const armorStandLoc = new BlockLocation(1, 2, 1);
		 122  284   
		      285 +   const loc = test.worldBlockLocation(center);
		      286 +   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		 123      -   test.spawn(villagerId, villagerLoc);
		      287 +   let explosionOptions = new ExplosionOptions();
		 124      -   test.spawnItem(emeraldItem, new Location(3.5, 4.5, 3.5));
		 125  288   
		 126      -   test.succeedWhen(() => {
		 127      -     test.assertEntityPresent(villagerId, villagerLoc, true);
		 128      -     test.assertItemEntityPresent(MinecraftItemTypes.emerald, emeraldItemLoc, 0, true);
		      289 +   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		 129      -     test.assertEntityPresent(armorStandId, armorStandLoc, true);
		 130  290   
		      291 +   // Start by exploding without breaking blocks
		      292 +   explosionOptions.breaksBlocks = false;
		 131      -     // Check all blocks surrounding the minecart
		 132      -     for (let x = -1; x <= 1; x++) {
		      293 +   const creeper = test.spawn("minecraft:creeper", new BlockLocation(1, 2, 1));
		      294 +   explosionOptions.source = creeper;
		      295 +   test.assertEntityPresent(pigId, pigLoc, true);
		      296 +   dimension.createExplosion(explosionLoc, 10, explosionOptions);
		      297 +   creeper.kill();
		      298 +   test.assertEntityPresent(pigId, pigLoc, false);
		      299 +   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		      300 + 
		      301 +   // Next, explode with fire
		      302 +   explosionOptions = new ExplosionOptions();
		      303 +   explosionOptions.causesFire = true;
		 133      -       for (let z = -1; z <= 1; z++) {
		 134      -         let offsetLoc = new BlockLocation(minecartLoc.x + x, minecartLoc.y, minecartLoc.z + z);
		 135      -         if (x == 0 && z == 0) {
		 136      -           test.assertEntityPresent(minecartId, offsetLoc, true);
		 137      -         } else {
		 138      -           test.assertEntityPresent(minecartId, offsetLoc, false);
		 139      -         }
		 140      -       }
		 141      -     }
		 142      -   });
		 143      - }).tag(GameTest.Tags.suiteDefault);
		 144  304   
		      305 +   let findFire = () => {
		      306 +     let foundFire = false;
		      307 +     for (let x = 0; x <= 6; x++) {
		      308 +       for (let z = 0; z <= 6; z++) {
		      309 +         try {
		      310 +           test.assertBlockPresent(MinecraftBlockTypes.fire, new BlockLocation(x, 3, z), true);
		      311 +           foundFire = true;
		      312 +           break;
		      313 +         } catch (e) {}
		      314 +       }
		      315 +     }
		      316 +     return foundFire;
		      317 +   };
		 145      - GameTest.register("APITests", "assert_entity_not_present", (test) => {
		 146      -   const armorStandId = "minecraft:armor_stand";
		 147      -   const pigId = "minecraft:pig";
		 148      -   const armorStandLoc = new BlockLocation(1, 2, 1);
		 149      -   const airLoc = new BlockLocation(0, 2, 1);
		 150      - 
		 151      -   try {
		 152      -     test.assertEntityPresentInArea(armorStandId, false);
		 153      -     test.fail(); // this assert should throw
		 154      -   } catch (e) {}
		 155  318   
		      319 +   test.assert(!findFire(), "Unexpected fire");
		      320 +   dimension.createExplosion(explosionLoc, 15, explosionOptions);
		 156      -   try {
		 157      -     test.assertEntityPresent(armorStandId, armorStandLoc, false);
		      321 +   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, false);
		      322 +   test.assert(findFire(), "No fire found");
		 158      -     test.fail(); // this assert should throw
		 159      -   } catch (e) {}
		 160  323   
		      324 +   // Finally, explode in water
		      325 +   explosionOptions.allowUnderwater = true;
		      326 +   const belowWaterLoc = new BlockLocation(3, 1, 3);
		      327 +   test.assertBlockPresent(MinecraftBlockTypes.air, belowWaterLoc, false);
		      328 +   dimension.createExplosion(explosionLoc, 10, explosionOptions);
		      329 +   test.assertBlockPresent(MinecraftBlockTypes.air, belowWaterLoc, true);
		 161      -   test.assertEntityPresent(armorStandId, airLoc, false);
		 162      -   test.assertEntityPresentInArea(pigId, false);
		 163      - 
		 164  330     test.succeed();
		 165  331   })
		      332 +   .padding(10) // The blast can destroy nearby items and mobs
		 166      -   .structureName("APITests:armor_stand")
		 167  333     .tag(GameTest.Tags.suiteDefault);
		 168  334   
		      335 + GameTest.register("APITests", "triggerEvent", (test) => {
		 169      - GameTest.register("APITests", "assert_item_entity_count_is", (test) => {
		 170      -   let oneItemLoc = new BlockLocation(3, 2, 1);
		 171      -   let fiveItemsLoc = new BlockLocation(1, 2, 1);
		      336 +   const creeper = test.spawn("creeper", new BlockLocation(1, 2, 1));
		      337 +   creeper.triggerEvent("minecraft:start_exploding_forced");
		 172      -   let noItemsLoc = new BlockLocation(2, 2, 1);
		 173      -   let diamondPickaxeLoc = new BlockLocation(2, 2, 4);
		 174  338   
		      339 +   test.succeedWhen(() => {
		      340 +     test.assertEntityPresentInArea("creeper", false);
		 175      -   const oneEmerald = new ItemStack(MinecraftItemTypes.emerald, 1, 0);
		      341 +   });
		      342 + })
		 176      -   const onePickaxe = new ItemStack(MinecraftItemTypes.diamondPickaxe, 1, 0);
		 177      -   const fiveEmeralds = new ItemStack(MinecraftItemTypes.emerald, 5, 0);
		 178      - 
		      343 +   .structureName("ComponentTests:glass_cage")
		      344 +   .tag(GameTest.Tags.suiteDefault);
		 179      -   test.spawnItem(oneEmerald, new Location(3.5, 3, 1.5));
		 180      -   test.spawnItem(fiveEmeralds, new Location(1.5, 3, 1.5));
		 181  345   
		 182      -   // spawn 9 pickaxes in a 3x3 grid
		 183      -   for (let x = 1.5; x <= 3.5; x++) {
		 184      -     for (let z = 3.5; z <= 5.5; z++) {
		 185      -       test.spawnItem(onePickaxe, new Location(x, 3, z));
		      346 + GameTest.register("APITests", "chat", (test) => {
		      347 +   test.print("subscribing");
		 186      -     }
		 187      -   }
		 188  348   
		      349 +   const chatCallback = world.events.beforeChat.subscribe((eventData) => {
		      350 +     if (eventData.message === "!killme") {
		      351 +       eventData.sender.kill();
		      352 +       eventData.cancel = true;
		 189      -   test.assertItemEntityCountIs(MinecraftItemTypes.emerald, noItemsLoc, 0, 0);
		 190      - 
		      353 +     } else if (eventData.message === "!players") {
		      354 +       test.print(`There are ${eventData.targets.length} players in the server.`);
		      355 +       for (const target of eventData.targets) {
		      356 +         test.print("Player: " + target.name);
		      357 +       }
		      358 +     } else {
		      359 +       eventData.message = `Modified '${eventData.message}'`;
		      360 +     }
		 191      -   test.succeedWhen(() => {
		 192      -     test.assertItemEntityCountIs(MinecraftItemTypes.feather, oneItemLoc, 0, 0);
		 193      -     test.assertItemEntityCountIs(MinecraftItemTypes.emerald, oneItemLoc, 0, 1);
		 194      -     test.assertItemEntityCountIs(MinecraftItemTypes.feather, fiveItemsLoc, 0, 0);
		 195      -     test.assertItemEntityCountIs(MinecraftItemTypes.emerald, fiveItemsLoc, 0, 5);
		 196      -     test.assertItemEntityCountIs(MinecraftItemTypes.emerald, fiveItemsLoc, 0, 5);
		 197      -     test.assertItemEntityCountIs(MinecraftItemTypes.diamondPickaxe, diamondPickaxeLoc, 1, 9);
		 198      -     test.assertItemEntityCountIs(MinecraftItemTypes.diamondPickaxe, diamondPickaxeLoc, 0, 1);
		 199  361     });
		 200      - }).tag(GameTest.Tags.suiteDefault);
		 201      - 
		 202      - GameTest.register("APITests", "assert_entity_touching", (test) => {
		 203      -   const armorStandId = "minecraft:armor_stand";
		 204  362   
		      363 +   test
		      364 +     .startSequence()
		 205      -   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.5), true);
		 206      -   test.assertEntityTouching(armorStandId, new Location(1.5, 3.5, 1.5), true);
		      365 +     .thenIdle(200)
		      366 +     .thenExecute(() => {
		      367 +       world.events.beforeChat.unsubscribe(chatCallback);
		      368 +       test.print("unsubscribed");
		      369 +     })
		      370 +     .thenSucceed();
		 207      -   test.assertEntityTouching(armorStandId, new Location(1.0, 2.5, 1.5), false);
		 208      -   test.assertEntityTouching(armorStandId, new Location(2.0, 2.5, 1.5), false);
		 209      -   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.0), false);
		 210      -   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 2.0), false);
		 211      - 
		 212      -   test.succeed();
		 213  371   })
		      372 +   .structureName("ComponentTests:platform")
		      373 +   .maxTicks(1000)
		 214      -   .structureName("APITests:armor_stand")
		      374 +   .tag(GameTest.Tags.suiteDisabled);
		 215      -   .tag(GameTest.Tags.suiteDefault);
		 216  375   
		      376 + GameTest.register("APITests", "add_effect_event", (test) => {
		 217      - GameTest.register("APITests", "pulse_redstone", (test) => {
		 218      -   const pulseLoc = new BlockLocation(1, 2, 2);
		 219      -   const lampLoc = new BlockLocation(1, 2, 1);
		      377 +   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		      378 +   const villager = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		 220      -   test.assertRedstonePower(lampLoc, 0);
		 221      -   test.pulseRedstone(pulseLoc, 2);
		 222  379   
		      380 +   const effectAddCallback = world.events.effectAdd.subscribe((eventData) => {
		 223      -   test
		 224      -     .startSequence()
		 225      -     .thenIdle(2)
		      381 +     test.assert(eventData.entity.id === "minecraft:villager_v2", "Unexpected id");
		      382 +     test.assert(eventData.effect.displayName === "Poison II", "Unexpected display name");
		      383 +     test.assert(eventData.effectState === 1, "Unexpected effect state");
		      384 +     test.succeed();
		      385 +   });
		 226      -     .thenExecute(() => test.assertRedstonePower(lampLoc, 15))
		 227      -     .thenIdle(2)
		 228      -     .thenExecute(() => test.assertRedstonePower(lampLoc, 0))
		 229      -     .thenSucceed();
		 230      - }).tag(GameTest.Tags.suiteDefault);
		 231  386   
		      387 +   villager.addEffect(MinecraftEffectTypes.poison, 5, 1);
		      388 +   world.events.effectAdd.unsubscribe(effectAddCallback);
		 232      - GameTest.register("APITests", "block_location", (test) => {
		      389 + })
		      390 +   .structureName("ComponentTests:animal_pen")
		      391 +   .tag(GameTest.Tags.suiteDefault);
		      392 + 
		      393 + GameTest.register("APITests", "piston", (test) => {
		      394 +   const dimension = test.getDimension();
		      395 +   const pistonLoc = new BlockLocation(1, 2, 1);
		      396 +   const redstoneLoc = new BlockLocation(1, 2, 0);
		      397 +   const pistonComp = test.getDimension().getBlock(test.worldBlockLocation(pistonLoc)).getComponent("piston");
		 233      -   let testLoc = new BlockLocation(1, 1, 1);
		 234      -   let worldLoc = test.worldBlockLocation(testLoc);
		 235      -   let relativeLoc = test.relativeBlockLocation(worldLoc);
		 236      -   test.assert(!relativeLoc.equals(worldLoc), "Expected relativeLoc and worldLoc to be different");
		 237      -   test.assert(relativeLoc.equals(testLoc), "Expected relativeLoc to match testLoc");
		 238      -   test.succeed();
		 239      - })
		 240      -   .structureName("ComponentTests:platform")
		 241      -   .tag(GameTest.Tags.suiteDefault);
		 242  398   
		 243      - GameTest.register("APITests", "location", (test) => {
		 244      -   let testLoc = new Location(1.2, 1.2, 1.2);
		 245      -   let worldLoc = test.worldLocation(testLoc);
		 246      -   let relativeLoc = test.relativeLocation(worldLoc);
		      399 +   test.assert(pistonComp != undefined, "Expected piston component");
		      400 + 
		      401 +   let assertPistonState = (isMoving, isExpanded, isExpanding, isRetracted, isRetracting) => {
		      402 +     test.assert(pistonComp.isMoving === isMoving, "Unexpected isMoving");
		      403 +     test.assert(pistonComp.isExpanded === isExpanded, "Unexpected isExpanded");
		      404 +     test.assert(pistonComp.isExpanding === isExpanding, "Unexpected isExpanding");
		 247      -   test.assert(!relativeLoc.isNear(worldLoc, 0.01), "Expected relativeLoc and worldLoc to be different");
		 248      -   test.assert(relativeLoc.isNear(testLoc, 0.01), "Expected relativeLoc to match testLoc");
		 249      -   test.succeed();
		 250      - })
		 251      -   .structureName("ComponentTests:platform")
		 252      -   .tag(GameTest.Tags.suiteDefault);
		 253      - 
		      405 +     test.assert(pistonComp.isRetracted === isRetracted, "Unexpected isRetracted");
		      406 +     test.assert(pistonComp.isRetracting === isRetracting, "Unexpected isRetracting");
		      407 +   };
		 254      - GameTest.register("APITests", "create_explosion_basic", (test) => {
		 255      -   let overworld = World.getDimension("overworld");
		 256      -   const center = new BlockLocation(2, 3, 2);
		 257  408   
		      409 +   test
		      410 +     .startSequence()
		      411 +     .thenExecute(() => {
		      412 +       test.assert(pistonComp.attachedBlocks.length === 0, "Expected 0 attached blocks");
		 258      -   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		 259      - 
		      413 +       assertPistonState(false, false, false, true, false); // isRetracted
		      414 +       test.setBlockType(MinecraftBlockTypes.redstoneBlock, redstoneLoc);
		      415 +     })
		      416 +     .thenIdle(4)
		      417 +     .thenExecute(() => {
		      418 +       test.assert(pistonComp.attachedBlocks.length === 3, "Expected 3 attached blocks");
		      419 +       assertPistonState(true, false, true, false, false); // isMoving, isExpanding
		      420 +     })
		      421 +     .thenIdle(2)
		      422 +     .thenExecute(() => {
		      423 +       assertPistonState(false, true, false, false, false); // isExpanded
		 260      -   const loc = test.worldBlockLocation(center);
		 261      -   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		 262      -   overworld.createExplosion(explosionLoc, 10, new ExplosionOptions());
		 263      - 
		 264      -   for (let x = 1; x <= 3; x++) {
		 265      -     for (let y = 2; y <= 4; y++) {
		 266      -       for (let z = 1; z <= 3; z++) {
		 267      -         test.assertBlockPresent(MinecraftBlockTypes.cobblestone, new BlockLocation(x, y, z), false);
		 268      -       }
		 269      -     }
		 270      -   }
		 271  424   
		      425 +       test.setBlockType(MinecraftBlockTypes.air, redstoneLoc);
		      426 +     })
		 272      -   test.succeed();
		 273      - })
		      427 +     .thenIdle(4)
		      428 +     .thenExecute(() => {
		      429 +       assertPistonState(true, false, false, false, true); // isMoving, isRetracting
		      430 +     })
		      431 +     .thenIdle(2)
		      432 +     .thenExecute(() => {
		      433 +       assertPistonState(false, false, false, true, false); // isRetracted
		      434 +     })
		      435 +     .thenSucceed();
		      436 + }).tag(GameTest.Tags.suiteDefault);
		 274      -   .padding(10) // The blast can destroy nearby items and mobs
		 275      -   .tag(GameTest.Tags.suiteDefault);
		 276      - 
		 277      - GameTest.register("APITests", "create_explosion_advanced", (test) => {
		 278      -   let overworld = World.getDimension("overworld");
		 279      -   const center = new BlockLocation(3, 3, 3);
		 280      - 
		 281      -   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		 282      -   const pigLoc = new BlockLocation(3, 4, 3);
		 283      -   test.spawn(pigId, pigLoc);
		 284  437   
		      438 + GameTest.register("APITests", "piston_event", (test) => {
		      439 +   let expanded = false;
		 285      -   const loc = test.worldBlockLocation(center);
		      440 +   let retracted = false;
		      441 +   const redstoneLoc = new BlockLocation(1, 2, 0);
		      442 +   const pistonLoc = new BlockLocation(1, 2, 1);
		      443 +   const planksLoc = new BlockLocation(2, 2, 1);
		 286      -   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		 287      -   let explosionOptions = new ExplosionOptions();
		 288      - 
		 289      -   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		 290  444   
		 291      -   // Start by exploding without breaking blocks
		 292      -   explosionOptions.breaksBlocks = false;
		 293      -   const creeper = test.spawn("minecraft:creeper", new BlockLocation(1, 2, 1));
		      445 +   const pistonCallback = world.events.pistonActivate.subscribe((pistonEvent) => {
		      446 +     test.assert(pistonEvent.piston !== undefined, "Expected piston");
		      447 +     if (pistonEvent.piston.location.equals(test.worldBlockLocation(pistonLoc))) {
		      448 +       if (pistonEvent.isExpanding) {
		      449 +         expanded = true;
		      450 +       } else {
		      451 +         retracted = true;
		      452 +       }
		      453 +     }
		      454 +   });
		 294      -   explosionOptions.source = creeper;
		 295      -   test.assertEntityPresent(pigId, pigLoc, true);
		 296      -   overworld.createExplosion(explosionLoc, 10, explosionOptions);
		 297      -   creeper.kill();
		 298      -   test.assertEntityPresent(pigId, pigLoc, false);
		 299      -   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		 300      - 
		 301      -   // Next, explode with fire
		 302      -   explosionOptions = new ExplosionOptions();
		 303      -   explosionOptions.causesFire = true;
		 304  455   
		      456 +   test
		      457 +     .startSequence()
		      458 +     .thenExecute(() => {
		 305      -   let findFire = () => {
		      459 +       test.pulseRedstone(redstoneLoc, 2);
		      460 +     })
		      461 +     .thenExecuteAfter(8, () => {
		      462 +       test.assertBlockPresent(MinecraftBlockTypes.air, planksLoc, true);
		      463 +       test.assert(expanded, "Expected piston expanding event");
		      464 +       test.assert(retracted, "Expected piston retracting event");
		      465 +       world.events.beforePistonActivate.unsubscribe(pistonCallback);
		      466 +     })
		      467 +     .thenSucceed();
		      468 + })
		      469 +   .structureName("APITests:piston")
		      470 +   .tag(GameTest.Tags.suiteDefault);
		 306      -     let foundFire = false;
		 307      -     for (let x = 0; x <= 6; x++) {
		 308      -       for (let z = 0; z <= 6; z++) {
		 309      -         try {
		 310      -           test.assertBlockPresent(MinecraftBlockTypes.fire, new BlockLocation(x, 3, z), true);
		 311      -           foundFire = true;
		 312      -           break;
		 313      -         } catch (e) {}
		 314      -       }
		 315      -     }
		 316      -     return foundFire;
		 317      -   };
		 318  471   
		      472 + GameTest.register("APITests", "piston_event_canceled", (test) => {
		      473 +   let canceled = false;
		 319      -   test.assert(!findFire(), "Unexpected fire");
		      474 +   const redstoneLoc = new BlockLocation(1, 2, 0);
		      475 +   const pistonLoc = new BlockLocation(1, 2, 1);
		      476 +   const planksLoc = new BlockLocation(2, 2, 1);
		 320      -   overworld.createExplosion(explosionLoc, 15, explosionOptions);
		 321      -   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, false);
		 322      -   test.assert(findFire(), "No fire found");
		 323  477   
		      478 +   const pistonCallback = world.events.beforePistonActivate.subscribe((pistonEvent) => {
		      479 +     test.assert(pistonEvent.piston !== undefined, "Expected piston");
		      480 +     if (pistonEvent.piston.location.equals(test.worldBlockLocation(pistonLoc))) {
		 324      -   // Finally, explode in water
		      481 +       pistonEvent.cancel = true;
		      482 +       canceled = true;
		      483 +     }
		      484 +   });
		      485 + 
		      486 +   test
		      487 +     .startSequence()
		      488 +     .thenExecute(() => {
		      489 +       test.pulseRedstone(redstoneLoc, 2);
		 325      -   explosionOptions.allowUnderwater = true;
		 326      -   const belowWaterLoc = new BlockLocation(3, 1, 3);
		 327      -   test.assertBlockPresent(MinecraftBlockTypes.air, belowWaterLoc, false);
		 328      -   overworld.createExplosion(explosionLoc, 10, explosionOptions);
		 329      -   test.assertBlockPresent(MinecraftBlockTypes.air, belowWaterLoc, true);
		 330      -   test.succeed();
		 331      - })
		 332      -   .padding(10) // The blast can destroy nearby items and mobs
		 333      -   .tag(GameTest.Tags.suiteDefault);
		 334      - 
		      490 +     })
		      491 +     .thenExecuteAfter(8, () => {
		      492 +       test.assert(canceled, "Expected canceled beforePistonActivate event");
		      493 +       test.assertBlockPresent(MinecraftBlockTypes.planks, planksLoc, true);
		      494 +       world.events.beforePistonActivate.unsubscribe(pistonCallback);
		      495 +     })
		      496 +     .thenSucceed();
		 335      - GameTest.register("APITests", "triggerEvent", (test) => {
		 336      -   const creeper = test.spawn("creeper", new BlockLocation(1, 2, 1));
		 337      -   creeper.triggerEvent("minecraft:start_exploding_forced");
		 338      - 
		 339      -   test.succeedWhen(() => {
		 340      -     test.assertEntityPresentInArea("creeper", false);
		 341      -   });
		 342  497   })
		      498 +   .structureName("APITests:piston")
		 343      -   .structureName("ComponentTests:glass_cage")
		 344  499     .tag(GameTest.Tags.suiteDefault);
		 345  500   
		      501 + GameTest.register("APITests", "sneaking", (test) => {
		      502 +   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		      503 +   const pigLoc = new BlockLocation(1, 2, 1);
		      504 +   const pig = test.spawn(pigId, pigLoc);
		      505 +   pig.isSneaking = true;
		      506 +   test
		      507 +     .startSequence()
		      508 +     .thenExecuteAfter(120, () => {
		      509 +       test.assertEntityPresent(pigId, pigLoc, true);
		      510 +     })
		      511 +     .thenSucceed();
		      512 + })
		      513 +   .maxTicks(130)
		      514 +   .tag(GameTest.Tags.suiteDefault);
		      515 + 
		      516 + GameTest.register("APITests", "assert_can_reach_location", (test) => {
		      517 +   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		      518 +   const villager1 = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		      519 +   const villager2 = test.spawn(villagerId, new BlockLocation(1, 2, 3));
		 346      - GameTest.register("APITests", "chat", (test) => {
		 347      -   test.print("subscribing");
		 348      - 
		 349      -   const chatCallback = World.events.beforeChat.subscribe((eventData) => {
		 350      -     if (eventData.message === "!killme") {
		 351      -       eventData.sender.kill();
		 352      -       eventData.cancel = true;
		 353      -     } else if (eventData.message === "!players") {
		 354      -       test.print(`There are ${eventData.targets.length} players in the server.`);
		 355      -       for (const target of eventData.targets) {
		 356      -         test.print("Player: " + target.name);
		 357      -       }
		 358      -     } else {
		 359      -       eventData.message = `Modified '${eventData.message}'`;
		 360      -     }
		 361      -   });
		 362      - 
		      520 +   const villager3 = test.spawn(villagerId, new BlockLocation(1, 2, 5));
		      521 +   test.assertCanReachLocation(villager1, new BlockLocation(4, 2, 1), true);
		      522 +   test.assertCanReachLocation(villager2, new BlockLocation(4, 2, 3), false);
		      523 +   test.assertCanReachLocation(villager3, new BlockLocation(4, 2, 5), false);
		      524 +   test.succeed();
		      525 + }).tag(GameTest.Tags.suiteDefault);
		      526 + 
		      527 + const isLocationInTest = (test, worldLoc) => {
		      528 +   const size = 4;
		      529 +   let loc = test.relativeBlockLocation(worldLoc);
		      530 +   return loc.x >= 0 && loc.y >= 0 && loc.z >= 0 && loc.x < size && loc.y < size && loc.z < size;
		      531 + };
		 363      -   test
		 364      -     .startSequence()
		 365      -     .thenIdle(200)
		 366      -     .thenExecute(() => {
		 367      -       World.events.beforeChat.unsubscribe(chatCallback);
		 368      -       test.print("unsubscribed");
		 369      -     })
		 370      -     .thenSucceed();
		 371      - })
		 372      -   .structureName("ComponentTests:platform")
		 373      -   .maxTicks(1000)
		 374      -   .tag(GameTest.Tags.suiteDisabled);
		 375  532   
		      533 + GameTest.register("APITests", "explosion_event", (test) => {
		      534 +   let exploded = false;
		 376      - GameTest.register("APITests", "add_effect_event", (test) => {
		      535 +   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		      536 +   const polishedAndesiteLoc = new BlockLocation(1, 1, 1);
		 377      -   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		 378      -   const villager = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		 379  537   
		      538 +   const beforeExplosionCallback = world.events.beforeExplosion.subscribe((explosionEvent) => {
		      539 +     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		      540 +     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		 380      -   const effectAddCallback = World.events.effectAdd.subscribe((eventData) => {
		      541 +     test.assert(explosionEvent.source !== undefined, "Expected source");
		      542 +     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		      543 +     test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		      544 +     explosionEvent.impactedBlocks = [test.worldBlockLocation(cobblestoneLoc)];
		 381      -     test.assert(eventData.entity.id === "minecraft:villager_v2", "Unexpected id");
		 382      -     test.assert(eventData.effect.displayName === "Poison II", "Unexpected display name");
		 383      -     test.assert(eventData.effectState === 1, "Unexpected effect state");
		 384      -     test.succeed();
		 385  545     });
		 386  546   
		      547 +   const explosionCallback = world.events.explosion.subscribe((explosionEvent) => {
		      548 +     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		 387      -   villager.addEffect(MinecraftEffectTypes.poison, 5, 1);
		      549 +     test.assert(explosionEvent.source !== undefined, "Expected source");
		      550 +     test.assert(explosionEvent.impactedBlocks.length === 1, "Unexpected number of impacted blocks");
		      551 +     exploded = true;
		      552 +   });
		 388      -   World.events.effectAdd.unsubscribe(effectAddCallback);
		 389      - })
		 390      -   .structureName("ComponentTests:animal_pen")
		 391      -   .tag(GameTest.Tags.suiteDefault);
		 392  553   
		      554 +   test
		      555 +     .startSequence()
		      556 +     .thenExecute(() => {
		      557 +       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		      558 +       test.spawn("tnt", new BlockLocation(1, 2, 1));
		      559 +     })
		      560 +     .thenExecuteAfter(85, () => {
		      561 +       test.assert(exploded, "Expected explosion event");
		      562 +       test.assertBlockPresent(MinecraftBlockTypes.stone, polishedAndesiteLoc, true);
		      563 +       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, false);
		      564 +       world.events.beforeExplosion.unsubscribe(beforeExplosionCallback);
		      565 +       world.events.explosion.unsubscribe(explosionCallback);
		      566 +     })
		      567 +     .thenSucceed();
		      568 + })
		      569 +   .padding(10) // The blast can destroy nearby items and mobs
		      570 +   .structureName("ComponentTests:platform")
		      571 +   .tag(GameTest.Tags.suiteDefault);
		 393      - GameTest.register("APITests", "piston", (test) => {
		 394      -   const overworld = World.getDimension("overworld");
		 395      -   const pistonLoc = new BlockLocation(1, 2, 1);
		 396      -   const redstoneLoc = new BlockLocation(1, 2, 0);
		 397      -   const pistonComp = overworld.getBlock(test.worldBlockLocation(pistonLoc)).getComponent("piston");
		 398      - 
		 399      -   test.assert(pistonComp != undefined, "Expected piston component");
		 400      - 
		 401      -   let assertPistonState = (isMoving, isExpanded, isExpanding, isRetracted, isRetracting) => {
		 402      -     test.assert(pistonComp.isMoving === isMoving, "Unexpected isMoving");
		 403      -     test.assert(pistonComp.isExpanded === isExpanded, "Unexpected isExpanded");
		 404      -     test.assert(pistonComp.isExpanding === isExpanding, "Unexpected isExpanding");
		 405      -     test.assert(pistonComp.isRetracted === isRetracted, "Unexpected isRetracted");
		 406      -     test.assert(pistonComp.isRetracting === isRetracting, "Unexpected isRetracting");
		 407      -   };
		 408  572   
		 409      -   test
		 410      -     .startSequence()
		 411      -     .thenExecute(() => {
		      573 + GameTest.register("APITests", "explosion_event_canceled", (test) => {
		      574 +   let canceled = false;
		      575 +   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		      576 + 
		      577 +   const explosionCallback = world.events.beforeExplosion.subscribe((explosionEvent) => {
		      578 +     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		      579 +     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		      580 +     test.assert(explosionEvent.source !== undefined, "Expected source");
		      581 +     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		      582 +     explosionEvent.cancel = true;
		      583 +     canceled = true;
		      584 +   });
		 412      -       test.assert(pistonComp.attachedBlocks.length === 0, "Expected 0 attached blocks");
		 413      -       assertPistonState(false, false, false, true, false); // isRetracted
		 414      -       test.setBlockType(MinecraftBlockTypes.redstoneBlock, redstoneLoc);
		 415      -     })
		 416      -     .thenIdle(4)
		 417      -     .thenExecute(() => {
		 418      -       test.assert(pistonComp.attachedBlocks.length === 3, "Expected 3 attached blocks");
		 419      -       assertPistonState(true, false, true, false, false); // isMoving, isExpanding
		 420      -     })
		 421      -     .thenIdle(2)
		 422      -     .thenExecute(() => {
		 423      -       assertPistonState(false, true, false, false, false); // isExpanded
		 424  585   
		      586 +   test
		 425      -       test.setBlockType(MinecraftBlockTypes.air, redstoneLoc);
		 426      -     })
		      587 +     .startSequence()
		 427      -     .thenIdle(4)
		 428  588       .thenExecute(() => {
		      589 +       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		      590 +       test.spawn("tnt", new BlockLocation(1, 2, 1));
		 429      -       assertPistonState(true, false, false, false, true); // isMoving, isRetracting
		 430  591       })
		      592 +     .thenExecuteAfter(85, () => {
		      593 +       test.assert(canceled, "Expected canceled beforeExplosionEvent event");
		 431      -     .thenIdle(2)
		      594 +       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		      595 +       world.events.beforeExplosion.unsubscribe(explosionCallback);
		 432      -     .thenExecute(() => {
		 433      -       assertPistonState(false, false, false, true, false); // isRetracted
		 434  596       })
		 435  597       .thenSucceed();
		 436      - }).tag(GameTest.Tags.suiteDefault);
		 437      - 
		 438      - GameTest.register("APITests", "piston_event", (test) => {
		 439      -   let expanded = false;
		      598 + })
		      599 +   .padding(10) // The blast can destroy nearby items and mobs
		      600 +   .structureName("ComponentTests:platform")
		      601 +   .tag(GameTest.Tags.suiteDefault);
		 440      -   let retracted = false;
		 441      -   const redstoneLoc = new BlockLocation(1, 2, 0);
		 442      -   const pistonLoc = new BlockLocation(1, 2, 1);
		 443      -   const planksLoc = new BlockLocation(2, 2, 1);
		 444  602   
		      603 + GameTest.register("APITests", "explode_block_event", (test) => {
		 445      -   const pistonCallback = World.events.pistonActivate.subscribe((pistonEvent) => {
		 446      -     test.assert(pistonEvent.piston !== undefined, "Expected piston");
		      604 +   let explodedCount = 0;
		      605 +   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		      606 + 
		      607 +   const blockExplodeCallback = world.events.blockExplode.subscribe((blockExplodeEvent) => {
		      608 +     if (!isLocationInTest(test, blockExplodeEvent.destroyedBlock.location)) return;
		      609 +     test.assert(blockExplodeEvent.source !== undefined, "Expected source");
		      610 +     explodedCount++;
		 447      -     if (pistonEvent.piston.location.equals(test.worldBlockLocation(pistonLoc))) {
		 448      -       if (pistonEvent.isExpanding) {
		 449      -         expanded = true;
		 450      -       } else {
		 451      -         retracted = true;
		 452      -       }
		 453      -     }
		 454  611     });
		 455  612   
		 456  613     test
		 457  614       .startSequence()
		 458  615       .thenExecute(() => {
		      616 +       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		      617 +       test.spawn("tnt", new BlockLocation(1, 2, 1));
		 459      -       test.pulseRedstone(redstoneLoc, 2);
		 460  618       })
		      619 +     .thenExecuteAfter(85, () => {
		 461      -     .thenExecuteAfter(8, () => {
		 462      -       test.assertBlockPresent(MinecraftBlockTypes.air, planksLoc, true);
		 463      -       test.assert(expanded, "Expected piston expanding event");
		      620 +       test.assert(explodedCount === 10, "Unexpected number of exploded blocks");
		      621 +       world.events.blockExplode.unsubscribe(blockExplodeCallback);
		 464      -       test.assert(retracted, "Expected piston retracting event");
		 465      -       World.events.beforePistonActivate.unsubscribe(pistonCallback);
		 466  622       })
		 467  623       .thenSucceed();
		 468  624   })
		      625 +   .padding(10) // The blast can destroy nearby items and mobs
		      626 +   .structureName("ComponentTests:platform")
		 469      -   .structureName("APITests:piston")
		 470  627     .tag(GameTest.Tags.suiteDefault);
		      628 + 
		      629 + GameTest.register("APITests", "connectivity", (test) => {
		      630 +   const centerLoc = new BlockLocation(1, 2, 1);
		 471  631   
		 472      - GameTest.register("APITests", "piston_event_canceled", (test) => {
		 473      -   let canceled = false;
		 474      -   const redstoneLoc = new BlockLocation(1, 2, 0);
		 475      -   const pistonLoc = new BlockLocation(1, 2, 1);
		      632 +   let connectivity = test.getFenceConnectivity(centerLoc);
		 476      -   const planksLoc = new BlockLocation(2, 2, 1);
		 477  633   
		 478      -   const pistonCallback = World.events.beforePistonActivate.subscribe((pistonEvent) => {
		 479      -     test.assert(pistonEvent.piston !== undefined, "Expected piston");
		 480      -     if (pistonEvent.piston.location.equals(test.worldBlockLocation(pistonLoc))) {
		      634 +   test.assert(!connectivity.north, "The stair is not oriented the right way to connect");
		      635 +   test.assert(connectivity.east, "Should connect to another fence");
		      636 +   test.assert(connectivity.south, "Should connect to another fence");
		      637 +   test.assert(connectivity.west, "Should connect to the back of the stairs");
		 481      -       pistonEvent.cancel = true;
		 482      -       canceled = true;
		 483      -     }
		 484      -   });
		 485  638   
		      639 +   test.succeed();
		 486      -   test
		 487      -     .startSequence()
		      640 + })
		      641 +   .rotateTest(true)
		      642 +   .tag(GameTest.Tags.suiteDefault);
		      643 + 
		      644 + GameTest.register("APITests", "spawn_at_location", (test) => {
		      645 +   const spawnLoc = new Location(1.3, 2, 1.3);
		      646 +   const chicken = test.spawnAtLocation("chicken", spawnLoc);
		      647 + 
		      648 +   test
		      649 +     .startSequence()
		      650 +     .thenExecute(() => {
		      651 +       const chickenLoc = chicken.location;
		      652 +       const relativeChickenLoc = test.relativeLocation(chickenLoc);
		      653 +       test.assert(relativeChickenLoc.isNear(spawnLoc, 0.01), "Unexpected spawn location");
		      654 +     })
		      655 +     .thenSucceed();
		      656 + })
		      657 +   .structureName("ComponentTests:animal_pen")
		      658 +   .rotateTest(true)
		      659 +   .tag(GameTest.Tags.suiteDefault);
		      660 + 
		      661 + GameTest.register("APITests", "walk_to_location", (test) => {
		      662 +   const spawnLoc = new BlockLocation(1, 2, 1);
		      663 +   const chicken = test.spawnWithoutBehaviors("chicken", spawnLoc);
		      664 + 
		      665 +   const targetLoc = new Location(2.2, 2, 3.2);
		      666 +   test.walkToLocation(chicken, targetLoc, 1);
		 488      -     .thenExecute(() => {
		 489      -       test.pulseRedstone(redstoneLoc, 2);
		 490      -     })
		 491      -     .thenExecuteAfter(8, () => {
		 492      -       test.assert(canceled, "Expected canceled beforePistonActivate event");
		 493      -       test.assertBlockPresent(MinecraftBlockTypes.planks, planksLoc, true);
		 494      -       World.events.beforePistonActivate.unsubscribe(pistonCallback);
		 495      -     })
		 496      -     .thenSucceed();
		 497      - })
		 498      -   .structureName("APITests:piston")
		 499      -   .tag(GameTest.Tags.suiteDefault);
		 500      - 
		 501      - GameTest.register("APITests", "sneaking", (test) => {
		 502      -   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		 503      -   const pigLoc = new BlockLocation(1, 2, 1);
		 504      -   const pig = test.spawn(pigId, pigLoc);
		 505      -   pig.isSneaking = true;
		 506      -   test
		 507      -     .startSequence()
		 508      -     .thenExecuteAfter(120, () => {
		 509      -       test.assertEntityPresent(pigId, pigLoc, true);
		 510      -     })
		 511      -     .thenSucceed();
		 512      - })
		 513      -   .maxTicks(130)
		 514      -   .tag(GameTest.Tags.suiteDefault);
		 515  667   
		      668 +   test.succeedWhen(() => {
		      669 +     const chickenLoc = chicken.location;
		      670 +     const relativeChickenLoc = test.relativeLocation(chickenLoc);
		      671 +     // Mobs will stop navigating as soon as they intersect the target location
		      672 +     test.assert(relativeChickenLoc.isNear(targetLoc, 0.65), "Chicken did not reach the target location");
		      673 +   });
		      674 + })
		      675 +   .structureName("ComponentTests:large_animal_pen")
		      676 +   .tag(GameTest.Tags.suiteDefault);
		      677 + 
		      678 + GameTest.register("APITests", "spread_from_face_toward_direction", (test) => {
		      679 +   let multifaceLoc = new BlockLocation(1, 4, 0);
		      680 +   let spreadLoc = new BlockLocation(1, 3, 0);
		 516      - GameTest.register("APITests", "assert_can_reach_location", (test) => {
		 517      -   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		 518      -   const villager1 = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		 519      -   const villager2 = test.spawn(villagerId, new BlockLocation(1, 2, 3));
		 520      -   const villager3 = test.spawn(villagerId, new BlockLocation(1, 2, 5));
		 521      -   test.assertCanReachLocation(villager1, new BlockLocation(4, 2, 1), true);
		 522      -   test.assertCanReachLocation(villager2, new BlockLocation(4, 2, 3), false);
		 523      -   test.assertCanReachLocation(villager3, new BlockLocation(4, 2, 5), false);
		 524      -   test.succeed();
		 525      - }).tag(GameTest.Tags.suiteDefault);
		 526  681   
		      682 +   const glowLichenPermutation = MinecraftBlockTypes.glowLichen.createDefaultBlockPermutation();
		 527      - const isLocationInTest = (test, worldLoc) => {
		 528      -   const size = 4;
		 529      -   let loc = test.relativeBlockLocation(worldLoc);
		      683 +   glowLichenPermutation.getProperty(BlockProperties.multiFaceDirectionBits).value = 1 << test.getTestDirection();
		      684 +   test.setBlockPermutation(glowLichenPermutation, multifaceLoc);
		 530      -   return loc.x >= 0 && loc.y >= 0 && loc.z >= 0 && loc.x < size && loc.y < size && loc.z < size;
		 531      - };
		 532  685   
		      686 +   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, multifaceLoc, true);
		 533      - GameTest.register("APITests", "explosion_event", (test) => {
		 534      -   let exploded = false;
		 535      -   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		      687 +   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, false);
		 536      -   const polishedAndesiteLoc = new BlockLocation(1, 1, 1);
		 537  688   
		      689 +   test.spreadFromFaceTowardDirection(multifaceLoc, test.getTestDirection(), Direction.down);
		      690 +   test
		      691 +     .startSequence()
		 538      -   const beforeExplosionCallback = World.events.beforeExplosion.subscribe((explosionEvent) => {
		      692 +     .thenExecuteAfter(1, () => {
		      693 +       test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, true);
		      694 +     })
		      695 +     .thenSucceed();
		      696 + })
		      697 +   .rotateTest(true)
		      698 +   .tag(GameTest.Tags.suiteDefault);
		 539      -     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		 540      -     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		 541      -     test.assert(explosionEvent.source !== undefined, "Expected source");
		 542      -     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		 543      -     test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		 544      -     explosionEvent.impactedBlocks = [test.worldBlockLocation(cobblestoneLoc)];
		 545      -   });
		 546  699   
		      700 + GameTest.register("APITests", "rotate_direction", (test) => {
		 547      -   const explosionCallback = World.events.explosion.subscribe((explosionEvent) => {
		 548      -     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		      701 +   test.assert(
		      702 +     test.rotateDirection(Direction.south) == test.getTestDirection(),
		      703 +     "Expected rotated south direction to match test direction"
		      704 +   );
		 549      -     test.assert(explosionEvent.source !== undefined, "Expected source");
		 550      -     test.assert(explosionEvent.impactedBlocks.length === 1, "Unexpected number of impacted blocks");
		 551      -     exploded = true;
		 552      -   });
		 553  705   
		      706 +   switch (test.getTestDirection()) {
		 554      -   test
		 555      -     .startSequence()
		      707 +     case Direction.north:
		      708 +       test.assert(
		      709 +         test.rotateDirection(Direction.north) === Direction.south,
		      710 +         "Unexpected rotated direction for Direction.north with testDirection Direction.north"
		      711 +       );
		      712 +       test.assert(
		      713 +         test.rotateDirection(Direction.east) === Direction.west,
		      714 +         "Unexpected rotated direction for Direction.east with testDirection Direction.north"
		      715 +       );
		      716 +       test.assert(
		      717 +         test.rotateDirection(Direction.south) === Direction.north,
		      718 +         "Unexpected rotated direction for Direction.south with testDirection Direction.north"
		      719 +       );
		      720 +       test.assert(
		      721 +         test.rotateDirection(Direction.west) === Direction.east,
		      722 +         "Unexpected rotated direction for Direction.west with testDirection Direction.north"
		      723 +       );
		      724 +       break;
		      725 +     case Direction.east:
		      726 +       test.assert(
		      727 +         test.rotateDirection(Direction.north) === Direction.west,
		      728 +         "Unexpected rotated direction for Direction.north with testDirection Direction.east"
		      729 +       );
		      730 +       test.assert(
		      731 +         test.rotateDirection(Direction.east) === Direction.north,
		      732 +         "Unexpected rotated direction for Direction.east with testDirection Direction.east"
		      733 +       );
		      734 +       test.assert(
		      735 +         test.rotateDirection(Direction.south) === Direction.east,
		      736 +         "Unexpected rotated direction for Direction.south with testDirection Direction.east"
		      737 +       );
		      738 +       test.assert(
		      739 +         test.rotateDirection(Direction.west) === Direction.south,
		      740 +         "Unexpected rotated direction for Direction.west with testDirection Direction.east"
		      741 +       );
		      742 +       break;
		      743 +     case Direction.south:
		      744 +       test.assert(
		      745 +         test.rotateDirection(Direction.north) === Direction.north,
		      746 +         "Unexpected rotated direction for Direction.north with testDirection Direction.south"
		      747 +       );
		      748 +       test.assert(
		      749 +         test.rotateDirection(Direction.east) === Direction.east,
		      750 +         "Unexpected rotated direction for Direction.east with testDirection Direction.south"
		      751 +       );
		      752 +       test.assert(
		      753 +         test.rotateDirection(Direction.south) === Direction.south,
		      754 +         "Unexpected rotated direction for Direction.south with testDirection Direction.south"
		      755 +       );
		      756 +       test.assert(
		      757 +         test.rotateDirection(Direction.west) === Direction.west,
		      758 +         "Unexpected rotated direction for Direction.west with testDirection Direction.south"
		      759 +       );
		      760 +       break;
		      761 +     case Direction.west:
		      762 +       test.assert(
		      763 +         test.rotateDirection(Direction.north) === Direction.east,
		      764 +         "Unexpected rotated direction for Direction.north with testDirection Direction.west"
		      765 +       );
		      766 +       test.assert(
		      767 +         test.rotateDirection(Direction.east) === Direction.south,
		      768 +         "Unexpected rotated direction for Direction.east with testDirection Direction.west"
		      769 +       );
		      770 +       test.assert(
		      771 +         test.rotateDirection(Direction.south) === Direction.west,
		      772 +         "Unexpected rotated direction for Direction.south with testDirection Direction.west"
		      773 +       );
		      774 +       test.assert(
		      775 +         test.rotateDirection(Direction.west) === Direction.north,
		      776 +         "Unexpected rotated direction for Direction.west with testDirection Direction.west"
		      777 +       );
		      778 +       break;
		      779 +     default:
		      780 +       test.assert(false, "Invalid test direction");
		      781 +   }
		 556      -     .thenExecute(() => {
		 557      -       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		 558      -       test.spawn("tnt", new BlockLocation(1, 2, 1));
		 559      -     })
		 560      -     .thenExecuteAfter(85, () => {
		 561      -       test.assert(exploded, "Expected explosion event");
		 562      -       test.assertBlockPresent(MinecraftBlockTypes.stone, polishedAndesiteLoc, true);
		 563      -       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, false);
		 564      -       World.events.beforeExplosion.unsubscribe(beforeExplosionCallback);
		 565      -       World.events.explosion.unsubscribe(explosionCallback);
		 566      -     })
		 567      -     .thenSucceed();
		 568      - })
		 569      -   .padding(10) // The blast can destroy nearby items and mobs
		 570      -   .structureName("ComponentTests:platform")
		 571      -   .tag(GameTest.Tags.suiteDefault);
		 572      - 
		 573      - GameTest.register("APITests", "explosion_event_canceled", (test) => {
		 574      -   let canceled = false;
		 575      -   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		 576      - 
		 577      -   const explosionCallback = World.events.beforeExplosion.subscribe((explosionEvent) => {
		 578      -     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		 579      -     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		 580      -     test.assert(explosionEvent.source !== undefined, "Expected source");
		 581      -     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		 582      -     explosionEvent.cancel = true;
		 583      -     canceled = true;
		 584      -   });
		 585      - 
		 586      -   test
		 587      -     .startSequence()
		 588      -     .thenExecute(() => {
		 589      -       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		 590      -       test.spawn("tnt", new BlockLocation(1, 2, 1));
		 591      -     })
		 592      -     .thenExecuteAfter(85, () => {
		 593      -       test.assert(canceled, "Expected canceled beforeExplosionEvent event");
		 594      -       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		 595      -       World.events.beforeExplosion.unsubscribe(explosionCallback);
		 596      -     })
		 597      -     .thenSucceed();
		 598      - })
		 599      -   .padding(10) // The blast can destroy nearby items and mobs
		 600      -   .structureName("ComponentTests:platform")
		 601      -   .tag(GameTest.Tags.suiteDefault);
		 602      - 
		 603      - GameTest.register("APITests", "explode_block_event", (test) => {
		 604      -   let explodedCount = 0;
		 605      -   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		 606      - 
		 607      -   const blockExplodeCallback = World.events.blockExplode.subscribe((blockExplodeEvent) => {
		 608      -     if (!isLocationInTest(test, blockExplodeEvent.destroyedBlock.location)) return;
		 609      -     test.assert(blockExplodeEvent.source !== undefined, "Expected source");
		 610      -     explodedCount++;
		 611      -   });
		 612      - 
		 613      -   test
		 614      -     .startSequence()
		 615      -     .thenExecute(() => {
		 616      -       test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		 617      -       test.spawn("tnt", new BlockLocation(1, 2, 1));
		 618      -     })
		 619      -     .thenExecuteAfter(85, () => {
		 620      -       test.assert(explodedCount === 10, "Unexpected number of exploded blocks");
		 621      -       World.events.blockExplode.unsubscribe(blockExplodeCallback);
		 622      -     })
		 623      -     .thenSucceed();
		 624      - })
		 625      -   .padding(10) // The blast can destroy nearby items and mobs
		 626      -   .structureName("ComponentTests:platform")
		 627      -   .tag(GameTest.Tags.suiteDefault);
		 628      - 
		 629      - GameTest.register("APITests", "connectivity", (test) => {
		 630      -   const centerLoc = new BlockLocation(1, 2, 1);
		 631  782   
		      783 +   const buttonLoc = new BlockLocation(1, 2, 1);
		      784 +   const buttonPermutation = MinecraftBlockTypes.stoneButton.createDefaultBlockPermutation();
		      785 +   buttonPermutation.getProperty(BlockProperties.facingDirection).value = test.rotateDirection(Direction.north);
		      786 +   test.setBlockPermutation(buttonPermutation, buttonLoc);
		 632      -   let connectivity = test.getFenceConnectivity(centerLoc);
		 633  787   
		      788 +   test
		      789 +     .startSequence()
		 634      -   test.assert(!connectivity.north, "The stair is not oriented the right way to connect");
		 635      -   test.assert(connectivity.east, "Should connect to another fence");
		      790 +     .thenExecuteAfter(2, () => {
		      791 +       test.assertBlockPresent(MinecraftBlockTypes.stoneButton, buttonLoc, true);
		      792 +     })
		      793 +     .thenSucceed();
		 636      -   test.assert(connectivity.south, "Should connect to another fence");
		 637      -   test.assert(connectivity.west, "Should connect to the back of the stairs");
		 638      - 
		 639      -   test.succeed();
		 640  794   })
		 641  795     .rotateTest(true)
		 642  796     .tag(GameTest.Tags.suiteDefault);
		 643  797   
		      798 + function isNear(a, b) {
		      799 +   return Math.abs(a - b) < 0.001;
		 644      - GameTest.register("APITests", "spawn_at_location", (test) => {
		 645      -   const spawnLoc = new Location(1.3, 2, 1.3);
		      800 + }
		 646      -   const chicken = test.spawnAtLocation("chicken", spawnLoc);
		 647  801   
		      802 + GameTest.register("APITests", "cauldron", (test) => {
		 648      -   test
		 649      -     .startSequence()
		      803 +   const loc = new BlockLocation(0, 1, 0);
		      804 +   var block = test.getBlock(loc);
		      805 + 
		      806 +   test.setFluidContainer(loc, GameTest.FluidType.water);
		      807 +   test.assert(block.getComponent("waterContainer") != null, "This is a water container");
		      808 +   test.assert(
		      809 +     block.getComponent("lavaContainer") == null,
		      810 +     "A water container should not have a lavaContainer component"
		      811 +   );
		      812 +   test.assert(
		      813 +     block.getComponent("snowContainer") == null,
		      814 +     "A water container should not have a snowContainer component"
		      815 +   );
		      816 +   test.assert(
		      817 +     block.getComponent("potionContainer") == null,
		      818 +     "A water container should not have a potionContainer component"
		      819 +   );
		 650      -     .thenExecute(() => {
		 651      -       const chickenLoc = chicken.location;
		 652      -       const relativeChickenLoc = test.relativeLocation(chickenLoc);
		 653      -       test.assert(relativeChickenLoc.isNear(spawnLoc, 0.01), "Unexpected spawn location");
		 654      -     })
		 655      -     .thenSucceed();
		 656      - })
		 657      -   .structureName("ComponentTests:animal_pen")
		 658      -   .rotateTest(true)
		 659      -   .tag(GameTest.Tags.suiteDefault);
		 660      - 
		 661      - GameTest.register("APITests", "walk_to_location", (test) => {
		 662      -   const spawnLoc = new BlockLocation(1, 2, 1);
		 663      -   const chicken = test.spawnWithoutBehaviors("chicken", spawnLoc);
		 664      - 
		 665      -   const targetLoc = new Location(2.2, 2, 3.2);
		 666      -   test.walkToLocation(chicken, targetLoc, 1);
		 667  820   
		 668      -   test.succeedWhen(() => {
		 669      -     const chickenLoc = chicken.location;
		 670      -     const relativeChickenLoc = test.relativeLocation(chickenLoc);
		 671      -     // Mobs will stop navigating as soon as they intersect the target location
		      821 +   block.getComponent("waterContainer").fillLevel = FluidContainer.maxFillLevel;
		      822 +   test.assert(
		      823 +     block.getComponent("waterContainer").fillLevel == FluidContainer.maxFillLevel,
		      824 +     "The fill level should match with what it was set to"
		      825 +   );
		 672      -     test.assert(relativeChickenLoc.isNear(targetLoc, 0.65), "Chicken did not reach the target location");
		 673      -   });
		 674      - })
		 675      -   .structureName("ComponentTests:large_animal_pen")
		 676      -   .tag(GameTest.Tags.suiteDefault);
		 677  826   
		      827 +   block.getComponent("waterContainer").customColor = new Color(1, 0, 0, 1);
		      828 +   test.assert(block.getComponent("waterContainer").customColor.red == 1, "red component should be set");
		 678      - GameTest.register("APITests", "spread_from_face_toward_direction", (test) => {
		      829 +   test.assert(block.getComponent("waterContainer").customColor.green == 0, "green component should be set");
		      830 +   test.assert(block.getComponent("waterContainer").customColor.blue == 0, "blue component should be set");
		 679      -   let multifaceLoc = new BlockLocation(1, 4, 0);
		 680      -   let spreadLoc = new BlockLocation(1, 3, 0);
		 681  831   
		      832 +   block.getComponent("waterContainer").addDye(MinecraftItemTypes.blueDye);
		      833 +   test.assert(isNear(block.getComponent("waterContainer").customColor.red, 0.616), "red component should be set");
		 682      -   const glowLichenPermutation = MinecraftBlockTypes.glowLichen.createDefaultBlockPermutation();
		      834 +   test.assert(isNear(block.getComponent("waterContainer").customColor.green, 0.133), "green component should be set");
		      835 +   test.assert(isNear(block.getComponent("waterContainer").customColor.blue, 0.333), "blue component should be set");
		 683      -   glowLichenPermutation.getProperty(BlockProperties.multiFaceDirectionBits).value = 1 << test.getTestDirection();
		 684      -   test.setBlockPermutation(glowLichenPermutation, multifaceLoc);
		 685  836   
		      837 +   test.setFluidContainer(loc, GameTest.FluidType.lava);
		      838 +   test.assert(
		      839 +     block.getComponent("waterContainer") == null,
		 686      -   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, multifaceLoc, true);
		      840 +     "A lava container should not have a waterContainer component"
		 687      -   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, false);
		 688      - 
		      841 +   );
		      842 +   test.assert(block.getComponent("lavaContainer") != null, "This is a lava component");
		      843 +   test.assert(
		      844 +     block.getComponent("snowContainer") == null,
		      845 +     "A lava container should not have a snowContainer component"
		      846 +   );
		      847 +   test.assert(
		      848 +     block.getComponent("potionContainer") == null,
		      849 +     "A lava container should not have a potionContainer component"
		      850 +   );
		 689      -   test.spreadFromFaceTowardDirection(multifaceLoc, test.getTestDirection(), Direction.down);
		 690      -   test
		 691      -     .startSequence()
		 692      -     .thenExecuteAfter(1, () => {
		 693      -       test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, true);
		 694      -     })
		 695      -     .thenSucceed();
		 696      - })
		 697      -   .rotateTest(true)
		 698      -   .tag(GameTest.Tags.suiteDefault);
		 699  851   
		      852 +   test.setFluidContainer(loc, GameTest.FluidType.powderSnow);
		 700      - GameTest.register("APITests", "rotate_direction", (test) => {
		 701  853     test.assert(
		      854 +     block.getComponent("waterContainer") == null,
		      855 +     "A snow container should not have a waterContainer component"
		 702      -     test.rotateDirection(Direction.south) == test.getTestDirection(),
		 703      -     "Expected rotated south direction to match test direction"
		 704  856     );
		      857 +   test.assert(
		 705      - 
		 706      -   switch (test.getTestDirection()) {
		      858 +     block.getComponent("lavaContainer") == null,
		      859 +     "A snow container should not have a lavaContainer component"
		      860 +   );
		      861 +   test.assert(block.getComponent("snowContainer") != null, "This is a snow container");
		      862 +   test.assert(
		      863 +     block.getComponent("potionContainer") == null,
		      864 +     "A snow container should not have a potionContainer component"
		      865 +   );
		      866 + 
		      867 +   test.setFluidContainer(loc, GameTest.FluidType.potion);
		      868 +   test.assert(
		      869 +     block.getComponent("snowContainer") == null,
		      870 +     "A potion container should not have a waterContainer component"
		      871 +   );
		      872 +   test.assert(
		      873 +     block.getComponent("lavaContainer") == null,
		      874 +     "A potion container should not have a lavaContainer component"
		      875 +   );
		      876 +   test.assert(
		      877 +     block.getComponent("snowContainer") == null,
		      878 +     "A potion container should not have a snowContainer component"
		      879 +   );
		      880 +   test.assert(block.getComponent("potionContainer") != null, "This is a potion container");
		      881 + 
		      882 +   test.succeed();
		      883 + }).tag(GameTest.Tags.suiteDefault);
		      884 + 
		      885 + GameTest.register("APITests", "jukebox", (test) => {
		      886 +   var jukeboxBlock = test.getBlock(new BlockLocation(0, 1, 0));
		      887 +   var musicPlayerComp = jukeboxBlock.getComponent("recordPlayer");
		      888 + 
		      889 +   try {
		      890 +     musicPlayerComp.setRecord(MinecraftItemTypes.apple);
		      891 +     test.fail("An exception should be thrown when playing an item that is not a music disk");
		      892 +   } catch (e) {}
		      893 + 
		      894 +   test.assert(musicPlayerComp.isPlaying() === false, "Should be stopped");
		      895 +   musicPlayerComp.setRecord(MinecraftItemTypes.musicDiscMellohi);
		      896 +   test.assert(musicPlayerComp.isPlaying() === true, "Should be playing");
		      897 + 
		      898 +   test
		      899 +     .startSequence()
		      900 +     .thenExecuteAfter(20, () => {
		      901 +       test.assert(musicPlayerComp.isPlaying() === true, "Disk should not be finished yet");
		      902 +       musicPlayerComp.clearRecord();
		      903 +       test.assert(musicPlayerComp.isPlaying() === false, "Disk should be stopped now");
		      904 +     })
		      905 +     .thenSucceed();
		      906 + })
		      907 +   .maxTicks(25)
		      908 +   .tag(GameTest.Tags.suiteDefault);
		      909 + 
		      910 + GameTest.register("APITests", "maybe_fill_cauldron", (test) => {
		      911 +   test
		      912 +     .startSequence()
		      913 +     .thenExecute(() => {
		      914 +       test.triggerInternalBlockEvent(new BlockLocation(1, 3, 1), "minecraft:drip");
		      915 +       test.triggerInternalBlockEvent(new BlockLocation(3, 3, 1), "minecraft:drip");
		      916 +     })
		      917 +     .thenIdle(61)
		      918 +     .thenExecute(() => {
		      919 +       var waterCauldron = test.getBlock(new BlockLocation(3, 2, 1));
		      920 +       var lavaCauldron = test.getBlock(new BlockLocation(1, 2, 1));
		 707      -     case Direction.north:
		 708      -       test.assert(
		 709      -         test.rotateDirection(Direction.north) === Direction.south,
		 710      -         "Unexpected rotated direction for Direction.north with testDirection Direction.north"
		 711      -       );
		 712      -       test.assert(
		 713      -         test.rotateDirection(Direction.east) === Direction.west,
		 714      -         "Unexpected rotated direction for Direction.east with testDirection Direction.north"
		 715      -       );
		 716      -       test.assert(
		 717      -         test.rotateDirection(Direction.south) === Direction.north,
		 718      -         "Unexpected rotated direction for Direction.south with testDirection Direction.north"
		 719      -       );
		 720      -       test.assert(
		 721      -         test.rotateDirection(Direction.west) === Direction.east,
		 722      -         "Unexpected rotated direction for Direction.west with testDirection Direction.north"
		 723      -       );
		 724      -       break;
		 725      -     case Direction.east:
		 726      -       test.assert(
		 727      -         test.rotateDirection(Direction.north) === Direction.west,
		 728      -         "Unexpected rotated direction for Direction.north with testDirection Direction.east"
		 729      -       );
		 730      -       test.assert(
		 731      -         test.rotateDirection(Direction.east) === Direction.north,
		 732      -         "Unexpected rotated direction for Direction.east with testDirection Direction.east"
		 733      -       );
		 734      -       test.assert(
		 735      -         test.rotateDirection(Direction.south) === Direction.east,
		 736      -         "Unexpected rotated direction for Direction.south with testDirection Direction.east"
		 737      -       );
		 738      -       test.assert(
		 739      -         test.rotateDirection(Direction.west) === Direction.south,
		 740      -         "Unexpected rotated direction for Direction.west with testDirection Direction.east"
		 741      -       );
		 742      -       break;
		 743      -     case Direction.south:
		 744      -       test.assert(
		 745      -         test.rotateDirection(Direction.north) === Direction.north,
		 746      -         "Unexpected rotated direction for Direction.north with testDirection Direction.south"
		 747      -       );
		 748      -       test.assert(
		 749      -         test.rotateDirection(Direction.east) === Direction.east,
		 750      -         "Unexpected rotated direction for Direction.east with testDirection Direction.south"
		 751      -       );
		 752      -       test.assert(
		 753      -         test.rotateDirection(Direction.south) === Direction.south,
		 754      -         "Unexpected rotated direction for Direction.south with testDirection Direction.south"
		 755      -       );
		 756      -       test.assert(
		 757      -         test.rotateDirection(Direction.west) === Direction.west,
		 758      -         "Unexpected rotated direction for Direction.west with testDirection Direction.south"
		 759      -       );
		 760      -       break;
		 761      -     case Direction.west:
		 762      -       test.assert(
		 763      -         test.rotateDirection(Direction.north) === Direction.east,
		 764      -         "Unexpected rotated direction for Direction.north with testDirection Direction.west"
		 765      -       );
		 766      -       test.assert(
		 767      -         test.rotateDirection(Direction.east) === Direction.south,
		 768      -         "Unexpected rotated direction for Direction.east with testDirection Direction.west"
		 769      -       );
		 770  921         test.assert(
		      922 +         waterCauldron.getComponent("waterContainer").fillLevel == 2,
		      923 +         "Expected water to be at level 2, but got " + waterCauldron.getComponent("waterContainer").fillLevel
		 771      -         test.rotateDirection(Direction.south) === Direction.west,
		 772      -         "Unexpected rotated direction for Direction.south with testDirection Direction.west"
		 773  924         );
		 774  925         test.assert(
		      926 +         lavaCauldron.getComponent("lavaContainer").fillLevel == FluidContainer.maxFillLevel,
		      927 +         "Expected lava to be full, but got a fill level of " + lavaCauldron.getComponent("lavaContainer").fillLevel
		 775      -         test.rotateDirection(Direction.west) === Direction.north,
		 776      -         "Unexpected rotated direction for Direction.west with testDirection Direction.west"
		 777  928         );
		      929 +     })
		      930 +     .thenSucceed();
		      931 + })
		 778      -       break;
		      932 +   .setupTicks(30) // time it takes lava to flow.
		      933 +   .maxTicks(100)
		      934 +   .tag(GameTest.Tags.suiteDefault);
		 779      -     default:
		 780      -       test.assert(false, "Invalid test direction");
		 781      -   }
		 782  935   
		      936 + GameTest.register("APITests", "grow_pointed_dripstone", (test) => {
		      937 +   test.triggerInternalBlockEvent(new BlockLocation(1, 5, 1), "grow_stalagtite");
		 783      -   const buttonLoc = new BlockLocation(1, 2, 1);
		 784      -   const buttonPermutation = MinecraftBlockTypes.stoneButton.createDefaultBlockPermutation();
		      938 +   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 4, 1), true);
		      939 +   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 2, 1), false);
		 785      -   buttonPermutation.getProperty(BlockProperties.facingDirection).value = test.rotateDirection(Direction.north);
		 786      -   test.setBlockPermutation(buttonPermutation, buttonLoc);
		 787  940   
		 788      -   test
		 789      -     .startSequence()
		 790      -     .thenExecuteAfter(2, () => {
		 791      -       test.assertBlockPresent(MinecraftBlockTypes.stoneButton, buttonLoc, true);
		      941 +   test.triggerInternalBlockEvent(new BlockLocation(1, 5, 1), "grow_stalagmite");
		      942 +   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 4, 1), true);
		      943 +   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 2, 1), true);
		      944 + 
		      945 +   test.assertBlockPresent(MinecraftBlockTypes.pointedDripstone, new BlockLocation(1, 3, 1), false);
		 792      -     })
		 793      -     .thenSucceed();
		 794      - })
		 795      -   .rotateTest(true)
		 796      -   .tag(GameTest.Tags.suiteDefault);
		 797  946   
		      947 +   test.succeed();
		 798      - function isNear(a, b) {
		 799      -   return Math.abs(a - b) < 0.001;
		      948 + }).tag(GameTest.Tags.suiteDefault);
		 800      - }
		 801  949   
		      950 + GameTest.register("APITests", "vines", (test) => {
		 802      - GameTest.register("APITests", "cauldron", (test) => {
		 803      -   const loc = new BlockLocation(0, 1, 0);
		      951 +   const testEx = new GameTestExtensions(test);
		 804      -   var block = test.getBlock(loc);
		 805  952   
		      953 +   const allBitmask = 15;
		 806      -   test.setFluidContainer(loc, GameTest.FluidType.water);
		 807      -   test.assert(block.getComponent("waterContainer") != null, "This is a water container");
		 808      -   test.assert(
		      954 +   const northBitmask = 1 << testEx.getVineDirection(Direction.north);
		      955 +   const eastBitmask = 1 << testEx.getVineDirection(Direction.east);
		      956 +   const southBitmask = 1 << testEx.getVineDirection(Direction.south);
		      957 +   const westBitmask = 1 << testEx.getVineDirection(Direction.west);
		      958 + 
		      959 +   test.triggerInternalBlockEvent(new BlockLocation(1, 4, 2), "grow_down", [southBitmask | northBitmask]);
		      960 +   testEx.assertBlockProperty(
		      961 +     BlockProperties.vineDirectionBits,
		      962 +     southBitmask | northBitmask,
		      963 +     new BlockLocation(1, 3, 2)
		 809      -     block.getComponent("lavaContainer") == null,
		 810      -     "A water container should not have a lavaContainer component"
		 811      -   );
		 812      -   test.assert(
		 813      -     block.getComponent("snowContainer") == null,
		 814      -     "A water container should not have a snowContainer component"
		 815      -   );
		 816      -   test.assert(
		 817      -     block.getComponent("potionContainer") == null,
		 818      -     "A water container should not have a potionContainer component"
		 819  964     );
		      965 + 
		      966 +   test.triggerInternalBlockEvent(new BlockLocation(1, 4, 2), "grow_up", [allBitmask]);
		      967 +   testEx.assertBlockProperty(BlockProperties.vineDirectionBits, southBitmask | eastBitmask, new BlockLocation(1, 5, 2));
		 820  968   
		      969 +   test.triggerInternalBlockEvent(new BlockLocation(7, 2, 1), "grow_sideways", [
		 821      -   block.getComponent("waterContainer").fillLevel = FluidContainer.maxFillLevel;
		 822      -   test.assert(
		      970 +     testEx.getVineDirection(Direction.west),
		      971 +   ]);
		      972 +   testEx.assertBlockProperty(BlockProperties.vineDirectionBits, southBitmask, new BlockLocation(6, 2, 1));
		 823      -     block.getComponent("waterContainer").fillLevel == FluidContainer.maxFillLevel,
		 824      -     "The fill level should match with what it was set to"
		 825      -   );
		 826  973   
		      974 +   test.triggerInternalBlockEvent(new BlockLocation(6, 2, 1), "grow_sideways", [
		      975 +     testEx.getVineDirection(Direction.west),
		 827      -   block.getComponent("waterContainer").customColor = new Color(1, 0, 0, 1);
		 828      -   test.assert(block.getComponent("waterContainer").customColor.red == 1, "red component should be set");
		      976 +   ]);
		      977 +   testEx.assertBlockProperty(BlockProperties.vineDirectionBits, southBitmask | westBitmask, new BlockLocation(6, 2, 1));
		 829      -   test.assert(block.getComponent("waterContainer").customColor.green == 0, "green component should be set");
		 830      -   test.assert(block.getComponent("waterContainer").customColor.blue == 0, "blue component should be set");
		 831  978   
		      979 +   test.triggerInternalBlockEvent(new BlockLocation(7, 2, 1), "grow_sideways", [
		      980 +     testEx.getVineDirection(Direction.east),
		 832      -   block.getComponent("waterContainer").addDye(MinecraftItemTypes.blueDye);
		 833      -   test.assert(isNear(block.getComponent("waterContainer").customColor.red, 0.616), "red component should be set");
		      981 +   ]);
		      982 +   testEx.assertBlockProperty(BlockProperties.vineDirectionBits, westBitmask, new BlockLocation(8, 2, 2));
		 834      -   test.assert(isNear(block.getComponent("waterContainer").customColor.green, 0.133), "green component should be set");
		 835      -   test.assert(isNear(block.getComponent("waterContainer").customColor.blue, 0.333), "blue component should be set");
		 836  983   
		 837      -   test.setFluidContainer(loc, GameTest.FluidType.lava);
		 838      -   test.assert(
		 839      -     block.getComponent("waterContainer") == null,
		      984 +   test.succeed();
		      985 + }).tag(GameTest.Tags.suiteDefault);
		      986 + 
		      987 + GameTest.register("APITests", "tags", (test) => {
		      988 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1), "tag_player");
		      989 +   const dimension = test.getDimension();
		      990 + 
		      991 +   test
		      992 +     .startSequence()
		      993 +     .thenExecuteAfter(2, () => {
		      994 +       dimension.runCommand("tag @p[name=tag_player] add test_tag_1");
		 840      -     "A lava container should not have a waterContainer component"
		 841      -   );
		 842      -   test.assert(block.getComponent("lavaContainer") != null, "This is a lava component");
		 843      -   test.assert(
		 844      -     block.getComponent("snowContainer") == null,
		 845      -     "A lava container should not have a snowContainer component"
		 846      -   );
		 847      -   test.assert(
		 848      -     block.getComponent("potionContainer") == null,
		 849      -     "A lava container should not have a potionContainer component"
		 850      -   );
		 851      - 
		      995 +       test.assert(player.hasTag("test_tag_1"), "Expected tag test_tag_1");
		      996 +       test.assert(!player.hasTag("test_tag_2"), "Did not expect tag test_tag_2");
		      997 +       test.assert(player.removeTag("test_tag_1"), "Expected successful tag removal");
		      998 +       test.assert(!player.removeTag("test_tag_1"), "Expected failed tag removal");
		      999 +       test.assert(!player.hasTag("test_tag_1"), "Did not expect tag test_tag_1");
		     1000 +       player.addTag("test_tag_2");
		     1001 +       test.assert(player.hasTag("test_tag_2"), "Expected tag test_tag_2");
		     1002 +       let tags = player.getTags();
		     1003 +       test.assert(tags.length === 1 && tags[0] === "test_tag_2", "Unexpected tags value");
		     1004 +     })
		     1005 +     .thenSucceed();
		     1006 + })
		     1007 +   .structureName("ComponentTests:platform")
		     1008 +   .tag(GameTest.Tags.suiteDefault);
		 852      -   test.setFluidContainer(loc, GameTest.FluidType.powderSnow);
		 853      -   test.assert(
		 854      -     block.getComponent("waterContainer") == null,
		 855      -     "A snow container should not have a waterContainer component"
		 856      -   );
		 857      -   test.assert(
		 858      -     block.getComponent("lavaContainer") == null,
		 859      -     "A snow container should not have a lavaContainer component"
		 860      -   );
		 861      -   test.assert(block.getComponent("snowContainer") != null, "This is a snow container");
		 862      -   test.assert(
		 863      -     block.getComponent("potionContainer") == null,
		 864      -     "A snow container should not have a potionContainer component"
		 865      -   );
		 866 1009   
		 867      -   test.setFluidContainer(loc, GameTest.FluidType.potion);
		 868      -   test.assert(
		 869      -     block.getComponent("snowContainer") == null,
		 870      -     "A potion container should not have a waterContainer component"
		     1010 + //AI tests
		     1011 + GameTest.register("APITests", "can_set_target", (test) => {
		     1012 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		     1013 +   let wolf = test.spawn("minecraft:wolf<minecraft:ageable_grow_up>", new BlockLocation(2, 2, 1));
		     1014 +   
		     1015 +   test
		     1016 +     .startSequence()
		     1017 +     .thenExecuteAfter(10, () => {
		     1018 +       wolf.target = player;
		     1019 +       const targetActor = wolf.target;
		     1020 +       wolf.kill();
		     1021 +       test.assert(targetActor == player, "Failed to set/get target on wolf");
		     1022 +     })
		     1023 +     .thenSucceed();
		     1024 + })
		     1025 +   .structureName("ComponentTests:platform")
		     1026 +   .tag(GameTest.Tags.suiteDefault);
		 871      -   );
		 872      -   test.assert(
		 873      -     block.getComponent("lavaContainer") == null,
		 874      -     "A potion container should not have a lavaContainer component"
		 875      -   );
		 876      -   test.assert(
		 877      -     block.getComponent("snowContainer") == null,
		 878      -     "A potion container should not have a snowContainer component"
		 879      -   );
		 880      -   test.assert(block.getComponent("potionContainer") != null, "This is a potion container");
		 881      - 
		 882      -   test.succeed();
		 883      - }).tag(GameTest.Tags.suiteDefault);
		 884      - 
		 885      - GameTest.register("APITests", "jukebox", (test) => {
		 886      -   var jukeboxBlock = test.getBlock(new BlockLocation(0, 1, 0));
		 887      -   var musicPlayerComp = jukeboxBlock.getComponent("recordPlayer");
		 888 1027   
		     1028 + GameTest.register("APITests", "set_target_attacks_player", (test) => {
		     1029 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		 889      -   try {
		 890      -     musicPlayerComp.setRecord(MinecraftItemTypes.apple);
		     1030 +   let wolf = test.spawn("minecraft:wolf<minecraft:ageable_grow_up>", new BlockLocation(2, 2, 1));
		     1031 +   
		     1032 +   test
		     1033 +     .startSequence()
		     1034 +     .thenExecuteAfter(10, () => {
		     1035 +       wolf.target = player;
		     1036 +     })
		     1037 +     .thenWait(() => {
		     1038 +       const healthComponent = player.getComponent("minecraft:health");
		     1039 +       test.assert(healthComponent.current != healthComponent.value, "Player should have been attacked");
		     1040 +     })
		     1041 +     .thenExecute(() => {
		     1042 +       wolf.kill();
		 891      -     test.fail("An exception should be thrown when playing an item that is not a music disk");
		 892      -   } catch (e) {}
		 893      - 
		 894      -   test.assert(musicPlayerComp.isPlaying() === false, "Should be stopped");
		 895      -   musicPlayerComp.setRecord(MinecraftItemTypes.musicDiscMellohi);
		 896      -   test.assert(musicPlayerComp.isPlaying() === true, "Should be playing");
		 897      - 
		 898      -   test
		 899      -     .startSequence()
		 900      -     .thenExecuteAfter(20, () => {
		 901      -       test.assert(musicPlayerComp.isPlaying() === true, "Disk should not be finished yet");
		 902      -       musicPlayerComp.clearRecord();
		 903      -       test.assert(musicPlayerComp.isPlaying() === false, "Disk should be stopped now");
		 904 1043       })
		 905 1044       .thenSucceed();
		 906 1045   })
		     1046 +   .maxTicks(200)
		     1047 +   .structureName("ComponentTests:platform")
		 907      -   .maxTicks(25)
		 908 1048     .tag(GameTest.Tags.suiteDefault);
		            '''
	Changed script "BlockTests.js":
		Total line: 375 (+2, -6)
		          '''
		          ...
		  3   3     BlockLocation,
		  4   4     MinecraftBlockTypes,
		  5   5     MinecraftItemTypes,
		  6   6     BlockProperties,
		  7   7     Direction,
		      8 +   world,
		  8     -   Commands,
		  9     -   World,
		 10   9     Location,
		 11  10   } from "mojang-minecraft";
		 12  11   import GameTestExtensions from "./GameTestExtensions.js";
		 13  12   
		 14  13   const TicksPerSecond = 20;
		          ...
		328 327     let playerSim = test.spawnSimulatedPlayer(new BlockLocation(1, 3, 1));
		329 328     let healthComp = playerSim.getComponent("health");
		330 329     test
		331 330       .startSequence()
		332 331       .thenExecuteAfter(180, () => test.assert(healthComp.current < healthComp.value, "no damage"))
		    332 +     .thenExecute(() => test.assertEntityInstancePresent(playerSim, new BlockLocation(1, 2, 1)))
		333     -     .thenExecute( () => test.assertEntityInstancePresent(playerSim, new BlockLocation(1, 2, 1)))
		334 333       .thenSucceed();
		335 334   })
		336 335     .maxTicks(200)
		337 336     .structureName(platformStructure)
		338 337     .tag(GameTest.Tags.suiteDefault);
		          ...
		342 341     test.setBlockType(MinecraftBlockTypes.powderSnow, new BlockLocation(1, 2, 1));
		343 342     test.setBlockType(MinecraftBlockTypes.powderSnow, new BlockLocation(1, 2, 2));
		344 343     let playerSim = test.spawnSimulatedPlayer(new BlockLocation(1, 5, 0), "playerSim_snow");
		345 344     test
		346 345       .startSequence()
		347     -     .thenExecuteAfter(5, () =>
		348     -       Commands.run(
		349     -         "/replaceitem entity playerSim_snow slot.armor.feet 0 leather_boots",
		    346 +     .thenExecuteAfter(5, () => {
		    347 +       playerSim.dimension.runCommand("replaceitem entity playerSim_snow slot.armor.feet 0 leather_boots");
		    348 +     })
		350     -         World.getDimension("overworld") //this command equips leather boots on the player
		351     -       )
		352     -     )
		353 349       .thenExecuteAfter(10, () => playerSim.moveToLocation(new Location(1, 3, 2.5)))
		354 350       .thenExecuteAfter(40, () => test.assertEntityPresent("player", new BlockLocation(1, 4, 2)))
		355 351       .thenSucceed();
		356 352   })
		357 353     .structureName(platformStructure)
		          ...
		          '''
	Added script "CommandTests.js":
		'''
		import * as GameTest from "mojang-gametest";
		import { world, BlockLocation } from "mojang-minecraft";
		
		GameTest.register("CommandTests", "commands_api_player_teleport", async (test) => {
		  const startLoc = new BlockLocation(6, 2, 1);
		  const endLoc = new BlockLocation(1, 2, 6);
		
		  const player = test.spawnSimulatedPlayer(startLoc, "Teleport-o-man"); // This line is never getting hit?!
		
		  await test.idle(20);
		  test.assertEntityInstancePresent(player, startLoc);
		
		  await test.idle(20);
		  const endLocAbs = test.worldBlockLocation(endLoc);
		  player.runCommand(`teleport ${endLocAbs.x} ${endLocAbs.y} ${endLocAbs.z}`);
		
		  await test.idle(20);
		  test.assertEntityInstancePresent(player, endLoc);
		
		  test.succeed();
		})
		  .structureName("CommandTests:commands_teleport")
		  .tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("CommandTests", "commands_api_pig_teleport", async (test) => {
		  const startLoc = new BlockLocation(6, 2, 1);
		  const endLoc = new BlockLocation(1, 2, 6);
		
		  const entity = test.spawn("minecraft:pig", startLoc);
		
		  await test.idle(20);
		  test.assertEntityInstancePresent(entity, startLoc);
		
		  await test.idle(20);
		  const endLocAbs = test.worldBlockLocation(endLoc);
		  entity.runCommand(`teleport ${endLocAbs.x} ${endLocAbs.y} ${endLocAbs.z}`);
		
		  await test.idle(20);
		  test.assertEntityInstancePresent(entity, endLoc);
		
		  test.succeed();
		})
		  .structureName("CommandTests:commands_teleport")
		  .tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("CommandTests", "commands_api_dimension_spawn_pig", async (test) => {
		  const spawnLoc = new BlockLocation(6, 2, 1);
		
		  const absSpawnLoc = test.worldBlockLocation(new BlockLocation(6, 2, 1));
		  test.getDimension().runCommand(`summon minecraft:pig ${absSpawnLoc.x} ${absSpawnLoc.y} ${absSpawnLoc.z}`);
		
		  await test.idle(20);
		  test.assertEntityPresent("minecraft:pig", spawnLoc);
		
		  test.succeed();
		})
		  .structureName("CommandTests:commands_teleport")
		  .tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("CommandTests", "commands_api_execute_vs_player", async (test) => {
		  const spawnLoc1 = new BlockLocation(1, 2, 1);
		  const spawnLoc2 = new BlockLocation(3, 2, 1);
		  const playerName1 = "Sim Player (execute at)";
		  const playerName2 = "Sim Player (runCommand)";
		  const player1 = test.spawnSimulatedPlayer(spawnLoc1, playerName1);
		  const player2 = test.spawnSimulatedPlayer(spawnLoc2, playerName2);
		
		  // Spawn blocks
		  await test.idle(20);
		
		  test.getDimension().runCommand(`execute "${playerName1}" ~ ~ ~ setblock ~ ~2 ~ stone`);
		  player2.runCommand(`setblock ~ ~2 ~ stone`);
		
		  // Test for blocks
		  await test.idle(40);
		
		  test.assert(
		    test.getBlock(new BlockLocation(1, 4, 1)).id == "minecraft:stone",
		    `Expected Stone block above ${playerName1}.`
		  );
		  test.assert(
		    test.getBlock(new BlockLocation(3, 4, 1)).id == "minecraft:stone",
		    `Expected Stone block above ${playerName2}.`
		  );
		  test.succeed();
		})
		  .structureName("CommandTests:doublecage")
		  .maxTicks(100);
		'''
	Changed script "DoorTests.js":
		Total line: 174 (+2, -3)
		          '''
		          ...
		140 140       testEx.assertBlockProperty("open_bit", 0, new BlockLocation(4, 2, 4));
		141 141       testEx.assertBlockProperty("open_bit", 0, new BlockLocation(2, 2, 4));
		142 142       testEx.assertBlockProperty("open_bit", 0, new BlockLocation(1, 2, 4));
		143 143       testEx.assertBlockProperty("open_bit", 0, new BlockLocation(2, 2, 5));
		144 144       testEx.assertBlockProperty("open_bit", 0, new BlockLocation(1, 2, 5));
		    145 +   });
		145     -   })
		146 146   })
		147 147     .maxTicks(900)
		148 148     .padding(DOOR_TEST_PADDING)
		149 149     .batch("night")
		150 150     .required(false)
		          ...
		162 162       test.assertEntityPresent(villagerActor, new BlockLocation(1, 2, 4), true);
		163 163       test.assertEntityPresent(villagerActor, new BlockLocation(3, 2, 5), true);
		164 164   
		165 165       testEx.assertBlockProperty("open_bit", 0, new BlockLocation(1, 2, 3));
		166 166       testEx.assertBlockProperty("open_bit", 0, new BlockLocation(3, 2, 3));
		    167 +   });
		167     - 
		168     -   })
		169 168   })
		170 169     .maxTicks(900)
		171 170     .padding(DOOR_TEST_PADDING)
		172 171     .batch("night")
		173 172     .required(false)
		          ...
		          '''
	Changed script "DripstoneTests.js":
		Total line: 177 (+2, -2)
		          '''
		  1   1   import * as GameTest from "mojang-gametest";
		      2 + import { BlockLocation, MinecraftBlockTypes, MinecraftItemTypes, world } from "mojang-minecraft";
		  2     - import { BlockLocation, MinecraftBlockTypes, MinecraftItemTypes, World } from "mojang-minecraft";
		  3   3   import GameTestExtensions from "./GameTestExtensions.js";
		  4   4   
		  5   5   function placeDripstoneTip(test, pos, hanging, waterlogged = false) {
		  6   6     const pointedDripstonePermutation = MinecraftBlockTypes.pointedDripstone.createDefaultBlockPermutation();
		  7   7     pointedDripstonePermutation.getProperty("hanging").value = hanging;
		  8   8     pointedDripstonePermutation.getProperty("dripstone_thickness").value = "tip";
		  9   9   
		     10 +   const pointedDripstoneBlock = test.getDimension().getBlock(test.worldBlockLocation(pos));
		 10     -   const pointedDripstoneBlock = World.getDimension("overworld").getBlock(test.worldBlockLocation(pos));
		 11  11     pointedDripstoneBlock.setPermutation(pointedDripstonePermutation);
		 12  12     pointedDripstoneBlock.isWaterlogged = waterlogged;
		 13  13   }
		 14  14   
		 15  15   function assertDripstone(test, pos, hanging, thickness, waterlogged = false) {
		          ...
		          '''
	Changed script "GameTestExtensions.js":
		Total line: 56 (+20, -4)
		        '''
		    1 + import { Direction } from "mojang-minecraft";
		    2 + import {ItemStack} from "mojang-minecraft";
		    3 + 
		    4 + export default class GameTestExtensions {
		    5 +   constructor(test) {
		    6 +     this.test = test;
		    7 +   }
		    8 + 
		    9 +   addEntityInBoat(entityType, blockLoc) {
		   10 +     const boat = this.test.spawn("boat", blockLoc);
		   11 +     this.test.assert(boat !== undefined, "Failed to spawn boat");
		   12 +     const rider = this.test.spawn(entityType, blockLoc);
		   13 +     this.test.assert(rider !== undefined, "Failed to spawn rider");
		   14 +     const boatRideableComp = boat.getComponent("rideable");
		   15 +     this.test.assert(boatRideableComp !== undefined, "Boat missing rideable component");
		   16 +     this.test.assert(boatRideableComp.addRider(rider), "Failed to add rider");
		   17 +     return rider;
		   18 +   }
		   19 + 
		   20 +   makeAboutToDrown(entity) {
		   21 +     this.test.assert(entity !== undefined, "Expected entity");
		   22 +     const healthComp = entity.getComponent("health");
		   23 +     this.test.assert(healthComp !== undefined, "Entity missing health component");
		   24 +     const breathableComp = entity.getComponent("breathable");
		   25 +     this.test.assert(breathableComp !== undefined, "Entity missing breathable component");
		   26 +     healthComp.setCurrent(1);
		   27 +     breathableComp.setAirSupply(0);
		   28 +   }
		   29 + 
		   30 +   assertBlockProperty(propertyName, value, blockLocation) {
		   31 +     this.test.assertBlockState(blockLocation, (block) => {
		   32 +       return block.permutation.getProperty(propertyName).value == value;
		   33 +     });
		 1    - import {ItemStack} from "mojang-minecraft";
		 2    - export default class GameTestExtensions {
		 3    -   constructor(test) {
		 4    -     this.test = test;
		 5    -   }
		 6    - 
		 7    -   addEntityInBoat(entityType, blockLoc) {
		 8    -     const boat = this.test.spawn("boat", blockLoc);
		 9    -     this.test.assert(boat !== undefined, "Failed to spawn boat");
		10    -     const rider = this.test.spawn(entityType, blockLoc);
		11    -     this.test.assert(rider !== undefined, "Failed to spawn rider");
		12    -     const boatRideableComp = boat.getComponent("rideable");
		13    -     this.test.assert(boatRideableComp !== undefined, "Boat missing rideable component");
		14    -     this.test.assert(boatRideableComp.addRider(rider), "Failed to add rider");
		15    -     return rider;
		16 34     }
		17 35   
		   36 + giveItem(player, itemType, amount, slot) {
		18    -   makeAboutToDrown(entity) {
		19    -     this.test.assert(entity !== undefined, "Expected entity");
		   37 +   const inventoryContainer = player.getComponent("inventory").container;
		   38 +   inventoryContainer.addItem(new ItemStack(itemType, amount ?? 1));
		   39 +   player.selectSlot(slot ?? 0);
		   40 + }
		   41 + 
		   42 +   getVineDirection(direction) {
		   43 +     const rotated = this.test.rotateDirection(direction);
		20    -     const healthComp = entity.getComponent("health");
		21    -     this.test.assert(healthComp !== undefined, "Entity missing health component");
		22    -     const breathableComp = entity.getComponent("breathable");
		23    -     this.test.assert(breathableComp !== undefined, "Entity missing breathable component");
		24    -     healthComp.setCurrent(1);
		25    -     breathableComp.setAirSupply(0);
		26    -   }
		27 44   
		   45 +     switch (rotated) {
		28    -   assertBlockProperty(propertyName, value, blockLocation) {
		29    -     this.test.assertBlockState(blockLocation, (block) => {
		   46 +       case Direction.north:
		   47 +         return 2;
		   48 +       case Direction.east:
		   49 +         return 3;
		   50 +       case Direction.south:
		   51 +         return 0;
		   52 +       case Direction.west:
		   53 +         return 1;
		   54 +     }
		   55 +   }
		30    -       return block.permutation.getProperty(propertyName).value == value;
		31    -     });
		32    -   }
		33    - 
		34    - giveItem(player, itemType, amount, slot) {
		35    -   const inventoryContainer = player.getComponent("inventory").container;
		36    -   inventoryContainer.addItem(new ItemStack(itemType, amount ?? 1));
		37    -   player.selectSlot(slot ?? 0);
		38    - }
		39    - 
		40 56   }
		        '''
	Added script "ItemTests.js":
		'''
		import * as GameTest from "mojang-gametest";
		import {
		  BlockLocation,
		  MinecraftBlockTypes,
		  Direction,
		  MinecraftItemTypes,
		  ItemStack,
		  Location,
		  world,
		} from "mojang-minecraft";
		
		function giveItem(player, itemType, amount, slot) {
		  const inventoryContainer = player.getComponent("inventory").container;
		  inventoryContainer.addItem(new ItemStack(itemType, amount ?? 1));
		  player.selectSlot(slot ?? 0);
		}
		
		GameTest.register("ItemTests", "item_use_event", (test) => {
		  const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		  
		  const blaze = test.spawn("blaze", new BlockLocation(1, 2, 3));
		  test.assert(blaze != undefined, "Failed to initialize Blaze");
		  const blazeHealth = blaze.getComponent("health");
		  let initialHealth = blazeHealth.current;
		
		  const snowball = new ItemStack(MinecraftItemTypes.snowball, 1);
		  
		  let eventReceived = false;
		  const eventSubscription = world.events.itemUse.subscribe((eventData) => {
		    if(eventData.source != player) {
		      return;
		    }
		    eventReceived = true;
		  });
		
		  test
		    .startSequence()
		    .thenExecuteAfter(5, () => {
		      player.useItem(snowball);
		    })
		    .thenExecuteAfter(5, () => {
		      world.events.itemUse.unsubscribe(eventSubscription);
		
		      let afterUseHealth = blazeHealth.current;
		      blaze.kill(); 
		
		      test.assert(eventReceived, "Should have received itemUse event");
		
		      test.assert(afterUseHealth < initialHealth, 
		        `Blaze was not hurt after snowball throw should have been cancelled: before-> ${initialHealth} after-> ${afterUseHealth}`
		      );     
		
		    })
		    .thenSucceed();
		})
		.structureName("SimulatedPlayerTests:use_item")
		.tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("ItemTests", "item_use_event_cancelled", (test) => {
		  const player = test.spawnSimulatedPlayer(new BlockLocation(0, 2, 0));
		  
		  const snowball = new ItemStack(MinecraftItemTypes.snowball, 1);
		  
		  let eventReceived = false;
		  let beforeEventReceived = false;
		
		  const beforeEventSubscription = world.events.beforeItemUse.subscribe((eventData) => {
		    if(eventData.source != player) {
		      return;
		    }
		    beforeEventReceived = true;
		    eventData.cancel = true;
		  });
		
		  const eventSubscription = world.events.itemUse.subscribe((eventData) => {
		    if(eventData.source != player) {
		      return;
		    }
		    eventReceived = true;
		  });
		
		  test
		    .startSequence()
		    .thenIdle(5)
		    .thenExecute(() => {
		      player.useItem(snowball);
		    })
		    .thenExecuteAfter(5, () => {
		      world.events.beforeItemUse.unsubscribe(beforeEventSubscription);
		      world.events.itemUse.unsubscribe(eventSubscription);
		
		      test.assert(beforeEventReceived, "Should have received beforeItemUse event");
		      test.assert(eventReceived == false, "Should not have received itemUse event");
		    })
		    .thenSucceed();
		})
		.structureName("ComponentTests:platform")
		.tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("ItemTests", "item_use_event_cancelled_stops_action", (test) => {
		  const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		  
		  const blaze = test.spawn("blaze", new BlockLocation(1, 2, 3));
		  test.assert(blaze != undefined, "Failed to initialize Blaze");
		  const blazeHealth = blaze.getComponent("health");
		  let initialHealth = blazeHealth.current;
		
		  const slot = 0;
		  const snowballCount = 10;
		  const inventoryContainer = player.getComponent("inventory").container;
		  
		  giveItem(player, MinecraftItemTypes.snowball, snowballCount, slot);
		    
		  let eventReceived = false;
		  let beforeEventReceived = false;
		
		  const beforeEventSubscription = world.events.beforeItemUse.subscribe((eventData) => {
		    if(eventData.source != player) {
		      return;
		    }
		    beforeEventReceived = true;
		    eventData.cancel = true;
		  });
		
		  const eventSubscription = world.events.itemUse.subscribe((eventData) => {
		    if(eventData.source != player) {
		      return;
		    }
		    eventReceived = true;
		  });
		
		  test
		    .startSequence()
		    .thenIdle(5)
		    .thenExecute(() => {
		      player.useItemInSlot(slot);
		    })
		    .thenExecuteAfter(5, () => {
		      world.events.beforeItemUse.unsubscribe(beforeEventSubscription);
		      world.events.itemUse.unsubscribe(eventSubscription);
		
		      let afterUseHealth = blazeHealth.current;
		      blaze.kill(); 
		
		      test.assert(beforeEventReceived, "Should have received beforeItemUse event");
		      test.assert(eventReceived == false, "Should not have received itemUse event");
		
		      let actualAmount = inventoryContainer.getItem(slot).amount;
		      test.assert(
		        actualAmount === snowballCount,
		        `Player should have ${snowballCount} snowballs but has ${actualAmount}`
		      );
		
		      test.assert(afterUseHealth === initialHealth, 
		        `Blaze was hurt after snowball throw should have been cancelled: before-> ${initialHealth} after-> ${afterUseHealth}`
		      );     
		
		    })
		    .thenSucceed();
		})
		.structureName("SimulatedPlayerTests:use_item")
		.tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("ItemTests", "item_use_on_event", (test) => {
		  const player = test.spawnSimulatedPlayer(new BlockLocation(0, 2, 0));
		  const dirtLoc = new BlockLocation(2, 1, 1);
		  const dirt = new ItemStack(MinecraftItemTypes.dirt, 1);
		
		  let eventReceived = false;
		  const eventSubscription = world.events.itemUseOn.subscribe((eventData) => {
		    if(eventData.source != player) {
		      return;
		    }
		    eventReceived = true;
		  });
		
		  test
		    .startSequence()
		    .thenExecuteAfter(5, () => {
		      player.useItemOnBlock(dirt, dirtLoc, Direction.up);
		    })
		    .thenExecuteAfter(5, () => {
		      world.events.itemUseOn.unsubscribe(eventSubscription);
		      test.assert(eventReceived, "Should have received itemUseOn event");
		    })
		    .thenSucceed();
		})
		.structureName("ComponentTests:platform")
		.tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("ItemTests", "item_use_on_event_cancelled_stops_action", (test) => {
		  const player = test.spawnSimulatedPlayer(new BlockLocation(0, 2, 0));
		  const dirtLoc = new BlockLocation(2, 1, 1);
		  const dirt = new ItemStack(MinecraftItemTypes.dirt, 1);
		
		  const beforeEventSubscription = world.events.beforeItemUseOn.subscribe((eventData) => {
		    if(eventData.source != player) {
		      return;
		    }
		    eventData.cancel = true;
		  });
		
		  test
		    .startSequence()
		    .thenExecuteAfter(5, () => {
		      player.useItemOnBlock(dirt, dirtLoc, Direction.up);
		    })
		    .thenExecuteAfter(5, () => {
		      world.events.beforeItemUseOn.unsubscribe(beforeEventSubscription);
		      test.assertBlockPresent(MinecraftBlockTypes.dirt, dirtLoc.above(), false);
		    })
		    .thenSucceed();
		})
		.structureName("ComponentTests:platform")
		.tag(GameTest.Tags.suiteDefault);
		'''
	Changed script "Main.js":
		Total line: 29 (+3, -0)
		        '''
		 1  1   import "scripts/APITests.js";
		 2  2   import "scripts/BlockTests.js";
		 3  3   import "scripts/ComponentTests.js";
		    4 + import "scripts/CommandTests.js";
		 4  5   import "scripts/DebugTests.js";
		 5  6   import "scripts/DispenserTests.js";
		 6  7   import "scripts/DoorTests.js";
		 7  8   import "scripts/DripstoneTests.js";
		 8  9   import "scripts/DuplicationTests.js";
		        ...
		18 19   import "scripts/PistonTests.js";
		19 20   import "scripts/TntTests.js";
		20 21   import "scripts/WaterPathfindingTests.js";
		21 22   import "scripts/SmallMobTests.js";
		22 23   import "scripts/BigMobTests.js";
		   24 + import "scripts/RaycastingTests.js";
		23 25   import "scripts/RedstoneTests.js";
		24 26   import "scripts/SimulatedPlayerTests.js";
		25 27   import "scripts/RespawnAnchorTests.js";
		26 28   import "scripts/PlaceSeedsTests.js";
		   29 + import "scripts/ItemTests.js";
		        '''
	Changed script "MobTests.js":
		Total line: 302 (+93, -43)
		          '''
		  1   1   import * as GameTest from "mojang-gametest";
		      2 + import { BlockLocation, MinecraftBlockTypes, MinecraftEffectTypes, MinecraftItemTypes } from "mojang-minecraft";
		      3 + import GameTestExtensions from "./GameTestExtensions.js";
		      4 + 
		      5 + 
		      6 + const TicksPerSecond = 20;
		      7 + 
		      8 + GameTest.register("MobTests", "zombie_burn", (test) => {
		      9 +   const zombieEntityType = "minecraft:zombie";
		     10 +   const zombiePosition = new BlockLocation(1, 2, 1);
		     11 + 
		     12 +   test.succeedWhenEntityPresent(zombieEntityType, zombiePosition, false);
		     13 + })
		     14 +   .maxTicks(TicksPerSecond * 30)
		     15 +   .tag(GameTest.Tags.suiteDefault)
		     16 +   .batch("day");
		     17 + 
		     18 + GameTest.register("MobTests", "effect_durations_longer_first", (test) => {
		     19 +   const testEx = new GameTestExtensions(test);
		     20 +   const villagerId = "minecraft:villager_v2";
		     21 +   const villagerPos = new BlockLocation(1, 2, 1);
		     22 +   const buttonPos = new BlockLocation(1, 4, 0);
		     23 +   const strongPotion = new BlockLocation(0, 4, 0);
		     24 +   const weakPotion = new BlockLocation(2, 4, 0);
		     25 +   const strongPotionDuration = TicksPerSecond * 16;
		     26 + 
		     27 +   test.spawn(villagerId, villagerPos);
		     28 + 
		     29 +   test
		     30 +     .startSequence()
		     31 +     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, weakPotion))
		     32 +     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		     33 +     .thenWait(() => testEx.assertBlockProperty("button_pressed_bit", 0, buttonPos))
		     34 +     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, strongPotion))
		     35 +     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		     36 +     .thenIdle(strongPotionDuration)
		     37 +     .thenWait(() => {
		     38 +       test.assertEntityState(
		     39 +         villagerPos,
		     40 +         villagerId,
		     41 +         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).amplifier == 0
		     42 +       ); // Strength level I
		     43 +       test.assertEntityState(
		     44 +         villagerPos,
		     45 +         villagerId,
		     46 +         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).duration > TicksPerSecond * 10
		     47 +       );
		     48 +     })
		     49 +     .thenSucceed();
		     50 + })
		     51 +   .structureName("MobTests:effect_durations")
		     52 +   .maxTicks(400)
		     53 +   .tag("suite:java_parity")
		     54 +   .tag(GameTest.Tags.suiteDisabled); // Weak potion duration is 33 seconds, strong is 16. After the strong potion expires the weak potion effect should have time remaining
		     55 + 
		     56 + GameTest.register("MobTests", "drowning_test", (test) => {
		     57 +   const villagerEntitySpawnType = "minecraft:villager_v2";
		     58 +   const pigSpawnType = "minecraft:pig";
		     59 + 
		     60 +   test.spawn(villagerEntitySpawnType, new BlockLocation(3, 2, 2));
		     61 +   test.spawn(pigSpawnType, new BlockLocation(3, 2, 4));
		     62 +   test.succeedWhen(() => {
		     63 +     test.assertEntityPresentInArea(pigSpawnType, false);
		     64 +     test.assertEntityPresentInArea(villagerEntitySpawnType, false);
		     65 +   });
		     66 + })
		     67 +   .maxTicks(TicksPerSecond * 45)
		     68 +   .tag(GameTest.Tags.suiteDefault);
		  2     - import GameTestExtensions from "./GameTestExtensions.js";
		  3     - 
		  4     - import { BlockLocation, MinecraftEffectTypes, MinecraftBlockTypes, Commands, World, MinecraftItemTypes} from "mojang-minecraft";
		  5     - 
		  6     - const TicksPerSecond = 20;
		  7  69   
		     70 + GameTest.register("MobTests", "golem_vs_pillager", (test) => {
		     71 +   const ironGolem = "minecraft:iron_golem";
		     72 +   const pillager = "minecraft:pillager";
		  8     - GameTest.register("MobTests", "zombie_burn", (test) => {
		     73 +   const ironGolemPos = new BlockLocation(3, 2, 3);
		     74 +   const pillagerPos = new BlockLocation(3, 2, 4);
		  9     -   const zombieEntityType = "minecraft:zombie";
		 10     -   const zombiePosition = new BlockLocation(1, 2, 1);
		 11  75   
		 12     -   test.succeedWhenEntityPresent(zombieEntityType, zombiePosition, false);
		 13     - })
		 14     -   .maxTicks(TicksPerSecond * 30)
		     76 +   test.spawn(ironGolem, ironGolemPos);
		     77 +   test.spawn(pillager, pillagerPos);
		 15     -   .tag(GameTest.Tags.suiteDefault)
		 16     -   .batch("day");
		 17  78   
		 18     - GameTest.register("MobTests", "effect_durations_longer_first", (test) => {
		 19     -   const testEx = new GameTestExtensions(test);
		 20     -   const villagerId = "minecraft:villager_v2";
		 21     -   const villagerPos = new BlockLocation(1, 2, 1);
		     79 +   test.succeedWhen(() => {
		     80 +     test.assertEntityPresent(pillager, ironGolemPos, false);
		     81 +     test.assertEntityPresent(ironGolem, pillagerPos, true);
		     82 +   });
		 22     -   const buttonPos = new BlockLocation(1, 4, 0);
		 23     -   const strongPotion = new BlockLocation(0, 4, 0);
		 24     -   const weakPotion = new BlockLocation(2, 4, 0);
		 25     -   const strongPotionDuration = TicksPerSecond * 16;
		 26     - 
		     83 + }).tag(GameTest.Tags.suiteDefault);
		 27     -   test.spawn(villagerId, villagerPos);
		 28  84   
		     85 + GameTest.register("MobTests", "effect_durations_stronger_first", (test) => {
		     86 +   const testEx = new GameTestExtensions(test);
		 29     -   test
		     87 +   const villagerId = "minecraft:villager_v2";
		     88 +   const villagerPos = new BlockLocation(1, 2, 1);
		     89 +   const buttonPos = new BlockLocation(1, 4, 0);
		     90 +   const strongPotion = new BlockLocation(0, 4, 0);
		     91 +   const weakPotion = new BlockLocation(2, 4, 0);
		     92 +   const strongPotionDuration = TicksPerSecond * 16;
		     93 + 
		     94 +   test.spawn(villagerId, villagerPos);
		     95 + 
		     96 +   test
		     97 +     .startSequence()
		     98 +     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, strongPotion))
		     99 +     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		    100 +     .thenWait(() => testEx.assertBlockProperty("button_pressed_bit", 0, buttonPos))
		    101 +     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, weakPotion))
		    102 +     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		    103 +     .thenIdle(strongPotionDuration)
		    104 +     .thenWait(() => {
		    105 +       test.assertEntityState(
		    106 +         villagerPos,
		    107 +         villagerId,
		    108 +         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).amplifier == 0
		    109 +       ); // Strength level I
		    110 +       test.assertEntityState(
		    111 +         villagerPos,
		    112 +         villagerId,
		    113 +         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).duration > TicksPerSecond * 10
		    114 +       );
		    115 +     })
		    116 +     .thenSucceed();
		    117 + })
		    118 +   .structureName("MobTests:effect_durations")
		    119 +   .maxTicks(400)
		    120 +   .tag("suite:java_parity")
		    121 +   .tag(GameTest.Tags.suiteDisabled); // Weak potion duration is 33 seconds, strong is 16. After the strong potion expires the weak potion effect should have time remaining
		    122 + 
		    123 + GameTest.register("MobTests", "silverfish_no_suffocate", (test) => {
		    124 +   const silverfishPos = new BlockLocation(1, 2, 1);
		    125 +   const silverfish = "minecraft:silverfish";
		 30     -     .startSequence()
		 31     -     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, weakPotion))
		 32     -     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		 33     -     .thenWait(() => testEx.assertBlockProperty("button_pressed_bit", 0, buttonPos))
		 34     -     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, strongPotion))
		 35     -     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		 36     -     .thenIdle(strongPotionDuration)
		 37     -     .thenWait(() => {
		 38     -       test.assertEntityState(
		 39     -         villagerPos,
		 40     -         villagerId,
		 41     -         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).amplifier == 0
		 42     -       ); // Strength level I
		 43     -       test.assertEntityState(
		 44     -         villagerPos,
		 45     -         villagerId,
		 46     -         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).duration > TicksPerSecond * 10
		 47     -       );
		 48     -     })
		 49     -     .thenSucceed();
		 50     - })
		 51     -   .structureName("MobTests:effect_durations")
		 52     -   .maxTicks(400)
		 53     -   .tag("suite:java_parity")
		 54     -   .tag(GameTest.Tags.suiteDisabled); // Weak potion duration is 33 seconds, strong is 16. After the strong potion expires the weak potion effect should have time remaining
		 55     - 
		 56     - GameTest.register("MobTests", "drowning_test", (test) => {
		 57     -   const villagerEntitySpawnType = "minecraft:villager_v2";
		 58     -   const pigSpawnType = "minecraft:pig";
		 59     - 
		 60     -   test.spawn(villagerEntitySpawnType, new BlockLocation(3, 2, 2));
		 61     -   test.spawn(pigSpawnType, new BlockLocation(3, 2, 4));
		 62     -   test.succeedWhen(() => {
		 63     -     test.assertEntityPresentInArea(pigSpawnType, false);
		 64     -     test.assertEntityPresentInArea(villagerEntitySpawnType, false);
		 65     -   });
		 66     - })
		 67     -   .maxTicks(TicksPerSecond * 45)
		 68     -   .tag(GameTest.Tags.suiteDefault);
		 69 126   
		    127 +   test
		    128 +     .startSequence()
		 70     - GameTest.register("MobTests", "golem_vs_pillager", (test) => {
		 71     -   const ironGolem = "minecraft:iron_golem";
		    129 +     .thenExecute(() => test.assertEntityHasComponent(silverfish, "minecraft:health", silverfishPos, true))
		    130 +     .thenIdle(40)
		    131 +     .thenExecute(() => test.assertEntityHasComponent(silverfish, "minecraft:health", silverfishPos, true))
		    132 +     .thenSucceed();
		    133 +   test
		    134 +     .startSequence()
		    135 +     .thenWait(() => test.assertEntityPresent(silverfish, silverfishPos, false))
		    136 +     .thenFail("Silverfish died");
		    137 + })
		    138 +   .maxTicks(TicksPerSecond * 30)
		    139 +   .required(false)
		    140 +   .tag(GameTest.Tags.suiteDefault);
		 72     -   const pillager = "minecraft:pillager";
		 73     -   const ironGolemPos = new BlockLocation(3, 2, 3);
		 74     -   const pillagerPos = new BlockLocation(3, 2, 4);
		 75     - 
		 76     -   test.spawn(ironGolem, ironGolemPos);
		 77     -   test.spawn(pillager, pillagerPos);
		 78     - 
		 79     -   test.succeedWhen(() => {
		 80     -     test.assertEntityPresent(pillager, ironGolemPos, false);
		 81     -     test.assertEntityPresent(ironGolem, pillagerPos, true);
		 82     -   });
		 83     - }).tag(GameTest.Tags.suiteDefault);
		 84 141   
		    142 + GameTest.register("MobTests", "small_mobs_keep_head_above_water", (test) => {
		 85     - GameTest.register("MobTests", "effect_durations_stronger_first", (test) => {
		 86 143     const testEx = new GameTestExtensions(test);
		    144 +   const swimmerPos = new BlockLocation(1, 3, 1); //When the silverfish is produced at (1, 2, 1), the silverfish is stuck in the glass below and dies, so the y-axis goes up one frame
		 87     -   const villagerId = "minecraft:villager_v2";
		 88     -   const villagerPos = new BlockLocation(1, 2, 1);
		    145 +   const swimmer = test.spawn("minecraft:silverfish", swimmerPos);
		    146 + 
		    147 +   const drownerPos = new BlockLocation(5, 2, 1);
		    148 +   const drowner = test.spawn("minecraft:silverfish", drownerPos);
		 89     -   const buttonPos = new BlockLocation(1, 4, 0);
		 90     -   const strongPotion = new BlockLocation(0, 4, 0);
		 91     -   const weakPotion = new BlockLocation(2, 4, 0);
		 92     -   const strongPotionDuration = TicksPerSecond * 16;
		 93 149   
		    150 +   testEx.makeAboutToDrown(swimmer);
		    151 +   testEx.makeAboutToDrown(drowner);
		 94     -   test.spawn(villagerId, villagerPos);
		 95 152   
		 96 153     test
		 97 154       .startSequence()
		    155 +     .thenWaitAfter(40, () => {
		    156 +       test.assertEntityPresent("minecraft:silverfish", swimmerPos, true);
		 98     -     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, strongPotion))
		    157 +       test.assertEntityPresent("minecraft:silverfish", drownerPos, false);
		    158 +     })
		    159 +     .thenSucceed();
		    160 + }).tag(GameTest.Tags.suiteDefault);
		    161 + 
		    162 + GameTest.register("MobTests", "small_mobs_breathe_in_boats", (test) => {
		    163 +   const testEx = new GameTestExtensions(test);
		    164 +   const catPos = new BlockLocation(2, 3, 2);
		    165 +   const cat = testEx.addEntityInBoat("minecraft:cat", catPos);
		    166 +   testEx.makeAboutToDrown(cat);
		    167 + 
		    168 +   const silverfishPos = new BlockLocation(4, 3, 2);
		    169 +   const silverfish = testEx.addEntityInBoat("minecraft:silverfish", silverfishPos);
		    170 +   testEx.makeAboutToDrown(silverfish);
		    171 + 
		    172 +   const underWaterPos = new BlockLocation(6, 2, 2);
		    173 +   const silverfish2 = testEx.addEntityInBoat("minecraft:silverfish", underWaterPos);
		    174 +   testEx.makeAboutToDrown(silverfish2);
		    175 + 
		    176 +   test
		    177 +     .startSequence()
		    178 +     .thenIdle(40)
		    179 +     .thenExecute(() => test.assertEntityPresent("minecraft:cat", catPos, true))
		    180 +     .thenExecute(() => test.assertEntityPresent("minecraft:silverfish", silverfishPos, true))
		    181 +     .thenExecute(() => test.assertEntityPresent("minecraft:silverfish", underWaterPos, false))
		    182 +     .thenSucceed();
		    183 + }).tag(GameTest.Tags.suiteDefault);
		 99     -     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		100     -     .thenWait(() => testEx.assertBlockProperty("button_pressed_bit", 0, buttonPos))
		101     -     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, weakPotion))
		102     -     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		103     -     .thenIdle(strongPotionDuration)
		104     -     .thenWait(() => {
		105     -       test.assertEntityState(
		106     -         villagerPos,
		107     -         villagerId,
		108     -         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).amplifier == 0
		109     -       ); // Strength level I
		110     -       test.assertEntityState(
		111     -         villagerPos,
		112     -         villagerId,
		113     -         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).duration > TicksPerSecond * 10
		114     -       );
		115     -     })
		116     -     .thenSucceed();
		117     - })
		118     -   .structureName("MobTests:effect_durations")
		119     -   .maxTicks(400)
		120     -   .tag("suite:java_parity")
		121     -   .tag(GameTest.Tags.suiteDisabled); // Weak potion duration is 33 seconds, strong is 16. After the strong potion expires the weak potion effect should have time remaining
		122     - 
		123     - GameTest.register("MobTests", "silverfish_no_suffocate", (test) => {
		124     -   const silverfishPos = new BlockLocation(1, 2, 1);
		125     -   const silverfish = "minecraft:silverfish";
		126 184   
		    185 + ///
		127     -   test
		128     -     .startSequence()
		129     -     .thenExecute(() => test.assertEntityHasComponent(silverfish, "minecraft:health", silverfishPos, true))
		    186 + // Axolotl Tests
		    187 + ///
		    188 + const platformStructure = "ComponentTests:platform";
		    189 + 
		    190 + GameTest.register("MobTests", "axolotl_bucket_capture", (test) => {
		    191 +   let playerSim = test.spawnSimulatedPlayer(new BlockLocation(1, 5, 0), "playerSim_axolotl");
		    192 +   let target = test.spawn("minecraft:axolotl", new BlockLocation(1, 5, 2));
		    193 +   const testEx = new GameTestExtensions(test);
		    194 + 
		    195 +   test
		    196 +     .startSequence()
		130     -     .thenIdle(40)
		131     -     .thenExecute(() => test.assertEntityHasComponent(silverfish, "minecraft:health", silverfishPos, true))
		132     -     .thenSucceed();
		133     -   test
		134     -     .startSequence()
		135     -     .thenWait(() => test.assertEntityPresent(silverfish, silverfishPos, false))
		136     -     .thenFail("Silverfish died");
		137     - })
		138     -   .maxTicks(TicksPerSecond * 30)
		139     -   .required(false)
		140     -   .tag(GameTest.Tags.suiteDefault);
		141 197   
		    198 +     .thenExecuteAfter(20, () => testEx.giveItem(playerSim, MinecraftItemTypes.waterBucket, 1, 0))
		    199 +     .thenExecute(() => test.assert(playerSim.interactWithEntity(target) == true, ""))
		142     - GameTest.register("MobTests", "small_mobs_keep_head_above_water", (test) => {
		143     -   const testEx = new GameTestExtensions(test);
		    200 +     .thenExecute(() =>
		    201 +       test.assert(playerSim.getComponent("inventory").container.getItem(0).id === "minecraft:axolotl_bucket", "")
		144     -   const swimmerPos = new BlockLocation(1, 3, 1); //When the silverfish is produced at (1, 2, 1), the silverfish is stuck in the glass below and dies, so the y-axis goes up one frame
		145     -   const swimmer = test.spawn("minecraft:silverfish", swimmerPos);
		146     - 
		    202 +     )
		    203 +     .thenSucceed();
		    204 + })
		    205 +   .structureName(platformStructure)
		    206 +   .tag(GameTest.Tags.suiteDefault);
		147     -   const drownerPos = new BlockLocation(5, 2, 1);
		148     -   const drowner = test.spawn("minecraft:silverfish", drownerPos);
		149     - 
		150     -   testEx.makeAboutToDrown(swimmer);
		151     -   testEx.makeAboutToDrown(drowner);
		152 207   
		153     -   test
		154     -     .startSequence()
		155     -     .thenWaitAfter(40, () => {
		    208 + GameTest.register("MobTests", "axolotl_attacks_squid", (test) => {
		    209 +   let axlSpawn = new BlockLocation(2, 3, 2);
		    210 +   let squidSpawn = new BlockLocation(2, 4, 2);
		    211 +   test.spawn("minecraft:axolotl", axlSpawn);
		    212 +   let prey = test.spawn("minecraft:squid", squidSpawn);
		    213 +   let preyHealth = prey.getComponent("health").current;
		    214 +   test
		    215 +     .startSequence()
		    216 +     .thenIdle(20)
		    217 +     .thenWait(() => test.assert(prey.getComponent("health").current < preyHealth, ""))
		    218 +     .thenSucceed();
		    219 + })
		    220 +   .maxTicks(140)
		    221 +   .structureName("ComponentTests:aquarium")
		    222 +   .tag(GameTest.Tags.suiteDefault);
		156     -       test.assertEntityPresent("minecraft:silverfish", swimmerPos, true);
		157     -       test.assertEntityPresent("minecraft:silverfish", drownerPos, false);
		158     -     })
		159     -     .thenSucceed();
		160     - }).tag(GameTest.Tags.suiteDefault);
		161     - 
		162     - GameTest.register("MobTests", "small_mobs_breathe_in_boats", (test) => {
		163     -   const testEx = new GameTestExtensions(test);
		164     -   const catPos = new BlockLocation(2, 3, 2);
		165     -   const cat = testEx.addEntityInBoat("minecraft:cat", catPos);
		166     -   testEx.makeAboutToDrown(cat);
		167     - 
		168     -   const silverfishPos = new BlockLocation(4, 3, 2);
		169     -   const silverfish = testEx.addEntityInBoat("minecraft:silverfish", silverfishPos);
		170     -   testEx.makeAboutToDrown(silverfish);
		171 223   
		    224 + GameTest.register("MobTests", "axolotl_lure_no_attack", (test) => {
		    225 +   const playerSim = test.spawnSimulatedPlayer(new BlockLocation(1, 5, 0), "playerSim_axolotl_lure");
		    226 +   let prey = test.spawn("minecraft:squid", new BlockLocation(1, 1, 1));
		172     -   const underWaterPos = new BlockLocation(6, 2, 2);
		    227 +   let prey_health = prey.getComponent("health").current;
		    228 +   const testEx = new GameTestExtensions(test);
		173     -   const silverfish2 = testEx.addEntityInBoat("minecraft:silverfish", underWaterPos);
		174     -   testEx.makeAboutToDrown(silverfish2);
		175 229   
		176 230     test
		177 231       .startSequence()
		    232 +     .thenExecuteAfter(20, () => testEx.giveItem(playerSim, MinecraftItemTypes.tropicalFishBucket, 1, 0))
		    233 +     .thenExecute(() => test.spawn("minecraft:axolotl", new BlockLocation(1, 5, 2)))
		178     -     .thenIdle(40)
		179     -     .thenExecute(() => test.assertEntityPresent("minecraft:cat", catPos, true))
		    234 +     .thenIdle(60)
		    235 +     .thenExecute(() => test.assert(prey.getComponent("health").current == prey_health, ""))
		180     -     .thenExecute(() => test.assertEntityPresent("minecraft:silverfish", silverfishPos, true))
		181     -     .thenExecute(() => test.assertEntityPresent("minecraft:silverfish", underWaterPos, false))
		182 236       .thenSucceed();
		    237 + })
		    238 +   .structureName("MobTests:axolotl_lure")
		    239 +   .tag(GameTest.Tags.suiteDefault);
		183     - }).tag(GameTest.Tags.suiteDefault);
		184 240   
		185 241   ///
		    242 + // Goat Tests
		186     - // Axolotl Tests
		187 243   ///
		188     - const platformStructure = "ComponentTests:platform";
		189 244   
		    245 + GameTest.register("MobTests", "goat_wheat_breeding", (test) => {
		    246 +   let playerSim = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0), "playerSim_goat");
		190     - GameTest.register("MobTests", "axolotl_bucket_capture", (test) =>{
		    247 +   let goat_1 = test.spawn("minecraft:goat<minecraft:ageable_grow_up>", new BlockLocation(2, 2, 1));
		    248 +   let goat_2 = test.spawn("minecraft:goat<minecraft:ageable_grow_up>", new BlockLocation(0, 2, 1));
		191     -   let playerSim = test.spawnSimulatedPlayer(new BlockLocation(1,5,0), "playerSim_axolotl")
		192     -   let target = test.spawn("minecraft:axolotl", new BlockLocation(1, 5, 2));
		193 249     const testEx = new GameTestExtensions(test);
		194     - 
		195     -   test.startSequence()
		196     - 
		    250 +   test
		    251 +     .startSequence()
		    252 +     .thenExecuteAfter(10, () => testEx.giveItem(playerSim, MinecraftItemTypes.wheat, 3, 0))
		    253 +     .thenExecute(() => playerSim.interactWithEntity(goat_1))
		    254 +     .thenExecute(() => playerSim.interactWithEntity(goat_2))
		    255 +     .thenExecuteAfter(60, () => goat_1.kill())
		    256 +     .thenExecute(() => goat_2.kill())
		    257 +     .thenWait(() => test.assertEntityPresentInArea("minecraft:goat", true)) //does not count red, dying goats as a goat entity. Only counts the newborn baby
		    258 +     .thenSucceed();
		    259 + })
		    260 +   .maxTicks(120)
		    261 +   .structureName(platformStructure)
		    262 +   .tag(GameTest.Tags.suiteDefault);
		    263 + 
		    264 + GameTest.register("MobTests", "piglin_should_drop_different_loots", (test) => {
		    265 +   const testEx = new GameTestExtensions(test);
		    266 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 3, 1));
		    267 +   const inventoryContainer = player.getComponent("inventory").container;
		    268 +   const goldIngotCount = 10;
		    269 +   const piglinEntityType = "minecraft:piglin<spawn_adult>";
		    270 +   const piglin = test.spawn(piglinEntityType, new BlockLocation(1, 2, 2));
		197     -   .thenExecuteAfter(20, () => testEx.giveItem(playerSim, MinecraftItemTypes.waterBucket, 1, 0))
		198     -   .thenExecute(() => test.assert(playerSim.interactWithEntity(target) == true, ""))
		199     -   .thenExecute(() => test.assert(playerSim.getComponent("inventory").container.getItem(0).id === "minecraft:axolotl_bucket", ""))
		200     -   .thenSucceed();
		201     - }).structureName(platformStructure)
		202     - .tag(GameTest.Tags.suiteDefault);
		203     - 
		204     - 
		205     - GameTest.register("MobTests", "axolotl_attacks_squid", (test) =>{
		206     -   let axlSpawn = new BlockLocation(2, 3, 2);
		207     -   let squidSpawn = new BlockLocation(2, 4, 2);
		208     -   test.spawn("minecraft:axolotl", axlSpawn);
		209     -   let prey = test.spawn("minecraft:squid", squidSpawn);
		210     -   let preyHealth = prey.getComponent("health").current;
		211     -   test.startSequence()
		212     -   .thenIdle(20)
		213     -   .thenWait( () => test.assert(prey.getComponent("health").current < preyHealth, ""))
		214     -   .thenSucceed();
		215     - }).maxTicks(140).structureName("ComponentTests:aquarium")
		216     - .tag(GameTest.Tags.suiteDefault);
		217     - 
		218 271   
		219     - GameTest.register("MobTests", "axolotl_lure_no_attack", (test) =>{
		220     -   const playerSim = test.spawnSimulatedPlayer(new BlockLocation(1,5,0), "playerSim_axolotl_lure");
		221     -   let prey = test.spawn("minecraft:squid", new BlockLocation(1, 1, 1));
		222     -   let prey_health = prey.getComponent("health").current;
		    272 +   testEx.giveItem(player, MinecraftItemTypes.goldIngot, goldIngotCount);
		223     -   const testEx = new GameTestExtensions(test);
		224 273   
		    274 +   let sequence = test.startSequence().thenIdle(5);
		    275 +   //Barter with piglin up to 10 times
		225     -   test.startSequence()
		226     -   .thenExecuteAfter(20, () => testEx.giveItem(playerSim, MinecraftItemTypes.tropicalFishBucket, 1, 0))
		    276 +   for (let i = 1; i <= goldIngotCount; i++) {
		    277 +     sequence
		    278 +       .thenExecute(() => {
		    279 +         try {
		    280 +           player.selectSlot(0);
		    281 +           player.interactWithEntity(piglin);
		    282 +         } catch { }
		    283 +       })
		    284 +       .thenExecuteAfter(200, () => {
		    285 +         piglin.triggerEvent("stop_zombification_event");
		227     -   .thenExecute(() => test.spawn("minecraft:axolotl", new BlockLocation(1, 5, 2)))
		228     -   .thenIdle(60)
		229     -   .thenExecute( () => test.assert(prey.getComponent("health").current == prey_health, ""))
		230     -   .thenSucceed();
		231     - }).structureName("MobTests:axolotl_lure")
		232     - .tag(GameTest.Tags.suiteDefault);
		233     - 
		234     - ///
		235     - // Goat Tests
		236     - ///
		237 286   
		    287 +         // Check the player's inventory for 2 unique items
		    288 +         for (let j = 1; j <= i; j++) {
		238     - GameTest.register("MobTests", "goat_wheat_breeding", (test) =>{
		    289 +           try {
		    290 +             let item1 = inventoryContainer.getItem(j);
		    291 +             let item2 = inventoryContainer.getItem(j + 1);
		    292 +             if (item2 != undefined && item1.id != item2.id) {
		    293 +               test.succeed();
		    294 +             }
		    295 +           } catch (e) { }
		    296 +         }
		    297 +       });
		    298 +   }
		    299 +   sequence.thenFail("Failed to obtain 2 or more unique items from bartering");
		    300 + })
		    301 +   .maxTicks(3000)
		    302 +   .tag(GameTest.Tags.suiteDefault);
		239     -   let playerSim = test.spawnSimulatedPlayer(new BlockLocation(1,2,0), "playerSim_goat");
		240     -   let goat_1 = test.spawn("minecraft:goat<minecraft:ageable_grow_up>", new BlockLocation(2, 2, 1));
		241     -   let goat_2 = test.spawn("minecraft:goat<minecraft:ageable_grow_up>", new BlockLocation(0, 2, 1));
		242     -   const testEx = new GameTestExtensions(test);
		243     -   test.startSequence()
		244     -   .thenExecuteAfter(10, () => testEx.giveItem(playerSim, MinecraftItemTypes.wheat, 3, 0) )
		245     -   .thenExecute( () => playerSim.interactWithEntity(goat_1))
		246     -   .thenExecute( () => playerSim.interactWithEntity(goat_2))
		247     -   .thenExecuteAfter(60, () => goat_1.kill())
		248     -   .thenExecute( () => goat_2.kill())
		249     -   .thenWait( () => test.assertEntityPresentInArea("minecraft:goat", true)) //does not count red, dying goats as a goat entity. Only counts the newborn baby
		250     -   .thenSucceed();
		251     - }).maxTicks(120).structureName(platformStructure)
		252     - .tag(GameTest.Tags.suiteDefault);
		          '''
	Changed script "MultifaceTests.js":
		Total line: 285 (+2, -2)
		          '''
		          ...
		  3   3     BlockLocation,
		  4   4     MinecraftBlockTypes,
		  5   5     BlockProperties,
		  6   6     MinecraftItemTypes,
		  7   7     Direction,
		      8 +   world,
		  8     -   World,
		  9   9   } from "mojang-minecraft";
		 10  10   import GameTestExtensions from "./GameTestExtensions.js";
		 11  11   
		 12  12   const DOWN = Direction.down;
		 13  13   const UP = Direction.up;
		          ...
		 29  29   function assertLichen(test, pos, waterlogged, ...faces) {
		 30  30     test.assertBlockPresent(MinecraftBlockTypes.glowLichen, pos, true);
		 31  31     test.assertIsWaterlogged(pos, waterlogged);
		 32  32   
		 33  33     const glowLichenWorldPos = test.worldBlockLocation(pos);
		     34 +   const glowLichenBlock = test.getDimension().getBlock(glowLichenWorldPos);
		 34     -   const glowLichenBlock = World.getDimension("overworld").getBlock(glowLichenWorldPos);
		 35  35     const glowLichenPermutation = glowLichenBlock.permutation;
		 36  36     const glowLichenmultiFaceDirectionBits = glowLichenPermutation.getProperty(
		 37  37       BlockProperties.multiFaceDirectionBits
		 38  38     ).value;
		 39  39   
		          ...
		          '''
	Added script "RaycastingTests.js":
		'''
		import * as GameTest from "mojang-gametest";
		import {
		  BlockLocation,
		  BlockRaycastOptions,
		  EntityRaycastOptions,
		  MinecraftBlockTypes,
		  Location,
		} from "mojang-minecraft";
		
		const replacementBlock = MinecraftBlockTypes.redGlazedTerracotta;
		
		function lookAtThree(test, blocks, blockVectorOptions) {
		    const player = test.spawnSimulatedPlayer(new BlockLocation(2, 9, 2), "Player");
		
		    test.startSequence()
		        .thenExecuteAfter(10, () => {
		            player.lookAtBlock(blocks[0]);
		        })
		        .thenExecuteAfter(10, () => {
		            var block = player.getBlockFromViewVector(blockVectorOptions);
		            const relativePos = test.relativeBlockLocation(block.location);
		            test.assert(relativePos.equals(blocks[0]), "Locations should match, but got [" + relativePos.x + "," + relativePos.y + ", " + relativePos.z + "]");
		            block.setType(replacementBlock);
		
		            player.lookAtBlock(blocks[1]);
		        })
		        .thenExecuteAfter(10, () => {
		            var block = player.getBlockFromViewVector(blockVectorOptions);
		            const relativePos = test.relativeBlockLocation(block.location);
		            test.assert(relativePos.equals(blocks[1]), "Locations should match, but got [" + relativePos.x + "," + relativePos.y + ", " + relativePos.z + "]");
		            block.setType(replacementBlock);
		            player.lookAtBlock(blocks[2]);
		        })
		        .thenExecuteAfter(10, () => {
		            var block = player.getBlockFromViewVector(blockVectorOptions);
		            const relativePos = test.relativeBlockLocation(block.location);
		            test.assert(relativePos.equals(blocks[2]), "Locations should match, but got [" + relativePos.x + "," + relativePos.y + ", " + relativePos.z + "]");
		            block.setType(replacementBlock);
		        })
		        .thenSucceed();
		}
		
		GameTest.register("RaycastingTests", "player_looks_under_water", (test) => {
		    var blocks = [new BlockLocation(1, 1, 1), new BlockLocation(2, 1, 1), new BlockLocation(3, 1, 1)];
		
		    const blockVectorOptions = new BlockRaycastOptions();
		    blockVectorOptions.includePassableBlocks = false;
		    blockVectorOptions.includeLiquidBlocks = false;
		
		    lookAtThree(test, blocks, blockVectorOptions);
		})
		    .maxTicks(50)
		    .structureName("RaycastingTests:player_looks_block")
		    .tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RaycastingTests", "player_looks_at_water", (test) => {
		    var blocks = [new BlockLocation(1, 2, 1), new BlockLocation(2, 2, 1), new BlockLocation(3, 2, 1)];
		
		    const blockVectorOptions = new BlockRaycastOptions();
		    blockVectorOptions.includePassableBlocks = true;
		    blockVectorOptions.includeLiquidBlocks = true;
		
		    lookAtThree(test, blocks, blockVectorOptions);
		})
		    .maxTicks(50)
		    .structureName("RaycastingTests:player_looks_block")
		    .tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RaycastingTests", "player_looks_under_carpet", (test) => {
		    var blocks = [new BlockLocation(1, 2, 0), new BlockLocation(2, 2, 0), new BlockLocation(3, 2, 0)];
		
		    const blockVectorOptions = new BlockRaycastOptions();
		    blockVectorOptions.includePassableBlocks = false;
		    blockVectorOptions.includeLiquidBlocks = false;
		
		    lookAtThree(test, blocks, blockVectorOptions);
		})
		    .maxTicks(50)
		    .structureName("RaycastingTests:player_looks_block")
		    .tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RaycastingTests", "player_looks_at_carpet", (test) => {
		    var blocks = [new BlockLocation(1, 3, 0), new BlockLocation(2, 3, 0), new BlockLocation(3, 3, 0)];
		
		    const blockVectorOptions = new BlockRaycastOptions();
		    blockVectorOptions.includePassableBlocks = true;
		    blockVectorOptions.includeLiquidBlocks = false;
		
		    lookAtThree(test, blocks, blockVectorOptions);
		})
		    .maxTicks(50)
		    .structureName("RaycastingTests:player_looks_block")
		    .tag(GameTest.Tags.suiteDefault);
		
		
		GameTest.register("RaycastingTests", "get_block_from_vector", (test) => {
		
		    let dimension = test.getDimension();
		    const blockVectorOptions = new BlockRaycastOptions();
		
		
		    blockVectorOptions.includePassableBlocks = false;
		    blockVectorOptions.includeLiquidBlocks = false;
		
		    const bars = dimension.getBlockFromRay(test.worldLocation(new Location(.5, 2, 1.5)), new Location(1, 0, 0), blockVectorOptions);
		    test.assert(bars.type == MinecraftBlockTypes.ironBars, "Expected to see through the banner and the water to the iron bars");
		
		    blockVectorOptions.includePassableBlocks = true;
		    const banner = dimension.getBlockFromRay(test.worldLocation(new Location(.5, 2, 1.5)), new Location(1, 0, 0), blockVectorOptions);
		    test.assert(banner.type == MinecraftBlockTypes.standingBanner, "Expected to see through the water to the iron bars");
		
		    blockVectorOptions.includeLiquidBlocks = true;
		    const water = dimension.getBlockFromRay(test.worldLocation(new Location(.5, 2, 1.5)), new Location(1, 0, 0), blockVectorOptions);
		    test.assert(water.type == MinecraftBlockTypes.water, "Expected to see the water");
		
		    test.succeed();
		})
		    .setupTicks(4) // time for water to convert from dynamic to static type
		    .tag(GameTest.Tags.suiteDefault);
		
		
		GameTest.register("RaycastingTests", "get_entity_from_vector", (test) => {
		
		    let dimension = test.getDimension();
		
		    test.spawnWithoutBehaviors("creeper", new BlockLocation(3, 2, 1))
		    test.spawnWithoutBehaviors("creeper", new BlockLocation(2, 2, 1))
		
		    // test both creepers are found
		    const creepers = dimension.getEntitiesFromRay(test.worldLocation(new Location(.5, 3.5, 1.5)), new Location(1, 0, 0), new EntityRaycastOptions());
		    test.assert(creepers.length == 2, "Expected to find 2 creepers");
		    test.assertEntityInstancePresent(creepers[0], new BlockLocation(2, 2, 1));
		    test.assertEntityInstancePresent(creepers[1], new BlockLocation(3, 2, 1));
		
		    // check the entities are sorted by distance
		    const creepersReversed = dimension.getEntitiesFromRay(test.worldLocation(new Location(5.5, 2.5, 1.5)), new Location(-1, 0, 0), new EntityRaycastOptions());
		    test.assert(creepersReversed.length == 2, "Expected to find 2 creepers");
		    test.assertEntityInstancePresent(creepersReversed[0], new BlockLocation(3, 2, 1));
		    test.assertEntityInstancePresent(creepersReversed[1], new BlockLocation(2, 2, 1));
		
		    // test blocks stop the entity raycast
		    const blockedCreepers = dimension.getEntitiesFromRay(test.worldLocation(new Location(5.5, 3.5, 1.5)), new Location(-1, 0, 0), new EntityRaycastOptions());
		    test.assert(blockedCreepers.length == 0, "Expected the block to stop the raycast");
		
		    test.succeed();
		})
		    .setupTicks(4) // time for water to convert from dynamic to static type
		    .tag(GameTest.Tags.suiteDefault);
		'''
	Changed script "RedstoneTests.js":
		Total line: 1033 (+6, -4)
		            '''
		   1    1   import * as GameTest from "mojang-gametest";
		        2 + import { BlockLocation, MinecraftBlockTypes, MinecraftItemTypes, BlockProperties, world } from "mojang-minecraft";
		   2      - import { BlockLocation, MinecraftBlockTypes, MinecraftItemTypes, BlockProperties, World } from "mojang-minecraft";
		   3    3   import GameTestExtensions from "./GameTestExtensions.js";
		   4    4   
		   5    5   const TicksPerSecond = 20;
		   6    6   
		   7    7   const LEVEL_TO_RECORDS = new Map([
		            ...
		  16   16     [8, MinecraftItemTypes.musicDiscStal],
		  17   17     [9, MinecraftItemTypes.musicDiscStrad],
		  18   18     [10, MinecraftItemTypes.musicDiscWard],
		  19   19     [11, MinecraftItemTypes.musicDisc11],
		  20   20     [12, MinecraftItemTypes.musicDiscWait],
		       21 +   [13, MinecraftItemTypes.musicDiscPigstep],
		  21      -   [15, MinecraftItemTypes.musicDiscPigstep],
		  22   22   ]);
		  23   23   
		  24   24   GameTest.register("RedstoneTests", "itemframe_override", (test) => {
		  25   25     const itemFrameTest = new BlockLocation(3, 2, 5);
		  26   26     const itemFrameOverrideNoTest = new BlockLocation(3, 2, 10);
		            ...
		 409  409       null,
		 410  410       "XXXX",
		 411  411     ];
		 412  412   
		 413  413     test.pulseRedstone(inputPos, 3);
		      414 +   const dimension = test.getDimension();
		 414  415   
		 415  416     let sequence = test.startSequence();
		 416  417     for (const state of states) {
		 417  418       if (state == null) {
		 418  419         sequence = sequence.thenIdle(2);
		            ...
		 421  422           for (let line = 0; line < 4; line++) {
		 422  423             const expected = state.charAt(line);
		 423  424             const expectedPos = expected == "X" ? -1 : expected - "0";
		 424  425             for (let linePos = 0; linePos < 4; linePos++) {
		 425  426               const blockWorldPos = test.worldBlockLocation(linesPos[line][linePos]);
		      427 +             const block = dimension.getBlock(blockWorldPos);
		 426      -             const block = World.getDimension("overworld").getBlock(blockWorldPos);
		 427  428               const blockId = block.id;
		 428  429   
		 429  430               if (linePos == expectedPos) {
		 430  431                 test.assert(
		 431  432                   blockId == "minecraft:powered_repeater",
		            ...
		 479  480       null,
		 480  481       "XXXX",
		 481  482     ];
		 482  483   
		 483  484     test.pulseRedstone(inputPos, 3); //Change redstone pulse form 2 ticks to 3.
		      485 +   const dimension = test.getDimension();
		 484  486   
		 485  487     let sequence = test.startSequence();
		 486  488     for (const state of states) {
		 487  489       if (state == null) {
		 488  490         sequence = sequence.thenIdle(2);
		            ...
		 491  493           for (let line = 0; line < 4; line++) {
		 492  494             const expected = state.charAt(line);
		 493  495             const expectedPos = expected == "X" ? -1 : expected - "0";
		 494  496             for (let linePos = 0; linePos < 4; linePos++) {
		 495  497               const blockWorldPos = test.worldBlockLocation(linesPos[line][linePos]);
		      498 +             const block = dimension.getBlock(blockWorldPos);
		 496      -             const block = World.getDimension("overworld").getBlock(blockWorldPos);
		 497  499               const blockPerm = block.permutation;
		 498  500               const blockType = blockPerm.type;
		 499  501   
		 500  502               if (linePos == expectedPos) {
		 501  503                 test.assert(
		            ...
		            '''
	Changed script "SimulatedPlayerTests.js":
		Total line: 1091 (+342, -228)
		            '''
		   1    1   import * as GameTest from "mojang-gametest";
		   2    2   import GameTestExtensions from "./GameTestExtensions.js";
		   3    3   import {
		   4    4     BlockLocation,
		        5 +   Direction,
		        6 +   ItemStack,
		        7 +   Location,
		        8 +   MinecraftBlockTypes,
		        9 +   MinecraftItemTypes,
		       10 +   world,
		       11 + } from "mojang-minecraft";
		       12 + 
		       13 + function isNear(n1, n2) {
		       14 +   return Math.abs(n1 - n2) < 0.01;
		       15 + }
		       16 + 
		       17 + GameTest.register("SimulatedPlayerTests", "spawn_simulated_player", (test) => {
		       18 +   const spawnLoc = new BlockLocation(1, 5, 1);
		       19 +   const landLoc = new BlockLocation(1, 2, 1);
		       20 +   const playerName = "Test Player";
		       21 +   const player = test.spawnSimulatedPlayer(spawnLoc, playerName);
		       22 +   test.assertEntityPresent("player", spawnLoc);
		       23 +   test.assert(player.nameTag === playerName, "Unexpected name tag");
		       24 +   test.succeedWhen(() => {
		       25 +     test.assertEntityPresent("player", landLoc);
		       26 +   });
		       27 + })
		       28 +   .structureName("ComponentTests:platform")
		       29 +   .tag(GameTest.Tags.suiteDefault);
		       30 + 
		       31 + GameTest.register("SimulatedPlayerTests", "remove_simulated_player", (test) => {
		       32 +   const spawnLoc = new BlockLocation(1, 2, 1);
		       33 +   const player = test.spawnSimulatedPlayer(spawnLoc);
		       34 +   test.assertEntityPresent("player", spawnLoc);
		       35 + 
		       36 +   test
		       37 +     .startSequence()
		       38 +     .thenExecuteAfter(10, () => {
		       39 +       test.removeSimulatedPlayer(player);
		       40 +       test.assertEntityPresent("player", spawnLoc, false);
		       41 +     })
		       42 +     .thenSucceed();
		       43 + })
		       44 +   .structureName("ComponentTests:platform")
		       45 +   .tag(GameTest.Tags.suiteDefault);
		       46 + 
		       47 + GameTest.register("SimulatedPlayerTests", "jump", (test) => {
		       48 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		       49 +   const goalLoc = new BlockLocation(1, 2, 3);
		       50 +   let jumpCount = 0;
		       51 + 
		       52 +   test
		       53 +     .startSequence()
		       54 +     .thenExecuteAfter(10, () => {
		       55 +       player.move(0, 1);
		       56 +     })
		       57 +     .thenWait(() => {
		       58 +       if (player.jump()) {
		       59 +         jumpCount++;
		       60 +       }
		       61 +       test.assertEntityInstancePresent(player, goalLoc);
		       62 +       test.assert(jumpCount === 10, "Expected 2 jumps up the stairs and 8 in the snow block");
		       63 +     })
		       64 +     .thenSucceed();
		       65 + }).tag(GameTest.Tags.suiteDefault);
		       66 + 
		       67 + GameTest.register("SimulatedPlayerTests", "attack_entity", (test) => {
		       68 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		       69 +   const cow = test.spawn("minecraft:cow<minecraft:ageable_grow_up>", new BlockLocation(3, 2, 3));
		       70 +   let hitCount = 0;
		       71 +   test
		       72 +     .startSequence()
		       73 +     .thenWait(() => {
		       74 +       player.lookAtEntity(cow);
		       75 +       if (player.attackEntity(cow)) {
		       76 +         hitCount++;
		       77 +       }
		       78 +       test.assertEntityPresentInArea("cow", false);
		       79 +     })
		       80 +     .thenExecute(() => {
		       81 +       test.assert(hitCount === 5, "It should take 5 hits to kill a Cow.");
		       82 +     })
		       83 +     .thenSucceed();
		       84 + })
		       85 +   .maxTicks(200)
		       86 +   .structureName("ComponentTests:large_animal_pen")
		       87 +   .tag(GameTest.Tags.suiteDefault);
		       88 + 
		       89 + GameTest.register("SimulatedPlayerTests", "jump_attack_entity", (test) => {
		       90 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		       91 +   const cow = test.spawn("minecraft:cow<minecraft:ageable_grow_up>", new BlockLocation(3, 2, 3));
		       92 +   let hitCount = 0;
		       93 +   test
		       94 +     .startSequence()
		       95 +     .thenWait(() => {
		       96 +       player.lookAtEntity(cow);
		       97 +       player.jump();
		       98 +       if (player.velocity.y < -0.3 && player.attackEntity(cow)) {
		       99 +         hitCount++;
		      100 +       }
		      101 +       test.assertEntityPresentInArea("cow", false);
		      102 +     })
		      103 +     .thenExecute(() => {
		      104 +       test.assert(hitCount === 4, "It should take 4 critical hits to kill a Cow.");
		      105 +     })
		      106 +     .thenSucceed();
		      107 + })
		      108 +   .maxTicks(200)
		      109 +   .structureName("ComponentTests:large_animal_pen")
		      110 +   .tag(GameTest.Tags.suiteDefault);
		      111 + 
		      112 + GameTest.register("SimulatedPlayerTests", "attack", (test) => {
		      113 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		      114 +   const cow = test.spawn("minecraft:cow<minecraft:ageable_grow_up>", new BlockLocation(3, 2, 3));
		      115 +   let hitCount = 0;
		      116 +   test
		      117 +     .startSequence()
		      118 +     .thenWait(() => {
		      119 +       player.lookAtEntity(cow);
		      120 +       if (player.attack()) {
		      121 +         hitCount++;
		      122 +       }
		      123 +       test.assertEntityPresentInArea("cow", false);
		      124 +     })
		      125 +     .thenExecute(() => {
		      126 +       test.assert(hitCount === 5, "It should take 5 hits to kill a Cow.");
		      127 +     })
		      128 +     .thenSucceed();
		      129 + })
		      130 +   .maxTicks(200)
		      131 +   .structureName("ComponentTests:large_animal_pen")
		      132 +   .tag(GameTest.Tags.suiteDefault);
		      133 + 
		      134 + GameTest.register("SimulatedPlayerTests", "use_item", (test) => {
		      135 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		      136 +   const snowball = new ItemStack(MinecraftItemTypes.snowball, 1);
		      137 +   test.spawn("blaze", new BlockLocation(1, 2, 3));
		      138 +   let useCount = 0;
		      139 +   test
		      140 +     .startSequence()
		      141 +     .thenIdle(5)
		      142 +     .thenWait(() => {
		      143 +       if (player.useItem(snowball)) {
		      144 +         useCount++;
		      145 +       }
		      146 +       test.assertEntityPresentInArea("blaze", false);
		      147 +     })
		      148 +     .thenExecute(() => {
		      149 +       test.assert(useCount === 7, "It should take 7 snowballs to kill a Blaze");
		      150 +     })
		      151 +     .thenSucceed();
		      152 + })
		      153 +   .maxTicks(200)
		      154 +   .tag(GameTest.Tags.suiteDefault);
		      155 + 
		      156 + GameTest.register("SimulatedPlayerTests", "use_item_in_slot", (test) => {
		      157 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		      158 +   test.spawn("blaze", new BlockLocation(1, 2, 3));
		      159 +   let useCount = 0;
		      160 +   const slot = 0;
		      161 +   const snowballCount = 10;
		      162 +   const inventoryContainer = player.getComponent("inventory").container;
		      163 + 
		      164 +   player.setItem(new ItemStack(MinecraftItemTypes.snowball, snowballCount), slot, true);
		      165 + 
		      166 +   test
		      167 +     .startSequence()
		      168 +     .thenIdle(5)
		      169 +     .thenWait(() => {
		      170 +       test.assert(
		      171 +         inventoryContainer.getItem(slot).amount === snowballCount - useCount,
		      172 +         `Player should have ${snowballCount} snowballs`
		      173 +       );
		      174 +       if (player.useItemInSlot(slot)) {
		      175 +         useCount++;
		      176 +       }
		      177 +       test.assertEntityPresentInArea("blaze", false);
		      178 +     })
		      179 +     .thenExecute(() => {
		      180 +       test.assert(
		      181 +         inventoryContainer.getItem(slot).amount === snowballCount - useCount,
		      182 +         `Player should have ${snowballCount - useCount} snowballs`
		      183 +       );
		      184 +       test.assert(useCount === 7, "It should take 7 snowballs to kill a Blaze");
		      185 +     })
		      186 +     .thenSucceed();
		      187 + })
		      188 +   .maxTicks(200)
		      189 +   .structureName("SimulatedPlayerTests:use_item")
		      190 +   .tag(GameTest.Tags.suiteDefault);
		      191 + 
		      192 + GameTest.register("SimulatedPlayerTests", "use_item_on_block", (test) => {
		      193 +   const player = test.spawnSimulatedPlayer(new BlockLocation(0, 2, 0));
		      194 +   test
		      195 +     .startSequence()
		      196 +     .thenWait(() => {
		      197 +       const armorStand = new ItemStack(MinecraftItemTypes.armorStand, 1);
		      198 +       const armorStandLoc = new BlockLocation(1, 1, 1);
		      199 +       const used = player.useItemOnBlock(armorStand, armorStandLoc, Direction.up);
		      200 +       test.assert(used, "Expected armor stand to be used");
		      201 +       test.assertEntityPresent("armor_stand", armorStandLoc.above());
		      202 +     })
		      203 +     .thenWaitAfter(10, () => {
		      204 +       const dirt = new ItemStack(MinecraftItemTypes.dirt, 1);
		      205 +       const dirtLoc = new BlockLocation(2, 1, 1);
		      206 +       const used = player.useItemOnBlock(dirt, dirtLoc, Direction.up);
		      207 +       test.assert(used, "Expected dirt to be used");
		      208 +       test.assertBlockPresent(MinecraftBlockTypes.dirt, dirtLoc.above());
		      209 +     })
		      210 +     .thenWaitAfter(10, () => {
		      211 +       const bucket = new ItemStack(MinecraftItemTypes.bucket, 1);
		      212 +       const waterLoc = new BlockLocation(1, 2, 3);
		      213 +       const used = player.useItemOnBlock(bucket, waterLoc);
		      214 +       test.assert(used, "Expected bucket to be used");
		      215 +       test.assertBlockPresent(MinecraftBlockTypes.air, waterLoc);
		      216 +     })
		      217 +     .thenSucceed();
		      218 + }).tag(GameTest.Tags.suiteDefault);
		      219 + 
		      220 + GameTest.register("SimulatedPlayerTests", "give_item", (test) => {
		      221 +     const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		      222 +     let useCount = 0;
		      223 + 
		      224 +     test.assert(player.giveItem(new ItemStack(MinecraftItemTypes.snowball, 16), true), "giveItem() returned false");
		      225 +     test.spawn("blaze", new BlockLocation(1, 2, 2));
		   5      -   Commands,
		   6      -   Direction,
		   7      -   ItemStack,
		   8      -   Location,
		   9      -   MinecraftBlockTypes,
		  10      -   MinecraftItemTypes,
		  11      -   World,
		  12      - } from "mojang-minecraft";
		  13      - 
		  14      - function isNear(n1, n2) {
		  15      -   return Math.abs(n1 - n2) < 0.01;
		  16      - }
		  17      - 
		  18      - GameTest.register("SimulatedPlayerTests", "spawn_simulated_player", (test) => {
		  19      -   const spawnLoc = new BlockLocation(1, 5, 1);
		  20      -   const landLoc = new BlockLocation(1, 2, 1);
		  21      -   const playerName = "Test Player";
		  22      -   const player = test.spawnSimulatedPlayer(spawnLoc, playerName);
		  23      -   test.assertEntityPresent("player", spawnLoc);
		  24      -   test.assert(player.nameTag === playerName, "Unexpected name tag");
		  25      -   test.succeedWhen(() => {
		  26      -     test.assertEntityPresent("player", landLoc);
		  27      -   });
		  28      - })
		  29      -   .structureName("ComponentTests:platform")
		  30      -   .tag(GameTest.Tags.suiteDefault);
		  31  226   
		      227 +     test
		      228 +         .startSequence()
		  32      - GameTest.register("SimulatedPlayerTests", "remove_simulated_player", (test) => {
		      229 +         .thenIdle(5)
		      230 +         .thenWait(() => {
		      231 +             if (player.useItemInSlot(0)) {
		      232 +                 useCount++;
		      233 +             }
		      234 +             test.assertEntityPresentInArea("blaze", false);
		      235 +         })
		      236 +         .thenExecute(() => {
		      237 +             test.assert(useCount === 7, "It should take 7 snowballs to kill a Blaze");
		      238 +         })
		      239 +         .thenSucceed();
		  33      -   const spawnLoc = new BlockLocation(1, 2, 1);
		  34      -   const player = test.spawnSimulatedPlayer(spawnLoc);
		  35      -   test.assertEntityPresent("player", spawnLoc);
		  36      - 
		  37      -   test
		  38      -     .startSequence()
		  39      -     .thenExecuteAfter(10, () => {
		  40      -       test.removeSimulatedPlayer(player);
		  41      -       test.assertEntityPresent("player", spawnLoc, false);
		  42      -     })
		  43      -     .thenSucceed();
		  44  240   })
		  45      -   .structureName("ComponentTests:platform")
		  46      -   .tag(GameTest.Tags.suiteDefault);
		  47      - 
		  48      - GameTest.register("SimulatedPlayerTests", "jump", (test) => {
		      241 +     .maxTicks(200)
		      242 +     .structureName("SimulatedPlayerTests:blaze_trap")
		      243 +     .tag(GameTest.Tags.suiteDefault);
		  49      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		  50      -   const goalLoc = new BlockLocation(1, 2, 3);
		  51      -   let jumpCount = 0;
		  52  244   
		      245 + GameTest.register("SimulatedPlayerTests", "give_item_full_inventory", (test) => {
		      246 +     const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		  53      -   test
		      247 +     const containerSize = player.getComponent("inventory").container.size;
		      248 +     for (let i = 0; i < containerSize; i++) {
		      249 +         test.assert(player.giveItem(new ItemStack(MinecraftItemTypes.dirt, 64), false), "");
		      250 +     }
		      251 + 
		      252 +     test
		      253 +         .startSequence()
		      254 +         .thenExecuteAfter(20, () => test.assert(!player.giveItem(new ItemStack(MinecraftItemTypes.oakStairs, 64), true), ""))
		      255 +         .thenSucceed();
		      256 + })
		      257 +     .maxTicks(100)
		      258 +     .structureName("ComponentTests:platform")
		      259 +     .tag(GameTest.Tags.suiteDefault);
		  54      -     .startSequence()
		  55      -     .thenExecuteAfter(10, () => {
		  56      -       player.move(0, 1);
		  57      -     })
		  58      -     .thenWait(() => {
		  59      -       if (player.jump()) {
		  60      -         jumpCount++;
		  61      -       }
		  62      -       test.assertEntityInstancePresent(player, goalLoc);
		  63      -       test.assert(jumpCount === 10, "Expected 2 jumps up the stairs and 8 in the snow block");
		  64      -     })
		  65      -     .thenSucceed();
		  66      - }).tag(GameTest.Tags.suiteDefault);
		  67  260   
		  68      - GameTest.register("SimulatedPlayerTests", "attack_entity", (test) => {
		  69      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		  70      -   const cow = test.spawn("minecraft:cow<minecraft:ageable_grow_up>", new BlockLocation(3, 2, 3));
		  71      -   let hitCount = 0;
		      261 + GameTest.register("SimulatedPlayerTests", "set_item", (test) => {
		      262 +     const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		      263 +     let useCount = 0;
		      264 + 
		      265 +     test.assert(player.setItem(new ItemStack(MinecraftItemTypes.snowball, 16), 0), "setItem() failed");
		      266 +     test.spawn("blaze", new BlockLocation(1, 2, 2));
		      267 + 
		      268 +     test
		      269 +         .startSequence()
		      270 +         .thenIdle(5)
		      271 +         .thenWait(() => {
		      272 +             if (player.useItemInSlot(0)) {
		      273 +                 useCount++;
		      274 +             }
		      275 +             test.assertEntityPresentInArea("blaze", false);
		      276 +         })
		      277 +         .thenExecute(() => {
		      278 +             test.assert(useCount === 7, "It should take 7 snowballs to kill a Blaze");
		      279 +         })
		      280 +         .thenSucceed();
		      281 + })
		      282 +     .maxTicks(200)
		      283 +     .structureName("SimulatedPlayerTests:blaze_trap")
		      284 +     .tag(GameTest.Tags.suiteDefault);
		      285 + 
		      286 + GameTest.register("SimulatedPlayerTests", "set_item_full_inventory", (test) => {
		      287 +     const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		      288 +     const containerSize = player.getComponent("inventory").container.size;
		      289 +     for (let i = 0; i < containerSize; i++) {
		      290 +         test.assert(player.giveItem(new ItemStack(MinecraftItemTypes.dirt, 64), false), "");
		      291 +     }
		      292 + 
		      293 +     test
		      294 +         .startSequence()
		      295 +         .thenExecuteAfter(20, () => test.assert(player.setItem(new ItemStack(MinecraftItemTypes.oakStairs, 64), 0, true), "setItem() failed"))
		      296 +         .thenSucceed();
		  72      -   test
		  73      -     .startSequence()
		  74      -     .thenWait(() => {
		  75      -       player.lookAtEntity(cow);
		  76      -       if (player.attackEntity(cow)) {
		  77      -         hitCount++;
		  78      -       }
		  79      -       test.assertEntityPresentInArea("cow", false);
		  80      -     })
		  81      -     .thenExecute(() => {
		  82      -       test.assert(hitCount === 5, "It should take 5 hits to kill a Cow.");
		  83      -     })
		  84      -     .thenSucceed();
		  85      - })
		  86      -   .maxTicks(200)
		  87      -   .structureName("ComponentTests:large_animal_pen")
		  88      -   .tag(GameTest.Tags.suiteDefault);
		  89      - 
		  90      - GameTest.register("SimulatedPlayerTests", "jump_attack_entity", (test) => {
		  91      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		  92      -   const cow = test.spawn("minecraft:cow<minecraft:ageable_grow_up>", new BlockLocation(3, 2, 3));
		  93      -   let hitCount = 0;
		  94      -   test
		  95      -     .startSequence()
		  96      -     .thenWait(() => {
		  97      -       player.lookAtEntity(cow);
		  98      -       player.jump();
		  99      -       if (player.velocity.y < -0.3 && player.attackEntity(cow)) {
		 100      -         hitCount++;
		 101      -       }
		 102      -       test.assertEntityPresentInArea("cow", false);
		 103      -     })
		 104      -     .thenExecute(() => {
		 105      -       test.assert(hitCount === 4, "It should take 4 critical hits to kill a Cow.");
		 106      -     })
		 107      -     .thenSucceed();
		 108  297   })
		      298 +     .maxTicks(100)
		      299 +     .structureName("ComponentTests:platform")
		 109      -   .maxTicks(200)
		 110      -   .structureName("ComponentTests:large_animal_pen")
		      300 +     .tag(GameTest.Tags.suiteDefault);
		 111      -   .tag(GameTest.Tags.suiteDefault);
		 112  301   
		      302 + GameTest.register("SimulatedPlayerTests", "interact_with_entity", (test) => {
		      303 +   const player = test.spawnSimulatedPlayer(new BlockLocation(0, 2, 0));
		      304 +   const minecart = test.spawn("minecart", new BlockLocation(1, 2, 1));
		 113      - GameTest.register("SimulatedPlayerTests", "attack", (test) => {
		      305 +   player.interactWithEntity(minecart);
		      306 +   test.succeedWhenEntityPresent("minecraft:player", new BlockLocation(1, 3, 1));
		      307 + }).tag(GameTest.Tags.suiteDefault);
		      308 + 
		      309 + GameTest.register("SimulatedPlayerTests", "destroy_block", (test) => {
		      310 +   const player = test.spawnSimulatedPlayer(new BlockLocation(0, 2, 0));
		      311 +   const fenceLoc = new BlockLocation(1, 2, 0);
		      312 +   const chestLoc = new BlockLocation(2, 2, 0);
		      313 +   const ironOreLoc = new BlockLocation(0, 2, 1);
		      314 +   const planksLoc = new BlockLocation(1, 2, 1);
		      315 +   const blockLocs = [fenceLoc, chestLoc, ironOreLoc, planksLoc];
		      316 + 
		      317 +   const blockTypes = [
		      318 +     MinecraftBlockTypes.fence,
		      319 +     MinecraftBlockTypes.chest,
		      320 +     MinecraftBlockTypes.ironOre,
		      321 +     MinecraftBlockTypes.planks,
		      322 +   ];
		      323 + 
		      324 +   player.giveItem(new ItemStack(MinecraftItemTypes.ironPickaxe, 1), true);
		 114      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		 115      -   const cow = test.spawn("minecraft:cow<minecraft:ageable_grow_up>", new BlockLocation(3, 2, 3));
		 116      -   let hitCount = 0;
		 117      -   test
		 118      -     .startSequence()
		 119      -     .thenWait(() => {
		 120      -       player.lookAtEntity(cow);
		 121      -       if (player.attack()) {
		 122      -         hitCount++;
		 123      -       }
		 124      -       test.assertEntityPresentInArea("cow", false);
		 125      -     })
		 126      -     .thenExecute(() => {
		 127      -       test.assert(hitCount === 5, "It should take 5 hits to kill a Cow.");
		 128      -     })
		 129      -     .thenSucceed();
		 130      - })
		 131      -   .maxTicks(200)
		 132      -   .structureName("ComponentTests:large_animal_pen")
		 133      -   .tag(GameTest.Tags.suiteDefault);
		 134  325   
		      326 +   for (let i = 0; i < blockLocs.length; i++) {
		 135      - GameTest.register("SimulatedPlayerTests", "use_item", (test) => {
		 136      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		      327 +     test.assertBlockPresent(blockTypes[i], blockLocs[i]);
		      328 +   }
		      329 + 
		      330 +   const sequence = test.startSequence().thenIdle(5);
		      331 + 
		      332 +   for (let i = 0; i < blockLocs.length; i++) {
		      333 +     sequence
		      334 +       .thenExecute(() => {
		      335 +         player.destroyBlock(blockLocs[i]);
		      336 +       })
		      337 +       .thenWait(() => {
		      338 +         test.assertBlockPresent(blockTypes[i], blockLocs[i], false);
		      339 +       });
		      340 +   }
		      341 + 
		      342 +   sequence.thenSucceed();
		 137      -   const snowball = new ItemStack(MinecraftItemTypes.snowball, 1);
		 138      -   test.spawn("blaze", new BlockLocation(1, 2, 3));
		 139      -   let useCount = 0;
		 140      -   test
		 141      -     .startSequence()
		 142      -     .thenIdle(5)
		 143      -     .thenWait(() => {
		 144      -       if (player.useItem(snowball)) {
		 145      -         useCount++;
		 146      -       }
		 147      -       test.assertEntityPresentInArea("blaze", false);
		 148      -     })
		 149      -     .thenExecute(() => {
		 150      -       test.assert(useCount === 7, "It should take 7 snowballs to kill a Blaze");
		 151      -     })
		 152      -     .thenSucceed();
		 153  343   })
		      344 +   .maxTicks(300)
		 154      -   .maxTicks(200)
		 155  345     .tag(GameTest.Tags.suiteDefault);
		 156  346   
		      347 + GameTest.register("SimulatedPlayerTests", "stop_destroying_block", (test) => {
		 157      - GameTest.register("SimulatedPlayerTests", "use_item_in_slot", (test) => {
		 158      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		 159      -   test.spawn("blaze", new BlockLocation(1, 2, 3));
		      348 +   const ironOreLoc = new BlockLocation(1, 2, 1);
		      349 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		      350 + 
		      351 +   test.setBlockType(MinecraftBlockTypes.ironOre, ironOreLoc);
		      352 +   player.giveItem(new ItemStack(MinecraftItemTypes.ironPickaxe, 1), true);
		 160      -   let useCount = 0;
		 161      -   const slot = 0;
		 162      -   const snowballCount = 10;
		 163      -   const inventoryContainer = player.getComponent("inventory").container;
		 164      -   const testEx = new GameTestExtensions(test);
		 165  353   
		 166      -   testEx.giveItem(player, MinecraftItemTypes.snowball, snowballCount, slot);
		 167  354   
		 168  355     test
		 169  356       .startSequence()
		      357 +     .thenExecuteAfter(5, () => {
		 170      -     .thenIdle(5)
		 171      -     .thenWait(() => {
		 172      -       test.assert(
		      358 +       player.destroyBlock(ironOreLoc);
		      359 +     })
		      360 +     .thenExecuteAfter(10, () => {
		      361 +       player.stopDestroyingBlock();
		      362 +     })
		      363 +     .thenExecuteAfter(20, () => {
		      364 +       test.assertBlockPresent(MinecraftBlockTypes.ironOre, ironOreLoc);
		 173      -         inventoryContainer.getItem(slot).amount === snowballCount - useCount,
		 174      -         `Player should have ${snowballCount} snowballs`
		 175      -       );
		 176      -       if (player.useItemInSlot(slot)) {
		 177      -         useCount++;
		 178      -       }
		 179      -       test.assertEntityPresentInArea("blaze", false);
		 180  365       })
		      366 +     .thenSucceed();
		      367 + })
		 181      -     .thenExecute(() => {
		      368 +   .structureName("ComponentTests:platform")
		      369 +   .tag(GameTest.Tags.suiteDefault);
		      370 + 
		      371 + GameTest.register("SimulatedPlayerTests", "use_item_while_destroying_block", (test) => {
		      372 +   const ironOreLoc = new BlockLocation(1, 2, 1);
		      373 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		      374 + 
		      375 +   test.setBlockType(MinecraftBlockTypes.ironOre, ironOreLoc);
		      376 +   player.giveItem(new ItemStack(MinecraftItemTypes.ironPickaxe, 1), false);
		      377 +   player.giveItem(new ItemStack(MinecraftItemTypes.potion, 1), false);
		      378 + 
		 182      -       test.assert(
		 183      -         inventoryContainer.getItem(slot).amount === snowballCount - useCount,
		 184      -         `Player should have ${snowballCount - useCount} snowballs`
		 185      -       );
		 186      -       test.assert(useCount === 7, "It should take 7 snowballs to kill a Blaze");
		 187      -     })
		 188      -     .thenSucceed();
		 189      - })
		 190      -   .maxTicks(200)
		 191      -   .structureName("SimulatedPlayerTests:use_item")
		 192      -   .tag(GameTest.Tags.suiteDefault);
		 193  379   
		 194      - GameTest.register("SimulatedPlayerTests", "use_item_on_block", (test) => {
		 195      -   const player = test.spawnSimulatedPlayer(new BlockLocation(0, 2, 0));
		 196  380     test
		 197  381       .startSequence()
		 198      -     .thenWait(() => {
		 199      -       const armorStand = new ItemStack(MinecraftItemTypes.armorStand, 1);
		 200      -       const armorStandLoc = new BlockLocation(1, 1, 1);
		 201      -       const used = player.useItemOnBlock(armorStand, armorStandLoc, Direction.up);
		      382 +     .thenExecuteAfter(5, () => {
		      383 +       player.destroyBlock(ironOreLoc);
		 202      -       test.assert(used, "Expected armor stand to be used");
		 203      -       test.assertEntityPresent("armor_stand", armorStandLoc.above());
		 204  384       })
		 205      -     .thenWaitAfter(10, () => {
		 206      -       const dirt = new ItemStack(MinecraftItemTypes.dirt, 1);
		 207      -       const dirtLoc = new BlockLocation(2, 1, 1);
		 208      -       const used = player.useItemOnBlock(dirt, dirtLoc, Direction.up);
		      385 +     .thenExecuteAfter(10, () => {
		      386 +       player.useItemInSlot(1); // drink potion
		 209      -       test.assert(used, "Expected dirt to be used");
		 210      -       test.assertBlockPresent(MinecraftBlockTypes.dirt, dirtLoc.above());
		 211  387       })
		 212      -     .thenWaitAfter(10, () => {
		 213      -       const bucket = new ItemStack(MinecraftItemTypes.bucket, 1);
		 214      -       const waterLoc = new BlockLocation(1, 2, 3);
		 215      -       const used = player.useItemOnBlock(bucket, waterLoc);
		      388 +     .thenExecuteAfter(30, () => {
		      389 +       test.assertBlockPresent(MinecraftBlockTypes.ironOre, ironOreLoc);
		 216      -       test.assert(used, "Expected bucket to be used");
		 217      -       test.assertBlockPresent(MinecraftBlockTypes.air, waterLoc);
		 218  390       })
		 219  391       .thenSucceed();
		      392 + })
		      393 +   .structureName("ComponentTests:platform")
		      394 +   .tag(GameTest.Tags.suiteDefault);
		 220      - }).tag(GameTest.Tags.suiteDefault);
		 221  395   
		 222      - GameTest.register("SimulatedPlayerTests", "interact_with_entity", (test) => {
		 223      -   const player = test.spawnSimulatedPlayer(new BlockLocation(0, 2, 0));
		 224      -   const minecart = test.spawn("minecart", new BlockLocation(1, 2, 1));
		 225      -   player.interactWithEntity(minecart);
		      396 + GameTest.register("SimulatedPlayerTests", "move", (test) => {
		      397 +   const player = test.spawnSimulatedPlayer(new BlockLocation(3, 2, 3));
		 226      -   test.succeedWhenEntityPresent("minecraft:player", new BlockLocation(1, 3, 1));
		 227      - }).tag(GameTest.Tags.suiteDefault);
		 228  398   
		      399 +   test
		 229      - GameTest.register("SimulatedPlayerTests", "destroy_block", (test) => {
		 230      -   const player = test.spawnSimulatedPlayer(new BlockLocation(0, 2, 0));
		      400 +     .startSequence()
		      401 +     .thenIdle(10)
		      402 +     .thenExecute(() => {
		      403 +       player.move(0, -1);
		      404 +       player.setBodyRotation(180);
		      405 +     })
		      406 +     .thenIdle(16)
		      407 +     .thenExecute(() => {
		      408 +       player.move(1, 1);
		      409 +       player.setBodyRotation(50);
		      410 +     })
		      411 +     .thenIdle(16)
		      412 +     .thenExecute(() => {
		      413 +       player.move(-1, 1);
		      414 +       player.setBodyRotation(100);
		      415 +     })
		      416 +     .thenIdle(16)
		      417 +     .thenExecute(() => {
		      418 +       player.move(-1, -1);
		      419 +       player.setBodyRotation(220);
		      420 +     })
		      421 +     .thenIdle(16)
		      422 +     .thenExecute(() => {
		      423 +       player.move(1, -1);
		      424 +       player.setBodyRotation(0);
		      425 +     })
		      426 +     .thenWait(() => {
		      427 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(2, 2, 0));
		      428 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(0, 2, 4));
		      429 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(4, 2, 6));
		      430 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(6, 2, 2));
		      431 +     })
		      432 +     .thenSucceed();
		 231      -   const fenceLoc = new BlockLocation(1, 2, 0);
		 232      -   const chestLoc = new BlockLocation(2, 2, 0);
		 233      -   const ironOreLoc = new BlockLocation(0, 2, 1);
		 234      -   const planksLoc = new BlockLocation(1, 2, 1);
		 235      -   const testEx = new GameTestExtensions(test);
		 236      -   const blockLocs = [fenceLoc, chestLoc, ironOreLoc, planksLoc];
		 237      -   
		 238      -   const blockTypes = [
		 239      -     MinecraftBlockTypes.fence,
		 240      -     MinecraftBlockTypes.chest,
		 241      -     MinecraftBlockTypes.ironOre,
		 242      -     MinecraftBlockTypes.planks,
		 243      -   ];
		 244      - 
		 245      -   testEx.giveItem(player, MinecraftItemTypes.ironPickaxe);
		 246      - 
		 247      -   for (let i = 0; i < blockLocs.length; i++) {
		 248      -     test.assertBlockPresent(blockTypes[i], blockLocs[i]);
		 249      -   }
		 250      - 
		 251      -   const sequence = test.startSequence().thenIdle(5);
		 252      - 
		 253      -   for (let i = 0; i < blockLocs.length; i++) {
		 254      -     sequence
		 255      -       .thenExecute(() => {
		 256      -         player.destroyBlock(blockLocs[i]);
		 257      -       })
		 258      -       .thenWait(() => {
		 259      -         test.assertBlockPresent(blockTypes[i], blockLocs[i], false);
		 260      -       });
		 261      -   }
		 262      - 
		 263      -   sequence.thenSucceed();
		 264  433   })
		      434 +   .maxTicks(110)
		 265      -   .maxTicks(300)
		 266  435     .tag(GameTest.Tags.suiteDefault);
		      436 + 
		      437 + GameTest.register("SimulatedPlayerTests", "move_relative", (test) => {
		      438 +   const player = test.spawnSimulatedPlayer(new BlockLocation(3, 2, 3));
		 267  439   
		      440 +   test
		      441 +     .startSequence()
		      442 +     .thenIdle(10)
		 268      - GameTest.register("SimulatedPlayerTests", "stop_destroying_block", (test) => {
		      443 +     .thenExecute(() => {
		      444 +       player.moveRelative(0, 1);
		      445 +       player.setBodyRotation(180);
		      446 +     })
		      447 +     .thenIdle(16)
		      448 +     .thenExecute(() => {
		      449 +       player.setBodyRotation(-45);
		      450 +     })
		      451 +     .thenIdle(16)
		      452 +     .thenExecute(() => {
		      453 +       player.setBodyRotation(45);
		 269      -   const ironOreLoc = new BlockLocation(1, 2, 1);
		 270      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		 271      -   const testEx = new GameTestExtensions(test);
		 272      - 
		 273      -   test.setBlockType(MinecraftBlockTypes.ironOre, ironOreLoc);
		 274      -   testEx.giveItem(player, MinecraftItemTypes.ironPickaxe);
		 275      - 
		 276      -   test
		 277      -     .startSequence()
		 278      -     .thenExecuteAfter(5, () => {
		 279      -       player.destroyBlock(ironOreLoc);
		 280  454       })
		      455 +     .thenIdle(16)
		      456 +     .thenExecute(() => {
		 281      -     .thenExecuteAfter(10, () => {
		      457 +       player.setBodyRotation(135);
		 282      -       player.stopDestroyingBlock();
		 283  458       })
		      459 +     .thenIdle(16)
		      460 +     .thenExecute(() => {
		 284      -     .thenExecuteAfter(20, () => {
		      461 +       player.setBodyRotation(225);
		 285      -       test.assertBlockPresent(MinecraftBlockTypes.ironOre, ironOreLoc);
		 286  462       })
		      463 +     .thenWait(() => {
		 287      -     .thenSucceed();
		 288      - })
		 289      -   .structureName("ComponentTests:platform")
		      464 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(2, 2, 0));
		      465 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(0, 2, 4));
		      466 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(4, 2, 6));
		      467 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(6, 2, 2));
		      468 +     })
		      469 +     .thenSucceed();
		      470 + })
		      471 +   .maxTicks(110)
		      472 +   .structureName("SimulatedPlayerTests:move")
		      473 +   .tag(GameTest.Tags.suiteDefault);
		 290      -   .tag(GameTest.Tags.suiteDefault);
		 291      - 
		 292      - GameTest.register("SimulatedPlayerTests", "use_item_while_destroying_block", (test) => {
		 293      -   const ironOreLoc = new BlockLocation(1, 2, 1);
		 294      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		 295      -   const testEx = new GameTestExtensions(test);
		 296      - 
		 297      -   test.setBlockType(MinecraftBlockTypes.ironOre, ironOreLoc);
		 298      -   testEx.giveItem(player, MinecraftItemTypes.ironPickaxe);
		 299      -   testEx.giveItem(player, MinecraftItemTypes.potion);
		 300  474   
		 301      -   test
		 302      -     .startSequence()
		 303      -     .thenExecuteAfter(5, () => {
		      475 + GameTest.register("SimulatedPlayerTests", "move_to_block", (test) => {
		      476 +   const player = test.spawnSimulatedPlayer(new BlockLocation(3, 2, 3));
		      477 +   test
		      478 +     .startSequence()
		      479 +     .thenIdle(5)
		      480 +     .thenExecute(() => {
		      481 +       player.moveToBlock(new BlockLocation(3, 2, 1));
		 304      -       player.destroyBlock(ironOreLoc);
		 305      -     })
		 306      -     .thenExecuteAfter(10, () => {
		 307      -       player.useItemInSlot(1); // drink potion
		 308      -     })
		 309      -     .thenExecuteAfter(30, () => {
		 310      -       test.assertBlockPresent(MinecraftBlockTypes.ironOre, ironOreLoc);
		 311  482       })
		      483 +     .thenIdle(25)
		 312      -     .thenSucceed();
		 313      - })
		 314      -   .structureName("ComponentTests:platform")
		      484 +     .thenExecute(() => {
		      485 +       player.moveToBlock(new BlockLocation(5, 2, 3));
		      486 +     })
		      487 +     .thenIdle(25)
		      488 +     .thenExecute(() => {
		      489 +       player.moveToBlock(new BlockLocation(3, 2, 5));
		      490 +     })
		      491 +     .thenIdle(25)
		 315      -   .tag(GameTest.Tags.suiteDefault);
		 316      - 
		 317      - GameTest.register("SimulatedPlayerTests", "move", (test) => {
		 318      -   const player = test.spawnSimulatedPlayer(new BlockLocation(3, 2, 3));
		 319      - 
		 320      -   test
		 321      -     .startSequence()
		 322      -     .thenIdle(10)
		 323  492       .thenExecute(() => {
		      493 +       player.moveToBlock(new BlockLocation(1, 2, 3));
		 324      -       player.move(0, -1);
		 325      -       player.setBodyRotation(180);
		 326  494       })
		      495 +     .thenIdle(25)
		 327      -     .thenIdle(16)
		 328  496       .thenExecute(() => {
		      497 +       player.moveToBlock(new BlockLocation(3, 2, 1));
		 329      -       player.move(1, 1);
		 330      -       player.setBodyRotation(50);
		 331  498       })
		      499 +     .thenIdle(25)
		 332      -     .thenIdle(16)
		 333  500       .thenExecute(() => {
		      501 +       player.moveToBlock(new BlockLocation(3, 2, 3));
		 334      -       player.move(-1, 1);
		 335      -       player.setBodyRotation(100);
		 336  502       })
		      503 +     .thenWait(() => {
		      504 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(2, 2, 0));
		 337      -     .thenIdle(16)
		      505 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(0, 2, 4));
		      506 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(4, 2, 6));
		      507 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(6, 2, 2));
		 338      -     .thenExecute(() => {
		 339      -       player.move(-1, -1);
		 340      -       player.setBodyRotation(220);
		 341  508       })
		      509 +     .thenSucceed();
		      510 + })
		      511 +   .maxTicks(200)
		      512 +   .structureName("SimulatedPlayerTests:move")
		      513 +   .tag(GameTest.Tags.suiteDefault);
		      514 + 
		      515 + GameTest.register("SimulatedPlayerTests", "move_to_location", (test) => {
		      516 +   const player = test.spawnSimulatedPlayer(new BlockLocation(3, 2, 3));
		      517 +   test
		      518 +     .startSequence()
		      519 +     .thenIdle(5)
		      520 +     .thenExecute(() => {
		      521 +       player.moveToLocation(new Location(3.5, 2, 1.5));
		 342      -     .thenIdle(16)
		 343      -     .thenExecute(() => {
		 344      -       player.move(1, -1);
		 345      -       player.setBodyRotation(0);
		 346      -     })
		 347      -     .thenWait(() => {
		 348      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(2, 2, 0));
		 349      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(0, 2, 4));
		 350      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(4, 2, 6));
		 351      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(6, 2, 2));
		 352  522       })
		      523 +     .thenIdle(25)
		 353      -     .thenSucceed();
		 354      - })
		 355      -   .maxTicks(110)
		      524 +     .thenExecute(() => {
		      525 +       player.moveToLocation(new Location(5.5, 2, 3.5));
		      526 +     })
		      527 +     .thenIdle(25)
		      528 +     .thenExecute(() => {
		      529 +       player.moveToLocation(new Location(3.5, 2, 5.5));
		      530 +     })
		      531 +     .thenIdle(25)
		 356      -   .tag(GameTest.Tags.suiteDefault);
		 357      - 
		 358      - GameTest.register("SimulatedPlayerTests", "move_relative", (test) => {
		 359      -   const player = test.spawnSimulatedPlayer(new BlockLocation(3, 2, 3));
		 360      - 
		 361      -   test
		 362      -     .startSequence()
		 363      -     .thenIdle(10)
		 364  532       .thenExecute(() => {
		      533 +       player.moveToLocation(new Location(1.5, 2, 3.5));
		 365      -       player.moveRelative(0, 1);
		 366      -       player.setBodyRotation(180);
		 367  534       })
		      535 +     .thenIdle(25)
		 368      -     .thenIdle(16)
		 369  536       .thenExecute(() => {
		      537 +       player.moveToLocation(new Location(3.5, 2, 1.5));
		 370      -       player.setBodyRotation(-45);
		 371  538       })
		      539 +     .thenIdle(25)
		 372      -     .thenIdle(16)
		 373  540       .thenExecute(() => {
		      541 +       player.moveToLocation(new Location(3.5, 2, 3.5));
		 374      -       player.setBodyRotation(45);
		 375  542       })
		      543 +     .thenWait(() => {
		      544 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(2, 2, 0));
		      545 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(0, 2, 4));
		 376      -     .thenIdle(16)
		      546 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(4, 2, 6));
		      547 +       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(6, 2, 2));
		 377      -     .thenExecute(() => {
		 378      -       player.setBodyRotation(135);
		 379  548       })
		      549 +     .thenSucceed();
		      550 + })
		 380      -     .thenIdle(16)
		      551 +   .maxTicks(200)
		      552 +   .structureName("SimulatedPlayerTests:move")
		 381      -     .thenExecute(() => {
		 382      -       player.setBodyRotation(225);
		 383      -     })
		      553 +   .tag(GameTest.Tags.suiteDefault);
		      554 + 
		      555 + GameTest.register("SimulatedPlayerTests", "navigate_to_block", (test) => {
		      556 +   const player = test.spawnSimulatedPlayer(new BlockLocation(2, 2, 0));
		      557 +   const goalLoc = new BlockLocation(0, 3, 2);
		      558 +   const behindDoorLoc = new BlockLocation(4, 3, 2);
		      559 + 
		      560 +   test
		      561 +     .startSequence()
		      562 +     .thenExecuteAfter(10, () => {
		      563 +       const nav = player.navigateToBlock(behindDoorLoc);
		 384      -     .thenWait(() => {
		 385      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(2, 2, 0));
		 386      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(0, 2, 4));
		 387      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(4, 2, 6));
		 388      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(6, 2, 2));
		 389      -     })
		 390      -     .thenSucceed();
		 391      - })
		 392      -   .maxTicks(110)
		 393      -   .structureName("SimulatedPlayerTests:move")
		 394      -   .tag(GameTest.Tags.suiteDefault);
		 395      - 
		      564 +       test.assert(nav.isFullPath, "Expected successful navigation result");
		      565 +       const path = nav.path;
		      566 +       test.assert(path[0].equals(new BlockLocation(2, 2, 0)), "Unexpected starting BlockLocation in navigation path.");
		      567 +       test.assert(
		      568 +         path[path.length - 1].equals(new BlockLocation(4, 3, 2)),
		      569 +         "Unexpected ending BlockLocation in navigation path."
		      570 +       );
		 396      - GameTest.register("SimulatedPlayerTests", "move_to_block", (test) => {
		 397      -   const player = test.spawnSimulatedPlayer(new BlockLocation(3, 2, 3));
		 398      -   test
		 399      -     .startSequence()
		 400      -     .thenIdle(5)
		 401      -     .thenExecute(() => {
		 402      -       player.moveToBlock(new BlockLocation(3, 2, 1));
		 403  571       })
		      572 +     .thenWait(() => {
		 404      -     .thenIdle(25)
		 405      -     .thenExecute(() => {
		      573 +       test.assertEntityInstancePresent(player, behindDoorLoc);
		 406      -       player.moveToBlock(new BlockLocation(5, 2, 3));
		 407  574       })
		      575 +     .thenExecuteAfter(10, () => {
		      576 +       const nav = player.navigateToBlock(goalLoc);
		 408      -     .thenIdle(25)
		      577 +       test.assert(nav.isFullPath, "Expected successful navigation result");
		      578 +       const path = nav.path;
		      579 +       test.assert(
		      580 +         path[path.length - 1].equals(new BlockLocation(0, 3, 2)),
		      581 +         "Unexpected ending BlockLocation in navigation path."
		      582 +       );
		 409      -     .thenExecute(() => {
		 410      -       player.moveToBlock(new BlockLocation(3, 2, 5));
		 411      -     })
		 412      -     .thenIdle(25)
		 413      -     .thenExecute(() => {
		 414      -       player.moveToBlock(new BlockLocation(1, 2, 3));
		 415  583       })
		      584 +     .thenWait(() => {
		 416      -     .thenIdle(25)
		 417      -     .thenExecute(() => {
		      585 +       test.assertEntityInstancePresent(player, goalLoc);
		 418      -       player.moveToBlock(new BlockLocation(3, 2, 1));
		 419  586       })
		      587 +     .thenSucceed();
		      588 + })
		      589 +   .maxTicks(300)
		      590 +   .structureName("SimulatedPlayerTests:navigate_to_location")
		      591 +   .tag(GameTest.Tags.suiteDefault);
		      592 + 
		      593 + GameTest.register("SimulatedPlayerTests", "navigate_to_entity", (test) => {
		      594 +   const player = test.spawnSimulatedPlayer(new BlockLocation(2, 2, 0));
		      595 +   const goalLoc = new BlockLocation(0, 3, 2);
		      596 +   const behindDoorLoc = new BlockLocation(4, 3, 2);
		      597 + 
		      598 +   const armorStand1 = test.spawn("armor_stand", behindDoorLoc.above());
		      599 +   const armorStand2 = test.spawn("armor_stand", goalLoc.above());
		      600 + 
		      601 +   test
		      602 +     .startSequence()
		      603 +     .thenExecuteAfter(10, () => {
		      604 +       const nav = player.navigateToEntity(armorStand1);
		 420      -     .thenIdle(25)
		 421      -     .thenExecute(() => {
		 422      -       player.moveToBlock(new BlockLocation(3, 2, 3));
		 423      -     })
		 424      -     .thenWait(() => {
		 425      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(2, 2, 0));
		 426      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(0, 2, 4));
		 427      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(4, 2, 6));
		 428      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(6, 2, 2));
		 429      -     })
		 430      -     .thenSucceed();
		 431      - })
		 432      -   .maxTicks(200)
		 433      -   .structureName("SimulatedPlayerTests:move")
		 434      -   .tag(GameTest.Tags.suiteDefault);
		 435      - 
		      605 +       test.assert(nav.isFullPath, "Expected successful navigation result");
		      606 +       const path = nav.path;
		      607 +       test.assert(path[0].equals(new BlockLocation(2, 2, 0)), "Unexpected starting BlockLocation in navigation path.");
		      608 +       test.assert(
		      609 +         path[path.length - 1].equals(new BlockLocation(4, 3, 2)),
		      610 +         "Unexpected ending BlockLocation in navigation path."
		      611 +       );
		 436      - GameTest.register("SimulatedPlayerTests", "move_to_location", (test) => {
		 437      -   const player = test.spawnSimulatedPlayer(new BlockLocation(3, 2, 3));
		 438      -   test
		 439      -     .startSequence()
		 440      -     .thenIdle(5)
		 441      -     .thenExecute(() => {
		 442      -       player.moveToLocation(new Location(3.5, 2, 1.5));
		 443  612       })
		      613 +     .thenWait(() => {
		 444      -     .thenIdle(25)
		 445      -     .thenExecute(() => {
		      614 +       test.assertEntityInstancePresent(player, behindDoorLoc);
		 446      -       player.moveToLocation(new Location(5.5, 2, 3.5));
		 447  615       })
		      616 +     .thenExecuteAfter(10, () => {
		      617 +       const nav = player.navigateToEntity(armorStand2);
		 448      -     .thenIdle(25)
		      618 +       test.assert(nav.isFullPath, "Expected successful navigation result");
		      619 +       const path = nav.path;
		      620 +       test.assert(
		      621 +         path[path.length - 1].equals(new BlockLocation(0, 3, 2)),
		      622 +         "Unexpected ending BlockLocation in navigation path."
		      623 +       );
		 449      -     .thenExecute(() => {
		 450      -       player.moveToLocation(new Location(3.5, 2, 5.5));
		 451      -     })
		 452      -     .thenIdle(25)
		 453      -     .thenExecute(() => {
		 454      -       player.moveToLocation(new Location(1.5, 2, 3.5));
		 455  624       })
		      625 +     .thenWait(() => {
		 456      -     .thenIdle(25)
		 457      -     .thenExecute(() => {
		      626 +       test.assertEntityInstancePresent(player, goalLoc);
		 458      -       player.moveToLocation(new Location(3.5, 2, 1.5));
		 459  627       })
		      628 +     .thenSucceed();
		      629 + })
		      630 +   .maxTicks(300)
		      631 +   .structureName("SimulatedPlayerTests:navigate_to_location")
		      632 +   .tag(GameTest.Tags.suiteDefault);
		      633 + 
		      634 + GameTest.register("SimulatedPlayerTests", "navigate_to_location", (test) => {
		      635 +   const player = test.spawnSimulatedPlayer(new BlockLocation(2, 2, 0));
		      636 +   const goalLoc = new BlockLocation(0, 3, 2);
		      637 +   const behindDoorLoc = new BlockLocation(4, 3, 2);
		      638 + 
		      639 +   test
		      640 +     .startSequence()
		      641 +     .thenExecuteAfter(10, () => {
		      642 +       const nav = player.navigateToLocation(new Location(4.5, 3, 2.5));
		      643 +       test.assert(nav.isFullPath, "Expected successful navigation result");
		      644 +       const path = nav.path;
		      645 +       test.assert(path[0].equals(new BlockLocation(2, 2, 0)), "Unexpected starting BlockLocation in navigation path.");
		      646 +       test.assert(
		      647 +         path[path.length - 1].equals(new BlockLocation(4, 3, 2)),
		      648 +         "Unexpected ending BlockLocation in navigation path."
		      649 +       );
		      650 +     })
		      651 +     .thenWait(() => {
		      652 +       test.assertEntityInstancePresent(player, behindDoorLoc);
		      653 +     })
		 460      -     .thenIdle(25)
		 461      -     .thenExecute(() => {
		 462      -       player.moveToLocation(new Location(3.5, 2, 3.5));
		 463      -     })
		 464      -     .thenWait(() => {
		 465      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(2, 2, 0));
		 466      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(0, 2, 4));
		 467      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(4, 2, 6));
		 468      -       test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(6, 2, 2));
		 469      -     })
		 470      -     .thenSucceed();
		 471      - })
		 472      -   .maxTicks(200)
		 473      -   .structureName("SimulatedPlayerTests:move")
		 474      -   .tag(GameTest.Tags.suiteDefault);
		 475      - 
		 476      - GameTest.register("SimulatedPlayerTests", "navigate_to_block", (test) => {
		 477      -   const player = test.spawnSimulatedPlayer(new BlockLocation(2, 2, 0));
		 478      -   const goalLoc = new BlockLocation(0, 3, 2);
		 479      -   const behindDoorLoc = new BlockLocation(4, 3, 2);
		 480      - 
		 481      -   test
		 482      -     .startSequence()
		 483  654       .thenExecuteAfter(10, () => {
		      655 +       const nav = player.navigateToLocation(new Location(0.5, 3, 2.5));
		 484      -       const nav = player.navigateToBlock(behindDoorLoc);
		 485  656         test.assert(nav.isFullPath, "Expected successful navigation result");
		 486  657         const path = nav.path;
		 487      -       test.assert(path[0].equals(new BlockLocation(2, 2, 0)), "Unexpected starting BlockLocation in navigation path.");
		 488  658         test.assert(
		      659 +         path[path.length - 1].equals(new BlockLocation(0, 3, 2)),
		 489      -         path[path.length - 1].equals(new BlockLocation(4, 3, 2)),
		 490  660           "Unexpected ending BlockLocation in navigation path."
		 491  661         );
		 492  662       })
		 493  663       .thenWait(() => {
		      664 +       test.assertEntityInstancePresent(player, goalLoc);
		 494      -       test.assertEntityInstancePresent(player, behindDoorLoc);
		 495  665       })
		      666 +     .thenSucceed();
		 496      -     .thenExecuteAfter(10, () => {
		 497      -       const nav = player.navigateToBlock(goalLoc);
		 498      -       test.assert(nav.isFullPath, "Expected successful navigation result");
		      667 + })
		      668 +   .maxTicks(300)
		      669 +   .tag(GameTest.Tags.suiteDefault);
		      670 + 
		      671 + GameTest.register("SimulatedPlayerTests", "navigate_to_locations", (test) => {
		      672 +   const player = test.spawnSimulatedPlayer(new BlockLocation(2, 2, 0));
		      673 +   const goalLoc = new BlockLocation(0, 3, 2);
		      674 +   const locations = [new Location(4.5, 3, 2.5), new Location(0.5, 3, 2.5)];
		      675 + 
		      676 +   test
		      677 +     .startSequence()
		      678 +     .thenExecuteAfter(10, () => {
		      679 +       player.navigateToLocations(locations);
		      680 +     })
		      681 +     .thenWait(() => {
		      682 +       test.assertEntityInstancePresent(player, goalLoc);
		      683 +     })
		      684 +     .thenSucceed();
		      685 + })
		      686 +   .maxTicks(300)
		      687 +   .structureName("SimulatedPlayerTests:navigate_to_location")
		      688 +   .tag(GameTest.Tags.suiteDefault);
		 499      -       const path = nav.path;
		 500      -       test.assert(
		 501      -         path[path.length - 1].equals(new BlockLocation(0, 3, 2)),
		 502      -         "Unexpected ending BlockLocation in navigation path."
		 503      -       );
		 504      -     })
		 505      -     .thenWait(() => {
		 506      -       test.assertEntityInstancePresent(player, goalLoc);
		 507      -     })
		 508      -     .thenSucceed();
		 509      - })
		 510      -   .maxTicks(300)
		 511      -   .structureName("SimulatedPlayerTests:navigate_to_location")
		 512      -   .tag(GameTest.Tags.suiteDefault);
		 513      - 
		 514      - GameTest.register("SimulatedPlayerTests", "navigate_to_entity", (test) => {
		 515      -   const player = test.spawnSimulatedPlayer(new BlockLocation(2, 2, 0));
		 516      -   const goalLoc = new BlockLocation(0, 3, 2);
		 517      -   const behindDoorLoc = new BlockLocation(4, 3, 2);
		 518      - 
		 519      -   const armorStand1 = test.spawn("armor_stand", behindDoorLoc.above());
		 520      -   const armorStand2 = test.spawn("armor_stand", goalLoc.above());
		 521  689   
		      690 + GameTest.register("SimulatedPlayerTests", "stop_moving", (test) => {
		 522      -   test
		 523      -     .startSequence()
		 524      -     .thenExecuteAfter(10, () => {
		      691 +   const spawnLoc = new BlockLocation(1, 2, 0);
		      692 +   const player = test.spawnSimulatedPlayer(spawnLoc);
		      693 +   player.move(0, 1);
		      694 + 
		      695 +   test
		      696 +     .startSequence()
		      697 +     .thenExecuteAfter(10, () => {
		      698 +       player.stopMoving();
		 525      -       const nav = player.navigateToEntity(armorStand1);
		 526      -       test.assert(nav.isFullPath, "Expected successful navigation result");
		 527      -       const path = nav.path;
		 528      -       test.assert(path[0].equals(new BlockLocation(2, 2, 0)), "Unexpected starting BlockLocation in navigation path.");
		 529      -       test.assert(
		 530      -         path[path.length - 1].equals(new BlockLocation(4, 3, 2)),
		 531      -         "Unexpected ending BlockLocation in navigation path."
		 532      -       );
		 533  699       })
		      700 +     .thenExecuteAfter(20, () => {
		      701 +       test.assertEntityInstancePresent(player, spawnLoc, false);
		 534      -     .thenWait(() => {
		      702 +       test.assertEntityInstancePresent(player, new BlockLocation(1, 3, 4), false);
		 535      -       test.assertEntityInstancePresent(player, behindDoorLoc);
		 536  703       })
		      704 +     .thenSucceed();
		      705 + }).tag(GameTest.Tags.suiteDefault);
		      706 + 
		 537      -     .thenExecuteAfter(10, () => {
		      707 + GameTest.register("SimulatedPlayerTests", "shoot_bow", (test) => {
		      708 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		      709 +   const lampLoc = new BlockLocation(2, 3, 7);
		      710 + 
		      711 + 
		      712 +   test
		      713 +       .startSequence()
		      714 +       .thenExecuteAfter(5, () => {
		      715 +         player.giveItem(new ItemStack(MinecraftItemTypes.bow, 1), false);
		      716 +         player.giveItem(new ItemStack(MinecraftItemTypes.arrow, 64), false);
		 538      -       const nav = player.navigateToEntity(armorStand2);
		 539      -       test.assert(nav.isFullPath, "Expected successful navigation result");
		 540      -       const path = nav.path;
		 541      -       test.assert(
		 542      -         path[path.length - 1].equals(new BlockLocation(0, 3, 2)),
		 543      -         "Unexpected ending BlockLocation in navigation path."
		 544      -       );
		 545      -     })
		 546      -     .thenWait(() => {
		 547      -       test.assertEntityInstancePresent(player, goalLoc);
		 548  717       })
		      718 +     .thenExecuteAfter(5, () => {
		 549      -     .thenSucceed();
		 550      - })
		 551      -   .maxTicks(300)
		      719 +       player.useItemInSlot(0);
		      720 +     })
		      721 +     .thenExecuteAfter(50, () => {
		      722 +       player.stopUsingItem();
		      723 +     })
		      724 +     .thenWait(() => {
		      725 +       test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, lampLoc);
		      726 +     })
		      727 +     .thenSucceed();
		      728 + })
		      729 +   .structureName("SimulatedPlayerTests:target_practice")
		      730 +   .tag(GameTest.Tags.suiteDefault);
		      731 + 
		      732 + GameTest.register("SimulatedPlayerTests", "shoot_crossbow", (test) => {
		      733 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		      734 +   const lampLoc = new BlockLocation(2, 3, 7);
		      735 + 
		      736 +   test
		      737 +       .startSequence()
		      738 +       .thenExecuteAfter(5, () => {
		      739 +           player.giveItem(new ItemStack(MinecraftItemTypes.crossbow, 1), false);
		      740 +           player.giveItem(new ItemStack(MinecraftItemTypes.arrow, 64), false);
		 552      -   .structureName("SimulatedPlayerTests:navigate_to_location")
		 553      -   .tag(GameTest.Tags.suiteDefault);
		 554      - 
		 555      - GameTest.register("SimulatedPlayerTests", "navigate_to_location", (test) => {
		 556      -   const player = test.spawnSimulatedPlayer(new BlockLocation(2, 2, 0));
		 557      -   const goalLoc = new BlockLocation(0, 3, 2);
		 558      -   const behindDoorLoc = new BlockLocation(4, 3, 2);
		 559      - 
		 560      -   test
		 561      -     .startSequence()
		 562      -     .thenExecuteAfter(10, () => {
		 563      -       const nav = player.navigateToLocation(new Location(4.5, 3, 2.5));
		 564      -       test.assert(nav.isFullPath, "Expected successful navigation result");
		 565      -       const path = nav.path;
		 566      -       test.assert(path[0].equals(new BlockLocation(2, 2, 0)), "Unexpected starting BlockLocation in navigation path.");
		 567      -       test.assert(
		 568      -         path[path.length - 1].equals(new BlockLocation(4, 3, 2)),
		 569      -         "Unexpected ending BlockLocation in navigation path."
		 570      -       );
		 571      -     })
		 572      -     .thenWait(() => {
		 573      -       test.assertEntityInstancePresent(player, behindDoorLoc);
		 574  741       })
		      742 +     .thenExecuteAfter(5, () => {
		 575      -     .thenExecuteAfter(10, () => {
		 576      -       const nav = player.navigateToLocation(new Location(0.5, 3, 2.5));
		 577      -       test.assert(nav.isFullPath, "Expected successful navigation result");
		      743 +       player.useItemInSlot(0);
		      744 +     })
		      745 +     .thenExecuteAfter(50, () => {
		      746 +       player.stopUsingItem();
		      747 +       player.useItemInSlot(0);
		 578      -       const path = nav.path;
		 579      -       test.assert(
		 580      -         path[path.length - 1].equals(new BlockLocation(0, 3, 2)),
		 581      -         "Unexpected ending BlockLocation in navigation path."
		 582      -       );
		 583  748       })
		 584  749       .thenWait(() => {
		      750 +       test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, lampLoc);
		 585      -       test.assertEntityInstancePresent(player, goalLoc);
		 586  751       })
		 587  752       .thenSucceed();
		 588  753   })
		      754 +   .maxTicks(150)
		      755 +   .structureName("SimulatedPlayerTests:target_practice")
		 589      -   .maxTicks(300)
		 590  756     .tag(GameTest.Tags.suiteDefault);
		 591  757   
		      758 + GameTest.register("SimulatedPlayerTests", "move_in_minecart", (test) => {
		      759 +   const player = test.spawnSimulatedPlayer(new BlockLocation(0, 2, 0));
		 592      - GameTest.register("SimulatedPlayerTests", "navigate_to_locations", (test) => {
		 593      -   const player = test.spawnSimulatedPlayer(new BlockLocation(2, 2, 0));
		      760 +   const minecart = test.spawn("minecart", new BlockLocation(1, 2, 0));
		      761 +   const lampLoc = new BlockLocation(0, 2, 3);
		 594      -   const goalLoc = new BlockLocation(0, 3, 2);
		 595      -   const locations = [new Location(4.5, 3, 2.5), new Location(0.5, 3, 2.5)];
		 596  762   
		 597  763     test
		 598  764       .startSequence()
		      765 +     .thenExecuteAfter(20, () => {
		      766 +       player.interactWithEntity(minecart);
		 599      -     .thenExecuteAfter(10, () => {
		      767 +       player.move(0, 1);
		 600      -       player.navigateToLocations(locations);
		 601  768       })
		 602  769       .thenWait(() => {
		      770 +       test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, lampLoc);
		 603      -       test.assertEntityInstancePresent(player, goalLoc);
		 604  771       })
		 605  772       .thenSucceed();
		 606  773   })
		      774 +   .maxTicks(200)
		 607      -   .maxTicks(300)
		 608      -   .structureName("SimulatedPlayerTests:navigate_to_location")
		 609  775     .tag(GameTest.Tags.suiteDefault);
		 610  776   
		      777 + GameTest.register("SimulatedPlayerTests", "rotate_body", (test) => {
		 611      - GameTest.register("SimulatedPlayerTests", "stop_moving", (test) => {
		 612      -   const spawnLoc = new BlockLocation(1, 2, 0);
		 613      -   const player = test.spawnSimulatedPlayer(spawnLoc);
		      778 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		 614      -   player.move(0, 1);
		 615  779   
		 616  780     test
		 617  781       .startSequence()
		 618      -     .thenExecuteAfter(10, () => {
		 619      -       player.stopMoving();
		 620      -     })
		 621      -     .thenExecuteAfter(20, () => {
		      782 +     .thenExecuteAfter(5, () => {
		      783 +       test.assert(player.bodyRotation === 0, "Expected body rotation of 0 degrees (1)");
		 622      -       test.assertEntityInstancePresent(player, spawnLoc, false);
		 623      -       test.assertEntityInstancePresent(player, new BlockLocation(1, 3, 4), false);
		 624  784       })
		 625      -     .thenSucceed();
		 626      - }).tag(GameTest.Tags.suiteDefault);
		 627      - 
		      785 +     .thenExecuteAfter(5, () => {
		      786 +       player.setBodyRotation(90);
		      787 +       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees (2)");
		      788 +     })
		      789 +     .thenExecuteAfter(5, () => {
		      790 +       player.setBodyRotation(-90);
		      791 +       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees (3)");
		      792 +     })
		 628      - GameTest.register("SimulatedPlayerTests", "shoot_bow", (test) => {
		 629      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		 630      -   const lampLoc = new BlockLocation(2, 3, 7);
		 631      -   const testEx = new GameTestExtensions(test);
		 632      - 
		 633      - 
		 634      -   test
		 635      -     .startSequence()
		 636  793       .thenExecuteAfter(5, () => {
		      794 +       player.setBodyRotation(180);
		      795 +       test.assert(player.bodyRotation === -180, "Expected body rotation of -180 degrees (4)");
		 637      -       testEx.giveItem(player, MinecraftItemTypes.bow);
		 638      -       testEx.giveItem(player, MinecraftItemTypes.arrow, 64);
		 639  796       })
		 640  797       .thenExecuteAfter(5, () => {
		      798 +       player.rotateBody(180);
		      799 +       test.assert(player.bodyRotation === 0, "Expected body rotation of 0 degrees (5)");
		 641      -       player.useItemInSlot(0);
		 642  800       })
		      801 +     .thenExecuteAfter(5, () => {
		      802 +       player.rotateBody(90);
		 643      -     .thenExecuteAfter(50, () => {
		      803 +       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees (6)");
		 644      -       player.stopUsingItem();
		 645  804       })
		      805 +     .thenExecuteAfter(5, () => {
		      806 +       player.rotateBody(-180);
		 646      -     .thenWait(() => {
		      807 +       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees (7)");
		 647      -       test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, lampLoc);
		 648  808       })
		 649  809       .thenSucceed();
		 650  810   })
		      811 +   .structureName("ComponentTests:platform")
		 651      -   .structureName("SimulatedPlayerTests:target_practice")
		 652  812     .tag(GameTest.Tags.suiteDefault);
		 653  813   
		      814 + GameTest.register("SimulatedPlayerTests", "look_at_entity", (test) => {
		 654      - GameTest.register("SimulatedPlayerTests", "shoot_crossbow", (test) => {
		 655  815     const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		      816 +   const leftArmorStand = test.spawn("armor_stand", new BlockLocation(2, 2, 1));
		      817 +   const rightArmorStand = test.spawn("armor_stand", new BlockLocation(0, 2, 1));
		 656      -   const lampLoc = new BlockLocation(2, 3, 7);
		 657      -   const testEx = new GameTestExtensions(test);
		 658      - 
		 659  818   
		 660  819     test
		 661  820       .startSequence()
		 662      -     .thenExecuteAfter(5, () => {
		 663      -       testEx.giveItem(player, MinecraftItemTypes.crossbow);
		 664      -       testEx.giveItem(player, MinecraftItemTypes.arrow, 64);
		 665      -     })
		 666  821       .thenExecuteAfter(5, () => {
		 667      -       player.useItemInSlot(0);
		 668      -     })
		 669      -     .thenExecuteAfter(50, () => {
		      822 +       player.lookAtEntity(leftArmorStand);
		      823 +       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees");
		 670      -       player.stopUsingItem();
		 671      -       player.useItemInSlot(0);
		 672  824       })
		      825 +     .thenExecuteAfter(5, () => {
		      826 +       player.lookAtEntity(rightArmorStand);
		 673      -     .thenWait(() => {
		      827 +       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees");
		 674      -       test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, lampLoc);
		 675  828       })
		 676  829       .thenSucceed();
		 677  830   })
		      831 +   .structureName("ComponentTests:platform")
		 678      -   .maxTicks(150)
		 679      -   .structureName("SimulatedPlayerTests:target_practice")
		 680  832     .tag(GameTest.Tags.suiteDefault);
		 681  833   
		      834 + GameTest.register("SimulatedPlayerTests", "look_at_block", (test) => {
		      835 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		 682      - GameTest.register("SimulatedPlayerTests", "move_in_minecart", (test) => {
		 683      -   const player = test.spawnSimulatedPlayer(new BlockLocation(0, 2, 0));
		      836 +   const leftBlockLoc = new BlockLocation(2, 2, 1);
		      837 +   const rightBlockLoc = new BlockLocation(0, 2, 1);
		 684      -   const minecart = test.spawn("minecart", new BlockLocation(1, 2, 0));
		 685      -   const lampLoc = new BlockLocation(0, 2, 3);
		 686  838   
		 687  839     test
		 688  840       .startSequence()
		      841 +     .thenExecuteAfter(10, () => {
		 689      -     .thenExecuteAfter(20, () => {
		 690      -       player.interactWithEntity(minecart);
		      842 +       test.assert(player.bodyRotation === 0, "Expected body rotation of 0 degrees");
		      843 +       test.assert(player.headRotation.pitch === 0, "Expected head pitch of 0 degrees");
		      844 +       test.assert(player.headRotation.yaw === 0, "Expected head yaw of 0 degrees");
		      845 +       player.lookAtBlock(leftBlockLoc);
		 691      -       player.move(0, 1);
		 692      -     })
		 693      -     .thenWait(() => {
		 694      -       test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, lampLoc);
		 695  846       })
		      847 +     .thenExecuteAfter(20, () => {
		      848 +       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees");
		 696      -     .thenSucceed();
		 697      - })
		      849 +       test.assert(isNear(player.headRotation.pitch, 48.24), "Expected head pitch of ~48.24 degrees");
		      850 +       test.assert(player.headRotation.yaw === -90, "Expected head yaw of -90 degrees");
		      851 +     })
		      852 +     .thenExecuteAfter(10, () => {
		      853 +       player.lookAtBlock(rightBlockLoc);
		      854 +     })
		      855 +     .thenExecuteAfter(20, () => {
		      856 +       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees");
		      857 +       test.assert(isNear(player.headRotation.pitch, 48.24), "Expected head pitch of ~48.24 degrees");
		      858 +       test.assert(player.headRotation.yaw === 90, "Expected head yaw of 90 degrees");
		 698      -   .maxTicks(200)
		 699      -   .tag(GameTest.Tags.suiteDefault);
		 700      - 
		 701      - GameTest.register("SimulatedPlayerTests", "rotate_body", (test) => {
		 702      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		 703      - 
		 704      -   test
		 705      -     .startSequence()
		 706      -     .thenExecuteAfter(5, () => {
		 707      -       test.assert(player.bodyRotation === 0, "Expected body rotation of 0 degrees (1)");
		 708  859       })
		      860 +     .thenSucceed();
		      861 + })
		      862 +   .structureName("ComponentTests:platform")
		 709      -     .thenExecuteAfter(5, () => {
		      863 +   .tag(GameTest.Tags.suiteDefault);
		      864 + 
		      865 + GameTest.register("SimulatedPlayerTests", "look_at_location", (test) => {
		      866 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		      867 +   const leftLoc = new Location(2.5, 2, 1.5);
		      868 +   const rightLoc = new Location(0.5, 2, 1.5);
		      869 + 
		      870 +   test
		      871 +     .startSequence()
		      872 +     .thenExecuteAfter(10, () => {
		      873 +       test.assert(player.bodyRotation === 0, "Expected body rotation of 0 degrees");
		      874 +       test.assert(player.headRotation.pitch === 0, "Expected head pitch of 0 degrees");
		      875 +       test.assert(player.headRotation.yaw === 0, "Expected head yaw of 0 degrees");
		      876 +       player.lookAtLocation(leftLoc);
		 710      -       player.setBodyRotation(90);
		 711      -       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees (2)");
		 712      -     })
		 713      -     .thenExecuteAfter(5, () => {
		 714      -       player.setBodyRotation(-90);
		 715      -       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees (3)");
		 716      -     })
		 717      -     .thenExecuteAfter(5, () => {
		 718      -       player.setBodyRotation(180);
		 719      -       test.assert(player.bodyRotation === -180, "Expected body rotation of -180 degrees (4)");
		 720      -     })
		 721      -     .thenExecuteAfter(5, () => {
		 722      -       player.rotateBody(180);
		 723      -       test.assert(player.bodyRotation === 0, "Expected body rotation of 0 degrees (5)");
		 724  877       })
		      878 +     .thenExecuteAfter(20, () => {
		      879 +       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees");
		 725      -     .thenExecuteAfter(5, () => {
		      880 +       test.assert(isNear(player.headRotation.pitch, 58.31), "Expected head pitch of ~58.31 degrees");
		      881 +       test.assert(player.headRotation.yaw === -90, "Expected head yaw of -90 degrees");
		 726      -       player.rotateBody(90);
		 727      -       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees (6)");
		 728  882       })
		      883 +     .thenExecuteAfter(10, () => {
		 729      -     .thenExecuteAfter(5, () => {
		 730      -       player.rotateBody(-180);
		      884 +       player.lookAtLocation(rightLoc);
		 731      -       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees (7)");
		 732  885       })
		      886 +     .thenExecuteAfter(20, () => {
		      887 +       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees");
		 733      -     .thenSucceed();
		 734      - })
		      888 +       test.assert(isNear(player.headRotation.pitch, 58.31), "Expected head pitch of ~58.31 degrees");
		      889 +       test.assert(player.headRotation.yaw === 90, "Expected head yaw of 90 degrees");
		      890 +     })
		      891 +     .thenSucceed();
		      892 + })
		      893 +   .structureName("ComponentTests:platform")
		      894 +   .tag(GameTest.Tags.suiteDefault);
		 735      -   .structureName("ComponentTests:platform")
		 736      -   .tag(GameTest.Tags.suiteDefault);
		 737      - 
		 738      - GameTest.register("SimulatedPlayerTests", "look_at_entity", (test) => {
		 739      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		 740      -   const leftArmorStand = test.spawn("armor_stand", new BlockLocation(2, 2, 1));
		 741      -   const rightArmorStand = test.spawn("armor_stand", new BlockLocation(0, 2, 1));
		 742  895   
		 743      -   test
		 744      -     .startSequence()
		 745      -     .thenExecuteAfter(5, () => {
		      896 + GameTest.register("SimulatedPlayerTests", "use_item_in_slot_on_block", (test) => {
		      897 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		      898 +   const wallLoc = new BlockLocation(1, 3, 2);
		      899 +   const slabLoc = new BlockLocation(1, 3, 1);
		      900 +   const woodenSlabSlot = 1;
		      901 +   const inventoryContainer = player.getComponent("inventory").container;
		      902 + 
		      903 +   test
		      904 +     .startSequence()
		      905 +     .thenExecuteAfter(5, () => {
		      906 +         player.setItem(new ItemStack(MinecraftItemTypes.crimsonSlab, 2), 0);
		      907 +         player.setItem(new ItemStack(MinecraftItemTypes.woodenSlab, 2), woodenSlabSlot);
		      908 +         player.setItem(new ItemStack(MinecraftItemTypes.warpedSlab, 2), 2);
		      909 +         test.assert(inventoryContainer.getItem(woodenSlabSlot).amount === 2, "Player should have 2 wooden slabs");
		      910 +     })
		      911 +     .thenExecuteAfter(10, () => {
		      912 +       player.useItemInSlotOnBlock(woodenSlabSlot, wallLoc, Direction.north, 0.5, 0.75); // place upper slab
		      913 +       test.assert(inventoryContainer.getItem(woodenSlabSlot).amount === 1, "Player should have 1 wooden slab");
		      914 +     })
		 746      -       player.lookAtEntity(leftArmorStand);
		 747      -       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees");
		 748      -     })
		 749      -     .thenExecuteAfter(5, () => {
		 750      -       player.lookAtEntity(rightArmorStand);
		 751      -       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees");
		 752      -     })
		 753      -     .thenSucceed();
		 754      - })
		 755      -   .structureName("ComponentTests:platform")
		 756      -   .tag(GameTest.Tags.suiteDefault);
		 757      - 
		 758      - GameTest.register("SimulatedPlayerTests", "look_at_block", (test) => {
		 759      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		 760      -   const leftBlockLoc = new BlockLocation(2, 2, 1);
		 761      -   const rightBlockLoc = new BlockLocation(0, 2, 1);
		 762      - 
		 763      -   test
		 764      -     .startSequence()
		 765  915       .thenExecuteAfter(10, () => {
		      916 +       player.useItemInSlotOnBlock(woodenSlabSlot, wallLoc, Direction.north, 0.5, 0.25); // place lower slab
		      917 +       test.assert(inventoryContainer.getItem(woodenSlabSlot) === undefined, "Player should have 0 wooden slabs");
		 766      -       test.assert(player.bodyRotation === 0, "Expected body rotation of 0 degrees");
		      918 +     })
		      919 +     .thenWait(() => {
		      920 +       test.assertBlockPresent(MinecraftBlockTypes.doubleWoodenSlab, slabLoc);
		 767      -       test.assert(player.headRotation.pitch === 0, "Expected head pitch of 0 degrees");
		 768      -       test.assert(player.headRotation.yaw === 0, "Expected head yaw of 0 degrees");
		 769      -       player.lookAtBlock(leftBlockLoc);
		 770  921       })
		      922 +     .thenSucceed();
		      923 + }).tag(GameTest.Tags.suiteDefault);
		 771      -     .thenExecuteAfter(20, () => {
		      924 + 
		      925 + GameTest.register("SimulatedPlayerTests", "use_item_on_block_2", (test) => {
		      926 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		      927 +   const wallLoc = new BlockLocation(1, 3, 2);
		      928 +   const slabLoc = new BlockLocation(1, 3, 1);
		      929 +   const woodenSlab = new ItemStack(MinecraftItemTypes.woodenSlab, 1);
		      930 + 
		      931 +   test
		      932 +     .startSequence()
		      933 +     .thenExecuteAfter(10, () => {
		      934 +       player.useItemOnBlock(woodenSlab, wallLoc, Direction.north, 0.5, 0.75); // place upper slab
		 772      -       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees");
		 773      -       test.assert(isNear(player.headRotation.pitch, 48.24), "Expected head pitch of ~48.24 degrees");
		 774      -       test.assert(player.headRotation.yaw === -90, "Expected head yaw of -90 degrees");
		 775      -     })
		 776      -     .thenExecuteAfter(10, () => {
		 777      -       player.lookAtBlock(rightBlockLoc);
		 778      -     })
		 779      -     .thenExecuteAfter(20, () => {
		 780      -       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees");
		 781      -       test.assert(isNear(player.headRotation.pitch, 48.24), "Expected head pitch of ~48.24 degrees");
		 782      -       test.assert(player.headRotation.yaw === 90, "Expected head yaw of 90 degrees");
		 783  935       })
		 784      -     .thenSucceed();
		 785      - })
		 786      -   .structureName("ComponentTests:platform")
		 787      -   .tag(GameTest.Tags.suiteDefault);
		      936 +     .thenExecuteAfter(10, () => {
		      937 +       player.useItemOnBlock(woodenSlab, wallLoc, Direction.north, 0.5, 0.25); // place lower slab
		      938 +     })
		      939 +     .thenWait(() => {
		      940 +       test.assertBlockPresent(MinecraftBlockTypes.doubleWoodenSlab, slabLoc);
		      941 +     })
		      942 +     .thenSucceed();
		      943 + })
		      944 +   .structureName("SimulatedPlayerTests:use_item_in_slot_on_block")
		      945 +   .tag(GameTest.Tags.suiteDefault);
		      946 + 
		      947 + GameTest.register("SimulatedPlayerTests", "interact", (test) => {
		      948 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		      949 +   const leverLoc = new BlockLocation(1, 3, 2);
		      950 +   const lampLoc = new BlockLocation(2, 2, 2);
		      951 + 
		      952 +   test
		      953 +     .startSequence()
		      954 +     .thenExecuteAfter(5, () => {
		      955 +       player.lookAtBlock(leverLoc);
		      956 +       player.interact();
		 788      - 
		 789      - GameTest.register("SimulatedPlayerTests", "look_at_location", (test) => {
		 790      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 1));
		 791      -   const leftLoc = new Location(2.5, 2, 1.5);
		 792      -   const rightLoc = new Location(0.5, 2, 1.5);
		 793      - 
		 794      -   test
		 795      -     .startSequence()
		 796      -     .thenExecuteAfter(10, () => {
		 797      -       test.assert(player.bodyRotation === 0, "Expected body rotation of 0 degrees");
		 798      -       test.assert(player.headRotation.pitch === 0, "Expected head pitch of 0 degrees");
		 799      -       test.assert(player.headRotation.yaw === 0, "Expected head yaw of 0 degrees");
		 800      -       player.lookAtLocation(leftLoc);
		 801      -     })
		 802      -     .thenExecuteAfter(20, () => {
		 803      -       test.assert(player.bodyRotation === -90, "Expected body rotation of -90 degrees");
		 804      -       test.assert(isNear(player.headRotation.pitch, 58.31), "Expected head pitch of ~58.31 degrees");
		 805      -       test.assert(player.headRotation.yaw === -90, "Expected head yaw of -90 degrees");
		 806      -     })
		 807      -     .thenExecuteAfter(10, () => {
		 808      -       player.lookAtLocation(rightLoc);
		 809  957       })
		      958 +     .thenWait(() => {
		 810      -     .thenExecuteAfter(20, () => {
		 811      -       test.assert(player.bodyRotation === 90, "Expected body rotation of 90 degrees");
		 812      -       test.assert(isNear(player.headRotation.pitch, 58.31), "Expected head pitch of ~58.31 degrees");
		      959 +       test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, lampLoc);
		 813      -       test.assert(player.headRotation.yaw === 90, "Expected head yaw of 90 degrees");
		 814  960       })
		 815  961       .thenSucceed();
		      962 + }).tag(GameTest.Tags.suiteDefault);
		 816      - })
		 817      -   .structureName("ComponentTests:platform")
		 818      -   .tag(GameTest.Tags.suiteDefault);
		 819  963   
		      964 + GameTest.register("SimulatedPlayerTests", "interact_with_block", (test) => {
		 820      - GameTest.register("SimulatedPlayerTests", "use_item_in_slot_on_block", (test) => {
		 821  965     const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		 822      -   const wallLoc = new BlockLocation(1, 3, 2);
		 823      -   const slabLoc = new BlockLocation(1, 3, 1);
		 824      -   const woodenSlabSlot = 1;
		      966 +   const leverLoc = new BlockLocation(1, 3, 2);
		      967 +   const lampLoc = new BlockLocation(2, 2, 2);
		 825      -   const inventoryContainer = player.getComponent("inventory").container;
		 826      -   const testEx = new GameTestExtensions(test);
		 827      - 
		 828  968   
		 829  969     test
		 830  970       .startSequence()
		 831  971       .thenExecuteAfter(5, () => {
		      972 +       player.interactWithBlock(leverLoc);
		      973 +     })
		 832      -       testEx.giveItem(player, MinecraftItemTypes.crimsonSlab, 2, 0);
		 833      -       testEx.giveItem(player, MinecraftItemTypes.woodenSlab, 2, woodenSlabSlot);
		      974 +     .thenWait(() => {
		      975 +       test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, lampLoc);
		 834      -       testEx.giveItem(player, MinecraftItemTypes.warpedSlab, 2, 2);
		 835      -       test.assert(inventoryContainer.getItem(woodenSlabSlot).amount === 2, "Player should have 2 wooden slabs");
		 836  976       })
		      977 +     .thenSucceed();
		      978 + })
		 837      -     .thenExecuteAfter(10, () => {
		      979 +   .structureName("SimulatedPlayerTests:interact")
		      980 +   .tag(GameTest.Tags.suiteDefault);
		 838      -       player.useItemInSlotOnBlock(woodenSlabSlot, wallLoc, Direction.north, 0.5, 0.75); // place upper slab
		 839      -       test.assert(inventoryContainer.getItem(woodenSlabSlot).amount === 1, "Player should have 1 wooden slab");
		 840      -     })
		      981 + 
		      982 + GameTest.register("SimulatedPlayerTests", "one_tick", (test) => {
		      983 +   for (let i = 0; i < 3; i++) {
		      984 +     test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		      985 +   }
		      986 +   test.succeedOnTick(1);
		      987 + })
		      988 +   .structureName("ComponentTests:platform")
		      989 +   .tag(GameTest.Tags.suiteDefault);
		 841      -     .thenExecuteAfter(10, () => {
		 842      -       player.useItemInSlotOnBlock(woodenSlabSlot, wallLoc, Direction.north, 0.5, 0.25); // place lower slab
		 843      -       test.assert(inventoryContainer.getItem(woodenSlabSlot) === undefined, "Player should have 0 wooden slabs");
		 844      -     })
		 845      -     .thenWait(() => {
		 846      -       test.assertBlockPresent(MinecraftBlockTypes.doubleWoodenSlab, slabLoc);
		 847      -     })
		 848      -     .thenSucceed();
		 849      - }).tag(GameTest.Tags.suiteDefault);
		 850  990   
		      991 + GameTest.register("SimulatedPlayerTests", "destroy_block_creative", (test) => {
		 851      - GameTest.register("SimulatedPlayerTests", "use_item_on_block_2", (test) => {
		 852      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		      992 +   const blockLoc = new BlockLocation(2, 2, 1);
		      993 +   const spawnLoc = new BlockLocation(2, 2, 3);
		      994 +   const playerName = "Simulated Player (Creative)";
		 853      -   const wallLoc = new BlockLocation(1, 3, 2);
		 854      -   const slabLoc = new BlockLocation(1, 3, 1);
		 855      -   const woodenSlab = new ItemStack(MinecraftItemTypes.woodenSlab, 1);
		 856  995   
		      996 +   let player = test.spawnSimulatedPlayer(spawnLoc, playerName);
		 857  997     test
		 858  998       .startSequence()
		 859      -     .thenExecuteAfter(10, () => {
		 860      -       player.useItemOnBlock(woodenSlab, wallLoc, Direction.north, 0.5, 0.75); // place upper slab
		 861      -     })
		      999 +     .thenExecuteAfter(5, () => {
		     1000 +       player.runCommand("gamemode creative");
		 862      -     .thenExecuteAfter(10, () => {
		 863      -       player.useItemOnBlock(woodenSlab, wallLoc, Direction.north, 0.5, 0.25); // place lower slab
		 864 1001       })
		     1002 +     .thenExecute(() => player.destroyBlock(blockLoc))
		     1003 +     .thenExecuteAfter(5, () => {
		 865      -     .thenWait(() => {
		     1004 +       test.assertBlockPresent(MinecraftBlockTypes.redstoneBlock, blockLoc, false);
		 866      -       test.assertBlockPresent(MinecraftBlockTypes.doubleWoodenSlab, slabLoc);
		 867 1005       })
		 868 1006       .thenSucceed();
		     1007 + }).tag(GameTest.Tags.suiteDefault);
		     1008 + 
		     1009 + GameTest.register("SimulatedPlayerTests", "sneaking", (test) => {
		     1010 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		     1011 +   const goalLoc = new BlockLocation(1, 2, 3);
		     1012 +   const healthComponent = player.getComponent("minecraft:health");
		 869      - })
		 870      -   .structureName("SimulatedPlayerTests:use_item_in_slot_on_block")
		 871      -   .tag(GameTest.Tags.suiteDefault);
		 872 1013   
		     1014 +   player.isSneaking = true;
		 873      - GameTest.register("SimulatedPlayerTests", "interact", (test) => {
		 874      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		 875      -   const leverLoc = new BlockLocation(1, 3, 2);
		     1015 +   player.moveToBlock(goalLoc);
		 876      -   const lampLoc = new BlockLocation(2, 2, 2);
		 877 1016   
		 878 1017     test
		 879 1018       .startSequence()
		 880      -     .thenExecuteAfter(5, () => {
		 881      -       player.lookAtBlock(leverLoc);
		 882      -       player.interact();
		 883      -     })
		     1019 +     .thenExecuteAfter(20, () => {
		     1020 +       test.assertEntityInstancePresent(player, goalLoc, false);
		 884      -     .thenWait(() => {
		 885      -       test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, lampLoc);
		 886 1021       })
		     1022 +     .thenExecuteAfter(60, () => {
		 887      -     .thenSucceed();
		 888      - }).tag(GameTest.Tags.suiteDefault);
		 889      - 
		     1023 +       test.assertEntityInstancePresent(player, goalLoc);
		     1024 +       test.assert(healthComponent.current === healthComponent.value, "Player should not be hurt");
		     1025 +     })
		     1026 +     .thenSucceed();
		 890      - GameTest.register("SimulatedPlayerTests", "interact_with_block", (test) => {
		 891      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		 892      -   const leverLoc = new BlockLocation(1, 3, 2);
		 893      -   const lampLoc = new BlockLocation(2, 2, 2);
		 894 1027   
		     1028 +   test.startSequence();
		 895      -   test
		 896      -     .startSequence()
		 897      -     .thenExecuteAfter(5, () => {
		     1029 + }).tag(GameTest.Tags.suiteDefault);
		 898      -       player.interactWithBlock(leverLoc);
		 899      -     })
		     1030 + 
		     1031 + GameTest.register("SimulatedPlayerTests", "move_to_block_slowly", (test) => {
		     1032 +   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		     1033 +   const goalLoc = new BlockLocation(1, 2, 3);
		     1034 +   const healthComponent = player.getComponent("minecraft:health");
		     1035 + 
		     1036 +   player.moveToBlock(goalLoc, 0.3);
		 900      -     .thenWait(() => {
		 901      -       test.assertBlockPresent(MinecraftBlockTypes.litRedstoneLamp, lampLoc);
		 902      -     })
		 903      -     .thenSucceed();
		 904      - })
		 905      -   .structureName("SimulatedPlayerTests:interact")
		 906      -   .tag(GameTest.Tags.suiteDefault);
		 907 1037   
		 908      - GameTest.register("SimulatedPlayerTests", "one_tick", (test) => {
		 909      -   for (let i = 0; i < 3; i++) {
		 910      -     test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		 911      -   }
		     1038 +   test
		     1039 +     .startSequence()
		     1040 +     .thenExecuteAfter(20, () => {
		     1041 +       test.assertEntityInstancePresent(player, goalLoc, false);
		     1042 +     })
		     1043 +     .thenExecuteAfter(60, () => {
		     1044 +       test.assertEntityInstancePresent(player, goalLoc);
		     1045 +       test.assert(healthComponent.current !== healthComponent.value, "Player should be hurt");
		     1046 +     })
		     1047 +     .thenSucceed();
		 912      -   test.succeedOnTick(1);
		 913      - })
		 914      -   .structureName("ComponentTests:platform")
		 915      -   .tag(GameTest.Tags.suiteDefault);
		 916      - 
		 917      - GameTest.register("SimulatedPlayerTests", "destroy_block_creative", (test) => {
		 918      -   const blockLoc = new BlockLocation(2, 2, 1);
		 919      -   const spawnLoc = new BlockLocation(2, 2, 3);
		 920      -   const playerName = "Simulated Player (Creative)";
		 921      -   const overworld = World.getDimension("overworld");
		 922 1048   
		 923      -   let player = test.spawnSimulatedPlayer(spawnLoc, playerName);
		 924      -   test
		 925      -     .startSequence()
		     1049 +   test.startSequence();
		     1050 + })
		     1051 +   .structureName("SimulatedPlayerTests:sneaking")
		     1052 +   .tag(GameTest.Tags.suiteDefault);
		     1053 + 
		     1054 + GameTest.register("SimulatedPlayerTests", "player_join_leave_events", async (test) => {
		     1055 +     const thePlayerName = "Gary_The_Duck_411";
		 926      -     .thenExecuteAfter(5, () => Commands.run(`/gamemode creative "${playerName}"`, overworld))
		 927      -     .thenExecute(() => player.destroyBlock(blockLoc))
		 928      -     .thenExecuteAfter(5, () => {
		 929      -       test.assertBlockPresent(MinecraftBlockTypes.redstoneBlock, blockLoc, false);
		 930      -     })
		 931      -     .thenSucceed();
		 932      - }).tag(GameTest.Tags.suiteDefault);
		 933 1056   
		     1057 +     let expectedPlayerJoined = false;
		     1058 +     const playerJoinCallback = world.events.playerJoin.subscribe((e) => {
		 934      - GameTest.register("SimulatedPlayerTests", "sneaking", (test) => {
		 935      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		     1059 +       if (e.player.name == thePlayerName) {
		     1060 +         expectedPlayerJoined = true;
		 936      -   const goalLoc = new BlockLocation(1, 2, 3);
		 937      -   const healthComponent = player.getComponent("minecraft:health");
		 938      - 
		     1061 +       }
		     1062 +     });
		 939      -   player.isSneaking = true;
		 940      -   player.moveToBlock(goalLoc);
		 941 1063   
		 942      -   test
		 943      -     .startSequence()
		 944      -     .thenExecuteAfter(20, () => {
		 945      -       test.assertEntityInstancePresent(player, goalLoc, false);
		     1064 +     let expectedPlayerLeft = false;
		     1065 +     const playerLeaveCallback = world.events.playerLeave.subscribe((e) => {
		     1066 +       if (e.playerName == thePlayerName) {
		     1067 +         expectedPlayerLeft = true;
		     1068 +       }
		     1069 +     });
		 946      -     })
		 947      -     .thenExecuteAfter(60, () => {
		 948      -       test.assertEntityInstancePresent(player, goalLoc);
		 949      -       test.assert(healthComponent.current === healthComponent.value, "Player should not be hurt");
		 950      -     })
		 951      -     .thenSucceed();
		 952 1070   
		     1071 +     let simPlayer = test.spawnSimulatedPlayer(new BlockLocation(0, 2, 0), thePlayerName);
		     1072 +     await test.idle(1);
		 953      -   test.startSequence();
		 954      - }).tag(GameTest.Tags.suiteDefault);
		 955 1073   
		     1074 +     if (!expectedPlayerJoined) {
		 956      - GameTest.register("SimulatedPlayerTests", "move_to_block_slowly", (test) => {
		 957      -   const player = test.spawnSimulatedPlayer(new BlockLocation(1, 2, 0));
		     1075 +       test.fail("Expected playerJoin event");
		     1076 +     }
		 958      -   const goalLoc = new BlockLocation(1, 2, 3);
		 959      -   const healthComponent = player.getComponent("minecraft:health");
		 960 1077   
		     1078 +     test.removeSimulatedPlayer(simPlayer);
		     1079 +     await test.idle(1);
		 961      -   player.moveToBlock(goalLoc, 0.3);
		 962 1080   
		 963      -   test
		 964      -     .startSequence()
		 965      -     .thenExecuteAfter(20, () => {
		 966      -       test.assertEntityInstancePresent(player, goalLoc, false);
		     1081 +     if (!expectedPlayerLeft) {
		     1082 +       test.fail("Expected playerLeave event");
		     1083 +     }
		     1084 + 
		     1085 +     world.events.playerJoin.unsubscribe(playerJoinCallback);
		     1086 +     world.events.playerLeave.unsubscribe(playerLeaveCallback);
		 967      -     })
		 968      -     .thenExecuteAfter(60, () => {
		 969      -       test.assertEntityInstancePresent(player, goalLoc);
		 970      -       test.assert(healthComponent.current !== healthComponent.value, "Player should be hurt");
		 971      -     })
		 972      -     .thenSucceed();
		 973 1087   
		     1088 +     test.succeed();
		     1089 +  })
		 974      -   test.startSequence();
		 975      - })
		     1090 +   .structureName("ComponentTests:platform")
		 976      -   .structureName("SimulatedPlayerTests:sneaking")
		 977 1091     .tag(GameTest.Tags.suiteDefault);
		            '''