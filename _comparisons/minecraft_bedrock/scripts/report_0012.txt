Difference of "scripts" between "1.17.11" and "1.17.20.20" (beta of "1.17.30").

Changed behavior pack "vanilla_gametest":
	Total script: 21 (+2, -0)
	Changed script "APITests.js":
		Total line: 673 (+393, -75)
		          '''
		  1   1   import * as GameTest from "GameTest";
		      2 + import {
		      3 +   BlockLocation,
		      4 +   BlockTypes,
		      5 +   Direction,
		      6 +   ExplosionOptions,
		      7 +   Effects,
		      8 +   Items,
		      9 +   ItemStack,
		     10 +   Location,
		     11 +   World,
		     12 + } from "Minecraft";
		     13 + 
		     14 + GameTest.register("APITests", "on_entity_created", (test) => {
		     15 +   const entityCreatedCallback = World.events.createEntity.subscribe((entity) => {
		     16 +     if (entity) {
		     17 +       test.succeed();
		     18 +     } else {
		     19 +       test.fail("Expected entity");
		     20 +     }
		     21 +   });
		     22 +   test.spawn("minecraft:horse<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		     23 +   World.events.createEntity.unsubscribe(entityCreatedCallback);
		     24 + })
		     25 +   .structureName("ComponentTests:animal_pen")
		     26 +   .tag(GameTest.Tags.suiteDefault);
		     27 + 
		     28 + GameTest.register("APITests", "assert_is_waterlogged", (test) => {
		     29 +   const waterChestLoc = new BlockLocation(5, 2, 1);
		     30 +   const waterLoc = new BlockLocation(4, 2, 1);
		     31 +   const chestLoc = new BlockLocation(2, 2, 1);
		     32 +   const airLoc = new BlockLocation(1, 2, 1);
		     33 + 
		     34 +   test.assertIsWaterlogged(waterChestLoc, true);
		     35 +   test.assertIsWaterlogged(waterLoc, false);
		     36 +   test.assertIsWaterlogged(chestLoc, false);
		     37 +   test.assertIsWaterlogged(airLoc, false);
		     38 +   test.succeed();
		     39 + }).tag(GameTest.Tags.suiteDefault);
		     40 + 
		     41 + GameTest.register("APITests", "assert_redstone_power", (test) => {
		     42 +   const redstoneBlockLoc = new BlockLocation(3, 2, 1);
		     43 +   const redstoneTorchLoc = new BlockLocation(2, 2, 1);
		     44 +   const poweredLampLoc = new BlockLocation(1, 2, 1);
		     45 +   const unpoweredLampLoc = new BlockLocation(0, 2, 1);
		     46 +   const airLoc = new BlockLocation(3, 2, 0);
		     47 +   const redstoneWireLoc = new BlockLocation(0, 1, 0);
		     48 + 
		     49 +   test.succeedWhen(() => {
		     50 +     test.assertRedstonePower(redstoneBlockLoc, 15);
		     51 +     test.assertRedstonePower(redstoneTorchLoc, 15);
		     52 +     test.assertRedstonePower(poweredLampLoc, 15);
		     53 +     test.assertRedstonePower(unpoweredLampLoc, 0);
		     54 +     test.assertRedstonePower(airLoc, -1);
		     55 +     test.assertRedstonePower(redstoneWireLoc, 13); // 3 length wire
		     56 +   });
		     57 + })
		     58 +   .maxTicks(20)
		     59 +   .tag(GameTest.Tags.suiteDefault);
		     60 + 
		     61 + GameTest.register("APITests", "spawn_item", (test) => {
		     62 +   const featherItem = new ItemStack(Items.feather, 1, 0);
		     63 +   test.spawnItem(featherItem, new Location(1.5, 3.5, 1.5));
		     64 +   test.succeedWhen(() => {
		     65 +     test.assertEntityPresent("minecraft:item", new BlockLocation(1, 2, 1));
		     66 +   });
		     67 + }).tag(GameTest.Tags.suiteDefault);
		     68 + 
		     69 + GameTest.register("APITests", "assert_entity_data", (test) => {
		     70 +   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		     71 +   const pigLoc = new BlockLocation(1, 2, 1);
		     72 +   test.spawn(pigId, pigLoc);
		     73 +   test.succeedWhen(() => {
		     74 +     test.assertEntityData(pigLoc, pigId, (entity) => entity.id !== undefined);
		     75 +   });
		     76 + })
		     77 +   .structureName("ComponentTests:animal_pen")
		     78 +   .tag(GameTest.Tags.suiteDefault);
		     79 + 
		     80 + GameTest.register("APITests", "add_effect", (test) => {
		     81 +   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		     82 +   const villagerLoc = new BlockLocation(1, 2, 1);
		     83 +   const villager = test.spawn(villagerId, villagerLoc);
		     84 +   const duration = 20;
		     85 +   villager.addEffect(Effects.poison, duration, 1);
		     86 + 
		     87 +   test.assertEntityData(villagerLoc, villagerId, (entity) => entity.getEffect(Effects.poison).duration == duration);
		     88 +   test.assertEntityData(villagerLoc, villagerId, (entity) => entity.getEffect(Effects.poison).amplifier == 1);
		     89 + 
		     90 +   test.runAfterDelay(duration, () => {
		     91 +     test.assertEntityData(villagerLoc, villagerId, (entity) => entity.getEffect(Effects.poison) === undefined);
		     92 +     test.succeed();
		     93 +   });
		     94 + })
		     95 +   .structureName("ComponentTests:animal_pen")
		     96 +   .tag(GameTest.Tags.suiteDefault);
		     97 + 
		     98 + GameTest.register("APITests", "assert_entity_present", (test) => {
		     99 +   const villagerId = "minecraft:villager_v2";
		    100 +   const villagerLoc = new BlockLocation(1, 2, 3);
		    101 +   const emeraldItem = new ItemStack(Items.emerald, 1, 0);
		    102 +   const emeraldItemLoc = new BlockLocation(3, 2, 3);
		    103 +   const minecartId = "minecraft:minecart";
		    104 +   const minecartLoc = new BlockLocation(3, 2, 1);
		    105 +   const armorStandId = "minecraft:armor_stand";
		    106 +   const armorStandLoc = new BlockLocation(1, 2, 1);
		    107 + 
		    108 +   test.spawn(villagerId, villagerLoc);
		    109 +   test.spawnItem(emeraldItem, new Location(3.5, 4.5, 3.5));
		    110 + 
		    111 +   test.succeedWhen(() => {
		    112 +     test.assertEntityPresent(villagerId, villagerLoc);
		    113 +     test.assertItemEntityPresent(Items.emerald, emeraldItemLoc, 0);
		    114 +     test.assertEntityPresent(armorStandId, armorStandLoc);
		    115 + 
		    116 +     // Check all blocks surrounding the minecart
		    117 +     for (let x = -1; x <= 1; x++) {
		    118 +       for (let z = -1; z <= 1; z++) {
		    119 +         let offsetLoc = new BlockLocation(minecartLoc.x + x, minecartLoc.y, minecartLoc.z + z);
		    120 +         if (x == 0 && z == 0) {
		    121 +           test.assertEntityPresent(minecartId, offsetLoc);
		    122 +         } else {
		    123 +           test.assertEntityNotPresent(minecartId, offsetLoc);
		    124 +         }
		    125 +       }
		    126 +     }
		    127 +   });
		    128 + }).tag(GameTest.Tags.suiteDefault);
		    129 + 
		    130 + GameTest.register("APITests", "assert_entity_not_present", (test) => {
		    131 +   const armorStandId = "minecraft:armor_stand";
		    132 +   const pigId = "minecraft:pig";
		    133 +   const armorStandLoc = new BlockLocation(1, 2, 1);
		    134 +   const airLoc = new BlockLocation(0, 2, 1);
		    135 + 
		    136 +   try {
		    137 +     test.assertEntityNotPresentInArea(armorStandId);
		    138 +     test.fail(); // this assert should throw
		    139 +   } catch (e) {}
		    140 + 
		    141 +   try {
		    142 +     test.assertEntityNotPresent(armorStandId, armorStandLoc);
		    143 +     test.fail(); // this assert should throw
		    144 +   } catch (e) {}
		    145 + 
		    146 +   test.assertEntityNotPresent(armorStandId, airLoc);
		    147 +   test.assertEntityNotPresentInArea(pigId);
		    148 + 
		    149 +   test.succeed();
		    150 + })
		    151 +   .structureName("APITests:armor_stand")
		    152 +   .tag(GameTest.Tags.suiteDefault);
		    153 + 
		    154 + GameTest.register("APITests", "assert_item_entity_count_is", (test) => {
		    155 +   let oneItemLoc = new BlockLocation(3, 2, 1);
		    156 +   let fiveItemsLoc = new BlockLocation(1, 2, 1);
		    157 +   let noItemsLoc = new BlockLocation(2, 2, 1);
		    158 +   let diamondPickaxeLoc = new BlockLocation(2, 2, 4);
		    159 + 
		    160 +   const oneEmerald = new ItemStack(Items.emerald, 1, 0);
		    161 +   const onePickaxe = new ItemStack(Items.diamondPickaxe, 1, 0);
		    162 +   const fiveEmeralds = new ItemStack(Items.emerald, 5, 0);
		    163 + 
		    164 +   test.spawnItem(oneEmerald, new Location(3.5, 3, 1.5));
		    165 +   test.spawnItem(fiveEmeralds, new Location(1.5, 3, 1.5));
		    166 + 
		    167 +   // spawn 9 pickaxes in a 3x3 grid
		    168 +   for (let x = 1.5; x <= 3.5; x++) {
		    169 +     for (let z = 3.5; z <= 5.5; z++) {
		    170 +       test.spawnItem(onePickaxe, new Location(x, 3, z));
		    171 +     }
		    172 +   }
		    173 + 
		    174 +   test.assertItemEntityCountIs(Items.emerald, noItemsLoc, 0, 0);
		    175 + 
		    176 +   test.succeedWhen(() => {
		    177 +     test.assertItemEntityCountIs(Items.feather, oneItemLoc, 0, 0);
		    178 +     test.assertItemEntityCountIs(Items.emerald, oneItemLoc, 0, 1);
		    179 +     test.assertItemEntityCountIs(Items.feather, fiveItemsLoc, 0, 0);
		    180 +     test.assertItemEntityCountIs(Items.emerald, fiveItemsLoc, 0, 5);
		    181 +     test.assertItemEntityCountIs(Items.emerald, fiveItemsLoc, 0, 5);
		    182 +     test.assertItemEntityCountIs(Items.diamondPickaxe, diamondPickaxeLoc, 1, 9);
		    183 +     test.assertItemEntityCountIs(Items.diamondPickaxe, diamondPickaxeLoc, 0, 1);
		    184 +   });
		    185 + }).tag(GameTest.Tags.suiteDefault);
		    186 + 
		    187 + GameTest.register("APITests", "assert_entity_touching", (test) => {
		    188 +   const armorStandId = "minecraft:armor_stand";
		    189 + 
		    190 +   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.5));
		    191 +   test.assertEntityTouching(armorStandId, new Location(1.5, 3.5, 1.5));
		    192 +   test.assertEntityNotTouching(armorStandId, new Location(1.0, 2.5, 1.5));
		    193 +   test.assertEntityNotTouching(armorStandId, new Location(2.0, 2.5, 1.5));
		    194 +   test.assertEntityNotTouching(armorStandId, new Location(1.5, 2.5, 1.0));
		    195 +   test.assertEntityNotTouching(armorStandId, new Location(1.5, 2.5, 2.0));
		    196 + 
		    197 +   test.succeed();
		    198 + })
		    199 +   .structureName("APITests:armor_stand")
		    200 +   .tag(GameTest.Tags.suiteDefault);
		    201 + 
		    202 + GameTest.register("APITests", "pulse_redstone", (test) => {
		    203 +   const pulseLoc = new BlockLocation(1, 2, 2);
		    204 +   const lampLoc = new BlockLocation(1, 2, 1);
		    205 +   test.assertRedstonePower(lampLoc, 0);
		    206 +   test.pulseRedstone(pulseLoc, 2);
		    207 + 
		    208 +   test
		    209 +     .startSequence()
		    210 +     .thenIdle(2)
		    211 +     .thenExecute(() => test.assertRedstonePower(lampLoc, 15))
		    212 +     .thenIdle(1)
		    213 +     .thenExecute(() => test.assertRedstonePower(lampLoc, 0))
		    214 +     .thenSucceed();
		    215 + }).tag(GameTest.Tags.suiteDefault);
		    216 + 
		    217 + GameTest.register("APITests", "location", (test) => {
		    218 +   let testLoc = new BlockLocation(1, 1, 1);
		    219 +   let worldLoc = test.worldLocation(testLoc);
		    220 +   let relativeLoc = test.relativeLocation(worldLoc);
		    221 +   test.assert(!relativeLoc.equals(worldLoc), "Expected relativeLoc and worldLoc to be different");
		    222 +   test.assert(relativeLoc.equals(testLoc), "Expected relativeLoc to match testLoc");
		    223 +   test.succeed();
		    224 + })
		    225 +   .structureName("ComponentTests:platform")
		    226 +   .tag(GameTest.Tags.suiteDefault);
		    227 + 
		    228 + GameTest.register("APITests", "create_explosion_basic", (test) => {
		    229 +   let overworld = World.getDimension("overworld");
		    230 +   const center = new BlockLocation(2, 3, 2);
		    231 + 
		    232 +   test.assertBlockTypePresent(BlockTypes.cobblestone, center);
		    233 + 
		    234 +   const loc = test.worldLocation(center);
		    235 +   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		    236 +   overworld.createExplosion(explosionLoc, 10, new ExplosionOptions());
		    237 + 
		    238 +   for (let x = 1; x <= 3; x++) {
		    239 +     for (let y = 2; y <= 4; y++) {
		    240 +       for (let z = 1; z <= 3; z++) {
		    241 +         test.assertBlockTypeNotPresent(BlockTypes.cobblestone, new BlockLocation(x, y, z));
		    242 +       }
		    243 +     }
		    244 +   }
		    245 + 
		    246 +   test.succeed();
		    247 + })
		    248 +   .padding(10) // The blast can destroy nearby items and mobs
		    249 +   .tag(GameTest.Tags.suiteDefault);
		    250 + 
		    251 + GameTest.register("APITests", "create_explosion_advanced", (test) => {
		    252 +   let overworld = World.getDimension("overworld");
		    253 +   const center = new BlockLocation(3, 3, 3);
		    254 + 
		    255 +   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		    256 +   const pigLoc = new BlockLocation(3, 4, 3);
		    257 +   test.spawn(pigId, pigLoc);
		    258 + 
		    259 +   const loc = test.worldLocation(center);
		    260 +   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		    261 +   let explosionOptions = new ExplosionOptions();
		    262 + 
		    263 +   test.assertBlockTypePresent(BlockTypes.cobblestone, center);
		    264 + 
		    265 +   // Start by exploding without breaking blocks
		    266 +   explosionOptions.breaksBlocks = false;
		    267 +   const creeper = test.spawn("minecraft:creeper", new BlockLocation(1, 2, 1));
		    268 +   explosionOptions.source = creeper;
		    269 +   test.assertEntityPresent(pigId, pigLoc);
		    270 +   overworld.createExplosion(explosionLoc, 10, explosionOptions);
		    271 +   creeper.kill();
		    272 +   test.assertEntityNotPresent(pigId, pigLoc);
		    273 +   test.assertBlockTypePresent(BlockTypes.cobblestone, center);
		    274 + 
		    275 +   // Next, explode with fire
		    276 +   explosionOptions = new ExplosionOptions();
		    277 +   explosionOptions.causesFire = true;
		    278 + 
		    279 +   let findFire = () => {
		    280 +     let foundFire = false;
		    281 +     for (let x = 0; x <= 6; x++) {
		    282 +       for (let z = 0; z <= 6; z++) {
		    283 +         try {
		    284 +           test.assertBlockTypePresent(BlockTypes.fire, new BlockLocation(x, 3, z));
		    285 +           foundFire = true;
		    286 +           break;
		    287 +         } catch (e) {}
		    288 +       }
		    289 +     }
		    290 +     return foundFire;
		    291 +   };
		    292 + 
		    293 +   test.assert(!findFire(), "Unexpected fire");
		    294 +   overworld.createExplosion(explosionLoc, 15, explosionOptions);
		    295 +   test.assertBlockTypeNotPresent(BlockTypes.cobblestone, center);
		    296 +   test.assert(findFire(), "No fire found");
		    297 + 
		    298 +   // Finally, explode in water
		    299 +   explosionOptions.allowUnderwater = true;
		    300 +   const belowWaterLoc = new BlockLocation(3, 1, 3);
		    301 +   test.assertBlockTypeNotPresent(BlockTypes.air, belowWaterLoc);
		    302 +   overworld.createExplosion(explosionLoc, 10, explosionOptions);
		    303 +   test.assertBlockTypePresent(BlockTypes.air, belowWaterLoc);
		    304 +   test.succeed();
		    305 + })
		    306 +   .padding(10) // The blast can destroy nearby items and mobs
		    307 +   .tag(GameTest.Tags.suiteDefault);
		    308 + 
		    309 + GameTest.register("APITests", "triggerEvent", (test) => {
		    310 +   const creeper = test.spawn("creeper", new BlockLocation(1, 2, 1));
		    311 +   creeper.triggerEvent("minecraft:start_exploding_forced");
		    312 + 
		    313 +   test.succeedWhen(() => {
		    314 +     test.assertEntityNotPresentInArea("creeper");
		    315 +   });
		    316 + })
		    317 +   .structureName("ComponentTests:glass_cage")
		    318 +   .tag(GameTest.Tags.suiteDefault);
		    319 + 
		    320 + GameTest.register("APITests", "chat", (test) => {
		    321 +   test.print("subscribing");
		    322 + 
		    323 +   const chatCallback = World.events.beforeChat.subscribe((eventData) => {
		    324 +     if (eventData.message === "!killme") {
		    325 +       eventData.sender.kill();
		    326 +       eventData.cancel = true;
		    327 +     } else if (eventData.message === "!players") {
		    328 +       test.print(`There are ${eventData.targets.length} players in the server.`);
		    329 +       for (const target of eventData.targets) {
		    330 +         test.print("Player: " + target.name);
		    331 +       }
		    332 +     } else {
		    333 +       eventData.message = `Modified '${eventData.message}'`;
		    334 +     }
		    335 +   });
		  2     - import { BlockLocation, BlockTypes, ExplosionOptions, Effects, Items, ItemStack, Location, World } from "Minecraft";
		  3 336   
		    337 +   test
		  4     - GameTest.register("APITests", "on_entity_created", (test) => {
		  5     -   const entityCreatedCallback = World.events.createEntity.subscribe((entity) => {
		  6     -     if (entity) {
		    338 +     .startSequence()
		    339 +     .thenIdle(200)
		    340 +     .thenExecute(() => {
		    341 +       World.events.beforeChat.unsubscribe(chatCallback);
		    342 +       test.print("unsubscribed");
		    343 +     })
		    344 +     .thenSucceed();
		  7     -       test.succeed();
		  8     -     } else {
		  9     -       test.fail("Expected entity");
		 10     -     }
		 11     -   });
		 12     -   test.spawn("minecraft:horse<minecraft:ageable_grow_up>", new BlockLocation(1, 2, 1));
		 13     -   World.events.createEntity.unsubscribe(entityCreatedCallback);
		 14 345   })
		    346 +   .structureName("ComponentTests:platform")
		    347 +   .maxTicks(1000)
		 15     -   .structureName("ComponentTests:animal_pen")
		    348 +   .tag(GameTest.Tags.suiteDisabled);
		 16     -   .tag(GameTest.Tags.suiteDefault);
		 17 349   
		    350 + GameTest.register("APITests", "add_effect_event", (test) => {
		 18     - GameTest.register("APITests", "assert_is_waterlogged", (test) => {
		 19     -   const waterChestLoc = new BlockLocation(5, 2, 1);
		 20     -   const waterLoc = new BlockLocation(4, 2, 1);
		    351 +   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		    352 +   const villager = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		 21     -   const chestLoc = new BlockLocation(2, 2, 1);
		 22     -   const airLoc = new BlockLocation(1, 2, 1);
		 23 353   
		    354 +   const addEffectCallback = World.events.addEffect.subscribe((eventData) => {
		    355 +     test.assert(eventData.entity.id === "minecraft:villager_v2", "Unexpected id");
		 24     -   test.assertIsWaterlogged(waterChestLoc, true);
		 25     -   test.assertIsWaterlogged(waterLoc, false);
		    356 +     test.assert(eventData.effect.displayName === "Poison II", "Unexpected display name");
		    357 +     test.assert(eventData.effectState === 1, "Unexpected effect state");
		    358 +     test.succeed();
		    359 +   });
		 26     -   test.assertIsWaterlogged(chestLoc, false);
		 27     -   test.assertIsWaterlogged(airLoc, false);
		 28     -   test.succeed();
		 29     - }).tag(GameTest.Tags.suiteDefault);
		 30 360   
		    361 +   villager.addEffect(Effects.poison, 5, 1);
		 31     - GameTest.register("APITests", "assert_redstone_power", (test) => {
		 32     -   const redstoneBlockLoc = new BlockLocation(3, 2, 1);
		 33     -   const redstoneTorchLoc = new BlockLocation(2, 2, 1);
		    362 +   World.events.beforeChat.unsubscribe(addEffectCallback);
		    363 + })
		    364 +   .structureName("ComponentTests:animal_pen")
		    365 +   .tag(GameTest.Tags.suiteDefault);
		 34     -   const poweredLampLoc = new BlockLocation(1, 2, 1);
		 35     -   const unpoweredLampLoc = new BlockLocation(0, 2, 1);
		 36     -   const airLoc = new BlockLocation(3, 2, 0);
		 37     -   const redstoneWireLoc = new BlockLocation(0, 1, 0);
		 38 366   
		 39     -   test.succeedWhen(() => {
		 40     -     test.assertRedstonePower(redstoneBlockLoc, 15);
		 41     -     test.assertRedstonePower(redstoneTorchLoc, 15);
		 42     -     test.assertRedstonePower(poweredLampLoc, 15);
		    367 + GameTest.register("APITests", "piston", (test) => {
		    368 +   const overworld = World.getDimension("overworld");
		    369 +   const pistonLoc = new BlockLocation(1, 2, 1);
		    370 +   const redstoneLoc = new BlockLocation(1, 2, 0);
		    371 +   const pistonComp = overworld.getBlock(test.worldLocation(pistonLoc)).getComponent("piston");
		    372 + 
		    373 +   test.assert(pistonComp != undefined, "Expected piston component");
		 43     -     test.assertRedstonePower(unpoweredLampLoc, 0);
		 44     -     test.assertRedstonePower(airLoc, -1);
		 45     -     test.assertRedstonePower(redstoneWireLoc, 13); // 3 length wire
		 46     -   });
		 47     - })
		 48     -   .maxTicks(20)
		 49     -   .tag(GameTest.Tags.suiteDefault);
		 50 374   
		    375 +   let assertPistonState = (isMoving, isExpanded, isExpanding, isRetracted, isRetracting) => {
		    376 +     test.assert(pistonComp.isMoving === isMoving, "Unexpected isMoving");
		 51     - GameTest.register("APITests", "spawn_item", (test) => {
		 52     -   const featherItem = new ItemStack(Items.feather, 1, 0);
		    377 +     test.assert(pistonComp.isExpanded === isExpanded, "Unexpected isExpanded");
		    378 +     test.assert(pistonComp.isExpanding === isExpanding, "Unexpected isExpanding");
		    379 +     test.assert(pistonComp.isRetracted === isRetracted, "Unexpected isRetracted");
		    380 +     test.assert(pistonComp.isRetracting === isRetracting, "Unexpected isRetracting");
		    381 +   };
		 53     -   test.spawnItem(featherItem, new Location(1.5, 3.5, 1.5));
		 54     -   test.succeedWhen(() => {
		 55     -     test.assertEntityPresent("minecraft:item", new BlockLocation(1, 2, 1));
		 56     -   });
		 57     - }).tag(GameTest.Tags.suiteDefault);
		 58 382   
		    383 +   test
		 59     - GameTest.register("APITests", "assert_entity_data", (test) => {
		 60     -   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		 61     -   const pigLoc = new BlockLocation(1, 2, 1);
		    384 +     .startSequence()
		    385 +     .thenExecute(() => {
		    386 +       test.assert(pistonComp.attachedBlocks.length === 0, "Expected 0 attached blocks");
		    387 +       assertPistonState(false, false, false, true, false); // isRetracted
		    388 +       test.setBlockType(BlockTypes.redstoneBlock, redstoneLoc);
		    389 +     })
		    390 +     .thenIdle(4)
		    391 +     .thenExecute(() => {
		    392 +       test.assert(pistonComp.attachedBlocks.length === 3, "Expected 3 attached blocks");
		    393 +       assertPistonState(true, false, true, false, false); // isMoving, isExpanding
		    394 +     })
		    395 +     .thenIdle(2)
		    396 +     .thenExecute(() => {
		    397 +       assertPistonState(false, true, false, false, false); // isExpanded
		 62     -   test.spawn(pigId, pigLoc);
		 63     -   test.succeedWhen(() => {
		 64     -     test.assertEntityData(pigLoc, pigId, (entity) => entity.id !== undefined);
		 65     -   });
		 66     - })
		 67     -   .structureName("ComponentTests:animal_pen")
		 68     -   .tag(GameTest.Tags.suiteDefault);
		 69     - 
		 70     - GameTest.register("APITests", "add_effect", (test) => {
		 71     -   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		 72     -   const villagerLoc = new BlockLocation(1, 2, 1);
		 73     -   const villager = test.spawn(villagerId, villagerLoc);
		 74     -   const duration = 20;
		 75     -   villager.addEffect(Effects.poison, duration, 1);
		 76 398   
		    399 +       test.setBlockType(BlockTypes.air, redstoneLoc);
		    400 +     })
		    401 +     .thenIdle(4)
		 77     -   test.assertEntityData(villagerLoc, villagerId, (entity) => entity.getEffect(Effects.poison).duration == duration);
		    402 +     .thenExecute(() => {
		    403 +       assertPistonState(true, false, false, false, true); // isMoving, isRetracting
		    404 +     })
		    405 +     .thenIdle(2)
		    406 +     .thenExecute(() => {
		    407 +       assertPistonState(false, false, false, true, false); // isRetracted
		    408 +     })
		    409 +     .thenSucceed();
		    410 + }).tag(GameTest.Tags.suiteDefault);
		 78     -   test.assertEntityData(villagerLoc, villagerId, (entity) => entity.getEffect(Effects.poison).amplifier == 1);
		 79     - 
		 80     -   test.runAfterDelay(duration, () => {
		 81     -     test.assertEntityData(villagerLoc, villagerId, (entity) => entity.getEffect(Effects.poison) === undefined);
		 82     -     test.succeed();
		 83     -   });
		 84     - })
		 85     -   .structureName("ComponentTests:animal_pen")
		 86     -   .tag(GameTest.Tags.suiteDefault);
		 87 411   
		 88     - GameTest.register("APITests", "assert_entity_present", (test) => {
		 89     -   const villagerId = "minecraft:villager_v2";
		 90     -   const villagerLoc = new BlockLocation(1, 2, 3);
		    412 + GameTest.register("APITests", "piston_event", (test) => {
		    413 +   let expanded = false;
		    414 +   let retracted = false;
		    415 +   const redstoneLoc = new BlockLocation(1, 2, 0);
		    416 +   const pistonLoc = new BlockLocation(1, 2, 1);
		    417 +   const planksLoc = new BlockLocation(2, 2, 1);
		 91     -   const emeraldItem = new ItemStack(Items.emerald, 1, 0);
		 92     -   const emeraldItemLoc = new BlockLocation(3, 2, 3);
		 93     -   const minecartId = "minecraft:minecart";
		 94     -   const minecartLoc = new BlockLocation(3, 2, 1);
		 95     -   const armorStandId = "minecraft:armor_stand";
		 96     -   const armorStandLoc = new BlockLocation(1, 2, 1);
		 97 418   
		    419 +   const pistonCallback = World.events.activatePiston.subscribe((pistonEvent) => {
		    420 +     test.assert(pistonEvent.piston !== undefined, "Expected piston");
		    421 +     if (pistonEvent.piston.location.equals(test.worldLocation(pistonLoc))) {
		    422 +       if (pistonEvent.isExpanding) {
		    423 +         expanded = true;
		    424 +       } else {
		    425 +         retracted = true;
		    426 +       }
		    427 +     }
		    428 +   });
		 98     -   test.spawn(villagerId, villagerLoc);
		 99     -   test.spawnItem(emeraldItem, new Location(3.5, 4.5, 3.5));
		100     - 
		101     -   test.succeedWhen(() => {
		102     -     test.assertEntityPresent(villagerId, villagerLoc);
		103     -     test.assertItemEntityPresent(Items.emerald, emeraldItemLoc, 0);
		104     -     test.assertEntityPresent(armorStandId, armorStandLoc);
		105 429   
		106     -     // Check all blocks surrounding the minecart
		107     -     for (let x = -1; x <= 1; x++) {
		108     -       for (let z = -1; z <= 1; z++) {
		109     -         let offsetLoc = new BlockLocation(minecartLoc.x + x, minecartLoc.y, minecartLoc.z + z);
		    430 +   test
		    431 +     .startSequence()
		    432 +     .thenExecute(() => {
		    433 +       test.pulseRedstone(redstoneLoc, 2);
		    434 +     })
		    435 +     .thenExecuteAfter(8, () => {
		    436 +       test.assertBlockTypePresent(BlockTypes.air, planksLoc);
		    437 +       test.assert(expanded, "Expected piston expanding event");
		    438 +       test.assert(retracted, "Expected piston retracting event");
		    439 +       World.events.beforeActivatePiston.unsubscribe(pistonCallback);
		    440 +     })
		    441 +     .thenSucceed();
		    442 + })
		    443 +   .structureName("APITests:piston")
		    444 +   .tag(GameTest.Tags.suiteDefault);
		110     -         if (x == 0 && z == 0) {
		111     -           test.assertEntityPresent(minecartId, offsetLoc);
		112     -         } else {
		113     -           test.assertEntityNotPresent(minecartId, offsetLoc);
		114     -         }
		115     -       }
		116     -     }
		117     -   });
		118     - }).tag(GameTest.Tags.suiteDefault);
		119     - 
		120     - GameTest.register("APITests", "assert_entity_not_present", (test) => {
		121     -   const armorStandId = "minecraft:armor_stand";
		122     -   const pigId = "minecraft:pig";
		123     -   const armorStandLoc = new BlockLocation(1, 2, 1);
		124     -   const airLoc = new BlockLocation(0, 2, 1);
		125 445   
		    446 + GameTest.register("APITests", "piston_event_canceled", (test) => {
		    447 +   let canceled = false;
		126     -   try {
		    448 +   const redstoneLoc = new BlockLocation(1, 2, 0);
		    449 +   const pistonLoc = new BlockLocation(1, 2, 1);
		    450 +   const planksLoc = new BlockLocation(2, 2, 1);
		127     -     test.assertEntityNotPresentInArea(armorStandId);
		128     -     test.fail(); // this assert should throw
		129     -   } catch (e) {}
		130 451   
		    452 +   const pistonCallback = World.events.beforeActivatePiston.subscribe((pistonEvent) => {
		    453 +     test.assert(pistonEvent.piston !== undefined, "Expected piston");
		131     -   try {
		132     -     test.assertEntityNotPresent(armorStandId, armorStandLoc);
		    454 +     if (pistonEvent.piston.location.equals(test.worldLocation(pistonLoc))) {
		    455 +       pistonEvent.cancel = true;
		    456 +       canceled = true;
		    457 +     }
		    458 +   });
		133     -     test.fail(); // this assert should throw
		134     -   } catch (e) {}
		135     - 
		136     -   test.assertEntityNotPresent(armorStandId, airLoc);
		137     -   test.assertEntityNotPresentInArea(pigId);
		138 459   
		    460 +   test
		    461 +     .startSequence()
		139     -   test.succeed();
		140     - })
		    462 +     .thenExecute(() => {
		    463 +       test.pulseRedstone(redstoneLoc, 2);
		    464 +     })
		    465 +     .thenExecuteAfter(8, () => {
		    466 +       test.assert(canceled, "Expected canceled beforeActivatePiston event");
		    467 +       test.assertBlockTypePresent(BlockTypes.planks, planksLoc);
		    468 +       World.events.beforeActivatePiston.unsubscribe(pistonCallback);
		    469 +     })
		    470 +     .thenSucceed();
		    471 + })
		    472 +   .structureName("APITests:piston")
		    473 +   .tag(GameTest.Tags.suiteDefault);
		141     -   .structureName("APITests:armor_stand")
		142     -   .tag(GameTest.Tags.suiteDefault);
		143     - 
		144     - GameTest.register("APITests", "assert_item_entity_count_is", (test) => {
		145     -   let oneItemLoc = new BlockLocation(3, 2, 1);
		146     -   let fiveItemsLoc = new BlockLocation(1, 2, 1);
		147     -   let noItemsLoc = new BlockLocation(2, 2, 1);
		148     -   let diamondPickaxeLoc = new BlockLocation(2, 2, 4);
		149     - 
		150     -   const oneEmerald = new ItemStack(Items.emerald, 1, 0);
		151     -   const onePickaxe = new ItemStack(Items.diamondPickaxe, 1, 0);
		152     -   const fiveEmeralds = new ItemStack(Items.emerald, 5, 0);
		153 474   
		    475 + GameTest.register("APITests", "sneaking", (test) => {
		    476 +   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		    477 +   const pigLoc = new BlockLocation(1, 2, 1);
		    478 +   const pig = test.spawn(pigId, pigLoc);
		    479 +   pig.isSneaking = true;
		    480 +   test
		    481 +     .startSequence()
		    482 +     .thenExecuteAfter(120, () => {
		    483 +       test.assertEntityPresent(pigId, pigLoc);
		    484 +     })
		    485 +     .thenSucceed();
		    486 + })
		    487 +   .maxTicks(130)
		    488 +   .tag(GameTest.Tags.suiteDefault);
		154     -   test.spawnItem(oneEmerald, new Location(3.5, 3, 1.5));
		155     -   test.spawnItem(fiveEmeralds, new Location(1.5, 3, 1.5));
		156     - 
		157     -   // spawn 9 pickaxes in a 3x3 grid
		158     -   for (let x = 1.5; x <= 3.5; x++) {
		159     -     for (let z = 3.5; z <= 5.5; z++) {
		160     -       test.spawnItem(onePickaxe, new Location(x, 3, z));
		161     -     }
		162     -   }
		163     - 
		164     -   test.assertItemEntityCountIs(Items.emerald, noItemsLoc, 0, 0);
		165 489   
		    490 + GameTest.register("APITests", "assert_can_reach_location", (test) => {
		    491 +   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		166     -   test.succeedWhen(() => {
		167     -     test.assertItemEntityCountIs(Items.feather, oneItemLoc, 0, 0);
		    492 +   const villager1 = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		    493 +   const villager2 = test.spawn(villagerId, new BlockLocation(1, 2, 3));
		    494 +   const villager3 = test.spawn(villagerId, new BlockLocation(1, 2, 5));
		    495 +   test.assertCanReachLocation(villager1, new BlockLocation(4, 2, 1), true);
		    496 +   test.assertCanReachLocation(villager2, new BlockLocation(4, 2, 3), false);
		    497 +   test.assertCanReachLocation(villager3, new BlockLocation(4, 2, 5), false);
		    498 +   test.succeed();
		168     -     test.assertItemEntityCountIs(Items.emerald, oneItemLoc, 0, 1);
		169     -     test.assertItemEntityCountIs(Items.feather, fiveItemsLoc, 0, 0);
		170     -     test.assertItemEntityCountIs(Items.emerald, fiveItemsLoc, 0, 5);
		171     -     test.assertItemEntityCountIs(Items.emerald, fiveItemsLoc, 0, 5);
		172     -     test.assertItemEntityCountIs(Items.diamondPickaxe, diamondPickaxeLoc, 1, 9);
		173     -     test.assertItemEntityCountIs(Items.diamondPickaxe, diamondPickaxeLoc, 0, 1);
		174     -   });
		175 499   }).tag(GameTest.Tags.suiteDefault);
		176     - 
		177     - GameTest.register("APITests", "assert_entity_touching", (test) => {
		178     -   const armorStandId = "minecraft:armor_stand";
		179 500   
		    501 + const isLocationInTest = (test, worldLoc) => {
		180     -   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.5));
		181     -   test.assertEntityTouching(armorStandId, new Location(1.5, 3.5, 1.5));
		    502 +   const size = 4;
		    503 +   let loc = test.relativeLocation(worldLoc);
		    504 +   return loc.x >= 0 && loc.y >= 0 && loc.z >= 0 && loc.x < size && loc.y < size && loc.z < size;
		    505 + };
		182     -   test.assertEntityNotTouching(armorStandId, new Location(1.0, 2.5, 1.5));
		183     -   test.assertEntityNotTouching(armorStandId, new Location(2.0, 2.5, 1.5));
		184     -   test.assertEntityNotTouching(armorStandId, new Location(1.5, 2.5, 1.0));
		185     -   test.assertEntityNotTouching(armorStandId, new Location(1.5, 2.5, 2.0));
		186 506   
		    507 + GameTest.register("APITests", "explosion_event", (test) => {
		    508 +   let exploded = false;
		187     -   test.succeed();
		188     - })
		    509 +   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		    510 +   const polishedAndesiteLoc = new BlockLocation(1, 1, 1);
		189     -   .structureName("APITests:armor_stand")
		190     -   .tag(GameTest.Tags.suiteDefault);
		191 511   
		    512 +   const beforeExplosionCallback = World.events.beforeExplosion.subscribe((explosionEvent) => {
		    513 +     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		    514 +     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		    515 +     test.assert(explosionEvent.source !== undefined, "Expected source");
		    516 +     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		    517 +     test.assertBlockTypePresent(BlockTypes.cobblestone, cobblestoneLoc);
		    518 +     explosionEvent.impactedBlocks = [test.worldLocation(cobblestoneLoc)];
		    519 +   });
		192     - GameTest.register("APITests", "pulse_redstone", (test) => {
		193     -   const pulseLoc = new BlockLocation(1, 2, 2);
		194     -   const lampLoc = new BlockLocation(1, 2, 1);
		195     -   test.assertRedstonePower(lampLoc, 0);
		196     -   test.pulseRedstone(pulseLoc, 2);
		197 520   
		    521 +   const explosionCallback = World.events.explosion.subscribe((explosionEvent) => {
		198     -   test
		199     -     .startSequence()
		200     -     .thenIdle(2)
		    522 +     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		    523 +     test.assert(explosionEvent.source !== undefined, "Expected source");
		    524 +     test.assert(explosionEvent.impactedBlocks.length === 1, "Unexpected number of impacted blocks");
		    525 +     exploded = true;
		    526 +   });
		201     -     .thenExecute(() => test.assertRedstonePower(lampLoc, 15))
		202     -     .thenIdle(1)
		203     -     .thenExecute(() => test.assertRedstonePower(lampLoc, 0))
		204     -     .thenSucceed();
		205     - }).tag(GameTest.Tags.suiteDefault);
		206 527   
		    528 +   test
		    529 +     .startSequence()
		    530 +     .thenExecute(() => {
		207     - GameTest.register("APITests", "location", (test) => {
		    531 +       test.setBlockType(BlockTypes.cobblestone, cobblestoneLoc);
		    532 +       test.spawn("tnt", new BlockLocation(1, 2, 1));
		    533 +     })
		    534 +     .thenExecuteAfter(60, () => {
		    535 +       test.assert(exploded, "Expected explosion event");
		    536 +       test.assertBlockTypePresent(BlockTypes.stone, polishedAndesiteLoc);
		    537 +       test.assertBlockTypeNotPresent(BlockTypes.cobblestone, cobblestoneLoc);
		    538 +       World.events.beforeExplosion.unsubscribe(beforeExplosionCallback);
		    539 +       World.events.explosion.unsubscribe(explosionCallback);
		    540 +     })
		    541 +     .thenSucceed();
		    542 + })
		    543 +   .padding(10) // The blast can destroy nearby items and mobs
		    544 +   .structureName("ComponentTests:platform")
		    545 +   .tag(GameTest.Tags.suiteDefault);
		208     -   let testLoc = new BlockLocation(1, 1, 1);
		209     -   let worldLoc = test.worldLocation(testLoc);
		210     -   let relativeLoc = test.relativeLocation(worldLoc);
		211     -   test.assert(!relativeLoc.equals(worldLoc), "Expected relativeLoc and worldLoc to be different");
		212     -   test.assert(relativeLoc.equals(testLoc), "Expected relativeLoc to match testLoc");
		213     -   test.succeed();
		214     - })
		215     -   .structureName("ComponentTests:platform")
		216     -   .tag(GameTest.Tags.suiteDefault);
		217     - 
		218     - GameTest.register("APITests", "create_explosion_basic", (test) => {
		219     -   let overworld = World.getDimension("overworld");
		220     -   const center = new BlockLocation(2, 3, 2);
		221     - 
		222     -   test.assertBlockTypePresent(BlockTypes.cobblestone, center);
		223 546   
		    547 + GameTest.register("APITests", "explosion_event_canceled", (test) => {
		    548 +   let canceled = false;
		224     -   const loc = test.worldLocation(center);
		225     -   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		    549 +   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		226     -   overworld.createExplosion(explosionLoc, 10, new ExplosionOptions());
		227 550   
		    551 +   const explosionCallback = World.events.beforeExplosion.subscribe((explosionEvent) => {
		    552 +     if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		228     -   for (let x = 1; x <= 3; x++) {
		    553 +     test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		    554 +     test.assert(explosionEvent.source !== undefined, "Expected source");
		    555 +     test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		    556 +     explosionEvent.cancel = true;
		    557 +     canceled = true;
		    558 +   });
		229     -     for (let y = 2; y <= 4; y++) {
		230     -       for (let z = 1; z <= 3; z++) {
		231     -         test.assertBlockTypeNotPresent(BlockTypes.cobblestone, new BlockLocation(x, y, z));
		232     -       }
		233     -     }
		234     -   }
		235 559   
		    560 +   test
		    561 +     .startSequence()
		236     -   test.succeed();
		237     - })
		    562 +     .thenExecute(() => {
		    563 +       test.setBlockType(BlockTypes.cobblestone, cobblestoneLoc);
		    564 +       test.spawn("tnt", new BlockLocation(1, 2, 1));
		    565 +     })
		    566 +     .thenExecuteAfter(60, () => {
		    567 +       test.assert(canceled, "Expected canceled beforeExplosionEvent event");
		    568 +       test.assertBlockTypePresent(BlockTypes.cobblestone, cobblestoneLoc);
		    569 +       World.events.beforeExplosion.unsubscribe(explosionCallback);
		    570 +     })
		    571 +     .thenSucceed();
		    572 + })
		    573 +   .padding(10) // The blast can destroy nearby items and mobs
		    574 +   .structureName("ComponentTests:platform")
		    575 +   .tag(GameTest.Tags.suiteDefault);
		238     -   .padding(10) // The blast can destroy nearby items and mobs
		239     -   .tag(GameTest.Tags.suiteDefault);
		240     - 
		241     - GameTest.register("APITests", "create_explosion_advanced", (test) => {
		242     -   let overworld = World.getDimension("overworld");
		243     -   const center = new BlockLocation(2, 3, 2);
		244     - 
		245     -   const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		246     -   const pigLoc = new BlockLocation(2, 4, 2);
		247     -   test.spawn(pigId, pigLoc);
		248     - 
		249     -   const loc = test.worldLocation(center);
		250     -   const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		251     -   let explosionOptions = new ExplosionOptions();
		252 576   
		    577 + GameTest.register("APITests", "explode_block_event", (test) => {
		    578 +   let explodedCount = 0;
		    579 +   const cobblestoneLoc = new BlockLocation(1, 3, 1);
		253     -   test.assertBlockTypePresent(BlockTypes.cobblestone, center);
		254 580   
		255     -   // Start by exploding without breaking blocks
		256     -   explosionOptions.breaksBlocks = false;
		257     -   const creeper = test.spawn("minecraft:creeper", new BlockLocation(1, 2, 1));
		258     -   explosionOptions.source = creeper;
		    581 +   const explodeBlockCallback = World.events.explodeBlock.subscribe((explodeBlockEvent) => {
		    582 +     if (!isLocationInTest(test, explodeBlockEvent.destroyedBlock.getLocation())) return;
		    583 +     test.assert(explodeBlockEvent.source !== undefined, "Expected source");
		    584 +     explodedCount++;
		    585 +   });
		259     -   test.assertEntityPresent(pigId, pigLoc);
		260     -   overworld.createExplosion(explosionLoc, 10, explosionOptions);
		261     -   creeper.kill();
		262     -   test.assertEntityNotPresent(pigId, pigLoc);
		263     -   test.assertBlockTypePresent(BlockTypes.cobblestone, center);
		264 586   
		    587 +   test
		    588 +     .startSequence()
		265     -   // Next, explode with fire
		    589 +     .thenExecute(() => {
		    590 +       test.setBlockType(BlockTypes.cobblestone, cobblestoneLoc);
		    591 +       test.spawn("tnt", new BlockLocation(1, 2, 1));
		    592 +     })
		    593 +     .thenExecuteAfter(60, () => {
		    594 +       test.assert(explodedCount === 10, "Unexpected number of exploded blocks");
		    595 +       World.events.explodeBlock.unsubscribe(explodeBlockCallback);
		    596 +     })
		    597 +     .thenSucceed();
		    598 + })
		    599 +   .padding(10) // The blast can destroy nearby items and mobs
		    600 +   .structureName("ComponentTests:platform")
		    601 +   .tag(GameTest.Tags.suiteDefault);
		    602 + 
		    603 + GameTest.register("APITests", "connectivity", (test) => {
		    604 +   const centerLoc = new BlockLocation(1, 2, 1);
		266     -   explosionOptions = new ExplosionOptions();
		267     -   explosionOptions.causesFire = true;
		268     - 
		269     -   let findFire = () => {
		270     -     let foundFire = false;
		271     -     for (let x = 0; x <= 4; x++) {
		272     -       for (let z = 0; z <= 4; z++) {
		273     -         try {
		274     -           test.assertBlockTypePresent(BlockTypes.fire, new BlockLocation(x, 3, z));
		275     -           foundFire = true;
		276     -           break;
		277     -         } catch (e) {}
		278     -       }
		279     -     }
		280     -     return foundFire;
		281     -   };
		282 605   
		283     -   test.assert(!findFire(), "Unexpected fire");
		284     -   overworld.createExplosion(explosionLoc, 10, explosionOptions);
		285     -   test.assertBlockTypeNotPresent(BlockTypes.cobblestone, center);
		    606 +   let connectivity = test.getFenceConnectivity(centerLoc);
		286     -   test.assert(findFire(), "No fire found");
		287 607   
		    608 +   test.assert(!connectivity.north, "The stair is not oriented the right way to connect");
		288     -   // Finally, explode in water
		289     -   explosionOptions.allowUnderwater = true;
		    609 +   test.assert(connectivity.east, "Should connect to another fence");
		    610 +   test.assert(connectivity.south, "Should connect to another fence");
		    611 +   test.assert(connectivity.west, "Should connect to the back of the stairs");
		    612 + 
		290     -   const belowWaterLoc = new BlockLocation(2, 1, 2);
		291     -   test.assertBlockTypeNotPresent(BlockTypes.air, belowWaterLoc);
		292     -   overworld.createExplosion(explosionLoc, 7, explosionOptions);
		293     -   test.assertBlockTypePresent(BlockTypes.air, belowWaterLoc);
		294 613     test.succeed();
		295 614   })
		296     -   .padding(10) // The blast can destroy nearby items and mobs
		297 615     .tag(GameTest.Tags.suiteDefault);
		298 616   
		    617 + GameTest.register("APITests", "spawn_at_location", (test) => {
		    618 +   const spawnLoc = new Location(1.3, 2, 1.3);
		299     - GameTest.register("APITests", "triggerEvent", (test) => {
		300     -   const creeper = test.spawn("creeper", new BlockLocation(1, 2, 1));
		    619 +   const chicken = test.spawnAtLocation("chicken", spawnLoc);
		301     -   creeper.triggerEvent("minecraft:start_exploding_forced");
		302 620   
		    621 +   test
		    622 +     .startSequence()
		303     -   test.succeedWhen(() => {
		    623 +     .thenIdle(1) // Entity location is not guaranteed to be accurate immidiately after spawning so wait 1 tick
		    624 +     .thenExecute(() => {
		    625 +       const chickenLoc = chicken.location;
		    626 +       const structureLoc = test.worldLocation(new BlockLocation(0, 0, 0));
		    627 +       const relativeChickenLoc = new Location(
		    628 +         chickenLoc.x - structureLoc.x,
		    629 +         chickenLoc.y - structureLoc.y,
		    630 +         chickenLoc.z - structureLoc.z
		    631 +       );
		    632 +       test.assert(relativeChickenLoc.isNear(spawnLoc, 0.01), "Unexpected spawn location");
		    633 +     })
		    634 +     .thenSucceed();
		    635 + })
		    636 +   .structureName("ComponentTests:animal_pen")
		    637 +   .tag(GameTest.Tags.suiteDefault);
		    638 + 
		    639 + GameTest.register("APITests", "walk_to_location", (test) => {
		    640 +   const spawnLoc = new BlockLocation(1, 2, 1);
		    641 +   const chicken = test.spawnWithoutBehaviors("chicken", spawnLoc);
		    642 + 
		    643 +   const targetLoc = new Location(2.2, 2, 3.2);
		    644 +   test.walkToLocation(chicken, targetLoc, 1);
		304     -     test.assertEntityNotPresentInArea("creeper");
		305     -   });
		306     - })
		307     -   .structureName("ComponentTests:glass_cage")
		308     -   .tag(GameTest.Tags.suiteDefault);
		309     - 
		310     - GameTest.register("APITests", "chat", (test) => {
		311     -   test.print("subscribing");
		312     - 
		313     -   const chatCallback = World.events.beforeChat.subscribe((eventData) => {
		314     -     if (eventData.message === "!killme") {
		315     -       eventData.sender.kill();
		316     -       eventData.canceled = true;
		317     -     } else if (eventData.message === "!players") {
		318     -       test.print(`There are ${eventData.targets.length} players in the server.`);
		319     -       for (const target of eventData.targets) {
		320     -         test.print("Player: " + target.name);
		321     -       }
		322     -     } else {
		323     -       eventData.message = `Modified '${eventData.message}'`;
		324     -     }
		325     -   });
		326 645   
		    646 +   test.succeedWhen(() => {
		    647 +     const chickenLoc = chicken.location;
		    648 +     const structureLoc = test.worldLocation(new BlockLocation(0, 0, 0));
		    649 +     const relativeChickenLoc = new Location(
		    650 +       chickenLoc.x - structureLoc.x,
		    651 +       chickenLoc.y - structureLoc.y,
		    652 +       chickenLoc.z - structureLoc.z
		    653 +     );
		    654 +     // Mobs will stop navigating as soon as they intersect the target location
		    655 +     test.assert(relativeChickenLoc.isNear(targetLoc, 0.65), "Chicken did not reach the target location");
		    656 +   });
		327     -   test
		328     -     .startSequence()
		329     -     .thenIdle(200)
		330     -     .thenExecute(() => {
		331     -       World.events.beforeChat.unsubscribe(chatCallback);
		332     -       test.print("unsubscribed");
		333     -     })
		334     -     .thenSucceed();
		335 657   })
		    658 +   .structureName("ComponentTests:large_animal_pen")
		336     -   .structureName("ComponentTests:platform")
		337     -   .maxTicks(1000)
		    659 +   .tag(GameTest.Tags.suiteDefault);
		338     -   .tag(GameTest.Tags.suiteDisabled);
		339 660   
		    661 + GameTest.register("APITests", "spread_from_face_toward_direction", (test) => {
		    662 +   let multifaceLoc = new BlockLocation(1, 4, 0);
		340     - GameTest.register("APITests", "add_effect_event", (test) => {
		341     -   const villagerId = "minecraft:villager_v2<minecraft:ageable_grow_up>";
		    663 +   let spreadLoc = new BlockLocation(1, 3, 0);
		342     -   const villager = test.spawn(villagerId, new BlockLocation(1, 2, 1));
		343 664   
		    665 +   test.assertBlockTypeNotPresent(BlockTypes.glowLichen, spreadLoc);
		344     -   const addEffectCallback = World.events.addEffect.subscribe((eventData) => {
		345     -     test.assert(eventData.entity.id === "minecraft:villager_v2", "Unexpected id");
		346     -     test.assert(eventData.effect.displayName === "Poison II", "Unexpected display name");
		    666 +   test.spreadFromFaceTowardDirection(multifaceLoc, Direction.south, Direction.down);
		    667 +   test
		    668 +     .startSequence()
		347     -     test.assert(eventData.effectState === 1, "Unexpected effect state");
		348     -     test.succeed();
		349     -   });
		350     - 
		    669 +     .thenExecuteAfter(1, () => {
		    670 +       test.assertBlockTypePresent(BlockTypes.glowLichen, spreadLoc);
		    671 +     })
		    672 +     .thenSucceed();
		    673 + });
		351     -   villager.addEffect(Effects.poison, 5, 1);
		352     -   World.events.beforeChat.unsubscribe(addEffectCallback);
		353     - })
		354     -   .structureName("ComponentTests:animal_pen")
		355     -   .tag(GameTest.Tags.suiteDefault);
		          '''
	Added script "BigMobTests.js":
		'''
		import * as GameTest from "GameTest";
		import { BlockLocation } from "Minecraft";
		
		const BIGMOB_TEST_MAX_TICKS = 100;
		const BIGMOB_TEST_STARTUP_TICKS = 0;
		const BIGMOB_REQUIRE = false;
		
		const ROTATION = ["NONE"]; //["NONE", "CLOCKWISE_90", "CLOCKWISE_180", "COUNTERCLOCKWISE_90"]
		const MOBTOTEST = ["zoglin", "ravager", "iron_golem", "spider", "horse"];
		
		function getRotationStepsForRotation(rotation) {
		    switch (rotation) {
		        case "NONE":
		            return 0;
		        case "CLOCKWISE_90":
		            return 1;
		        case "CLOCKWISE_180":
		            return 2;
		        case "COUNTERCLOCKWISE_90":
		            return 3;
		        default:
		            throw "Unknown rotation value, don't know how many steps it represents:" + rotation;
		    }
		}
		
		function _descending(test, entityType) {
		    let zPos = 1;  // in Java, let zPos = (wallSide=="RIGHT")?-0.25:0.25;
		    const spawnType = "minecraft:" + entityType;
		    const mob = test.spawnWithoutBehaviors(spawnType, new BlockLocation(0, 6, zPos));
		    const targetPos = new BlockLocation(7, 2, 1);
		    test.walkTo(mob, targetPos, 1);
		    test.succeedWhenEntityPresent(spawnType, targetPos);
		}
		
		
		function createDescendingTest(wallSide, rotation, entityType) {
		    const structureName = "BigMobTests:altitude_change_wall_on_" + wallSide.toLowerCase();
		    const testName = "altitude_change_wall_on_" + wallSide.toLowerCase() + "_descend_" + entityType + "_rotation_" + getRotationStepsForRotation(rotation);
		
		    if (entityType == 'horse') {
		        GameTest.register("BigMobTests", testName, (test) => { _descending(test, entityType) })
		            .structureName(structureName)
		            .maxTicks(BIGMOB_TEST_MAX_TICKS)
		            .setupTicks(BIGMOB_TEST_STARTUP_TICKS)
		            .tag(GameTest.Tags.suiteDisabled)  // Somes horses always walk at very low speed and cause timeout. So I disabled these tests.
		            .required(BIGMOB_REQUIRE);
		    }
		    else {
		        GameTest.register("BigMobTests", testName, (test) => { _descending(test, entityType) })
		            .structureName(structureName)
		            .maxTicks(BIGMOB_TEST_MAX_TICKS)
		            .setupTicks(BIGMOB_TEST_STARTUP_TICKS)
		            .tag(GameTest.Tags.suiteDefault)
		            .required(BIGMOB_REQUIRE);
		    }
		}
		
		
		function _ascending(test, entityType) {
		    const spawnType = "minecraft:" + entityType;
		    const targetPos = new BlockLocation(0, 6, 1); // Location(0.5, 6.0, 1.5) in Java , but not be supported to be parameter in .walkTo() 
		    const mob = test.spawnWithoutBehaviors(spawnType, new BlockLocation(7, 2, 1));
		    test.walkTo(mob, targetPos, 1);
		    test.succeedWhenEntityPresent(spawnType, targetPos);
		}
		
		function createAscendingTest(wallSide, rotation, entityType) {
		    const structureName = "BigMobTests:altitude_change_wall_on_" + wallSide.toLowerCase();
		    const testName = "altitude_change_wall_on_" + wallSide.toLowerCase() + "_ascend_" + entityType + "_rotation_" + getRotationStepsForRotation(rotation);
		
		    if (entityType == 'horse' || (entityType == 'spider' && wallSide.toLowerCase() == 'left')) {
		        GameTest.register("BigMobTests", testName, (test) => { _ascending(test, entityType) })
		            .structureName(structureName)
		            .maxTicks(BIGMOB_TEST_MAX_TICKS)
		            .setupTicks(BIGMOB_TEST_STARTUP_TICKS)
		            .tag(GameTest.Tags.suiteDisabled) // Somes horses always walk at very low speed and cause timeout. altitude_change_wall_on_left_ascend_spider_rotation_0 failed by timeout on BuildBott.So I disabled these tests.
		            .required(BIGMOB_REQUIRE);
		    }
		    else {
		        GameTest.register("BigMobTests", testName, (test) => { _ascending(test, entityType) })
		            .structureName(structureName)
		            .maxTicks(BIGMOB_TEST_MAX_TICKS)
		            .setupTicks(BIGMOB_TEST_STARTUP_TICKS)
		            .tag(GameTest.Tags.suiteDefault)
		            .required(BIGMOB_REQUIRE);
		    }
		}
		
		for (var bigmobIndex = 0; bigmobIndex < MOBTOTEST.length; bigmobIndex++) {
		    for (var rotationIndex = 0; rotationIndex < ROTATION.length; rotationIndex++) {
		        createDescendingTest("RIGHT", ROTATION[rotationIndex], MOBTOTEST[bigmobIndex]);
		        createDescendingTest("LEFT", ROTATION[rotationIndex], MOBTOTEST[bigmobIndex]);
		        createAscendingTest("RIGHT", ROTATION[rotationIndex], MOBTOTEST[bigmobIndex]);
		        createAscendingTest("LEFT", ROTATION[rotationIndex], MOBTOTEST[bigmobIndex]);
		    }
		}
		'''
	Changed script "BlockTests.js":
		Total line: 261 (+6, -6)
		          '''
		          ...
		 55  55   // Concrete Tests
		 56  56   ///
		 57  57   for (let i = 0; i < BLOCKS_THAT_POP_SAND.length; i++) {
		 58  58     const topBlock = BLOCKS_THAT_POP_SAND[i][0];
		 59  59     const bottomBlock = BLOCKS_THAT_POP_SAND[i][1];
		     60 +   const testName = "blocktests.falling_sand_pops_on_" + topBlock.getName();
		 60     -   const testName = "blocktests.falling_sand_pops_on_" + topBlock.name;
		 61  61     let tag = null;
		 62  62   
		 63  63     //When sand block falls on soul sand, it should pop into item.
		 64  64     //Buttons will break off if they face the worng direction. Wait API that can set the block property for "direction" for the button.
		     65 +   if (topBlock.getName() == "minecraft:soul_sand" || topBlock.getName() == "minecraft:stone_button") {
		 65     -   if (topBlock.name == "soul_sand" || topBlock.name == "stone_button") {
		 66  66       tag = GameTest.Tags.suiteDisabled;
		 67  67     } else {
		 68  68       tag = GameTest.Tags.suiteDefault;
		 69  69     }
		 70  70   
		          ...
		 80  80       .required(true)
		 81  81       .tag(tag);
		 82  82   }
		 83  83   
		 84  84   for (const block of BLOCKS_REPLACED_BY_SAND) {
		     85 +   const testName = "blocktests.falling_sand_replaces_" + block.getName();
		 85     -   const testName = "blocktests.falling_sand_replaces_" + block.name;
		 86  86   
		 87  87     GameTest.register("BlockTests", testName, (test) => {
		 88  88       //SetBlock will fail if set a block to what it already is. Skip to call setblock() for test falling_sand_replaces_air because it's just air block in initial structure.
		     89 +     if (block.getName() != "minecraft:air") {
		 89     -     if (block.name != "air") {
		 90  90         test.setBlockType(block, new BlockLocation(1, 2, 1));
		 91  91       }
		 92  92       testThatFallingSandReplaces(test);
		 93  93     })
		 94  94       .batch("day")
		          ...
		 98  98       .required(true)
		 99  99       .tag(GameTest.Tags.suiteDefault);
		100 100   }
		101 101   
		102 102   for (const block of BLOCKS_THAT_SUPPORT_SAND) {
		    103 +   const testName = "blocktests.falling_sand_lands_on_" + block.getName();
		103     -   const testName = "blocktests.falling_sand_lands_on_" + block.name;
		104 104     let tag = null;
		105 105   
		106 106     //When sand block falls on fence or stair, it shouldn't pop into item.
		    107 +   if (block.getName() == "minecraft:fence" || block.getName() == "minecraft:oak_stairs") {
		107     -   if (block.name == "fence" || block.name == "oak_stairs") {
		108 108       tag = GameTest.Tags.suiteDisabled;
		109 109     } else {
		110 110       tag = GameTest.Tags.suiteDefault;
		111 111     }
		112 112   
		          ...
		          '''
	Changed script "FlyingMachineTests.js":
		Total line: 264 (+1, -1)
		          '''
		          ...
		259 259       })
		260 260       .thenExecuteAfter(10, () => {
		261 261         test.assertBlockTypePresent(BlockTypes.slime, targetPos);
		262 262       })
		263 263       .thenSucceed();
		    264 + }).tag(GameTest.Tags.suiteDefault); 
		264     - }).tag(GameTest.Tags.suiteDisabled); // Unstable, the pass rate is 85%
		          '''
	Changed script "Main.js":
		Total line: 20 (+2, -0)
		        '''
		        ...
		14 14   import "scripts/PathFindingTests.js";
		15 15   import "scripts/FlyingMachineTests.js";
		16 16   import "scripts/PistonTests.js";
		17 17   import "scripts/TntTests.js";
		18 18   import "scripts/SmallMobTests.js";
		   19 + import "scripts/BigMobTests.js";
		   20 + import "scripts/RedstoneTests.js";
		        '''
	Changed script "PistonTests.js":
		Total line: 811 (+2, -8)
		          '''
		          ...
		510 510   })
		511 511     .tag("suite:java_parity")
		512 512     .tag(GameTest.Tags.suiteDisabled); // Game parity issue. Create a new test called triple_extender_bedrock using new structure, and updated piston react time.
		513 513   
		514 514   GameTest.register("PistonTests", "triple_extender_bedrock", (test) => {
		515     -   const retracted = new BlockLocation(0, 4, 4);
		516     -   const extended = new BlockLocation(0, 1, 4);
		517     -   const trigger = new BlockLocation(0, 7, 0);
		518     -   const assertBlockPresentA = new BlockLocation(0, 7, 4);
		519     -   const assertBlockPresentB = new BlockLocation(0, 6, 4);
		520     -   const assertBlockPresentC = new BlockLocation(0, 5, 4);
		521     -   const assertBlockPresentD = new BlockLocation(0, 3, 4);
		    515 +     const retracted = new BlockLocation(0, 4, 4);
		    516 +     const extended = new BlockLocation(0, 1, 4);
		    517 +     const trigger = new BlockLocation(0, 7, 0);
		    518 +     const assertBlockPresentA = new BlockLocation(0, 7, 4);
		    519 +     const assertBlockPresentB = new BlockLocation(0, 6, 4);
		    520 +     const assertBlockPresentC = new BlockLocation(0, 5, 4);
		    521 +     const assertBlockPresentD = new BlockLocation(0, 3, 4);
		    522 +     test.pressButton(trigger);
		    523 +     test
		    524 +         .startSequence()
		    525 +         .thenWait(() => {
		    526 +             test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentA);
		    527 +             test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentC);
		    528 +             test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentD);
		    529 +             test.assertBlockTypePresent(BlockTypes.concrete, extended);
		    530 +         })
		    531 +         .thenWait(() => {
		    532 +             test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentA);
		    533 +             test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentB);
		    534 +             test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentC);
		    535 +             test.assertBlockTypePresent(BlockTypes.concrete, retracted);
		    536 +         })
		    537 +         .thenSucceed();
		522     - 
		523     -   test.pressButton(trigger);
		524     -   test
		525     -     .startSequence()
		526     -     .thenIdle(33)
		527     -     .thenExecute(() => {
		528     -       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentA);
		529     -       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentC);
		530     -       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentD);
		531     -       test.assertBlockTypePresent(BlockTypes.concrete, extended);
		532     -     })
		533     -     .thenIdle(1)
		534     -     .thenExecute(() => {
		535     -       test.pressButton(trigger);
		536     -     })
		537     -     .thenIdle(45)
		538     -     .thenExecute(() => {
		539     -       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentA);
		540     -       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentB);
		541     -       test.assertBlockTypePresent(BlockTypes.stickyPiston, assertBlockPresentC);
		542     -       test.assertBlockTypePresent(BlockTypes.concrete, retracted);
		543     -     })
		544     -     .thenSucceed();
		545 538   })
		    539 +     .setupTicks(20)
		    540 +     .tag(GameTest.Tags.suiteDefault)
		546     -   .tag(GameTest.Tags.suiteDisabled) // Disable this test after it is not passing 100% in Main.
		    541 +     .maxTicks(100);
		547     -   .maxTicks(300);
		548 542   
		549 543   GameTest.register("PistonTests", "monostable", (test) => {
		550 544     const lampPos = new BlockLocation(0, 3, 5);
		551 545     const pullLeverPos = new BlockLocation(0, 2, 0);
		552 546   
		          ...
		          '''
	Added script "RedstoneTests.js":
		'''
		import * as GameTest from "GameTest";
		import { BlockLocation, BlockTypes, BlockProperties, World } from "Minecraft";
		
		const TicksPerSecond = 20;
		
		GameTest.register("RedstoneTests", "itemframe_override", (test) => {
		  const itemFrameTest = new BlockLocation(3, 2, 5);
		  const itemFrameOverrideNoTest = new BlockLocation(3, 2, 10);
		
		  const lever = new BlockLocation(1, 2, 0);
		  const leverOverrideTest = new BlockLocation(1, 2, 13);
		
		  test.assertRedstonePower(itemFrameTest, 1);
		  test.assertRedstonePower(itemFrameOverrideNoTest, 1);
		
		  test.pullLever(lever);
		
		  test.succeedWhen(() => {
		    test.assertRedstonePower(leverOverrideTest, 1);
		  });
		})
		  .tag("suite:java_parity")
		  .tag(GameTest.Tags.suiteDisabled); // Torches can't be placed on item frames in Bedrock,When the bow and arrow are placed on the item frame, it cannot be linked with red stone. So I changed the location of the red stone link to bedrock
		
		GameTest.register("RedstoneTests", "itemframe_override_bedrock", (test) => {
		  const itemFrameTest = new BlockLocation(3, 2, 5);
		  const itemFrameOverrideNoTest = new BlockLocation(2, 2, 10);
		
		  const lever = new BlockLocation(1, 2, 0);
		  const leverOverrideTest = new BlockLocation(0, 2, 13);
		
		  test
		    .startSequence()
		    .thenIdle(3)
		    .thenExecute(() => {
		      test.assertRedstonePower(itemFrameTest, 1);
		      test.assertRedstonePower(itemFrameOverrideNoTest, 1);
		    })
		    .thenExecute(() => {
		      test.pullLever(lever);
		    })
		    .thenIdle(10)
		    .thenExecute(() => {
		      test.assertRedstonePower(leverOverrideTest, 3);
		    })
		    .thenSucceed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RedstoneTests", "comparator_container", (test) => {
		  const aLeft = new BlockLocation(6, 2, 2);
		  const aRight = new BlockLocation(1, 2, 2);
		
		  test.assertRedstonePower(aLeft, 14);
		  test.assertRedstonePower(aRight, 15);
		
		  const bLeft = new BlockLocation(6, 2, 7);
		  const bRight = new BlockLocation(1, 2, 7);
		
		  test.assertRedstonePower(bLeft, 0);
		  test.assertRedstonePower(bRight, 15);
		
		  const cLeft = new BlockLocation(6, 2, 13);
		  const cRight = new BlockLocation(1, 2, 13);
		  test.assertRedstonePower(cLeft, 1);
		  test.assertRedstonePower(cRight, 15);
		
		  test.succeed();
		})
		  .tag("suite:java_parity")
		  .tag(GameTest.Tags.suiteDisabled); // In the bedrock version, the chest is next to the square, causing the red stone signal to fail to transmit
		
		GameTest.register("RedstoneTests", "comparator_container_bedrock", (test) => {
		  const aLeft = new BlockLocation(6, 2, 2);
		  const aRight = new BlockLocation(1, 2, 2);
		  const bLeft = new BlockLocation(6, 2, 7);
		  const bRight = new BlockLocation(1, 2, 7);
		  const cLeft = new BlockLocation(6, 2, 13);
		  const cRight = new BlockLocation(1, 2, 13);
		
		  test
		    .startSequence()
		    .thenExecute(() => {
		      test.assertRedstonePower(aLeft, 14);
		      test.assertRedstonePower(aRight, 15);
		    })
		    .thenExecute(() => {
		      test.assertRedstonePower(bLeft, 0);
		      test.assertRedstonePower(bRight, 0);
		    })
		    .thenExecute(() => {
		      test.assertRedstonePower(cLeft, 0);
		      test.assertRedstonePower(cRight, 0);
		    })
		    .thenSucceed();
		})
		  .structureName("RedstoneTests:comparator_container")
		  .tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RedstoneTests", "wireredirect_nonconductor", (test) => {
		  const levers = [new BlockLocation(3, 2, 0), new BlockLocation(1, 2, 0)];
		  const fenceGatesClosed = [
		    new BlockLocation(2, 3, 0),
		    new BlockLocation(2, 3, 2),
		    new BlockLocation(1, 2, 2),
		    new BlockLocation(2, 2, 2),
		    new BlockLocation(3, 2, 2),
		    new BlockLocation(0, 2, 1),
		    new BlockLocation(4, 2, 1),
		  ];
		  const fenceGatesOpen = [new BlockLocation(3, 3, 1), new BlockLocation(1, 3, 1)];
		
		  test
		    .startSequence()
		    .thenExecute(() => {
		      for (const lever of levers) {
		        test.pullLever(lever);
		      }
		      for (const fenceGateC of fenceGatesClosed) {
		        test.assertBlockState("open_bit", 0, fenceGateC);
		      }
		      for (const fenceGateO of fenceGatesOpen) {
		        test.assertBlockState("open_bit", 1, fenceGateO);
		      }
		    })
		    .thenSucceed();
		})
		  .tag("suite:java_parity")
		  .tag(GameTest.Tags.suiteDisabled); // There is no way to judge the opening and closing state of the fence door, so in is used in open_bit
		
		GameTest.register("RedstoneTests", "wireredirect_nonconductor_bedrock", (test) => {
		  const levers = [new BlockLocation(3, 2, 0), new BlockLocation(1, 2, 0)];
		  const fenceGatesClosed = [
		    new BlockLocation(2, 3, 0),
		    new BlockLocation(2, 3, 2),
		    new BlockLocation(1, 2, 2),
		    new BlockLocation(2, 2, 2),
		    new BlockLocation(3, 2, 2),
		    new BlockLocation(0, 2, 1),
		    new BlockLocation(4, 2, 1),
		  ];
		  const fenceGatesOpen = [new BlockLocation(3, 3, 1), new BlockLocation(1, 3, 1)];
		
		  test
		    .startSequence()
		    .thenIdle(2)
		    .thenExecute(() => {
		      for (const lever of levers) {
		        test.pullLever(lever);
		      }
		    })
		    .thenIdle(6)
		    .thenExecute(() => {
		      for (const fenceGateC of fenceGatesClosed) {
		        test.assertBlockState("open_bit", 0, fenceGateC);
		      }
		    })
		    .thenExecute(() => {
		      for (const fenceGateO of fenceGatesOpen) {
		        test.assertBlockState("open_bit", 1, fenceGateO);
		      }
		    })
		    .thenSucceed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RedstoneTests", "repeater_regeneration", (test) => {
		  const input = new BlockLocation(0, 2, 0);
		  const inactiveOutput = new BlockLocation(6, 3, 4);
		  const activeOutput = new BlockLocation(6, 3, 3);
		
		  test.setBlockType(BlockTypes.redstoneBlock, input);
		  test.succeedOnTickWhen(2, () => {
		    test.assertBlockState("open_bit", 0, inactiveOutput);
		    test.assertBlockState("open_bit", 1, activeOutput);
		  });
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RedstoneTests", "repeater_lock", (test) => {
		  const input = new BlockLocation(0, 2, 2);
		  const lock = new BlockLocation(1, 2, 0);
		  const output = new BlockLocation(2, 2, 1);
		
		  test.setBlockType(BlockTypes.redstoneBlock, input);
		
		  test
		    .startSequence()
		
		    .thenIdle(2)
		    .thenExecute(() => {
		      test.assertBlockState("open_bit", 1, output);
		    })
		    .thenExecute(() => {
		      test.setBlockType(BlockTypes.redstoneBlock, lock);
		      test.setBlockType(BlockTypes.air, input);
		      test.assertBlockState("open_bit", 1, output);
		    })
		    .thenExecuteAfter(2, () => {
		      test.setBlockType(BlockTypes.air, lock);
		    })
		    .thenIdle(4)
		    .thenExecute(() => {
		      test.assertBlockState("open_bit", 0, output);
		    })
		    .thenSucceed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RedstoneTests", "torch_monostable", (test) => {
		  const input = new BlockLocation(0, 2, 0);
		  const output = new BlockLocation(2, 2, 1);
		
		  test.pressButton(input);
		  test
		    .startSequence()
		    .thenWaitUntil(2, () => {
		      test.assertBlockState("open_bit", 0, output);
		    })
		    .thenWaitUntil(2, () => {
		      test.assertBlockState("open_bit", 1, output);
		    })
		    .thenExecute(() => {
		      test.failIf(() => {
		        test.assertBlockState("open_bit", 0, output);
		      });
		    })
		    .thenWait(() => {
		      test.assertBlockState("button_pressed_bit", 0, input);
		    })
		    .thenSucceed();
		})
		  .tag("suite:java_parity")
		  .tag(GameTest.Tags.suiteDisabled); // there are tick delay differences between Java and Bedrock.
		
		GameTest.register("RedstoneTests", "torch_monostable_bedrock", (test) => {
		  const input = new BlockLocation(0, 2, 0);
		  const output = new BlockLocation(2, 2, 1);
		
		  test
		    .startSequence()
		    .thenIdle(2)
		    .thenWait(() => {
		      test.pressButton(input);
		    })
		    .thenIdle(1)
		    .thenExecute(() => {
		      test.assertBlockState("open_bit", 0, output);
		    })
		    .thenIdle(2)
		    .thenWait(() => {
		      test.assertBlockState("open_bit", 1, output);
		    })
		    .thenExecute(() => {
		      test.failIf(() => {
		        test.assertBlockState("open_bit", 0, output);
		      });
		    })
		    .thenWait(() => {
		      test.assertBlockState("button_pressed_bit", 0, input);
		    })
		    .thenSucceed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RedstoneTests", "wire_redirect", (test) => {
		  const levers = [new BlockLocation(6, 2, 1), new BlockLocation(3, 2, 0), new BlockLocation(0, 2, 1)];
		  const wires = [new BlockLocation(5, 2, 4), new BlockLocation(3, 2, 4), new BlockLocation(1, 2, 4)];
		  const fenceGates = [
		    new BlockLocation(5, 3, 1),
		    new BlockLocation(5, 3, 3),
		    new BlockLocation(3, 3, 1),
		    new BlockLocation(3, 3, 3),
		    new BlockLocation(1, 3, 1),
		    new BlockLocation(1, 3, 3),
		  ];
		
		  test
		    .startSequence()
		    .thenExecute(() => {
		      for (const lever of levers) {
		        test.pullLever(lever);
		      }
		    })
		    .thenIdle(6)
		    .thenExecute(() => {
		      for (const wire of wires) {
		        test.assertRedstonePower(wire, 0);
		      }
		    })
		    .thenExecute(() => {
		      for (const fenceGate of fenceGates) {
		        test.assertBlockState("in_wall_bit", 0, fenceGate);
		      }
		    })
		    .thenSucceed();
		})
		  .tag("suite:java_parity")
		  .tag(GameTest.Tags.suiteDisabled); //Floating fence gates are powered differently
		
		GameTest.register("RedstoneTests", "wire_redirect_bedrock", (test) => {
		  const levers = [new BlockLocation(6, 2, 1), new BlockLocation(3, 2, 0), new BlockLocation(0, 2, 1)];
		  const wires = [new BlockLocation(5, 2, 4), new BlockLocation(3, 2, 4), new BlockLocation(1, 2, 4)];
		  const fenceGates = [
		    new BlockLocation(5, 3, 1),
		    new BlockLocation(5, 3, 3),
		    new BlockLocation(3, 3, 1),
		    new BlockLocation(3, 3, 3),
		    new BlockLocation(1, 3, 1),
		    new BlockLocation(1, 3, 3),
		  ];
		
		  test
		    .startSequence()
		    .thenExecute(() => {
		      for (const lever of levers) {
		        test.pullLever(lever);
		      }
		    })
		    .thenIdle(6)
		    .thenExecute(() => {
		      for (const wire of wires) {
		        test.assertRedstonePower(wire, 0);
		      }
		    })
		    .thenExecute(() => {
		      for (const fenceGate of fenceGates) {
		        test.assertBlockState("in_wall_bit", 0, fenceGate);
		      }
		    })
		    .thenSucceed();
		}).tag(GameTest.Tags.suiteDefault);
		
		let observerClock = (test, initialOpenBit) => {
		  const outputPos = new BlockLocation(2, 2, 0);
		
		  const blockPermutation = BlockTypes.trapdoor.createDefaultBlockPermutation();
		  blockPermutation.getProperty(BlockProperties.openBit).value = initialOpenBit;
		
		  test.setBlockPermutation(blockPermutation, outputPos);
		
		  let sequence = test.startSequence();
		
		  sequence.thenWait(() => {
		    test.assertBlockState("open_bit", 1, outputPos);
		  });
		
		  for (let i = 0; i < 8; i++) {
		    sequence
		      .thenWait(() => {
		        test.assertBlockState("open_bit", 0, outputPos);
		      })
		      .thenWait(() => {
		        test.assertBlockState("open_bit", 1, outputPos);
		      });
		  }
		  sequence.thenSucceed();
		};
		
		GameTest.register("RedstoneTests", "observer_clock", (test) => observerClock(test, false))
		  .tag("suite:java_parity") // Trapdoors do not always flip open from observer redstone signal when starting closed
		  .tag(GameTest.Tags.suiteDisabled);
		
		GameTest.register("RedstoneTests", "observer_clock_bedrock", (test) => observerClock(test, true))
		  .structureName("RedstoneTests:observer_clock")
		  .tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RedstoneTests", "repeater_delay_lines", (test) => {
		  const inputPos = new BlockLocation(0, 2, 0);
		
		  const linesPos = [
		    [new BlockLocation(4, 2, 1), new BlockLocation(4, 2, 2), new BlockLocation(4, 2, 3), new BlockLocation(4, 2, 4)], //4-tick delay
		    [new BlockLocation(3, 2, 1), new BlockLocation(3, 2, 2), new BlockLocation(3, 2, 3), new BlockLocation(3, 2, 4)], //3-tick delay
		    [new BlockLocation(2, 2, 1), new BlockLocation(2, 2, 2), new BlockLocation(2, 2, 3), new BlockLocation(2, 2, 4)], //2-tick delay
		    [new BlockLocation(1, 2, 1), new BlockLocation(1, 2, 2), new BlockLocation(1, 2, 3), new BlockLocation(1, 2, 4)], //1-tick delay
		  ];
		
		  const states = [
		    "XXX0",
		    "XX01",
		    "X002",
		    "0013",
		    "001X",
		    "012X",
		    null,
		    "113X",
		    "123X",
		    "12XX",
		    null,
		    "23XX",
		    null,
		    null,
		    "2XXX",
		    "3XXX",
		    null,
		    null,
		    null,
		    "XXXX",
		  ];
		
		  test.pulseRedstone(inputPos, 3);
		
		  let sequence = test.startSequence();
		  for (const state of states) {
		    if (state == null) {
		      sequence = sequence.thenIdle(2);
		    } else {
		      sequence = sequence.thenWaitWithDelay(2, () => {
		        for (let line = 0; line < 4; line++) {
		          const expected = state.charAt(line);
		          const expectedPos = expected == "X" ? -1 : expected - "0";
		          for (let linePos = 0; linePos < 4; linePos++) {
		            const blockWorldPos = test.worldLocation(linesPos[line][linePos]);
		            const block = World.getDimension("overworld").getBlock(blockWorldPos);
		            const blockPerm = block.getBlockData();
		            const blockType = blockPerm.getType();
		
		            if (linePos == expectedPos) {
		              test.assert(
		                blockType.getName() == "minecraft:powered_repeater",
		                "Unexpected Block State. Expected: powered. Actual: unpowered"
		              );
		            } else {
		              test.assert(
		                blockType.getName() == "minecraft:unpowered_repeater",
		                "Unexpected Block State. Expected: unpowered. Actual: powered"
		              );
		            }
		          }
		        }
		      });
		    }
		  }
		  sequence.thenSucceed();
		})
		  .tag("suite:java_parity")
		  .tag(GameTest.Tags.suiteDisabled); //The speed of the redstone pulse is different between Java and Bedrock.
		
		GameTest.register("RedstoneTests", "repeater_delay_lines_bedrock", (test) => {
		  const inputPos = new BlockLocation(0, 2, 0);
		
		  const linesPos = [
		    [new BlockLocation(4, 2, 1), new BlockLocation(4, 2, 2), new BlockLocation(4, 2, 3), new BlockLocation(4, 2, 4)], //4-tick delay
		    [new BlockLocation(3, 2, 1), new BlockLocation(3, 2, 2), new BlockLocation(3, 2, 3), new BlockLocation(3, 2, 4)], //3-tick delay
		    [new BlockLocation(2, 2, 1), new BlockLocation(2, 2, 2), new BlockLocation(2, 2, 3), new BlockLocation(2, 2, 4)], //2-tick delay
		    [new BlockLocation(1, 2, 1), new BlockLocation(1, 2, 2), new BlockLocation(1, 2, 3), new BlockLocation(1, 2, 4)], //1-tick delay
		  ];
		
		  const states = [
		    "XXX0",
		    "XX01",
		    "X002",
		    "0013",
		    "001X",
		    "012X",
		    null,
		    "113X",
		    "123X",
		    "12XX",
		    null,
		    "23XX",
		    null,
		    null,
		    "2XXX",
		    "3XXX",
		    null,
		    null,
		    null,
		    "XXXX",
		  ];
		
		  test.pulseRedstone(inputPos, 3); //Change redstone pulse form 2 ticks to 3.
		
		  let sequence = test.startSequence();
		  for (const state of states) {
		    if (state == null) {
		      sequence = sequence.thenIdle(2);
		    } else {
		      sequence = sequence.thenIdle(2).thenExecute(() => {
		        for (let line = 0; line < 4; line++) {
		          const expected = state.charAt(line);
		          const expectedPos = expected == "X" ? -1 : expected - "0";
		          for (let linePos = 0; linePos < 4; linePos++) {
		            const blockWorldPos = test.worldLocation(linesPos[line][linePos]);
		            const block = World.getDimension("overworld").getBlock(blockWorldPos);
		            const blockPerm = block.getBlockData();
		            const blockType = blockPerm.getType();
		
		            if (linePos == expectedPos) {
		              test.assert(
		                blockType.getName() == "minecraft:powered_repeater",
		                "Unexpected Block State. Expected: powered. Actual: unpowered"
		              );
		            } else {
		              test.assert(
		                blockType.getName() == "minecraft:unpowered_repeater",
		                "Unexpected Block State. Expected: unpowered. Actual: powered"
		              );
		            }
		          }
		        }
		      });
		    }
		  }
		  sequence.thenSucceed();
		})
		  .structureName("RedstoneTests:repeater_delay_lines")
		  .tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RedstoneTests", "repeater_clock", (test) => {
		  const startPos = new BlockLocation(0, 4, 0);
		  const stagesPos = [
		    new BlockLocation(0, 1, 0),
		    new BlockLocation(2, 1, 0),
		    new BlockLocation(2, 1, 2),
		    new BlockLocation(0, 1, 2),
		  ];
		
		  test.pulseRedstone(startPos, 2);
		
		  let sequence = test.startSequence();
		  for (let i = 0; i < 32; i++) {
		    const active = i % 4;
		    sequence = sequence.thenWaitWithDelay(i == 0 ? 0 : 2, () => {
		      for (let b = 0; b < 4; b++) {
		        test.assertBlockState("open_bit", b == active ? 1 : 0, stagesPos[b]);
		      }
		    });
		  }
		  sequence.thenSucceed();
		})
		  .tag("suite:java_parity")
		  .tag(GameTest.Tags.suiteDisabled); //The speed of the redstone pulse is different between Java and Bedrock.
		
		GameTest.register("RedstoneTests", "repeater_clock_bedrock", (test) => {
		  const startPos = new BlockLocation(0, 4, 0);
		  const stagesPos = [
		    new BlockLocation(0, 1, 0),
		    new BlockLocation(2, 1, 0),
		    new BlockLocation(2, 1, 2),
		    new BlockLocation(0, 1, 2),
		  ];
		
		  test.pulseRedstone(startPos, 3); //Change redstone pulse form 2 ticks to 3.
		
		  let sequence = test.startSequence();
		  for (let i = 0; i < 32; i++) {
		    const active = i % 4;
		    sequence = sequence.thenIdle(2).thenExecute(() => {
		      for (let b = 0; b < 4; b++) {
		        test.assertBlockState("open_bit", b == active ? 1 : 0, stagesPos[b]);
		      }
		    });
		  }
		  sequence.thenSucceed();
		})
		  .structureName("RedstoneTests:repeater_clock")
		  .tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RedstoneTests", "torch_nor", (test) => {
		  const inputA = new BlockLocation(4, 2, 0);
		  const inputB = new BlockLocation(0, 2, 0);
		  const output = new BlockLocation(2, 3, 0);
		  const FlatNorthSouth = 0;
		  const FlatEastWest = 1;
		
		  test
		    .startSequence()
		    .thenExecute(() => test.pullLever(inputA))
		    .thenIdle(2)
		    .thenWait(() => {
		      test.assertBlockState("open_bit", FlatEastWest, output);
		    })
		    .thenExecute(() => test.pullLever(inputA))
		    .thenIdle(2)
		    .thenWait(() => {
		      test.assertBlockState("open_bit", FlatEastWest, output);
		    })
		
		    .thenExecute(() => test.pullLever(inputB))
		    .thenIdle(2)
		    .thenWait(() => {
		      test.assertBlockState("open_bit", FlatNorthSouth, output);
		    })
		    .thenExecute(() => test.pullLever(inputB))
		    .thenIdle(2)
		    .thenWait(() => {
		      test.assertBlockState("open_bit", FlatEastWest, output);
		    })
		
		    .thenExecute(() => {
		      test.pullLever(inputA);
		      test.pullLever(inputB);
		    })
		
		    .thenIdle(2)
		    .thenWait(() => {
		      test.assertBlockState("open_bit", FlatNorthSouth, output);
		    })
		    .thenExecute(() => {
		      test.pullLever(inputA);
		      test.pullLever(inputB);
		    })
		    .thenIdle(2)
		    .thenWait(() => {
		      test.assertBlockState("open_bit", FlatEastWest, output);
		    })
		    .thenSucceed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RedstoneTests", "rs_latch", (test) => {
		  const r = new BlockLocation(1, 2, 0);
		  const s = new BlockLocation(2, 2, 5);
		
		  const q = new BlockLocation(0, 4, 2);
		  const notQ = new BlockLocation(3, 4, 3);
		
		  test
		    .startSequence()
		    .thenExecute(() => test.pulseRedstone(r, 2))
		    .thenIdle(4)
		    .thenWait(() => {
		      test.assertBlockState("open_bit", 1, q);
		      test.assertBlockState("open_bit", 0, notQ);
		    })
		    .thenExecute(() => test.pulseRedstone(r, 2))
		    .thenExecuteAfter(4, () => {
		      test.assertBlockState("open_bit", 1, q);
		      test.assertBlockState("open_bit", 0, notQ);
		    })
		
		    .thenExecute(() => test.pulseRedstone(s, 2))
		    .thenIdle(4)
		    .thenWait(() => {
		      test.assertBlockState("open_bit", 0, q);
		      test.assertBlockState("open_bit", 1, notQ);
		    })
		
		    .thenExecute(() => test.pulseRedstone(s, 2))
		    .thenExecuteAfter(4, () => {
		      test.assertBlockState("open_bit", 0, q);
		      test.assertBlockState("open_bit", 1, notQ);
		    })
		    .thenSucceed();
		}).tag(GameTest.Tags.suiteDisabled); // Redstone timing inconsistencies between java and bedrock.
		
		GameTest.register("RedstoneTests", "rs_latch_bedrock", (test) => {
		  const r = new BlockLocation(1, 2, 0);
		  const s = new BlockLocation(2, 2, 5);
		
		  const q = new BlockLocation(0, 4, 2);
		  const notQ = new BlockLocation(3, 4, 3);
		
		  test
		    .startSequence()
		    .thenIdle(2)
		    .thenExecute(() => test.pulseRedstone(r, 4))
		    .thenIdle(6)
		    .thenWait(() => {
		      test.assertBlockState("open_bit", 0, q);
		      test.assertBlockState("open_bit", 1, notQ);
		    })
		    .thenExecute(() => test.pulseRedstone(r, 4))
		    .thenExecuteAfter(6, () => {
		      test.assertBlockState("open_bit", 0, q);
		      test.assertBlockState("open_bit", 1, notQ);
		    })
		
		    .thenExecute(() => test.pulseRedstone(s, 4))
		    .thenIdle(6)
		    .thenWait(() => {
		      test.assertBlockState("open_bit", 1, q);
		      test.assertBlockState("open_bit", 0, notQ);
		    })
		
		    .thenExecute(() => test.pulseRedstone(s, 4))
		    .thenExecuteAfter(6, () => {
		      test.assertBlockState("open_bit", 1, q);
		      test.assertBlockState("open_bit", 0, notQ);
		    })
		    .thenSucceed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("RedstoneTests", "repeater_delay", (test) => {
		  test.setBlockType(BlockTypes.stone, new BlockLocation(0, 2, 5));
		
		  const lamp1 = new BlockLocation(1, 2, 0);
		  const lamp2 = new BlockLocation(3, 2, 0);
		
		  test
		    .startSequence()
		    .thenWait(() => {
		      test.assertRedstonePower(lamp1, 15);
		    })
		    .thenExecute(() => {
		      test.assertRedstonePower(lamp2, 15);
		    })
		    .thenWait(() => {
		      test.assertRedstonePower(lamp1, 0);
		    })
		    .thenExecute(() => {
		      test.assertRedstonePower(lamp2, 0);
		    })
		    .thenSucceed();
		})
		  .maxTicks(TicksPerSecond * 10)
		  .tag(GameTest.Tags.suiteDisabled); //The ticks of Redstone repeater is too short in structure, causing the Redstone lamp will not go out.
		
		GameTest.register("RedstoneTests", "repeater_delay_bedrock", (test) => {
		  test.setBlockType(BlockTypes.stone, new BlockLocation(0, 2, 5));
		
		  const lamp1 = new BlockLocation(1, 2, 0);
		  const lamp2 = new BlockLocation(3, 2, 0);
		
		  test
		    .startSequence()
		    .thenWait(() => {
		      test.assertRedstonePower(lamp1, 15);
		    })
		    .thenExecute(() => {
		      test.assertRedstonePower(lamp2, 15);
		    })
		    .thenWait(() => {
		      test.assertRedstonePower(lamp1, 0);
		    })
		    .thenExecute(() => {
		      test.assertRedstonePower(lamp2, 0);
		    })
		    .thenSucceed();
		})
		  .maxTicks(TicksPerSecond * 10)
		  .tag(GameTest.Tags.suiteDefault); //Change the ticks of Redstone repeater to the longest in structure.
		'''
	Changed script "SmallMobTests.js":
		Total line: 38 (+9, -8)
		        '''
		 1  1   import * as GameTest from "GameTest";
		 2  2   import { BlockLocation } from "Minecraft";
		 3  3   
		 4  4   GameTest.register("SmallMobTests", "fence_corner", (test) => {
		    5 +   const piglinEntityType = "minecraft:piglin<minecraft:entity_born>";
		    6 +   const entityLoc = new BlockLocation(1, 2, 1);
		    7 +   const piglin = test.spawnWithoutBehaviors(piglinEntityType, entityLoc);
		    8 + 
		    9 +   const targetPos = new BlockLocation(3, 2, 3);
		   10 +   test.walkTo(piglin, targetPos, 1);
		   11 +   test.succeedWhenEntityPresent(piglinEntityType, targetPos);
		   12 + }).tag(GameTest.Tags.suiteDefault);
		   13 + 
		   14 + GameTest.register("SmallMobTests", "fence_side", (test) => {
		   15 +   const piglinEntityType = "minecraft:piglin<minecraft:entity_born>";
		   16 +   const entityLoc = new BlockLocation(2, 2, 2);
		   17 +   const piglin = test.spawnWithoutBehaviors(piglinEntityType, entityLoc);
		 5    -     const piglinEntityType = "minecraft:piglin<minecraft:entity_born>";
		 6    -     const entityLoc = new BlockLocation(1, 2, 1);
		 7    -     const piglin = test.spawnWithoutBehaviors(piglinEntityType, entityLoc);
		 8    - 		
		 9    -     const targetPos = new BlockLocation(3, 2, 3);
		10    -     test.walkTo(piglin, targetPos, 1);
		11    -     test.succeedWhenEntityPresent(piglinEntityType, targetPos);
		12    - }).tag(GameTest.Tags.suiteDefault);
		13 18   
		14    - GameTest.register("SmallMobTests", "fence_side", (test) => {
		15    -     const piglinEntityType = "minecraft:piglin<minecraft:entity_born>";
		16    -     const entityLoc = new BlockLocation(2, 2, 2);
		17    -     const piglin = test.spawnWithoutBehaviors(piglinEntityType, entityLoc);
		   19 +   const targetPos = new BlockLocation(0, 2, 2);
		   20 +   test.walkTo(piglin, targetPos, 1);
		   21 +   test.succeedWhenEntityPresent(piglinEntityType, targetPos);
		   22 +   test.runAfterDelay(10, () => {
		   23 +     test.assertCanReachLocation(piglin, targetPos, false);
		   24 +     test.succeed();
		   25 +   });
		18    - 	
		19    -     const targetPos = new BlockLocation(0, 2, 2);
		20    -     test.walkTo(piglin, targetPos, 1);
		21    -     test.succeedWhenEntityPresent(piglinEntityType, targetPos);
		22    -     test.runAfterDelay(10, () => {
		23    -         test.succeedWhenEntityNotPresent(piglinEntityType, targetPos);
		24    -     })
		25 26   }).tag(GameTest.Tags.suiteDefault);
		26 27   
		   28 + GameTest.register("SmallMobTests", "fence_post", (test) => {
		   29 +   const chickenEntityType = "minecraft:chicken";
		27    - GameTest.register("SmallMobTests", "fence_post", (test) => { 
		28    -     const chickenEntityType = "minecraft:chicken";
		   30 +   const entityLoc = new BlockLocation(1, 2, 1);
		   31 +   const chicken = test.spawnWithoutBehaviors(chickenEntityType, entityLoc);
		29    -     const entityLoc = new BlockLocation(1, 2, 1);
		30    -     const chicken = test.spawnWithoutBehaviors(chickenEntityType, entityLoc);
		31 32   
		   33 +   const targetPos = new BlockLocation(3, 2, 3);
		   34 +   test.walkTo(chicken, targetPos, 1);
		32    -     const targetPos = new BlockLocation(3, 2, 3);
		33    -     test.walkTo(chicken, targetPos, 1);
		   35 +   test.succeedWhenEntityPresent(chickenEntityType, targetPos);
		34    -     test.succeedWhenEntityPresent(chickenEntityType, targetPos);
		35 36   })
		36 37     .tag("suite:java_parity")
		37 38     .tag(GameTest.Tags.suiteDisabled); //game parity,the chicken cannot walk between the fenceposts
		        '''