Difference of "scripts" between "1.17.20.22" (beta of "1.17.30") and "1.17.20.23" (beta of "1.17.30").

Changed behavior pack "vanilla_gametest":
	Total script: 22 (+1, -0)
	Changed script "APITests.js":
		Total line: 794 (+39, -39)
		          '''
		      1 + import * as GameTest from "mojang-gametest";
		  1     - import * as GameTest from "GameTest";
		  2   2   import {
		  3   3     BlockLocation,
		  4   4     BlockProperties,
		  5   5     MinecraftBlockTypes,
		  6   6     Direction,
		          ...
		  8   8     MinecraftEffectTypes,
		  9   9     MinecraftItemTypes,
		 10  10     ItemStack,
		 11  11     Location,
		 12  12     World,
		     13 + } from "mojang-minecraft";
		 13     - } from "Minecraft";
		 14  14   
		 15  15   GameTest.register("APITests", "on_entity_created", (test) => {
		 16  16     const entityCreatedCallback = World.events.entityCreate.subscribe((entity) => {
		 17  17       if (entity) {
		 18  18         test.succeed();
		          ...
		 61  61   
		 62  62   GameTest.register("APITests", "spawn_item", (test) => {
		 63  63     const featherItem = new ItemStack(MinecraftItemTypes.feather, 1, 0);
		 64  64     test.spawnItem(featherItem, new Location(1.5, 3.5, 1.5));
		 65  65     test.succeedWhen(() => {
		     66 +     test.assertEntityPresent("minecraft:item", new BlockLocation(1, 2, 1), true);
		 66     -     test.assertEntityPresent("minecraft:item", new BlockLocation(1, 2, 1));
		 67  67     });
		 68  68   }).tag(GameTest.Tags.suiteDefault);
		 69  69   
		 70  70   GameTest.register("APITests", "assert_entity_data", (test) => {
		 71  71     const pigId = "minecraft:pig<minecraft:ageable_grow_up>";
		 72  72     const pigLoc = new BlockLocation(1, 2, 1);
		 73  73     test.spawn(pigId, pigLoc);
		 74  74     test.succeedWhen(() => {
		     75 +     test.assertEntityState(pigLoc, pigId, (entity) => entity.id !== undefined);
		 75     -     test.assertEntityData(pigLoc, pigId, (entity) => entity.id !== undefined);
		 76  76     });
		 77  77   })
		 78  78     .structureName("ComponentTests:animal_pen")
		 79  79     .tag(GameTest.Tags.suiteDefault);
		 80  80   
		          ...
		 83  83     const villagerLoc = new BlockLocation(1, 2, 1);
		 84  84     const villager = test.spawn(villagerId, villagerLoc);
		 85  85     const duration = 20;
		 86  86     villager.addEffect(MinecraftEffectTypes.poison, duration, 1);
		 87  87   
		     88 +   test.assertEntityState(
		 88     -   test.assertEntityData(
		 89  89       villagerLoc,
		 90  90       villagerId,
		 91  91       (entity) => entity.getEffect(MinecraftEffectTypes.poison).duration == duration
		 92  92     );
		     93 +   test.assertEntityState(
		 93     -   test.assertEntityData(
		 94  94       villagerLoc,
		 95  95       villagerId,
		 96  96       (entity) => entity.getEffect(MinecraftEffectTypes.poison).amplifier == 1
		 97  97     );
		 98  98   
		 99  99     test.runAfterDelay(duration, () => {
		    100 +     test.assertEntityState(
		100     -     test.assertEntityData(
		101 101         villagerLoc,
		102 102         villagerId,
		103 103         (entity) => entity.getEffect(MinecraftEffectTypes.poison) === undefined
		104 104       );
		105 105       test.succeed();
		          ...
		120 120   
		121 121     test.spawn(villagerId, villagerLoc);
		122 122     test.spawnItem(emeraldItem, new Location(3.5, 4.5, 3.5));
		123 123   
		124 124     test.succeedWhen(() => {
		    125 +     test.assertEntityPresent(villagerId, villagerLoc, true);
		    126 +     test.assertItemEntityPresent(MinecraftItemTypes.emerald, emeraldItemLoc, 0, true);
		125     -     test.assertEntityPresent(villagerId, villagerLoc);
		126     -     test.assertItemEntityPresent(MinecraftItemTypes.emerald, emeraldItemLoc, 0);
		    127 +     test.assertEntityPresent(armorStandId, armorStandLoc, true);
		127     -     test.assertEntityPresent(armorStandId, armorStandLoc);
		128 128   
		129 129       // Check all blocks surrounding the minecart
		130 130       for (let x = -1; x <= 1; x++) {
		131 131         for (let z = -1; z <= 1; z++) {
		132 132           let offsetLoc = new BlockLocation(minecartLoc.x + x, minecartLoc.y, minecartLoc.z + z);
		133 133           if (x == 0 && z == 0) {
		    134 +           test.assertEntityPresent(minecartId, offsetLoc, true);
		134     -           test.assertEntityPresent(minecartId, offsetLoc);
		135 135           } else {
		    136 +           test.assertEntityPresent(minecartId, offsetLoc, false);
		136     -           test.assertEntityNotPresent(minecartId, offsetLoc);
		137 137           }
		138 138         }
		139 139       }
		140 140     });
		141 141   }).tag(GameTest.Tags.suiteDefault);
		          ...
		145 145     const pigId = "minecraft:pig";
		146 146     const armorStandLoc = new BlockLocation(1, 2, 1);
		147 147     const airLoc = new BlockLocation(0, 2, 1);
		148 148   
		149 149     try {
		    150 +     test.assertEntityPresentInArea(armorStandId, false);
		150     -     test.assertEntityNotPresentInArea(armorStandId);
		151 151       test.fail(); // this assert should throw
		152 152     } catch (e) {}
		153 153   
		154 154     try {
		    155 +     test.assertEntityPresent(armorStandId, armorStandLoc, false);
		155     -     test.assertEntityNotPresent(armorStandId, armorStandLoc);
		156 156       test.fail(); // this assert should throw
		157 157     } catch (e) {}
		158 158   
		    159 +   test.assertEntityPresent(armorStandId, airLoc, false);
		    160 +   test.assertEntityPresentInArea(pigId, false);
		159     -   test.assertEntityNotPresent(armorStandId, airLoc);
		160     -   test.assertEntityNotPresentInArea(pigId);
		161 161   
		162 162     test.succeed();
		163 163   })
		164 164     .structureName("APITests:armor_stand")
		165 165     .tag(GameTest.Tags.suiteDefault);
		          ...
		198 198   }).tag(GameTest.Tags.suiteDefault);
		199 199   
		200 200   GameTest.register("APITests", "assert_entity_touching", (test) => {
		201 201     const armorStandId = "minecraft:armor_stand";
		202 202   
		    203 +   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.5), true);
		    204 +   test.assertEntityTouching(armorStandId, new Location(1.5, 3.5, 1.5), true);
		203     -   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.5));
		204     -   test.assertEntityTouching(armorStandId, new Location(1.5, 3.5, 1.5));
		    205 +   test.assertEntityTouching(armorStandId, new Location(1.0, 2.5, 1.5), false);
		    206 +   test.assertEntityTouching(armorStandId, new Location(2.0, 2.5, 1.5), false);
		    207 +   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 1.0), false);
		    208 +   test.assertEntityTouching(armorStandId, new Location(1.5, 2.5, 2.0), false);
		205     -   test.assertEntityNotTouching(armorStandId, new Location(1.0, 2.5, 1.5));
		206     -   test.assertEntityNotTouching(armorStandId, new Location(2.0, 2.5, 1.5));
		207     -   test.assertEntityNotTouching(armorStandId, new Location(1.5, 2.5, 1.0));
		208     -   test.assertEntityNotTouching(armorStandId, new Location(1.5, 2.5, 2.0));
		209 209   
		210 210     test.succeed();
		211 211   })
		212 212     .structureName("APITests:armor_stand")
		213 213     .tag(GameTest.Tags.suiteDefault);
		          ...
		251 251   
		252 252   GameTest.register("APITests", "create_explosion_basic", (test) => {
		253 253     let overworld = World.getDimension("overworld");
		254 254     const center = new BlockLocation(2, 3, 2);
		255 255   
		    256 +   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		256     -   test.assertBlockTypePresent(MinecraftBlockTypes.cobblestone, center);
		257 257   
		258 258     const loc = test.worldBlockLocation(center);
		259 259     const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		260 260     overworld.createExplosion(explosionLoc, 10, new ExplosionOptions());
		261 261   
		262 262     for (let x = 1; x <= 3; x++) {
		263 263       for (let y = 2; y <= 4; y++) {
		264 264         for (let z = 1; z <= 3; z++) {
		    265 +         test.assertBlockPresent(MinecraftBlockTypes.cobblestone, new BlockLocation(x, y, z), false);
		265     -         test.assertBlockTypeNotPresent(MinecraftBlockTypes.cobblestone, new BlockLocation(x, y, z));
		266 266         }
		267 267       }
		268 268     }
		269 269   
		270 270     test.succeed();
		          ...
		282 282   
		283 283     const loc = test.worldBlockLocation(center);
		284 284     const explosionLoc = new Location(loc.x + 0.5, loc.y + 0.5, loc.z + 0.5);
		285 285     let explosionOptions = new ExplosionOptions();
		286 286   
		    287 +   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		287     -   test.assertBlockTypePresent(MinecraftBlockTypes.cobblestone, center);
		288 288   
		289 289     // Start by exploding without breaking blocks
		290 290     explosionOptions.breaksBlocks = false;
		291 291     const creeper = test.spawn("minecraft:creeper", new BlockLocation(1, 2, 1));
		292 292     explosionOptions.source = creeper;
		    293 +   test.assertEntityPresent(pigId, pigLoc, true);
		293     -   test.assertEntityPresent(pigId, pigLoc);
		294 294     overworld.createExplosion(explosionLoc, 10, explosionOptions);
		295 295     creeper.kill();
		    296 +   test.assertEntityPresent(pigId, pigLoc, false);
		    297 +   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, true);
		296     -   test.assertEntityNotPresent(pigId, pigLoc);
		297     -   test.assertBlockTypePresent(MinecraftBlockTypes.cobblestone, center);
		298 298   
		299 299     // Next, explode with fire
		300 300     explosionOptions = new ExplosionOptions();
		301 301     explosionOptions.causesFire = true;
		302 302   
		303 303     let findFire = () => {
		304 304       let foundFire = false;
		305 305       for (let x = 0; x <= 6; x++) {
		306 306         for (let z = 0; z <= 6; z++) {
		307 307           try {
		    308 +           test.assertBlockPresent(MinecraftBlockTypes.fire, new BlockLocation(x, 3, z), true);
		308     -           test.assertBlockTypePresent(MinecraftBlockTypes.fire, new BlockLocation(x, 3, z));
		309 309             foundFire = true;
		310 310             break;
		311 311           } catch (e) {}
		312 312         }
		313 313       }
		314 314       return foundFire;
		315 315     };
		316 316   
		317 317     test.assert(!findFire(), "Unexpected fire");
		318 318     overworld.createExplosion(explosionLoc, 15, explosionOptions);
		    319 +   test.assertBlockPresent(MinecraftBlockTypes.cobblestone, center, false);
		319     -   test.assertBlockTypeNotPresent(MinecraftBlockTypes.cobblestone, center);
		320 320     test.assert(findFire(), "No fire found");
		321 321   
		322 322     // Finally, explode in water
		323 323     explosionOptions.allowUnderwater = true;
		324 324     const belowWaterLoc = new BlockLocation(3, 1, 3);
		    325 +   test.assertBlockPresent(MinecraftBlockTypes.air, belowWaterLoc, false);
		325     -   test.assertBlockTypeNotPresent(MinecraftBlockTypes.air, belowWaterLoc);
		326 326     overworld.createExplosion(explosionLoc, 10, explosionOptions);
		    327 +   test.assertBlockPresent(MinecraftBlockTypes.air, belowWaterLoc, true);
		327     -   test.assertBlockTypePresent(MinecraftBlockTypes.air, belowWaterLoc);
		328 328     test.succeed();
		329 329   })
		330 330     .padding(10) // The blast can destroy nearby items and mobs
		331 331     .tag(GameTest.Tags.suiteDefault);
		332 332   
		333 333   GameTest.register("APITests", "triggerEvent", (test) => {
		334 334     const creeper = test.spawn("creeper", new BlockLocation(1, 2, 1));
		335 335     creeper.triggerEvent("minecraft:start_exploding_forced");
		336 336   
		337 337     test.succeedWhen(() => {
		    338 +     test.assertEntityPresentInArea("creeper", false);
		338     -     test.assertEntityNotPresentInArea("creeper");
		339 339     });
		340 340   })
		341 341     .structureName("ComponentTests:glass_cage")
		342 342     .tag(GameTest.Tags.suiteDefault);
		343 343   
		          ...
		455 455       .startSequence()
		456 456       .thenExecute(() => {
		457 457         test.pulseRedstone(redstoneLoc, 2);
		458 458       })
		459 459       .thenExecuteAfter(8, () => {
		    460 +       test.assertBlockPresent(MinecraftBlockTypes.air, planksLoc, true);
		460     -       test.assertBlockTypePresent(MinecraftBlockTypes.air, planksLoc);
		461 461         test.assert(expanded, "Expected piston expanding event");
		462 462         test.assert(retracted, "Expected piston retracting event");
		463 463         World.events.beforePistonActivate.unsubscribe(pistonCallback);
		464 464       })
		465 465       .thenSucceed();
		          ...
		486 486       .thenExecute(() => {
		487 487         test.pulseRedstone(redstoneLoc, 2);
		488 488       })
		489 489       .thenExecuteAfter(8, () => {
		490 490         test.assert(canceled, "Expected canceled beforePistonActivate event");
		    491 +       test.assertBlockPresent(MinecraftBlockTypes.planks, planksLoc, true);
		491     -       test.assertBlockTypePresent(MinecraftBlockTypes.planks, planksLoc);
		492 492         World.events.beforePistonActivate.unsubscribe(pistonCallback);
		493 493       })
		494 494       .thenSucceed();
		495 495   })
		496 496     .structureName("APITests:piston")
		          ...
		502 502     const pig = test.spawn(pigId, pigLoc);
		503 503     pig.isSneaking = true;
		504 504     test
		505 505       .startSequence()
		506 506       .thenExecuteAfter(120, () => {
		    507 +       test.assertEntityPresent(pigId, pigLoc, true);
		507     -       test.assertEntityPresent(pigId, pigLoc);
		508 508       })
		509 509       .thenSucceed();
		510 510   })
		511 511     .maxTicks(130)
		512 512     .tag(GameTest.Tags.suiteDefault);
		          ...
		536 536     const beforeExplosionCallback = World.events.beforeExplosion.subscribe((explosionEvent) => {
		537 537       if (!isLocationInTest(test, explosionEvent.impactedBlocks[0])) return;
		538 538       test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		539 539       test.assert(explosionEvent.source !== undefined, "Expected source");
		540 540       test.assert(explosionEvent.impactedBlocks.length === 10, "Unexpected number of impacted blocks");
		    541 +     test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		541     -     test.assertBlockTypePresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		542 542       explosionEvent.impactedBlocks = [test.worldBlockLocation(cobblestoneLoc)];
		543 543     });
		544 544   
		545 545     const explosionCallback = World.events.explosion.subscribe((explosionEvent) => {
		546 546       test.assert(explosionEvent.dimension !== undefined, "Expected dimension");
		          ...
		555 555         test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		556 556         test.spawn("tnt", new BlockLocation(1, 2, 1));
		557 557       })
		558 558       .thenExecuteAfter(60, () => {
		559 559         test.assert(exploded, "Expected explosion event");
		    560 +       test.assertBlockPresent(MinecraftBlockTypes.stone, polishedAndesiteLoc, true);
		    561 +       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, false);
		560     -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, polishedAndesiteLoc);
		561     -       test.assertBlockTypeNotPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		562 562         World.events.beforeExplosion.unsubscribe(beforeExplosionCallback);
		563 563         World.events.explosion.unsubscribe(explosionCallback);
		564 564       })
		565 565       .thenSucceed();
		566 566   })
		          ...
		587 587         test.setBlockType(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		588 588         test.spawn("tnt", new BlockLocation(1, 2, 1));
		589 589       })
		590 590       .thenExecuteAfter(60, () => {
		591 591         test.assert(canceled, "Expected canceled beforeExplosionEvent event");
		    592 +       test.assertBlockPresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc, true);
		592     -       test.assertBlockTypePresent(MinecraftBlockTypes.cobblestone, cobblestoneLoc);
		593 593         World.events.beforeExplosion.unsubscribe(explosionCallback);
		594 594       })
		595 595       .thenSucceed();
		596 596   })
		597 597     .padding(10) // The blast can destroy nearby items and mobs
		          ...
		679 679   
		680 680     const glowLichenPermutation = MinecraftBlockTypes.glowLichen.createDefaultBlockPermutation();
		681 681     glowLichenPermutation.getProperty(BlockProperties.multiFaceDirectionBits).value = 1 << test.getTestDirection();
		682 682     test.setBlockPermutation(glowLichenPermutation, multifaceLoc);
		683 683   
		    684 +   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, multifaceLoc, true);
		    685 +   test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, false);
		684     -   test.assertBlockTypePresent(MinecraftBlockTypes.glowLichen, multifaceLoc);
		685     -   test.assertBlockTypeNotPresent(MinecraftBlockTypes.glowLichen, spreadLoc);
		686 686   
		687 687     test.spreadFromFaceTowardDirection(multifaceLoc, test.getTestDirection(), Direction.down);
		688 688     test
		689 689       .startSequence()
		690 690       .thenExecuteAfter(1, () => {
		    691 +       test.assertBlockPresent(MinecraftBlockTypes.glowLichen, spreadLoc, true);
		691     -       test.assertBlockTypePresent(MinecraftBlockTypes.glowLichen, spreadLoc);
		692 692       })
		693 693       .thenSucceed();
		694 694   })
		695 695     .rotateTest(true)
		696 696     .tag(GameTest.Tags.suiteDefault);
		          ...
		784 784     test.setBlockPermutation(buttonPermutation, buttonLoc);
		785 785   
		786 786     test
		787 787       .startSequence()
		788 788       .thenExecuteAfter(2, () => {
		    789 +       test.assertBlockPresent(MinecraftBlockTypes.stoneButton, buttonLoc, true);
		789     -       test.assertBlockTypePresent(MinecraftBlockTypes.stoneButton, buttonLoc);
		790 790       })
		791 791       .thenSucceed();
		792 792   })
		793 793     .rotateTest(true)
		794 794     .tag(GameTest.Tags.suiteDefault);
		          '''
	Changed script "BigMobTests.js":
		Total line: 87 (+4, -4)
		        '''
		    1 + import * as GameTest from "mojang-gametest";
		    2 + import { BlockLocation } from "mojang-minecraft";
		 1    - import * as GameTest from "GameTest";
		 2    - import { BlockLocation } from "Minecraft";
		 3  3   
		 4  4   const BIGMOB_TEST_MAX_TICKS = 100;
		 5  5   const BIGMOB_TEST_STARTUP_TICKS = 0;
		 6  6   const BIGMOB_REQUIRE = false;
		 7  7   
		        ...
		11 11     let zPos = 1; // in Java, let zPos = (wallSide=="RIGHT")?-0.25:0.25;
		12 12     const spawnType = "minecraft:" + entityType;
		13 13     const mob = test.spawnWithoutBehaviors(spawnType, new BlockLocation(0, 6, zPos));
		14 14     const targetPos = new BlockLocation(7, 2, 1);
		15 15     test.walkTo(mob, targetPos, 1);
		   16 +   test.succeedWhenEntityPresent(spawnType, targetPos, true);
		16    -   test.succeedWhenEntityPresent(spawnType, targetPos);
		17 17   }
		18 18   
		19 19   function createDescendingTest(wallSide, entityType) {
		20 20     const structureName = "BigMobTests:altitude_change_wall_on_" + wallSide.toLowerCase();
		21 21     const testName = "altitude_change_wall_on_" + wallSide.toLowerCase() + "_descend_" + entityType;
		        ...
		46 46   function _ascending(test, entityType) {
		47 47     const spawnType = "minecraft:" + entityType;
		48 48     const targetPos = new BlockLocation(0, 6, 1);
		49 49     const mob = test.spawnWithoutBehaviors(spawnType, new BlockLocation(7, 2, 1));
		50 50     test.walkTo(mob, targetPos, 1);
		   51 +   test.succeedWhenEntityPresent(spawnType, targetPos, true);
		51    -   test.succeedWhenEntityPresent(spawnType, targetPos);
		52 52   }
		53 53   
		54 54   function createAscendingTest(wallSide, entityType) {
		55 55     const structureName = "BigMobTests:altitude_change_wall_on_" + wallSide.toLowerCase();
		56 56     const testName = "altitude_change_wall_on_" + wallSide.toLowerCase() + "_ascend_" + entityType;
		        ...
		        '''
	Changed script "BlockTests.js":
		Total line: 252 (+17, -17)
		          '''
		      1 + import * as GameTest from "mojang-gametest";
		      2 + import { BlockLocation, MinecraftBlockTypes, MinecraftItemTypes, BlockProperties, Direction } from "mojang-minecraft";
		  1     - import * as GameTest from "GameTest";
		  2     - import { BlockLocation, MinecraftBlockTypes, MinecraftItemTypes, BlockProperties, Direction } from "Minecraft";
		  3   3   
		  4   4   const TicksPerSecond = 20;
		  5   5   const FiveSecondsInTicks = 5 * TicksPerSecond;
		  6   6   
		  7   7   const FALLING_SAND_TEMPLATE_NAME = "BlockTests:falling_sand_template";
		          ...
		 34  34   function testThatFallingSandPopsIntoItem(test) {
		 35  35     test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		 36  36     const targetPos = new BlockLocation(1, 2, 1);
		 37  37   
		 38  38     test.succeedWhen(() => {
		     39 +     test.assertEntityPresentInArea("minecraft:item", true);
		     40 +     test.assertEntityPresent("minecraft:falling_block", targetPos, false);
		 39     -     test.assertEntityPresentInArea("minecraft:item");
		 40     -     test.assertEntityNotPresent("minecraft:falling_block", targetPos);
		 41  41     });
		 42  42   }
		 43  43   
		 44  44   function testThatFallingSandReplaces(test) {
		 45  45     test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		     46 +   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.sand, new BlockLocation(1, 2, 1), true);
		 46     -   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.sand, new BlockLocation(1, 2, 1));
		 47  47   }
		 48  48   
		 49  49   function testThatFallingSandLandsOnTop(test) {
		 50  50     test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		     51 +   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.sand, new BlockLocation(1, 3, 1), true);
		 51     -   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.sand, new BlockLocation(1, 3, 1));
		 52  52   }
		 53  53   
		 54  54   ///
		 55  55   // Concrete Tests
		 56  56   ///
		          ...
		115 115   
		116 116   GameTest.register("BlockTests", "concrete_solidifies_in_shallow_water", (test) => {
		117 117     test.setBlockType(MinecraftBlockTypes.concretepowder, new BlockLocation(1, 3, 1));
		118 118   
		119 119     test.succeedWhen(() => {
		    120 +     test.assertBlockPresent(MinecraftBlockTypes.concrete, new BlockLocation(1, 2, 1), true);
		120     -     test.assertBlockTypePresent(MinecraftBlockTypes.concrete, new BlockLocation(1, 2, 1));
		121 121     });
		122 122   })
		123 123     .maxTicks(FiveSecondsInTicks)
		124 124     .tag(GameTest.Tags.suiteDefault);
		125 125   
		126 126   GameTest.register("BlockTests", "concrete_solidifies_in_deep_water", (test) => {
		127 127     test.setBlockType(MinecraftBlockTypes.concretepowder, new BlockLocation(1, 4, 1));
		128 128   
		129 129     test.succeedWhen(() => {
		    130 +     test.assertBlockPresent(MinecraftBlockTypes.concrete, new BlockLocation(1, 2, 1), true);
		130     -     test.assertBlockTypePresent(MinecraftBlockTypes.concrete, new BlockLocation(1, 2, 1));
		131 131     });
		132 132   })
		133 133     .maxTicks(FiveSecondsInTicks)
		134 134     .tag(GameTest.Tags.suiteDefault);
		135 135   
		136 136   GameTest.register("BlockTests", "concrete_solidifies_next_to_water", (test) => {
		137 137     test.setBlockType(MinecraftBlockTypes.concretepowder, new BlockLocation(1, 3, 1));
		138 138   
		139 139     test.succeedWhen(() => {
		    140 +     test.assertBlockPresent(MinecraftBlockTypes.concrete, new BlockLocation(1, 2, 1), true);
		140     -     test.assertBlockTypePresent(MinecraftBlockTypes.concrete, new BlockLocation(1, 2, 1));
		141 141     });
		142 142   })
		143 143     .maxTicks(FiveSecondsInTicks)
		144 144     .tag(GameTest.Tags.suiteDefault);
		145 145   
		146 146   GameTest.register("BlockTests", "sand_fall_boats", (test) => {
		147 147     test.setBlockType(MinecraftBlockTypes.sand, new BlockLocation(1, 4, 1));
		148 148   
		149 149     test.succeedWhen(() => {
		    150 +     test.assertBlockPresent(MinecraftBlockTypes.sand, new BlockLocation(1, 2, 1), true);
		150     -     test.assertBlockTypePresent(MinecraftBlockTypes.sand, new BlockLocation(1, 2, 1));
		151 151     });
		152 152   })
		153 153     .maxTicks(FiveSecondsInTicks)
		154 154     .tag(GameTest.Tags.suiteDefault);
		155 155   
		          ...
		175 175       test.spawn(xpOrb, spawnPos);
		176 176     }
		177 177   
		178 178     // Fail if the turtle egg dies
		179 179     test.failIf(() => {
		    180 +     test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1), true);
		180     -     test.assertBlockTypePresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1));
		181 181     });
		182 182   
		183 183     // Succeed after 4 seconds
		184 184     test.startSequence().thenIdle(80).thenSucceed();
		185 185   })
		          ...
		189 189   GameTest.register("BlockTests", "turtle_eggs_survive_item", (test) => {
		190 190     test.pressButton(new BlockLocation(2, 4, 0));
		191 191   
		192 192     // Fail if the turtle egg dies
		193 193     test.failIf(() => {
		    194 +     test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1), true);
		194     -     test.assertBlockTypePresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1));
		195 195     });
		196 196   
		197 197     // Succeed after 4 seconds
		198 198     test.startSequence().thenIdle(80).thenSucceed();
		199 199   })
		          ...
		202 202   
		203 203   GameTest.register("BlockTests", "turtle_eggs_squished_by_mob", (test) => {
		204 204     const zombieEntityType = "minecraft:husk";
		205 205     const zombiePosition = new BlockLocation(1, 5, 1);
		206 206     test.spawn(zombieEntityType, zombiePosition);
		    207 +   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1), true);
		207     -   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1));
		208 208   })
		209 209     .required(false)
		210 210     .maxTicks(TicksPerSecond * 20)
		211 211     .tag(GameTest.Tags.suiteDefault);
		212 212   
		          ...
		215 215   
		216 216     test.succeedWhen(() => {
		217 217       const redSandstonePos = new BlockLocation(6, 2, 4);
		218 218       const sandstonePos = new BlockLocation(2, 2, 4);
		219 219   
		    220 +     test.assertBlockPresent(MinecraftBlockTypes.redSandstone, redSandstonePos, false);
		    221 +     test.assertBlockPresent(MinecraftBlockTypes.sandstone, sandstonePos, false);
		220     -     test.assertBlockTypeNotPresent(MinecraftBlockTypes.redSandstone, redSandstonePos);
		221     -     test.assertBlockTypeNotPresent(MinecraftBlockTypes.sandstone, sandstonePos);
		    222 +     test.assertItemEntityPresent(MinecraftItemTypes.redSandstone, redSandstonePos, 2.0, true);
		    223 +     test.assertItemEntityPresent(MinecraftItemTypes.sandstone, sandstonePos, 2.0, true);
		222     -     test.assertItemEntityPresent(MinecraftItemTypes.redSandstone, redSandstonePos, 2.0);
		223     -     test.assertItemEntityPresent(MinecraftItemTypes.sandstone, sandstonePos, 2.0);
		224 224     });
		225 225   })
		226 226     .maxTicks(TicksPerSecond * 10)
		227 227     .tag("suite:java_parity")
		228 228     .tag(GameTest.Tags.suiteDisabled) //redSandstone and sandstone items should be present.
		          ...
		230 230   
		231 231   GameTest.register("BlockTests", "concrete_pops_off_waterlogged_chest", (test) => {
		232 232     test.setBlockType(MinecraftBlockTypes.concretepowder, new BlockLocation(1, 4, 1));
		233 233     test.succeedWhen(() => {
		234 234       const chestPos = new BlockLocation(1, 2, 1);
		    235 +     test.assertBlockPresent(MinecraftBlockTypes.chest, chestPos, true);
		    236 +     test.assertItemEntityPresent(MinecraftItemTypes.concretePowder, chestPos, 2, true);
		235     -     test.assertBlockTypePresent(MinecraftBlockTypes.chest, chestPos);
		236     -     test.assertItemEntityPresent(MinecraftItemTypes.concretePowder, chestPos, 2);
		    237 +     test.assertEntityPresentInArea("falling_block", false);
		237     -     test.assertEntityNotPresentInArea("falling_block");
		238 238     });
		239 239   })
		240 240     .maxTicks(TicksPerSecond * 5)
		241 241     .tag(GameTest.Tags.suiteDefault);
		242 242   
		          ...
		          '''
	Changed script "ComponentTests.js":
		Total line: 463 (+3, -3)
		          '''
		      1 + import * as GameTest from "mojang-gametest";
		      2 + import { BlockLocation, MinecraftItemTypes, ItemStack } from "mojang-minecraft";
		  1     - import * as GameTest from "GameTest";
		  2     - import { BlockLocation, MinecraftItemTypes, ItemStack } from "Minecraft";
		  3   3   
		  4   4   function isNear(n1, n2) {
		  5   5     return Math.abs(n1 - n2) < 0.01;
		  6   6   }
		  7   7   
		          ...
		 68  68     leashableComp.leash(pig2);
		 69  69     test.runAtTickTime(20, () => {
		 70  70       leashableComp.unleash();
		 71  71     });
		 72  72     test.succeedWhen(() => {
		     73 +     test.assertEntityPresentInArea("minecraft:item", true); // Make sure the lead dropped
		 73     -     test.assertEntityPresentInArea("minecraft:item"); // Make sure the lead dropped
		 74  74     });
		 75  75   }).tag(GameTest.Tags.suiteDefault);
		 76  76   
		 77  77   GameTest.register("ComponentTests", "health_component", (test) => {
		 78  78     const sheepId = "minecraft:sheep<minecraft:ageable_grow_up>";
		          ...
		          '''
	Changed script "DebugTests.js":
		Total line: 15 (+1, -1)
		        '''
		    1 + import * as GameTest from "mojang-gametest";
		 1    - import * as GameTest from "GameTest";
		 2  2   
		 3  3   GameTest.register("DebugTests", "always_fail", (test) => {
		 4  4     // Do nothing, let the test time out
		 5  5   })
		 6  6     .maxTicks(50)
		        ...
		        '''
	Changed script "DispenserTests.js":
		Total line: 247 (+23, -21)
		          '''
		      1 + import * as GameTest from "mojang-gametest";
		      2 + import { BlockLocation, MinecraftBlockTypes, MinecraftItemTypes, ItemStack } from "mojang-minecraft";
		  1     - import * as GameTest from "GameTest";
		      3 + import GameTestExtensions from "./GameTestExtensions.js";
		  2     - import { BlockLocation, MinecraftBlockTypes, MinecraftItemTypes, ItemStack } from "Minecraft";
		  3   4   
		  4   5   const dispenserDelay = 5; // Number of ticks to wait for the dispenser to use or dispense an item
		  5   6   const armorSlotTorso = 1;
		  6   7   const pinkCarpet = 6;
		  7   8   const tameMountComponentName = "minecraft:tamemount";
		          ...
		  9  10   
		 10  11   GameTest.register("DispenserTests", "dispenser_shears_sheep", (test) => {
		 11  12     const sheepId = "minecraft:sheep<minecraft:ageable_grow_up>";
		 12  13     const entityLoc = new BlockLocation(1, 2, 1);
		 13  14     test.spawn(sheepId, entityLoc);
		     15 +   test.assertEntityPresent(sheepId, entityLoc, true);
		 14     -   test.assertEntityPresent(sheepId, entityLoc);
		 15  16     test.assertEntityHasComponent(sheepId, "minecraft:is_sheared", entityLoc, false);
		 16  17   
		 17  18     test.pressButton(new BlockLocation(0, 2, 0));
		 18  19   
		     20 +   test.assertEntityPresent(sheepId, entityLoc, true);
		 19     -   test.assertEntityPresent(sheepId, entityLoc);
		 20  21     test.succeedWhenEntityHasComponent(sheepId, "minecraft:is_sheared", entityLoc, true);
		 21  22   })
		 22  23     .maxTicks(threeSecondsInTicks)
		 23  24     .tag(GameTest.Tags.suiteDefault);
		 24  25   
		 25  26   GameTest.register("DispenserTests", "dispenser_shears_mooshroom", (test) => {
		 26  27     const cowId = "minecraft:cow<minecraft:ageable_grow_up>";
		 27  28     const mooshroomId = "minecraft:mooshroom<minecraft:ageable_grow_up>";
		 28  29     const entityLoc = new BlockLocation(1, 2, 1);
		 29  30     test.spawn(mooshroomId, entityLoc);
		     31 +   test.assertEntityPresent(mooshroomId, entityLoc, true);
		 30     -   test.assertEntityPresent(mooshroomId, entityLoc);
		 31  32     test.assertEntityHasComponent(mooshroomId, "minecraft:is_sheared", entityLoc, false);
		 32  33     test.pressButton(new BlockLocation(0, 2, 0));
		 33  34   
		     35 +   test.succeedWhenEntityPresent(cowId, entityLoc, true);
		 34     -   test.succeedWhenEntityPresent(cowId, entityLoc);
		 35  36   })
		 36  37     .maxTicks(threeSecondsInTicks)
		 37  38     .tag("suite:java_parity")
		 38  39     .tag(GameTest.Tags.suiteDisabled);
		 39  40   
		 40  41   GameTest.register("DispenserTests", "dispenser_shears_snowgolem", (test) => {
		 41  42     const snowGolemId = "minecraft:snow_golem";
		 42  43     const entityLoc = new BlockLocation(1, 2, 1);
		 43  44     test.spawn(snowGolemId, entityLoc);
		     45 +   test.assertEntityPresent(snowGolemId, entityLoc, true);
		 44     -   test.assertEntityPresent(snowGolemId, entityLoc);
		 45  46     test.assertEntityHasComponent(snowGolemId, "minecraft:is_sheared", entityLoc, false);
		 46  47   
		 47  48     test.pressButton(new BlockLocation(0, 2, 0));
		 48  49   
		     50 +   test.assertEntityPresent(snowGolemId, entityLoc, true);
		 49     -   test.assertEntityPresent(snowGolemId, entityLoc);
		 50  51     test.succeedWhenEntityHasComponent(snowGolemId, "minecraft:is_sheared", entityLoc, true);
		 51  52   })
		 52  53     .maxTicks(threeSecondsInTicks)
		 53  54     .tag("suite:java_parity")
		 54  55     .tag(GameTest.Tags.suiteDisabled);
		          ...
		 61  62   
		 62  63     test.assertEntityHasArmor(horseId, armorSlotTorso, "", 0, entityLoc, false);
		 63  64   
		 64  65     test.pressButton(new BlockLocation(0, 2, 0));
		 65  66   
		     67 +   test.assertEntityPresent(horseId, entityLoc, true);
		 66     -   test.assertEntityPresent(horseId, entityLoc);
		 67  68     test.succeedOnTickWhen(dispenserDelay, () => {
		 68  69       test.assertContainerEmpty(new BlockLocation(0, 2, 1));
		 69  70       test.assertEntityHasArmor(horseId, armorSlotTorso, "diamond_horse_armor", 0, entityLoc, true);
		 70  71     });
		 71  72   })
		          ...
		 79  80     test.spawn(pigId, entityLoc);
		 80  81     test.assertEntityHasComponent(pigId, "minecraft:is_saddled", entityLoc, false);
		 81  82   
		 82  83     test.pressButton(new BlockLocation(0, 2, 0));
		 83  84   
		     85 +   test.assertEntityPresent(pigId, entityLoc, true);
		 84     -   test.assertEntityPresent(pigId, entityLoc);
		 85  86     test.succeedOnTickWhen(dispenserDelay, () => {
		 86  87       test.assertContainerEmpty(new BlockLocation(0, 2, 1));
		 87  88       test.assertEntityHasComponent(pigId, "minecraft:is_saddled", entityLoc, true);
		 88  89     });
		 89  90   })
		          ...
		 99 100     horse.getComponent(tameMountComponentName).setTamed(false);
		100 101     test.assertEntityHasComponent(horseId, "minecraft:is_saddled", entityLoc, false);
		101 102   
		102 103     test.pressButton(new BlockLocation(0, 2, 0));
		103 104   
		    105 +   test.assertEntityPresent(horseId, entityLoc, true);
		104     -   test.assertEntityPresent(horseId, entityLoc);
		105 106     test.succeedOnTickWhen(dispenserDelay, () => {
		106 107       test.assertContainerEmpty(new BlockLocation(0, 2, 1));
		107 108       test.assertEntityHasComponent(horseId, "minecraft:is_saddled", entityLoc, true);
		108 109     });
		109 110   })
		          ...
		119 120     test.assertEntityHasComponent(llamaId, "minecraft:is_chested", entityLoc, false);
		120 121     test.assertEntityHasArmor(llamaId, armorSlotTorso, "", 0, entityLoc, false);
		121 122   
		122 123     test.pressButton(new BlockLocation(0, 2, 0));
		123 124   
		    125 +   test.assertEntityPresent(llamaId, entityLoc, true);
		124     -   test.assertEntityPresent(llamaId, entityLoc);
		125 126     test.succeedOnTickWhen(dispenserDelay, () => {
		126 127       test.assertContainerEmpty(new BlockLocation(0, 2, 1));
		127 128       test.assertEntityHasComponent(llamaId, "minecraft:is_chested", entityLoc, true);
		128 129     });
		129 130   })
		          ...
		138 139     llama.getComponent(tameMountComponentName).setTamed(false);
		139 140     test.assertEntityHasArmor(llamaId, armorSlotTorso, "", 0, entityLoc, false);
		140 141   
		141 142     test.pressButton(new BlockLocation(0, 2, 0));
		142 143   
		    144 +   test.assertEntityPresent(llamaId, entityLoc, true);
		143     -   test.assertEntityPresent(llamaId, entityLoc);
		144 145     test.succeedOnTickWhen(dispenserDelay, () => {
		145 146       test.assertContainerEmpty(new BlockLocation(0, 2, 1));
		146 147       test.assertEntityHasArmor(llamaId, armorSlotTorso, "minecraft:carpet", pinkCarpet, entityLoc, true);
		147 148     });
		148 149   })
		          ...
		150 151     .tag("suite:java_parity")
		151 152     .tag(GameTest.Tags.suiteDisabled);
		152 153   
		153 154   function dispenserMinecartTest(test, entityId) {
		154 155     const minecartPos = new BlockLocation(1, 2, 1);
		    156 +   test.assertEntityPresent(entityId, minecartPos, false);
		155     -   test.assertEntityNotPresent(entityId, minecartPos);
		156 157   
		157 158     test.pressButton(new BlockLocation(0, 2, 0));
		158 159   
		159 160     test.succeedOnTickWhen(dispenserDelay, () => {
		160 161       test.assertContainerEmpty(new BlockLocation(0, 2, 1));
		    162 +     test.assertEntityPresent(entityId, minecartPos, true);
		161     -     test.assertEntityPresent(entityId, minecartPos);
		162 163     });
		163 164   }
		164 165   
		165 166   GameTest.register("DispenserTests", "dispenser_minecart_track", (test) => {
		166 167     dispenserMinecartTest(test, "minecraft:minecart");
		          ...
		175 176     .tag(GameTest.Tags.suiteDefault);
		176 177   
		177 178   GameTest.register("DispenserTests", "dispenser_water", (test) => {
		178 179     const waterPos = new BlockLocation(1, 2, 1);
		179 180     const dispenserPos = new BlockLocation(0, 2, 1);
		    181 +   test.assertBlockPresent(MinecraftBlockTypes.water, waterPos, false);
		180     -   test.assertBlockTypeNotPresent(MinecraftBlockTypes.water, waterPos);
		181 182     test.assertContainerContains(new ItemStack(MinecraftItemTypes.waterBucket, 1, 0), dispenserPos);
		182 183   
		183 184     test.pressButton(new BlockLocation(0, 2, 0));
		184 185   
		185 186     test.succeedOnTickWhen(dispenserDelay, () => {
		186 187       test.assertContainerContains(new ItemStack(MinecraftItemTypes.bucket, 1, 0), dispenserPos);
		    188 +     test.assertBlockPresent(MinecraftBlockTypes.water, waterPos, true);
		187     -     test.assertBlockTypePresent(MinecraftBlockTypes.water, waterPos);
		188 189     });
		189 190   })
		190 191     .maxTicks(threeSecondsInTicks)
		191 192     .tag(GameTest.Tags.suiteDefault);
		192 193   
		193 194   GameTest.register("DispenserTests", "dispenser_arrow_trap", (test) => {
		194 195     const sheepId = "minecraft:sheep<minecraft:ageable_grow_up>";
		195 196     const sheepPos = new BlockLocation(4, 2, 2);
		196 197     test.spawn(sheepId, sheepPos);
		    198 +   test.assertEntityPresent(sheepId, sheepPos, true);
		197     -   test.assertEntityPresent(sheepId, sheepPos);
		198 199     test.pullLever(new BlockLocation(2, 3, 2));
		    200 +   test.succeedWhenEntityPresent(sheepId, sheepPos, false);
		199     -   test.succeedWhenEntityNotPresent(sheepId, sheepPos);
		200 201   })
		201 202     .maxTicks(200)
		202 203     .tag(GameTest.Tags.suiteDefault);
		203 204   
		204 205   GameTest.register("DispenserTests", "dispenser_charge_respawn_anchor", (test) => {
		    206 +   const testEx = new GameTestExtensions(test);
		205 207     test.pressButton(new BlockLocation(0, 2, 0));
		206 208     const respawnAnchorPos = new BlockLocation(1, 2, 1);
		207 209     const dispenserPos = new BlockLocation(0, 2, 1);
		208 210     test.assertContainerContains(new ItemStack(MinecraftItemTypes.glowstone, 1, 0), dispenserPos);
		209 211   
		    212 +   testEx.assertBlockProperty("respawn_anchor_charge", 0, respawnAnchorPos);
		210     -   test.assertBlockState("respawn_anchor_charge", 0, respawnAnchorPos);
		211 213     test.succeedWhen(() => {
		    214 +     testEx.assertBlockProperty("respawn_anchor_charge", 1, respawnAnchorPos);
		212     -     test.assertBlockState("respawn_anchor_charge", 1, respawnAnchorPos);
		213 215       test.assertContainerEmpty(dispenserPos);
		214 216     });
		215 217   })
		216 218     .maxTicks(threeSecondsInTicks)
		217 219     .tag(GameTest.Tags.suiteDefault);
		          ...
		227 229       new BlockLocation(2, 7, 1),
		228 230     ];
		229 231   
		230 232     test.succeedOnTickWhen(dispenserDelay, () => {
		231 233       for (const pos of firePositions) {
		    234 +       test.assertBlockPresent(MinecraftBlockTypes.fire, pos, true);
		232     -       test.assertBlockTypePresent(MinecraftBlockTypes.fire, pos);
		233 235       }
		234 236     });
		235 237   })
		236 238     .maxTicks(threeSecondsInTicks)
		237 239     .tag(GameTest.Tags.suiteDefault);
		          ...
		          '''
	Changed script "DoorTests.js":
		Total line: 117 (+34, -32)
		          '''
		      1 + import * as GameTest from "mojang-gametest";
		      2 + import { BlockLocation } from "mojang-minecraft";
		  1     - import * as GameTest from "GameTest";
		  2     - import { BlockLocation } from "Minecraft";
		  3   3   
		  4   4   const DOOR_TEST_PADDING = 100; // The padding for the door tests will need to be increased some more to prevent the interference
		  5   5   
		  6   6   GameTest.register("DoorTests", "four_villagers_one_door", (test) => {
		  7   7     const villagerEntityType = "minecraft:villager_v2";
		      8 +   const villagerEntitySpawnType = "minecraft:villager_v2<minecraft:spawn_farmer>"; // Attempt to spawn the villagers as farmers
		  8     -   const villagerEntitySpawnType =
		  9     -     "minecraft:villager_v2<minecraft:spawn_farmer>"; // Attempt to spawn the villagers as farmers
		 10   9   
		 11  10     test.spawn(villagerEntitySpawnType, new BlockLocation(5, 2, 4));
		 12  11     test.spawn(villagerEntitySpawnType, new BlockLocation(4, 2, 5));
		 13  12     test.spawn(villagerEntitySpawnType, new BlockLocation(2, 2, 5));
		 14  13     test.spawn(villagerEntitySpawnType, new BlockLocation(1, 2, 4));
		 15  14   
		 16  15     test.succeedWhen(() => {
		     16 +     test.assertEntityPresent(villagerEntityType, new BlockLocation(5, 2, 2), true);
		     17 +     test.assertEntityPresent(villagerEntityType, new BlockLocation(5, 2, 1), true);
		 17     -     test.assertEntityPresent(villagerEntityType, new BlockLocation(5, 2, 2));
		 18     -     test.assertEntityPresent(villagerEntityType, new BlockLocation(5, 2, 1));
		     18 +     test.assertEntityPresent(villagerEntityType, new BlockLocation(1, 2, 2), true);
		     19 +     test.assertEntityPresent(villagerEntityType, new BlockLocation(1, 2, 1), true);
		 19     -     test.assertEntityPresent(villagerEntityType, new BlockLocation(1, 2, 2));
		 20     -     test.assertEntityPresent(villagerEntityType, new BlockLocation(1, 2, 1));
		 21  20     });
		 22  21   })
		 23  22     .tag(GameTest.Tags.suiteDisabled) // Villagers can get stuck on the door or on sleeping villagers
		 24  23     .padding(DOOR_TEST_PADDING) // Space out villager tests to stop them from confusing each other
		 25  24     .batch("night") // This should be a constant at some point
		     25 +   .maxTicks(600);
		     26 + 
		     27 + GameTest.register("DoorTests", "villagers_can_pass_open_iron_door", (test) => {
		     28 +   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		 26     -   .maxTicks(600);  
		 27  29   
		 28     - GameTest.register("DoorTests", "villagers_can_pass_open_iron_door", (test) => {
		 29     - 	const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		 30     - 	
		     30 +   test.spawn(villagerActor, new BlockLocation(2, 2, 5));
		     31 + 
		     32 +   test.succeedWhenEntityPresent(villagerActor, new BlockLocation(1, 2, 1), true);
		 31     - 	test.spawn(villagerActor, new BlockLocation(2, 2, 5));
		 32     - 	
		 33     - 	test.succeedWhenEntityPresent(villagerActor, new BlockLocation(1, 2, 1));
		 34  33   })
		     34 +   .maxTicks(900) //Increase max ticks from 200 to 900 (same value as in PathFindingTests), to make sure villager can find and go to bed
		     35 +   .batch("night")
		     36 +   .required(false)
		     37 +   .padding(DOOR_TEST_PADDING)
		     38 +   .tag(GameTest.Tags.suiteDefault);
		     39 + 
		     40 + GameTest.register("DoorTests", "villagers_cant_pass_closed_iron_door", (test) => {
		     41 +   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		     42 + 
		     43 +   test.spawn(villagerActor, new BlockLocation(2, 2, 5));
		     44 + 
		     45 +   test
		     46 +     .startSequence()
		     47 +     .thenExecute(() => {
		     48 +       test.assertEntityPresent(villagerActor, new BlockLocation(1, 2, 1), false);
		     49 +     })
		     50 +     .thenIdle(200)
		     51 +     .thenSucceed();
		 35     - 	.maxTicks(900)   //Increase max ticks from 200 to 900 (same value as in PathFindingTests), to make sure villager can find and go to bed  
		 36     - 	.batch("night")
		 37     - 	.required(false)
		 38     - 	.padding(DOOR_TEST_PADDING)
		 39     - 	.tag(GameTest.Tags.suiteDefault);
		 40     - 	
		 41     - GameTest.register("DoorTests", "villagers_cant_pass_closed_iron_door", (test) =>{
		 42     - 	const villagerActor ="minecraft:villager_v2<minecraft:spawn_farmer>"
		 43     - 	
		 44     - 	test.spawn(villagerActor, new BlockLocation(2, 2, 5));
		 45     - 	
		 46     - 	test.startSequence()
		 47     - 	.thenExecute(() =>{test.assertEntityNotPresent(villagerActor,new BlockLocation(1, 2, 1));})
		 48     - 	.thenIdle(200) 
		 49     - 	.thenSucceed()
		 50  52   })
		     53 +   .maxTicks(220)
		     54 +   .padding(DOOR_TEST_PADDING)
		 51     - 	.maxTicks(220)
		 52     - 	.padding(DOOR_TEST_PADDING)
		     55 +   .batch("night")
		     56 +   .required(false)
		     57 +   .tag(GameTest.Tags.suiteDefault);
		 53     - 	.batch("night")
		 54     - 	.required(false)
		 55     - 	.tag(GameTest.Tags.suiteDefault);
		 56  58   
		 57  59   GameTest.register("DoorTests", "door_maze", (test) => {
		     60 +   const villagerActor = "minecraft:villager_v2";
		 58     - 	const villagerActor = "minecraft:villager_v2";
		 59  61   
		     62 +   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		 60     - 	test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		 61  63   
		     64 +   test.succeedWhenEntityPresent(villagerActor, new BlockLocation(7, 2, 7), true);
		 62     - 	test.succeedWhenEntityPresent(villagerActor, new BlockLocation(7, 2, 7));
		 63  65   })
		     66 +   .maxTicks(400)
		     67 +   .padding(DOOR_TEST_PADDING)
		 64     - 	.maxTicks(400)
		 65     - 	.padding(DOOR_TEST_PADDING)
		     68 +   .batch("night")
		     69 +   .required(false)
		     70 +   .tag(GameTest.Tags.suiteDisabled); // Both of Java and Bedrock are failed villager is stuck and doesn't find the good way.
		 66     - 	.batch("night")
		 67     - 	.required(false)
		 68     - 	.tag(GameTest.Tags.suiteDisabled); // Both of Java and Bedrock are failed villager is stuck and doesn't find the good way.
		 69  71   
		 70  72   GameTest.register("DoorTests", "door_maze_3d", (test) => {
		     73 +   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		 71     - 	const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		 72  74   
		     75 +   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		 73     - 	test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		 74  76   
		     77 +   test.succeedWhenEntityPresent(villagerActor, new BlockLocation(7, 2, 7), true);
		 75     - 	test.succeedWhenEntityPresent(villagerActor, new BlockLocation(7, 2, 7));
		 76  78   })
		     79 +   .maxTicks(400)
		     80 +   .padding(DOOR_TEST_PADDING)
		 77     - 	.maxTicks(400)
		 78     - 	.padding(DOOR_TEST_PADDING)
		     81 +   .batch("night")
		     82 +   .required(false)
		     83 +   .tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed looks like he doesn't cross obstacle and doesn't find the good way.
		 79     - 	.batch("night")
		 80     - 	.required(false)
		 81     - 	.tag(GameTest.Tags.suiteDisabled);  //Both of Java and Bedrock are failed looks like he doesn't cross obstacle and doesn't find the good way.
		 82  84   
		 83  85   GameTest.register("DoorTests", "door_maze_crowded", (test) => {
		     86 +   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		 84     - 	const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		 85  87   
		     88 +   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		     89 +   test.spawn(villagerActor, new BlockLocation(3, 2, 2));
		 86     - 	test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		 87     - 	test.spawn(villagerActor, new BlockLocation(3, 2, 2));
		     90 +   test.spawn(villagerActor, new BlockLocation(5, 2, 1));
		     91 +   test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		 88     - 	test.spawn(villagerActor, new BlockLocation(5, 2, 1));
		 89     - 	test.spawn(villagerActor, new BlockLocation(1, 2, 1));
		 90  92   
		     93 +   test.succeedWhen(() => {
		     94 +     test.assertEntityPresent(villagerActor, new BlockLocation(7, 2, 7), true);
		 91     - 	test.succeedWhen(() => {
		 92     - 		test.assertEntityPresent(villagerActor, new BlockLocation(7, 2, 7));
		     95 +     test.assertEntityPresent(villagerActor, new BlockLocation(4, 2, 8), true);
		     96 +     test.assertEntityPresent(villagerActor, new BlockLocation(2, 2, 7), true);
		     97 +     test.assertEntityPresent(villagerActor, new BlockLocation(1, 2, 8), true);
		     98 +   });
		 93     - 		test.assertEntityPresent(villagerActor, new BlockLocation(4, 2, 8));
		 94     - 		test.assertEntityPresent(villagerActor, new BlockLocation(2, 2, 7));
		 95     - 		test.assertEntityPresent(villagerActor, new BlockLocation(1, 2, 8));
		 96     - 	});
		 97  99   })
		    100 +   .maxTicks(400)
		    101 +   .padding(DOOR_TEST_PADDING)
		 98     - 	.maxTicks(400)
		 99     - 	.padding(DOOR_TEST_PADDING)
		    102 +   .batch("night")
		    103 +   .required(false)
		    104 +   .tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed, some villiages are stuck behind the door and doesn't find the path.
		    105 + 
		100     - 	.batch("night")
		101     - 	.required(false)
		102     - 	.tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed, some villiages are stuck behind the door and doesn't find the path.
		103     - 	
		104 106   GameTest.register("DoorTests", "inverted_door", (test) => {
		    107 +   const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		    108 + 
		105     - 	const villagerActor = "minecraft:villager_v2<minecraft:spawn_farmer>";
		106     - 	
		    109 +   test.spawn(villagerActor, new BlockLocation(3, 2, 1));
		    110 + 
		    111 +   test.succeedWhenEntityPresent(villagerActor, new BlockLocation(3, 2, 5), true);
		107     - 	test.spawn(villagerActor, new BlockLocation(3, 2, 1));
		108     - 	
		109     - 	test.succeedWhenEntityPresent(villagerActor, new BlockLocation(3, 2, 5));
		110 112   })
		    113 +   .maxTicks(200)
		    114 +   .padding(DOOR_TEST_PADDING)
		111     - 	.maxTicks(200)
		112     - 	.padding(DOOR_TEST_PADDING)
		    115 +   .batch("night")
		    116 +   .required(false)
		    117 +   .tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed, village is stuck behind the door, at there all time.
		113     - 	.batch("night")
		114     - 	.required(false)
		115     - 	.tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed, village is stuck behind the door, at there all time.
		          '''
	Changed script "DuplicationTests.js":
		Total line: 70 (+5, -3)
		        '''
		    1 + import * as GameTest from "mojang-gametest";
		    2 + import { BlockLocation, MinecraftItemTypes } from "mojang-minecraft";
		 1    - import * as GameTest from "GameTest";
		 2    - import { BlockLocation, MinecraftItemTypes } from "Minecraft";
		 3  3   
		 4  4   function poweredRailTest(test, pulseTicks) {
		 5  5     test.pulseRedstone(new BlockLocation(1, 2, 3), pulseTicks);
		 6  6   
		 7  7     test
		        ...
		39 39     test.spawn("minecraft:minecart", new BlockLocation(1, 3, 2));
		40 40   
		41 41     test
		42 42       .startSequence()
		43 43       .thenIdle(3)
		   44 +     .thenExecute(() =>
		   45 +       test.assertItemEntityCountIs(MinecraftItemTypes.detectorRail, new BlockLocation(1, 2, 1), 1.0, 1)
		   46 +     )
		44    -     .thenExecute(() => test.assertItemEntityCountIs(MinecraftItemTypes.detectorRail, new BlockLocation(1, 2, 1), 1.0, 1))
		45 47       .thenSucceed();
		46 48   }).tag(GameTest.Tags.suiteDefault);
		47 49   
		48 50   function railClassicTest(test, pulseTicks) {
		49 51     test.pulseRedstone(new BlockLocation(1, 5, 5), pulseTicks);
		        ...
		        '''
	Changed script "EntityTests.js":
		Total line: 44 (+4, -4)
		        '''
		    1 + import * as GameTest from "mojang-gametest";
		    2 + import { BlockLocation, MinecraftItemTypes, ItemStack, Location } from "mojang-minecraft";
		 1    - import * as GameTest from "GameTest";
		 2    - import { BlockLocation, MinecraftItemTypes, ItemStack, Location } from "Minecraft";
		 3  3   
		 4  4   function shallowItemStream(test) {
		 5  5     const lampPos = new BlockLocation(0, 1, 1);
		 6  6     let emerald = new ItemStack(MinecraftItemTypes.emerald, 1, 0);
		 7  7     test.assertRedstonePower(lampPos, 0);
		        ...
		30 30     test.spawnItem(netheriteHelmet, new Location(7.5, 4.0, 1.5));
		31 31   
		32 32     test
		33 33       .startSequence()
		34 34       .thenIdle(60)
		   35 +     .thenExecute(() => test.assertEntityPresent(itemEntityId, new BlockLocation(1, 2, 1)), true) // sink
		   36 +     .thenExecute(() => test.assertEntityPresent(itemEntityId, new BlockLocation(2, 2, 1)), false) // float
		35    -     .thenExecute(() => test.assertEntityPresent(itemEntityId, new BlockLocation(1, 2, 1))) // sink
		36    -     .thenExecute(() => test.assertEntityNotPresent(itemEntityId, new BlockLocation(2, 2, 1))) // float
		   37 +     .thenExecute(() => test.assertEntityPresent(itemEntityId, new BlockLocation(3, 2, 1)), false) // float
		   38 +     .thenExecute(() => test.assertEntityPresent(itemEntityId, new BlockLocation(5, 2, 1)), true) // sink
		   39 +     .thenExecute(() => test.assertEntityPresent(itemEntityId, new BlockLocation(6, 2, 1)), false) // float
		   40 +     .thenExecute(() => test.assertEntityPresent(itemEntityId, new BlockLocation(7, 2, 1)), false) // float
		37    -     .thenExecute(() => test.assertEntityNotPresent(itemEntityId, new BlockLocation(3, 2, 1))) // float
		38    -     .thenExecute(() => test.assertEntityPresent(itemEntityId, new BlockLocation(5, 2, 1))) // sink
		39    -     .thenExecute(() => test.assertEntityNotPresent(itemEntityId, new BlockLocation(6, 2, 1))) // float
		40    -     .thenExecute(() => test.assertEntityNotPresent(itemEntityId, new BlockLocation(7, 2, 1))) // float
		41 41       .thenSucceed();
		42 42   })
		43 43     .tag("suite:java_parity")
		44 44     .tag(GameTest.Tags.suiteDisabled); // In Bedrock, item entities don't rest on the enchanting table after falling through the water block
		        '''
	Changed script "ExtensionTests.js":
		Total line: 26 (+3, -3)
		        '''
		    1 + import * as GameTest from "mojang-gametest";
		 1    - import * as GameTest from "GameTest";
		 2  2   import GameTestExtensions from "./GameTestExtensions.js";
		    3 + import { BlockLocation } from "mojang-minecraft";
		 3    - import { BlockLocation } from "Minecraft";
		 4  4   
		 5  5   GameTest.register("ExtensionTests", "add_entity_in_boat", (test) => {
		 6  6     const testEx = new GameTestExtensions(test);
		 7  7     testEx.addEntityInBoat("sheep", new BlockLocation(1, 2, 1));
		 8  8     test.succeed();
		        ...
		16 16     const villager = test.spawn(villagerId, new BlockLocation(2, 2, 2));
		17 17   
		18 18     testEx.makeAboutToDrown(villager);
		19 19   
		20 20     test.succeedWhen(() => {
		   21 +     test.assertEntityPresentInArea(villagerId, false);
		21    -     test.assertEntityNotPresentInArea(villagerId);
		22 22     });
		23 23   })
		24 24     .structureName("ComponentTests:aquarium")
		25 25     .maxTicks(20)
		26 26     .tag(GameTest.Tags.suiteDefault);
		        '''
	Changed script "FireAvoidTests.js":
		Total line: 205 (+76, -81)
		          '''
		  1     - import * as GameTest from "GameTest";
		  2     - import { BlockLocation} from "Minecraft";
		  3     - 
		  4     - const TicksPerSecond = 20;
		  5     - const runWalkTestTicks = 5 * TicksPerSecond;
		  6     - 
		  7     - function runWalkTest(test, args) {
		  8     -     const spawnPosition = args["spawnPosition"];
		  9     -     const targetPosition = args["targetPosition"];
		      1 + import * as GameTest from "mojang-gametest";
		      2 + import { BlockLocation } from "mojang-minecraft";
		 10     -     const CanTakeDamage = args["CanTakeDamage"];
		 11     -     const shouldReachTarget = args["shouldReachTarget"];
		 12   3   
		      4 + const TicksPerSecond = 20;
		 13     -     const entityType = "minecraft:villager_v2";
		 14     -     const villagerEntitySpawnType =
		      5 + const runWalkTestTicks = 5 * TicksPerSecond;
		 15     -         "minecraft:villager_v2<minecraft:spawn_farmer>"; // Attempt to spawn the villagers as farmers
		 16   6   
		      7 + function runWalkTest(test, args) {
		      8 +   const spawnPosition = args["spawnPosition"];
		      9 +   const targetPosition = args["targetPosition"];
		     10 +   const CanTakeDamage = args["CanTakeDamage"];
		     11 +   const shouldReachTarget = args["shouldReachTarget"];
		 17     -     let villager = test.spawnWithoutBehaviors(villagerEntitySpawnType, spawnPosition);
		 18     -     test.walkTo(villager, targetPosition, 1);
		 19  12   
		     13 +   const entityType = "minecraft:villager_v2";
		     14 +   const villagerEntitySpawnType = "minecraft:villager_v2<minecraft:spawn_farmer>"; // Attempt to spawn the villagers as farmers
		 20     -     const startingHealth = villager.getComponent("minecraft:health").current
		 21  15   
		 22     -     test.runAfterDelay(runWalkTestTicks - 1, () => {
		 23     -         if (shouldReachTarget) {
		 24     -             test.assertEntityPresent(entityType, targetPosition);
		     16 +   let villager = test.spawnWithoutBehaviors(villagerEntitySpawnType, spawnPosition);
		     17 +   test.walkTo(villager, targetPosition, 1);
		     18 + 
		     19 +   const startingHealth = villager.getComponent("minecraft:health").current;
		 25     -         }
		 26     -         else {
		 27     -             test.assertEntityNotPresent(entityType, targetPosition);
		 28     -         }
		 29  20   
		     21 +   test.runAfterDelay(runWalkTestTicks - 1, () => {
		     22 +     if (shouldReachTarget) {
		     23 +       test.assertEntityPresent(entityType, targetPosition, true);
		     24 +     } else {
		     25 +       test.assertEntityPresent(entityType, targetPosition, false);
		     26 +     }
		 30     -         if (!CanTakeDamage && villager.getComponent("minecraft:health").current < startingHealth) {
		 31     -             test.fail("The villager has taken damage");
		 32     -         }
		 33  27   
		     28 +     if (!CanTakeDamage && villager.getComponent("minecraft:health").current < startingHealth) {
		     29 +       test.fail("The villager has taken damage");
		 34     -         test.succeed();
		     30 +     }
		 35     -     });
		 36  31   
		     32 +     test.succeed();
		     33 +   });
		 37  34   }
		 38  35   
		 39  36   GameTest.register("FireAvoidTests", "can_walk_around_lava", (test) => {
		     37 +   runWalkTest(test, {
		     38 +     spawnPosition: new BlockLocation(2, 3, 4),
		 40     -     runWalkTest(test, {
		 41     -         spawnPosition: new BlockLocation(2, 3, 4),
		     39 +     targetPosition: new BlockLocation(2, 3, 1),
		     40 +     CanTakeDamage: false,
		     41 +     shouldReachTarget: true,
		     42 +   });
		 42     -         targetPosition: new BlockLocation(2, 3, 1),
		 43     -         CanTakeDamage: false,
		 44     -         shouldReachTarget: true
		 45     -     });
		 46  43   })
		     44 +   .maxTicks(runWalkTestTicks)
		     45 +   .tag(GameTest.Tags.suiteDefault);
		 47     -     .maxTicks(runWalkTestTicks)
		 48     -     .tag(GameTest.Tags.suiteDefault);
		 49  46   
		 50  47   GameTest.register("FireAvoidTests", "dont_cut_corner_over_fire", (test) => {
		     48 +   runWalkTest(test, {
		     49 +     spawnPosition: new BlockLocation(1, 2, 1),
		 51     -     runWalkTest(test, {
		 52     -         spawnPosition: new BlockLocation(1, 2, 1),
		     50 +     targetPosition: new BlockLocation(2, 2, 2),
		     51 +     CanTakeDamage: false,
		     52 +     shouldReachTarget: true,
		     53 +   });
		 53     -         targetPosition: new BlockLocation(2, 2, 2),
		 54     -         CanTakeDamage: false,
		 55     -         shouldReachTarget: true
		 56     -     });
		 57  54   })
		     55 +   .maxTicks(runWalkTestTicks)
		     56 +   .tag(GameTest.Tags.suiteDefault);
		 58     -     .maxTicks(runWalkTestTicks)
		 59     -     .tag(GameTest.Tags.suiteDefault);
		 60  57   
		 61  58   GameTest.register("FireAvoidTests", "dont_cut_corner_over_fire_far", (test) => {
		     59 +   runWalkTest(test, {
		     60 +     spawnPosition: new BlockLocation(1, 2, 1),
		 62     -     runWalkTest(test, {
		 63     -         spawnPosition: new BlockLocation(1, 2, 1),
		     61 +     targetPosition: new BlockLocation(5, 2, 1),
		     62 +     CanTakeDamage: false,
		     63 +     shouldReachTarget: true,
		     64 +   });
		 64     -         targetPosition: new BlockLocation(5, 2, 1),
		 65     -         CanTakeDamage: false,
		 66     -         shouldReachTarget: true
		 67     -     });
		 68  65   })
		     66 +   .maxTicks(runWalkTestTicks)
		     67 +   .tag(GameTest.Tags.suiteDefault);
		 69     -     .maxTicks(runWalkTestTicks)
		 70     -     .tag(GameTest.Tags.suiteDefault);
		 71  68   
		 72  69   GameTest.register("FireAvoidTests", "dont_walk_into_magma", (test) => {
		     70 +   runWalkTest(test, {
		     71 +     spawnPosition: new BlockLocation(1, 2, 1),
		 73     -     runWalkTest(test, {
		 74     -         spawnPosition: new BlockLocation(1, 2, 1),
		     72 +     targetPosition: new BlockLocation(3, 2, 1),
		     73 +     CanTakeDamage: false,
		     74 +     shouldReachTarget: false,
		     75 +   });
		 75     -         targetPosition: new BlockLocation(3, 2, 1),
		 76     -         CanTakeDamage: false,
		 77     -         shouldReachTarget: false
		 78     -     });
		 79  76   })
		     77 +   .maxTicks(runWalkTestTicks)
		     78 +   .tag(GameTest.Tags.suiteDefault);
		 80     -     .maxTicks(runWalkTestTicks)
		 81     -     .tag(GameTest.Tags.suiteDefault);
		 82  79   
		 83  80   GameTest.register("FireAvoidTests", "dont_walk_into_magma_diagonal", (test) => {
		     81 +   runWalkTest(test, {
		     82 +     spawnPosition: new BlockLocation(1, 2, 1),
		 84     -     runWalkTest(test, {
		 85     -         spawnPosition: new BlockLocation(1, 2, 1),
		     83 +     targetPosition: new BlockLocation(2, 2, 2),
		     84 +     CanTakeDamage: false,
		     85 +     shouldReachTarget: false,
		     86 +   });
		 86     -         targetPosition: new BlockLocation(2, 2, 2),
		 87     -         CanTakeDamage: false,
		 88     -         shouldReachTarget: false
		 89     -     });
		 90  87   })
		     88 +   .maxTicks(runWalkTestTicks)
		 91     -     .maxTicks(runWalkTestTicks)
		 92     -     .tag("suite:java_parity") // Java villagers don't cross diagonal magma blocks
		     89 +   .tag("suite:java_parity") // Java villagers don't cross diagonal magma blocks
		     90 +   .tag(GameTest.Tags.suiteDisabled);
		 93     -     .tag(GameTest.Tags.suiteDisabled);
		 94     - 
		 95  91   
		 96  92   GameTest.register("FireAvoidTests", "fire_maze", (test) => {
		     93 +   runWalkTest(test, {
		     94 +     spawnPosition: new BlockLocation(1, 2, 1),
		 97     -     runWalkTest(test, {
		 98     -         spawnPosition: new BlockLocation(1, 2, 1),
		     95 +     targetPosition: new BlockLocation(8, 2, 4),
		     96 +     CanTakeDamage: false,
		     97 +     shouldReachTarget: true,
		     98 +   });
		 99     -         targetPosition: new BlockLocation(8, 2, 4),
		100     -         CanTakeDamage: false,
		101     -         shouldReachTarget: true
		102     -     });
		103  99   })
		    100 +   .maxTicks(runWalkTestTicks)
		104     -     .maxTicks(runWalkTestTicks)
		105     -     .tag(GameTest.Tags.suiteDisabled); // villager gets caught on fire
		    101 +   .tag(GameTest.Tags.suiteDisabled); // villager gets caught on fire
		106     - 
		107 102   
		108 103   GameTest.register("FireAvoidTests", "fire_maze_3d", (test) => {
		    104 +   runWalkTest(test, {
		    105 +     spawnPosition: new BlockLocation(1, 3, 1),
		109     -     runWalkTest(test, {
		110     -         spawnPosition: new BlockLocation(1, 3, 1),
		    106 +     targetPosition: new BlockLocation(7, 2, 11),
		    107 +     CanTakeDamage: false,
		    108 +     shouldReachTarget: true,
		    109 +   });
		111     -         targetPosition: new BlockLocation(7, 2, 11),
		112     -         CanTakeDamage: false,
		113     -         shouldReachTarget: true
		114     -     });
		115 110   })
		    111 +   .maxTicks(TicksPerSecond * 10)
		    112 +   .tag(GameTest.Tags.suiteDisabled); // villager gets caught on fire
		116     -     .maxTicks(TicksPerSecond * 10)
		117     -     .tag(GameTest.Tags.suiteDisabled); // villager gets caught on fire
		118 113   
		119 114   GameTest.register("FireAvoidTests", "golem_chase_zombie_over_fire", (test) => {
		    115 +   const zombieLocation = new BlockLocation(7, 2, 1);
		    116 +   const zombieType = "minecraft:zombie";
		120     -     const zombieLocation = new BlockLocation(7, 2, 1);
		121     -     const zombieType = "minecraft:zombie";
		    117 +   test.spawnWithoutBehaviors(zombieType, zombieLocation);
		122     -     test.spawnWithoutBehaviors(zombieType, zombieLocation);
		123 118   
		    119 +   test.spawn("minecraft:iron_golem", new BlockLocation(1, 2, 2));
		124     -     test.spawn("minecraft:iron_golem", new BlockLocation(1, 2, 2));
		125 120   
		    121 +   // change the success condition because it would happen during the wandering behavior
		    122 +   // The golem was not actually chasing the zombie
		126     -     // change the success condition because it would happen during the wandering behavior
		127     -     // The golem was not actually chasing the zombie
		    123 +   test.succeedWhenEntityPresent(zombieType, zombieLocation, false);
		128     -     test.succeedWhenEntityNotPresent(zombieType, zombieLocation);
		129 124   })
		    125 +   .maxTicks(TicksPerSecond * 10)
		    126 +   .batch("night")
		130     -     .maxTicks(TicksPerSecond * 10)
		131     -     .batch("night")
		    127 +   .padding(10) // golem sends the zombie flying far so I added padding
		    128 +   .tag("suite:java_parity") // golem does not run over the fire
		    129 +   .tag(GameTest.Tags.suiteDisabled);
		132     -     .padding(10) // golem sends the zombie flying far so I added padding
		133     -     .tag("suite:java_parity") // golem does not run over the fire
		134     -     .tag(GameTest.Tags.suiteDisabled);
		135 130   
		136 131   GameTest.register("FireAvoidTests", "villager_dont_flee_over_fire", (test) => {
		    132 +   test.spawnWithoutBehaviors("minecraft:zombie", new BlockLocation(5, 2, 1));
		    133 +   const villager = test.spawn("minecraft:villager_v2", new BlockLocation(4, 2, 1));
		137     -     test.spawnWithoutBehaviors("minecraft:zombie", new BlockLocation(5, 2, 1));
		138     -     const villager = test.spawn("minecraft:villager_v2", new BlockLocation(4, 2, 1));
		139 134   
		    135 +   const startingHealth = villager.getComponent("minecraft:health").current;
		140     -     const startingHealth = villager.getComponent("minecraft:health").current
		141 136   
		    137 +   test.runAfterDelay(runWalkTestTicks - 1, () => {
		    138 +     if (villager.getComponent("minecraft:health").current < startingHealth) {
		142     -     test.runAfterDelay(runWalkTestTicks - 1, () => {
		143     -         if (villager.getComponent("minecraft:health").current < startingHealth) {
		    139 +       test.fail("The villager has taken damage");
		    140 +     }
		144     -             test.fail("The villager has taken damage");
		145     -         }
		146 141   
		    142 +     test.succeed();
		    143 +   });
		147     -         test.succeed();
		148     -     });
		149 144   })
		    145 +   .maxTicks(TicksPerSecond * 5)
		    146 +   .batch("night")
		150     -     .maxTicks(TicksPerSecond * 5)
		151     -     .batch("night")
		    147 +   .tag("suite:java_parity") // villager runs into the fire, but in Java does not
		    148 +   .tag(GameTest.Tags.suiteDisabled);
		152     -     .tag("suite:java_parity") // villager runs into the fire, but in Java does not
		153     -     .tag(GameTest.Tags.suiteDisabled);
		154 149   
		155 150   GameTest.register("FireAvoidTests", "walk_far_out_of_magma", (test) => {
		    151 +   runWalkTest(test, {
		    152 +     spawnPosition: new BlockLocation(1, 2, 1),
		156     -     runWalkTest(test, {
		157     -         spawnPosition: new BlockLocation(1, 2, 1),
		    153 +     targetPosition: new BlockLocation(4, 2, 1),
		    154 +     CanTakeDamage: true,
		    155 +     shouldReachTarget: true,
		    156 +   });
		158     -         targetPosition: new BlockLocation(4, 2, 1),
		159     -         CanTakeDamage: true,
		160     -         shouldReachTarget: true
		161     -     });
		162 157   })
		    158 +   .maxTicks(runWalkTestTicks)
		    159 +   .tag("suite:java_parity") // villager gets stuck in the magma
		163     -     .maxTicks(runWalkTestTicks)
		164     -     .tag("suite:java_parity") // villager gets stuck in the magma
		    160 +   .tag(GameTest.Tags.suiteDisabled);
		165     -     .tag(GameTest.Tags.suiteDisabled);
		166 161   
		167 162   GameTest.register("FireAvoidTests", "walk_far_out_of_magma_diagonal", (test) => {
		    163 +   runWalkTest(test, {
		    164 +     spawnPosition: new BlockLocation(1, 2, 1),
		168     -     runWalkTest(test, {
		169     -         spawnPosition: new BlockLocation(1, 2, 1),
		    165 +     targetPosition: new BlockLocation(3, 2, 3),
		    166 +     CanTakeDamage: true,
		    167 +     shouldReachTarget: true,
		    168 +   });
		170     -         targetPosition: new BlockLocation(3, 2, 3),
		171     -         CanTakeDamage: true,
		172     -         shouldReachTarget: true
		173     -     });
		174 169   })
		    170 +   .maxTicks(runWalkTestTicks)
		    171 +   .tag("suite:java_parity") // villager gets stuck in the magma
		175     -     .maxTicks(runWalkTestTicks)
		176     -     .tag("suite:java_parity") // villager gets stuck in the magma
		    172 +   .tag(GameTest.Tags.suiteDisabled);
		177     -     .tag(GameTest.Tags.suiteDisabled);
		178 173   
		179 174   GameTest.register("FireAvoidTests", "walk_out_of_magma", (test) => {
		    175 +   runWalkTest(test, {
		    176 +     spawnPosition: new BlockLocation(1, 2, 1),
		180     -     runWalkTest(test, {
		181     -         spawnPosition: new BlockLocation(1, 2, 1),
		    177 +     targetPosition: new BlockLocation(3, 2, 1),
		    178 +     CanTakeDamage: true,
		    179 +     shouldReachTarget: true,
		    180 +   });
		182     -         targetPosition: new BlockLocation(3, 2, 1),
		183     -         CanTakeDamage: true,
		184     -         shouldReachTarget: true
		185     -     });
		186 181   })
		    182 +   .maxTicks(runWalkTestTicks)
		    183 +   .tag("suite:java_parity") // villager gets stuck in the magma
		187     -     .maxTicks(runWalkTestTicks)
		188     -     .tag("suite:java_parity") // villager gets stuck in the magma
		    184 +   .tag(GameTest.Tags.suiteDisabled);
		189     -     .tag(GameTest.Tags.suiteDisabled); 
		190 185   
		191 186   GameTest.register("FireAvoidTests", "walk_out_of_magma_diagonal", (test) => {
		    187 +   runWalkTest(test, {
		    188 +     spawnPosition: new BlockLocation(1, 2, 1),
		192     -     runWalkTest(test, {
		193     -         spawnPosition: new BlockLocation(1, 2, 1),
		    189 +     targetPosition: new BlockLocation(2, 2, 2),
		    190 +     CanTakeDamage: true,
		    191 +     shouldReachTarget: true,
		    192 +   });
		194     -         targetPosition: new BlockLocation(2, 2, 2),
		195     -         CanTakeDamage: true,
		196     -         shouldReachTarget: true
		197     -     });
		198 193   })
		    194 +   .maxTicks(runWalkTestTicks)
		    195 +   .tag(GameTest.Tags.suiteDefault);
		199     -     .maxTicks(runWalkTestTicks)
		200     -     .tag(GameTest.Tags.suiteDefault);
		201 196   
		202 197   GameTest.register("FireAvoidTests", "zombie_chase_villager_over_fire", (test) => {
		    198 +   test.spawnWithoutBehaviors("minecraft:villager_v2", new BlockLocation(5, 2, 1));
		    199 +   const zombie = test.spawn("minecraft:zombie", new BlockLocation(1, 2, 1));
		203     -     test.spawnWithoutBehaviors("minecraft:villager_v2", new BlockLocation(5, 2, 1));
		204     -     const zombie = test.spawn("minecraft:zombie", new BlockLocation(1, 2, 1));
		205 200   
		    201 +   test.succeedWhenEntityPresent("minecraft:zombie", new BlockLocation(4, 2, 1), true);
		206     -     test.succeedWhenEntityPresent("minecraft:zombie", new BlockLocation(4, 2, 1));
		207 202   })
		    203 +   .maxTicks(TicksPerSecond * 10)
		    204 +   .batch("night")
		208     -     .maxTicks(TicksPerSecond * 10)
		209     -     .batch("night")
		    205 +   .tag(GameTest.Tags.suiteDefault);
		210     -     .tag(GameTest.Tags.suiteDefault);
		          '''
	Changed script "FlyingMachineTests.js":
		Total line: 264 (+34, -34)
		          '''
		      1 + import * as GameTest from "mojang-gametest";
		      2 + import { BlockLocation, MinecraftBlockTypes } from "mojang-minecraft";
		  1     - import * as GameTest from "GameTest";
		  2     - import { BlockLocation, MinecraftBlockTypes } from "Minecraft";
		  3   3   
		  4   4   GameTest.register("FlyingMachineTests", "machine_a", (test) => {
		  5   5     const triggerPos = new BlockLocation(1, 5, 1);
		  6   6     const farPos = new BlockLocation(2, 3, 5);
		  7   7     const nearPos = new BlockLocation(2, 3, 1);
		          ...
		 10  10       .startSequence()
		 11  11       .thenExecute(() => {
		 12  12         test.setBlockType(MinecraftBlockTypes.fire, triggerPos);
		 13  13       })
		 14  14       .thenExecuteAfter(20, () => {
		     15 +       test.assertBlockPresent(MinecraftBlockTypes.slime, farPos, true);
		 15     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, farPos);
		 16  16       })
		 17  17       .thenExecuteAfter(20, () => {
		     18 +       test.assertBlockPresent(MinecraftBlockTypes.slime, nearPos, true);
		 18     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, nearPos);
		 19  19       })
		 20  20       .thenSucceed();
		 21  21   })
		 22  22     .tag("suite:java_parity") // The behavior is different between Java and Bedrock.In Java the flying machine move forward to the end and then returns to its original position, but in Bedrock it returns before it reaches the end.That cause the far point or near point been judged fail.
		 23  23     .tag(GameTest.Tags.suiteDisabled); // Unstable, about 50% pass rate.
		          ...
		 31  31       .startSequence()
		 32  32       .thenExecute(() => {
		 33  33         test.pulseRedstone(triggerPos, 2);
		 34  34       })
		 35  35       .thenExecuteAfter(20, () => {
		     36 +       test.assertBlockPresent(MinecraftBlockTypes.slime, farPos, true);
		 36     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, farPos);
		 37  37       })
		 38  38       .thenExecuteAfter(20, () => {
		     39 +       test.assertBlockPresent(MinecraftBlockTypes.slime, nearPos, true);
		 39     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, nearPos);
		 40  40       })
		 41  41       .thenSucceed();
		 42  42   })
		 43  43     .tag("suite:java_parity")
		 44  44     .tag(GameTest.Tags.suiteDisabled); // After I use redstone instead of set fire block to active the observer, I can see this machine use 2 reverse sticky-piston for flying forward and back in Java. It didn't work well in bedrock.
		          ...
		 53  53       .startSequence()
		 54  54       .thenExecute(() => {
		 55  55         test.pulseRedstone(triggerPos, 2);
		 56  56       })
		 57  57       .thenExecuteAfter(20, () => {
		     58 +       test.assertBlockPresent(MinecraftBlockTypes.slime, farPos, true);
		 58     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, farPos);
		 59  59       })
		 60  60       .thenExecuteAfter(20, () => {
		 61  61         test.setBlockType(MinecraftBlockTypes.obsidian, stopBlock);
		 62  62       })
		 63  63       .thenExecuteAfter(2, () => {
		     64 +       test.assertBlockPresent(MinecraftBlockTypes.stickyPiston, nearPos, true);
		 64     -       test.assertBlockTypePresent(MinecraftBlockTypes.stickyPiston, nearPos);
		 65  65       })
		 66  66       .thenSucceed();
		 67  67   })
		 68  68     .tag("suite:java_parity")
		 69  69     .tag(GameTest.Tags.suiteDisabled); // Could not set fire block in the air even I use pulseRedstone() the machine didn't move.
		          ...
		 78  78       .startSequence()
		 79  79       .thenExecute(() => {
		 80  80         test.setBlockType(MinecraftBlockTypes.fire, triggerPos);
		 81  81       })
		 82  82       .thenExecuteAfter(16, () => {
		     83 +       test.assertBlockPresent(MinecraftBlockTypes.slime, dropPos, true);
		     84 +       test.assertBlockPresent(MinecraftBlockTypes.slime, farPos, true);
		 83     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, dropPos);
		 84     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, farPos);
		 85  85       })
		 86  86       .thenSucceed();
		 87  87   })
		 88  88     .tag("suite:java_parity")
		 89  89     .tag(GameTest.Tags.suiteDisabled); // Can't fly as a whole thing as expectation
		          ...
		 97  97       .startSequence()
		 98  98       .thenExecute(() => {
		 99  99         test.setBlockType(MinecraftBlockTypes.dirt, triggerPos);
		100 100       })
		101 101       .thenExecuteAfter(16, () => {
		    102 +       test.assertBlockPresent(MinecraftBlockTypes.honeyBlock, farPos, true);
		102     -       test.assertBlockTypePresent(MinecraftBlockTypes.honeyBlock, farPos);
		103 103       })
		104 104       .thenExecuteAfter(20, () => {
		    105 +       test.assertBlockPresent(MinecraftBlockTypes.observer, nearPos, true);
		105     -       test.assertBlockTypePresent(MinecraftBlockTypes.observer, nearPos);
		106 106       })
		107 107       .thenSucceed();
		108 108   })
		109 109     .tag("suite:java_parity") // The behavior is different between Java and Bedrock. In Java the flying machine move forward to the end and then returns to its original position, but in Bedrock it returns before it reaches the end. That cause the far point or near point been judged fail.
		110 110     .tag(GameTest.Tags.suiteDisabled); // Unstable
		          ...
		119 119       .startSequence()
		120 120       .thenExecute(() => {
		121 121         test.setBlockType(MinecraftBlockTypes.fire, triggerPos);
		122 122       })
		123 123       .thenExecuteAfter(18, () => {
		    124 +       test.assertBlockPresent(MinecraftBlockTypes.slime, farPos, true);
		124     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, farPos);
		125 125       })
		126 126       .thenExecuteAfter(40, () => {
		    127 +       test.assertBlockPresent(MinecraftBlockTypes.slime, dropPos, true);
		    128 +       test.assertBlockPresent(MinecraftBlockTypes.slime, nearPos, true);
		127     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, dropPos);
		128     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, nearPos);
		129 129       })
		130 130       .thenSucceed();
		131 131   })
		132 132     .tag("suite:java_parity")
		133 133     .tag(GameTest.Tags.suiteDisabled); // Unstable, when noFinishingSequence appears, it failed.
		          ...
		141 141       .startSequence()
		142 142       .thenExecute(() => {
		143 143         test.pulseRedstone(triggerPos, 2);
		144 144       })
		145 145       .thenExecuteAfter(16, () => {
		    146 +       test.assertBlockPresent(MinecraftBlockTypes.slime, farPos, true);
		146     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, farPos);
		147 147       })
		148 148       .thenExecuteAfter(20, () => {
		    149 +       test.assertBlockPresent(MinecraftBlockTypes.observer, nearPos, true);
		149     -       test.assertBlockTypePresent(MinecraftBlockTypes.observer, nearPos);
		150 150       })
		151 151       .thenSucceed();
		152 152   })
		153 153     .tag("suite:java_parity")
		154 154     .tag(GameTest.Tags.suiteDisabled); // Could not set fire in the air, so I use pulseRedstone to active the observer. It's 50% pass rate.
		          ...
		163 163       .startSequence()
		164 164       .thenExecute(() => {
		165 165         test.pulseRedstone(triggerPos, 2);
		166 166       })
		167 167       .thenExecuteAfter(20, () => {
		    168 +       test.assertBlockPresent(MinecraftBlockTypes.slime, farPos, true);
		168     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, farPos);
		169 169       })
		170 170       .thenExecuteAfter(20, () => {
		    171 +       test.assertBlockPresent(MinecraftBlockTypes.slime, dropPos, true);
		    172 +       test.assertBlockPresent(MinecraftBlockTypes.observer, nearPos, true);
		171     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, dropPos);
		172     -       test.assertBlockTypePresent(MinecraftBlockTypes.observer, nearPos);
		173 173       })
		174 174       .thenSucceed();
		175 175   })
		176 176     .tag("suite:java_parity")
		177 177     .tag(GameTest.Tags.suiteDisabled); // Could not set fire in the air, so I use pulseRedstone to active the observer, pass rate is less than 10%, the sticky-piston always unstick.
		          ...
		185 185       .startSequence()
		186 186       .thenExecute(() => {
		187 187         test.setBlockType(MinecraftBlockTypes.dirt, triggerPos);
		188 188       })
		189 189       .thenExecuteAfter(18, () => {
		    190 +       test.assertBlockPresent(MinecraftBlockTypes.honeyBlock, farPos, true);
		190     -       test.assertBlockTypePresent(MinecraftBlockTypes.honeyBlock, farPos);
		191 191       })
		192 192       .thenExecuteAfter(18, () => {
		    193 +       test.assertBlockPresent(MinecraftBlockTypes.observer, nearPos, true);
		193     -       test.assertBlockTypePresent(MinecraftBlockTypes.observer, nearPos);
		194 194       })
		195 195       .thenSucceed();
		196 196   })
		197 197     .tag("suite:java_parity") // The behavior is different between Java and Bedrock. In Java the flying machine move forward to the end and then returns to its original position, but in Bedrock it returns before it reaches the end. That cause the far point or near point been judged fail.
		198 198     .tag(GameTest.Tags.suiteDisabled); // Unstable.
		          ...
		204 204     const targetPos = new BlockLocation(8, 3, 1);
		205 205   
		206 206     test
		207 207       .startSequence()
		208 208       .thenExecute(() => {
		    209 +       test.assertBlockPresent(MinecraftBlockTypes.slime, sourcePos, true);
		    210 +       test.assertBlockPresent(MinecraftBlockTypes.slime, targetPos, false);
		209     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, sourcePos);
		210     -       test.assertBlockTypeNotPresent(MinecraftBlockTypes.slime, targetPos);
		211 211         test.setBlockType(MinecraftBlockTypes.redstoneBlock, triggerPos);
		212 212       })
		213 213       .thenExecuteAfter(10, () => {
		    214 +       test.assertBlockPresent(MinecraftBlockTypes.slime, sourcePos, false);
		214     -       test.assertBlockTypeNotPresent(MinecraftBlockTypes.slime, sourcePos);
		215 215       })
		216 216       .thenExecuteAfter(10, () => {
		    217 +       test.assertBlockPresent(MinecraftBlockTypes.slime, targetPos, true);
		217     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, targetPos);
		218 218       })
		219 219       .thenSucceed();
		220 220   }).tag(GameTest.Tags.suiteDefault);
		221 221   
		222 222   GameTest.register("FlyingMachineTests", "m2_bedrock", (test) => {
		          ...
		226 226     const targetPos = new BlockLocation(6, 3, 1);
		227 227   
		228 228     test
		229 229       .startSequence()
		230 230       .thenExecute(() => {
		    231 +       test.assertBlockPresent(MinecraftBlockTypes.slime, sourcePos, true);
		    232 +       test.assertBlockPresent(MinecraftBlockTypes.slime, targetPos, false);
		231     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, sourcePos);
		232     -       test.assertBlockTypeNotPresent(MinecraftBlockTypes.slime, targetPos);
		233 233         test.setBlockType(MinecraftBlockTypes.redstoneBlock, triggerPos);
		234 234       })
		235 235       .thenExecuteAfter(10, () => {
		    236 +       test.assertBlockPresent(MinecraftBlockTypes.slime, sourcePos, false);
		236     -       test.assertBlockTypeNotPresent(MinecraftBlockTypes.slime, sourcePos);
		237 237       })
		238 238       .thenExecuteAfter(10, () => {
		    239 +       test.assertBlockPresent(MinecraftBlockTypes.slime, targetPos, true);
		239     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, targetPos);
		240 240       })
		241 241       .thenSucceed();
		242 242   }).tag(GameTest.Tags.suiteDefault);
		243 243   
		244 244   GameTest.register("FlyingMachineTests", "m3_bedrock", (test) => {
		          ...
		248 248     const targetPos = new BlockLocation(7, 3, 2);
		249 249   
		250 250     test
		251 251       .startSequence()
		252 252       .thenExecute(() => {
		    253 +       test.assertBlockPresent(MinecraftBlockTypes.slime, sourcePos, true);
		    254 +       test.assertBlockPresent(MinecraftBlockTypes.slime, targetPos, false);
		253     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, sourcePos);
		254     -       test.assertBlockTypeNotPresent(MinecraftBlockTypes.slime, targetPos);
		255 255         test.setBlockType(MinecraftBlockTypes.redstoneBlock, triggerPos);
		256 256       })
		257 257       .thenExecuteAfter(10, () => {
		    258 +       test.assertBlockPresent(MinecraftBlockTypes.slime, sourcePos, false);
		258     -       test.assertBlockTypeNotPresent(MinecraftBlockTypes.slime, sourcePos);
		259 259       })
		260 260       .thenExecuteAfter(10, () => {
		    261 +       test.assertBlockPresent(MinecraftBlockTypes.slime, targetPos, true);
		261     -       test.assertBlockTypePresent(MinecraftBlockTypes.slime, targetPos);
		262 262       })
		263 263       .thenSucceed();
		264 264   }).tag(GameTest.Tags.suiteDefault);
		          '''
	Changed script "GameTestExtensions.js":
		Total line: 32 (+6, -0)
		        '''
		        ...
		21 21       const breathableComp = entity.getComponent("breathable");
		22 22       this.test.assert(breathableComp !== undefined, "Entity missing breathable component");
		23 23       healthComp.setCurrent(1);
		24 24       breathableComp.setAirSupply(0);
		25 25     }
		   26 + 
		   27 +   assertBlockProperty(propertyName, value, blockLocation) {
		   28 +     this.test.assertBlockState(blockLocation, (block) => {
		   29 +       return block.getBlockData().getProperty(propertyName) == value;
		   30 +     });
		   31 +   }
		26 32   }
		        '''
	Changed script "Main.js":
		Total line: 21 (+1, -0)
		        '''
		        ...
		 9  9   import "scripts/ExtensionTests.js";
		10 10   import "scripts/FireAvoidTests.js";
		11 11   import "scripts/GameTestExtensions.js";
		12 12   import "scripts/MinecartTests.js";
		13 13   import "scripts/MobTests.js";
		   14 + import "scripts/MultifaceTests.js";
		14 15   import "scripts/PathFindingTests.js";
		15 16   import "scripts/FlyingMachineTests.js";
		16 17   import "scripts/PistonTests.js";
		17 18   import "scripts/TntTests.js";
		18 19   import "scripts/SmallMobTests.js";
		        ...
		        '''
	Changed script "MinecartTests.js":
		Total line: 248 (+26, -23)
		          '''
		      1 + import * as GameTest from "mojang-gametest";
		      2 + import { BlockLocation, MinecraftBlockTypes, Direction } from "mojang-minecraft";
		  1     - import * as GameTest from "GameTest";
		      3 + import GameTestExtensions from "./GameTestExtensions.js";
		  2     - import { BlockLocation, MinecraftBlockTypes, Direction } from "Minecraft";
		  3   4   
		  4   5   GameTest.register("MinecartTests", "turn", (test) => {
		  5   6     const minecartEntityType = "minecart";
		  6   7   
		  7   8     const endPos = new BlockLocation(1, 2, 2);
		  8   9     const startPos = new BlockLocation(1, 2, 0);
		  9  10   
		     11 +   test.assertEntityPresent(minecartEntityType, startPos, true);
		     12 +   test.assertEntityPresent(minecartEntityType, endPos, false);
		 10     -   test.assertEntityPresent(minecartEntityType, startPos);
		 11     -   test.assertEntityNotPresent(minecartEntityType, endPos);
		 12  13   
		 13  14     test.pressButton(new BlockLocation(0, 3, 0));
		 14  15   
		     16 +   test.succeedWhenEntityPresent(minecartEntityType, endPos, true);
		 15     -   test.succeedWhenEntityPresent(minecartEntityType, endPos);
		 16  17   }).tag(GameTest.Tags.suiteDefault);
		 17  18   
		 18  19   GameTest.register("MinecartTests", "furnace_corner", (test) => {
		 19  20     const furnaceMinecart = "furnace_minecart";
		 20  21   
		 21  22     const endPos = new BlockLocation(2, 2, 1);
		 22  23     const startPos = new BlockLocation(1, 2, 0);
		 23  24   
		     25 +   test.assertEntityPresent(furnaceMinecart, startPos, true);
		 24     -   test.assertEntityPresent(furnaceMinecart, startPos);
		 25  26   
		     27 +   test.succeedWhenEntityPresent(furnace_minecart, endPos, true);
		 26     -   test.succeedWhenEntityPresent(furnace_minecart, endPos);
		 27  28   })
		 28  29     .tag("suite:java_parity")
		 29  30     .tag(GameTest.Tags.suiteDisabled); //furnace_minecart doesn't exist in bedrock
		 30  31   
		 31  32   GameTest.register("MinecartTests", "detector_rail_slope", (test) => {
		     33 +   const testEx = new GameTestExtensions(test);
		 32  34     const poweredDetectorPos = new BlockLocation(2, 2, 1);
		 33  35     let ascendingValue = null;
		 34  36     switch (test.getTestDirection()) {
		 35  37       case Direction.east:
		 36  38         ascendingValue = 2;
		          ...
		 43  45         break;
		 44  46       case Direction.south:
		 45  47         ascendingValue = 5;
		 46  48         break;
		 47  49     }
		     50 +   test.assertBlockPresent(MinecraftBlockTypes.detectorRail, poweredDetectorPos, true);
		     51 +   testEx.assertBlockProperty("rail_direction", ascendingValue, poweredDetectorPos);
		 48     -   test.assertBlockTypePresent(MinecraftBlockTypes.detectorRail, poweredDetectorPos);
		 49     -   test.assertBlockState("rail_direction", ascendingValue, poweredDetectorPos);
		 50  52   
		 51  53     test.pressButton(new BlockLocation(0, 3, 3));
		 52  54     test.runAfterDelay(20, () => {
		 53  55       test.succeedWhen(() => {
		     56 +       test.assertBlockPresent(MinecraftBlockTypes.detectorRail, poweredDetectorPos, true);
		     57 +       testEx.assertBlockProperty("rail_direction", ascendingValue, poweredDetectorPos);
		 54     -       test.assertBlockTypePresent(MinecraftBlockTypes.detectorRail, poweredDetectorPos);
		 55     -       test.assertBlockState("rail_direction", ascendingValue, poweredDetectorPos);
		 56  58       });
		 57  59     });
		 58  60   })
		 59  61     .rotateTest(true)
		 60  62     .tag(GameTest.Tags.suiteDefault);
		 61  63   
		 62  64   GameTest.register("MinecartTests", "detector_rail_piston", (test) => {
		     65 +   const testEx = new GameTestExtensions(test);
		 63  66     const pistonRight = new BlockLocation(5, 3, 0);
		 64  67     const pistonLeft = new BlockLocation(0, 3, 0);
		 65  68     const torchRight = new BlockLocation(3, 2, 0);
		 66  69     const torchLeft = new BlockLocation(2, 2, 0);
		 67  70     let torchValue = null;
		          ...
		 84  87     test
		 85  88       .startSequence()
		 86  89       .thenExecute(() => test.pulseRedstone(pistonRight, 1))
		 87  90       .thenExecuteAfter(3, () => test.pulseRedstone(pistonLeft, 1))
		 88  91       .thenExecuteAfter(3, () => {
		     92 +       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchRight);
		     93 +       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchLeft);
		 89     -       test.assertBlockState("torch_facing_direction", torchValue, torchRight);
		 90     -       test.assertBlockState("torch_facing_direction", torchValue, torchLeft);
		 91  94         minecart = test.spawn("minecart", new BlockLocation(3, 3, 1));
		 92  95       })
		 93  96       .thenExecuteAfter(3, () => {
		     97 +       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchRight);
		 94     -       test.assertBlockState("torch_facing_direction", torchValue, torchRight);
		 95  98         test.pulseRedstone(pistonRight, 1);
		 96  99       })
		 97 100       .thenExecuteAfter(7, () => {
		    101 +       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchRight);
		    102 +       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchLeft);
		 98     -       test.assertBlockState("torch_facing_direction", torchValue, torchRight);
		 99     -       test.assertBlockState("torch_facing_direction", torchValue, torchLeft);
		100 103         test.pulseRedstone(pistonLeft, 1);
		101 104       })
		102 105       .thenExecuteAfter(7, () => {
		    106 +       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchRight);
		    107 +       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchLeft);
		103     -       test.assertBlockState("torch_facing_direction", torchValue, torchRight);
		104     -       test.assertBlockState("torch_facing_direction", torchValue, torchLeft);
		105 108         minecart.kill();
		106 109       })
		107 110       .thenExecuteAfter(6, () => {
		    111 +       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchRight);
		    112 +       testEx.assertBlockProperty("torch_facing_direction", torchValue, torchLeft);
		108     -       test.assertBlockState("torch_facing_direction", torchValue, torchRight);
		109     -       test.assertBlockState("torch_facing_direction", torchValue, torchLeft);
		110 113       })
		111 114       .thenSucceed();
		112 115   })
		113 116     .rotateTest(true)
		114 117     .required(false)
		115 118     .tag(GameTest.Tags.suiteDefault);
		116 119   
		117 120   function runWaterSlowdownTest(test, buttonPos, dryTrackEndPos, wetTrackEndPos, entityType) {
		    121 +   test.assertEntityPresent(entityType, dryTrackEndPos, false);
		    122 +   test.assertEntityPresent(entityType, wetTrackEndPos, false);
		118     -   test.assertEntityNotPresent(entityType, dryTrackEndPos);
		119     -   test.assertEntityNotPresent(entityType, wetTrackEndPos);
		120 123   
		121 124     test.pressButton(buttonPos);
		122 125   
		123 126     test
		124 127       .startSequence()
		    128 +     .thenWait(() => test.assertEntityPresent(entityType, dryTrackEndPos), true)
		    129 +     .thenExecute(() => test.assertEntityPresent(entityType, wetTrackEndPos), false)
		125     -     .thenWait(() => test.assertEntityPresent(entityType, dryTrackEndPos))
		126     -     .thenExecute(() => test.assertEntityNotPresent(entityType, wetTrackEndPos))
		    130 +     .thenWait(() => test.assertEntityPresent(entityType, wetTrackEndPos), true)
		127     -     .thenWait(() => test.assertEntityPresent(entityType, wetTrackEndPos))
		128 131       .thenSucceed();
		129 132   }
		130 133   
		131 134   function runWaterSlowdown(test, entityType) {
		132 135     const buttonPos = new BlockLocation(1, 4, 2);
		          ...
		          '''
	Changed script "MobTests.js":
		Total line: 182 (+72, -28)
		          '''
		      1 + import * as GameTest from "mojang-gametest";
		      2 + import GameTestExtensions from "./GameTestExtensions.js";
		      3 + 
		      4 + import { BlockLocation, MinecraftEffectTypes, MinecraftBlockTypes } from "mojang-minecraft";
		      5 + 
		      6 + const TicksPerSecond = 20;
		      7 + 
		      8 + GameTest.register("MobTests", "zombie_burn", (test) => {
		      9 +   const zombieEntityType = "minecraft:zombie";
		     10 +   const zombiePosition = new BlockLocation(1, 2, 1);
		     11 + 
		     12 +   test.succeedWhenEntityPresent(zombieEntityType, zombiePosition, false);
		     13 + })
		     14 +   .maxTicks(TicksPerSecond * 30)
		     15 +   .tag(GameTest.Tags.suiteDefault)
		     16 +   .batch("day");
		     17 + 
		     18 + GameTest.register("MobTests", "effect_durations_longer_first", (test) => {
		     19 +   const testEx = new GameTestExtensions(test);
		     20 +   const villagerId = "minecraft:villager_v2";
		     21 +   const villagerPos = new BlockLocation(1, 2, 1);
		     22 +   const buttonPos = new BlockLocation(1, 4, 0);
		     23 +   const strongPotion = new BlockLocation(0, 4, 0);
		     24 +   const weakPotion = new BlockLocation(2, 4, 0);
		     25 +   const strongPotionDuration = TicksPerSecond * 16;
		     26 + 
		     27 +   test.spawn(villagerId, villagerPos);
		     28 + 
		     29 +   test
		     30 +     .startSequence()
		     31 +     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, weakPotion))
		     32 +     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		     33 +     .thenWait(() => testEx.assertBlockProperty("button_pressed_bit", 0, buttonPos))
		     34 +     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, strongPotion))
		     35 +     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		     36 +     .thenIdle(strongPotionDuration)
		     37 +     .thenWait(() => {
		     38 +       test.assertEntityState(
		     39 +         villagerPos,
		     40 +         villagerId,
		     41 +         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).amplifier == 0
		     42 +       ); // Strength level I
		     43 +       test.assertEntityState(
		     44 +         villagerPos,
		     45 +         villagerId,
		     46 +         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).duration > TicksPerSecond * 10
		     47 +       );
		     48 +     })
		     49 +     .thenSucceed();
		     50 + })
		     51 +   .structureName("MobTests:effect_durations")
		     52 +   .maxTicks(400)
		     53 +   .tag("suite:java_parity")
		     54 +   .tag(GameTest.Tags.suiteDisabled); // Weak potion duration is 33 seconds, strong is 16. After the strong potion expires the weak potion effect should have time remaining
		  1     - import * as GameTest from "GameTest";
		  2     - import GameTestExtensions from "./GameTestExtensions.js";
		  3     - 
		  4     - import { BlockLocation, MinecraftEffectTypes, MinecraftBlockTypes } from "Minecraft";
		  5  55   
		     56 + GameTest.register("MobTests", "drowning_test", (test) => {
		     57 +   const villagerEntitySpawnType = "minecraft:villager_v2";
		     58 +   const pigSpawnType = "minecraft:pig";
		  6     - const TicksPerSecond = 20;
		  7  59   
		     60 +   test.spawn(villagerEntitySpawnType, new BlockLocation(3, 2, 2));
		     61 +   test.spawn(pigSpawnType, new BlockLocation(3, 2, 4));
		  8     - GameTest.register("MobTests", "zombie_burn", (test) => {
		     62 +   test.succeedWhen(() => {
		     63 +     test.assertEntityPresentInArea(pigSpawnType, false);
		     64 +     test.assertEntityPresentInArea(villagerEntitySpawnType, false);
		     65 +   });
		  9     -   const zombieEntityType = "minecraft:zombie";
		 10     -   const zombiePosition = new BlockLocation(1, 2, 1);
		 11     - 
		 12     -   test.succeedWhenEntityNotPresent(zombieEntityType, zombiePosition);
		 13  66   })
		     67 +   .maxTicks(TicksPerSecond * 45)
		 14     -   .maxTicks(TicksPerSecond * 30)
		 15     -   .tag(GameTest.Tags.suiteDefault)
		     68 +   .tag(GameTest.Tags.suiteDefault);
		 16     -   .batch("day");
		 17  69   
		     70 + GameTest.register("MobTests", "golem_vs_pillager", (test) => {
		 18     - GameTest.register("MobTests", "effect_durations_longer_first", (test) => {
		 19     -   const villagerId = "minecraft:villager_v2";
		 20     -   const villagerPos = new BlockLocation(1, 2, 1);
		     71 +   const ironGolem = "minecraft:iron_golem";
		     72 +   const pillager = "minecraft:pillager";
		     73 +   const ironGolemPos = new BlockLocation(3, 2, 3);
		     74 +   const pillagerPos = new BlockLocation(3, 2, 4);
		 21     -   const buttonPos = new BlockLocation(1, 4, 0);
		 22     -   const strongPotion = new BlockLocation(0, 4, 0);
		 23     -   const weakPotion = new BlockLocation(2, 4, 0);
		 24     -   const strongPotionDuration = TicksPerSecond * 16;
		 25  75   
		     76 +   test.spawn(ironGolem, ironGolemPos);
		     77 +   test.spawn(pillager, pillagerPos);
		 26     -   test.spawn(villagerId, villagerPos);
		 27  78   
		     79 +   test.succeedWhen(() => {
		     80 +     test.assertEntityPresent(pillager, ironGolemPos, false);
		 28     -   test
		     81 +     test.assertEntityPresent(ironGolem, pillagerPos, true);
		     82 +   });
		     83 + }).tag(GameTest.Tags.suiteDefault);
		     84 + 
		     85 + GameTest.register("MobTests", "effect_durations_stronger_first", (test) => {
		     86 +   const testEx = new GameTestExtensions(test);
		     87 +   const villagerId = "minecraft:villager_v2";
		     88 +   const villagerPos = new BlockLocation(1, 2, 1);
		     89 +   const buttonPos = new BlockLocation(1, 4, 0);
		     90 +   const strongPotion = new BlockLocation(0, 4, 0);
		     91 +   const weakPotion = new BlockLocation(2, 4, 0);
		     92 +   const strongPotionDuration = TicksPerSecond * 16;
		     93 + 
		     94 +   test.spawn(villagerId, villagerPos);
		     95 + 
		     96 +   test
		     97 +     .startSequence()
		     98 +     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, strongPotion))
		     99 +     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		    100 +     .thenWait(() => testEx.assertBlockProperty("button_pressed_bit", 0, buttonPos))
		    101 +     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, weakPotion))
		    102 +     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		    103 +     .thenIdle(strongPotionDuration)
		    104 +     .thenWait(() => {
		    105 +       test.assertEntityState(
		    106 +         villagerPos,
		    107 +         villagerId,
		    108 +         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).amplifier == 0
		    109 +       ); // Strength level I
		    110 +       test.assertEntityState(
		    111 +         villagerPos,
		    112 +         villagerId,
		    113 +         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).duration > TicksPerSecond * 10
		    114 +       );
		    115 +     })
		    116 +     .thenSucceed();
		 29     -     .startSequence()
		 30     -     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, weakPotion))
		 31     -     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		 32     -     .thenWait(() => test.assertBlockState("button_pressed_bit", 0, buttonPos))
		 33     -     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, strongPotion))
		 34     -     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		 35     -     .thenIdle(strongPotionDuration)
		 36     -     .thenWait(() => {
		 37     -       test.assertEntityData(
		 38     -         villagerPos,
		 39     -         villagerId,
		 40     -         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).amplifier == 0
		 41     -       ); // Strength level I
		 42     -       test.assertEntityData(
		 43     -         villagerPos,
		 44     -         villagerId,
		 45     -         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).duration > TicksPerSecond * 10
		 46     -       );
		 47     -     })
		 48     -     .thenSucceed();
		 49     - })
		 50     -   .structureName("MobTests:effect_durations")
		 51     -   .maxTicks(400)
		 52     -   .tag("suite:java_parity")
		 53     -   .tag(GameTest.Tags.suiteDisabled); // Weak potion duration is 33 seconds, strong is 16. After the strong potion expires the weak potion effect should have time remaining
		 54     - 
		 55     - GameTest.register("MobTests", "drowning_test", (test) => {
		 56     -   const villagerEntitySpawnType = "minecraft:villager_v2";
		 57     -   const pigSpawnType = "minecraft:pig";
		 58     - 
		 59     -   test.spawn(villagerEntitySpawnType, new BlockLocation(3, 2, 2));
		 60     -   test.spawn(pigSpawnType, new BlockLocation(3, 2, 4));
		 61     -   test.succeedWhen(() => {
		 62     -     test.assertEntityNotPresentInArea(pigSpawnType);
		 63     -     test.assertEntityNotPresentInArea(villagerEntitySpawnType);
		 64     -   });
		 65 117   })
		 66     -   .maxTicks(TicksPerSecond * 45)
		 67     -   .tag(GameTest.Tags.suiteDefault);
		 68     - 
		 69     - GameTest.register("MobTests", "golem_vs_pillager", (test) => {
		    118 +   .structureName("MobTests:effect_durations")
		    119 +   .maxTicks(400)
		    120 +   .tag("suite:java_parity")
		    121 +   .tag(GameTest.Tags.suiteDisabled); // Weak potion duration is 33 seconds, strong is 16. After the strong potion expires the weak potion effect should have time remaining
		 70     -   const ironGolem = "minecraft:iron_golem";
		 71     -   const pillager = "minecraft:pillager";
		 72     -   const ironGolemPos = new BlockLocation(3, 2, 3);
		 73     -   const pillagerPos = new BlockLocation(3, 2, 4);
		 74 122   
		    123 + GameTest.register("MobTests", "silverfish_no_suffocate", (test) => {
		    124 +   const silverfishPos = new BlockLocation(1, 2, 1);
		 75     -   test.spawn(ironGolem, ironGolemPos);
		    125 +   const silverfish = "minecraft:silverfish";
		 76     -   test.spawn(pillager, pillagerPos);
		 77 126   
		    127 +   test
		 78     -   test.succeedWhen(() => {
		 79     -     test.assertEntityNotPresent(pillager, ironGolemPos);
		    128 +     .startSequence()
		    129 +     .thenExecute(() => test.assertEntityHasComponent(silverfish, "minecraft:health", silverfishPos, true))
		    130 +     .thenIdle(40)
		    131 +     .thenExecute(() => test.assertEntityHasComponent(silverfish, "minecraft:health", silverfishPos, true))
		    132 +     .thenSucceed();
		    133 +   test
		    134 +     .startSequence()
		    135 +     .thenWait(() => test.assertEntityPresent(silverfish, silverfishPos, false))
		    136 +     .thenFail("Silverfish died");
		    137 + })
		    138 +   .maxTicks(TicksPerSecond * 30)
		    139 +   .required(false)
		    140 +   .tag(GameTest.Tags.suiteDefault);
		 80     -     test.assertEntityPresent(ironGolem, pillagerPos);
		 81     -   });
		 82     - }).tag(GameTest.Tags.suiteDefault);
		 83     - 
		 84     - GameTest.register("MobTests", "effect_durations_stronger_first", (test) => {
		 85     -   const villagerId = "minecraft:villager_v2";
		 86     -   const villagerPos = new BlockLocation(1, 2, 1);
		 87     -   const buttonPos = new BlockLocation(1, 4, 0);
		 88     -   const strongPotion = new BlockLocation(0, 4, 0);
		 89     -   const weakPotion = new BlockLocation(2, 4, 0);
		 90     -   const strongPotionDuration = TicksPerSecond * 16;
		 91     - 
		 92     -   test.spawn(villagerId, villagerPos);
		 93 141   
		 94     -   test
		 95     -     .startSequence()
		 96     -     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, strongPotion))
		 97     -     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		    142 + GameTest.register("MobTests", "small_mobs_keep_head_above_water", (test) => {
		    143 +   const testEx = new GameTestExtensions(test);
		    144 +   const swimmerPos = new BlockLocation(1, 3, 1); //When the silverfish is produced at (1, 2, 1), the silverfish is stuck in the glass below and dies, so the y-axis goes up one frame
		    145 +   const swimmer = test.spawn("minecraft:silverfish", swimmerPos);
		    146 + 
		    147 +   const drownerPos = new BlockLocation(5, 2, 1);
		    148 +   const drowner = test.spawn("minecraft:silverfish", drownerPos);
		    149 + 
		    150 +   testEx.makeAboutToDrown(swimmer);
		    151 +   testEx.makeAboutToDrown(drowner);
		    152 + 
		    153 +   test
		    154 +     .startSequence()
		    155 +     .thenIdle(40)
		    156 +     .thenExecute(() => test.assertEntityPresent("minecraft:silverfish", swimmerPos, true))
		    157 +     .thenExecute(() => test.assertEntityPresent("minecraft:silverfish", drownerPos, false))
		 98     -     .thenWait(() => test.assertBlockState("button_pressed_bit", 0, buttonPos))
		 99     -     .thenExecute(() => test.setBlockType(MinecraftBlockTypes.air, weakPotion))
		100     -     .thenExecuteAfter(4, () => test.pressButton(buttonPos))
		101     -     .thenIdle(strongPotionDuration)
		102     -     .thenWait(() => {
		103     -       test.assertEntityData(
		104     -         villagerPos,
		105     -         villagerId,
		106     -         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).amplifier == 0
		107     -       ); // Strength level I
		108     -       test.assertEntityData(
		109     -         villagerPos,
		110     -         villagerId,
		111     -         (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).duration > TicksPerSecond * 10
		112     -       );
		113     -     })
		114 158       .thenSucceed();
		    159 + }).tag(GameTest.Tags.suiteDefault);
		    160 + 
		    161 + GameTest.register("MobTests", "small_mobs_breathe_in_boats", (test) => {
		115     - })
		    162 +   const testEx = new GameTestExtensions(test);
		    163 +   const catPos = new BlockLocation(2, 3, 2);
		    164 +   const cat = testEx.addEntityInBoat("minecraft:cat", catPos);
		    165 +   testEx.makeAboutToDrown(cat);
		116     -   .structureName("MobTests:effect_durations")
		117     -   .maxTicks(400)
		118     -   .tag("suite:java_parity")
		119     -   .tag(GameTest.Tags.suiteDisabled); // Weak potion duration is 33 seconds, strong is 16. After the strong potion expires the weak potion effect should have time remaining
		120 166   
		    167 +   const silverfishPos = new BlockLocation(4, 3, 2);
		    168 +   const silverfish = testEx.addEntityInBoat("minecraft:silverfish", silverfishPos);
		121     - GameTest.register("MobTests", "silverfish_no_suffocate", (test) => {
		122     -   const silverfishPos = new BlockLocation(1, 2, 1);
		    169 +   testEx.makeAboutToDrown(silverfish);
		123     -   const silverfish = "minecraft:silverfish";
		124 170   
		    171 +   const underWaterPos = new BlockLocation(6, 2, 2);
		125     -   test
		126     -     .startSequence()
		127     -     .thenExecute(() => test.assertEntityHasComponent(silverfish, "minecraft:health", silverfishPos, true))
		    172 +   const silverfish2 = testEx.addEntityInBoat("minecraft:silverfish", underWaterPos);
		    173 +   testEx.makeAboutToDrown(silverfish2);
		    174 + 
		128     -     .thenIdle(40)
		129     -     .thenExecute(() => test.assertEntityHasComponent(silverfish, "minecraft:health", silverfishPos, true))
		130     -     .thenSucceed();
		131 175     test
		132 176       .startSequence()
		    177 +     .thenIdle(40)
		    178 +     .thenExecute(() => test.assertEntityPresent("minecraft:cat", catPos, true))
		133     -     .thenWait(() => test.assertEntityNotPresent(silverfish, silverfishPos))
		134     -     .thenFail("Silverfish died");
		    179 +     .thenExecute(() => test.assertEntityPresent("minecraft:silverfish", silverfishPos, true))
		    180 +     .thenExecute(() => test.assertEntityPresent("minecraft:silverfish", underWaterPos, false))
		    181 +     .thenSucceed();
		    182 + }).tag(GameTest.Tags.suiteDefault);
		135     - })
		136     -   .maxTicks(TicksPerSecond * 30)
		137     -   .required(false)
		138     -   .tag(GameTest.Tags.suiteDefault);
		          '''
	Added script "MultifaceTests.js":
		'''
		import * as GameTest from "mojang-gametest";
		import {
		  BlockLocation,
		  MinecraftBlockTypes,
		  BlockProperties,
		  MinecraftItemTypes,
		  Direction,
		  World,
		} from "mojang-minecraft";
		import GameTestExtensions from "./GameTestExtensions.js";
		
		const DOWN = Direction.down;
		const UP = Direction.up;
		const NORTH = Direction.north;
		const SOUTH = Direction.south;
		const WEST = Direction.west;
		const EAST = Direction.east;
		const DIRECTIONS = [DOWN, UP, NORTH, SOUTH, WEST, EAST];
		
		function growLichen(test, lichenPos, faceToGrow, growDirection) {
		  test.assertBlockPresent(MinecraftBlockTypes.glowLichen, lichenPos, true);
		  test.spreadFromFaceTowardDirection(lichenPos, faceToGrow, growDirection);
		}
		
		function assertNoLichen(test, pos) {
		  test.assertBlockPresent(MinecraftBlockTypes.glowLichen, pos, false);
		}
		
		function assertLichen(test, pos, waterlogged, ...faces) {
		  test.assertBlockPresent(MinecraftBlockTypes.glowLichen, pos, true);
		  test.assertIsWaterlogged(pos, waterlogged);
		
		  const glowLichenWorldPos = test.worldBlockLocation(pos);
		  const glowLichenBlock = World.getDimension("overworld").getBlock(glowLichenWorldPos);
		  const glowLichenPermutation = glowLichenBlock.getBlockData();
		  const glowLichenmultiFaceDirectionBits = glowLichenPermutation.getProperty(
		    BlockProperties.multiFaceDirectionBits
		  ).value;
		
		  for (const face of DIRECTIONS) {
		    const expectFaceBit = faces.indexOf(face) != -1 ? 1 : 0;
		    const actualFaceBit = (glowLichenmultiFaceDirectionBits & (1 << face)) != 0 ? 1 : 0;
		    test.assert(
		      actualFaceBit == expectFaceBit,
		      `Unexpected face bit in the direction: ${face}. Expected: ${expectFaceBit}. Actual: ${actualFaceBit}`
		    );
		  }
		}
		
		///
		// Concrete Tests
		///
		GameTest.register("MultifaceTests", "spread_sideways_within_same_corner", (test) => {
		  assertLichen(test, new BlockLocation(1, 3, 0), false, SOUTH);
		  growLichen(test, new BlockLocation(1, 3, 0), SOUTH, WEST);
		  assertLichen(test, new BlockLocation(1, 3, 0), false, SOUTH, WEST);
		
		  assertLichen(test, new BlockLocation(4, 3, 0), false, UP, SOUTH);
		  growLichen(test, new BlockLocation(4, 3, 0), SOUTH, WEST);
		  assertLichen(test, new BlockLocation(4, 3, 0), false, UP, SOUTH, WEST);
		
		  assertLichen(test, new BlockLocation(7, 3, 0), false, UP, EAST, SOUTH);
		  growLichen(test, new BlockLocation(7, 3, 0), SOUTH, WEST);
		  assertLichen(test, new BlockLocation(7, 3, 0), false, UP, EAST, SOUTH, WEST);
		
		  assertLichen(test, new BlockLocation(11, 3, 0), false, UP, EAST, DOWN, SOUTH);
		  growLichen(test, new BlockLocation(11, 3, 0), SOUTH, WEST);
		  assertLichen(test, new BlockLocation(11, 3, 0), false, UP, EAST, DOWN, SOUTH, WEST);
		
		  growLichen(test, new BlockLocation(15, 3, 0), SOUTH, WEST);
		  assertLichen(test, new BlockLocation(15, 3, 0), false, UP);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "spread_up_within_same_corner", (test) => {
		  assertLichen(test, new BlockLocation(1, 3, 0), false, SOUTH);
		  growLichen(test, new BlockLocation(1, 3, 0), SOUTH, UP);
		  assertLichen(test, new BlockLocation(1, 3, 0), false, SOUTH, UP);
		
		  assertLichen(test, new BlockLocation(4, 3, 0), false, WEST, SOUTH);
		  growLichen(test, new BlockLocation(4, 3, 0), SOUTH, UP);
		  assertLichen(test, new BlockLocation(4, 3, 0), false, WEST, SOUTH, UP);
		
		  assertLichen(test, new BlockLocation(7, 3, 0), false, EAST, DOWN, SOUTH);
		  growLichen(test, new BlockLocation(7, 3, 0), SOUTH, UP);
		  assertLichen(test, new BlockLocation(7, 3, 0), false, EAST, DOWN, SOUTH, UP);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "spread_around_partly_blocked_corner", (test) => {
		  assertNoLichen(test, new BlockLocation(0, 3, 1));
		  growLichen(test, new BlockLocation(1, 3, 0), SOUTH, WEST);
		  assertLichen(test, new BlockLocation(1, 3, 0), false, SOUTH);
		  assertNoLichen(test, new BlockLocation(0, 3, 0));
		  assertLichen(test, new BlockLocation(0, 3, 1), false, EAST);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "dont_spread_toward_opposite_face", (test) => {
		  growLichen(test, new BlockLocation(1, 3, 1), EAST, WEST);
		  assertLichen(test, new BlockLocation(1, 3, 1), false, EAST);
		  assertNoLichen(test, new BlockLocation(0, 3, 1));
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "spread_on_flat_ceiling", (test) => {
		  assertNoLichen(test, new BlockLocation(0, 3, 1));
		  growLichen(test, new BlockLocation(1, 3, 1), UP, WEST);
		  assertLichen(test, new BlockLocation(1, 3, 1), false, UP);
		  assertLichen(test, new BlockLocation(0, 3, 1), false, UP);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "spread_from_wall_around_corner", (test) => {
		  assertNoLichen(test, new BlockLocation(0, 3, 1));
		  growLichen(test, new BlockLocation(1, 3, 0), SOUTH, WEST);
		  assertLichen(test, new BlockLocation(0, 3, 1), false, EAST);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "spread_from_ceiling_around_corner", (test) => {
		  assertNoLichen(test, new BlockLocation(0, 4, 1));
		  growLichen(test, new BlockLocation(1, 3, 1), UP, WEST);
		  assertLichen(test, new BlockLocation(0, 4, 1), false, EAST);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "spread_from_floor_around_corner", (test) => {
		  assertNoLichen(test, new BlockLocation(0, 3, 1));
		  growLichen(test, new BlockLocation(1, 4, 1), DOWN, WEST);
		  assertLichen(test, new BlockLocation(0, 3, 1), false, EAST);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "spread_on_flat_floor", (test) => {
		  assertNoLichen(test, new BlockLocation(0, 4, 1));
		  growLichen(test, new BlockLocation(1, 4, 1), DOWN, WEST);
		  assertLichen(test, new BlockLocation(0, 4, 1), false, DOWN);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "dont_spread_toward_same_face", (test) => {
		  growLichen(test, new BlockLocation(1, 3, 0), SOUTH, SOUTH);
		  assertLichen(test, new BlockLocation(1, 3, 0), false, SOUTH);
		  assertNoLichen(test, new BlockLocation(1, 3, 1));
		  assertNoLichen(test, new BlockLocation(1, 3, 2));
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "spread_on_flat_wall", (test) => {
		  assertNoLichen(test, new BlockLocation(0, 3, 0));
		  growLichen(test, new BlockLocation(1, 3, 0), SOUTH, WEST);
		  assertLichen(test, new BlockLocation(0, 3, 0), false, SOUTH);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "spread_from_water_to_air", (test) => {
		  assertNoLichen(test, new BlockLocation(1, 3, 1));
		  growLichen(test, new BlockLocation(1, 2, 1), SOUTH, UP);
		  assertLichen(test, new BlockLocation(1, 2, 1), true, SOUTH);
		  assertLichen(test, new BlockLocation(1, 3, 1), false, SOUTH);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "spread_from_air_to_water", (test) => {
		  assertNoLichen(test, new BlockLocation(1, 2, 1));
		  growLichen(test, new BlockLocation(1, 3, 1), SOUTH, DOWN);
		  assertLichen(test, new BlockLocation(1, 3, 1), false, SOUTH);
		  assertLichen(test, new BlockLocation(1, 2, 1), true, SOUTH);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "spread_within_water", (test) => {
		  assertNoLichen(test, new BlockLocation(1, 2, 1));
		  growLichen(test, new BlockLocation(2, 2, 1), SOUTH, WEST);
		  assertLichen(test, new BlockLocation(2, 2, 1), true, SOUTH);
		  assertLichen(test, new BlockLocation(1, 2, 1), true, SOUTH);
		
		  assertLichen(test, new BlockLocation(2, 2, 1), true, SOUTH);
		  growLichen(test, new BlockLocation(2, 2, 1), SOUTH, EAST);
		  assertLichen(test, new BlockLocation(2, 2, 1), true, SOUTH, EAST);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "dont_spread_into_flowing_water", (test) => {
		  growLichen(test, new BlockLocation(2, 2, 1), SOUTH, WEST);
		  assertLichen(test, new BlockLocation(2, 2, 1), true, SOUTH);
		  assertNoLichen(test, new BlockLocation(1, 2, 1));
		  test.assertBlockPresent(MinecraftBlockTypes.flowingWater, new BlockLocation(1, 2, 1), true);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "dont_spread_into_lava", (test) => {
		  growLichen(test, new BlockLocation(2, 2, 1), SOUTH, WEST);
		  assertLichen(test, new BlockLocation(2, 2, 1), false, SOUTH);
		  assertNoLichen(test, new BlockLocation(1, 2, 1));
		  test.assertBlockPresent(MinecraftBlockTypes.flowingLava, new BlockLocation(1, 2, 1), true);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "break_if_all_supporting_faces_destroyed", (test) => {
		  const testEx = new GameTestExtensions(test);
		  // break the supporting block behind the non-waterlogged lichen
		  test.setBlockType(MinecraftBlockTypes.air, new BlockLocation(1, 2, 2)); //Use setBlockType(air) instead of destroyBlock()
		
		  // break the supporting block behind the waterlogged lichen
		  test.setBlockType(MinecraftBlockTypes.air, new BlockLocation(4, 2, 2)); //Use setBlockType(air) instead of destroyBlock()
		
		  test.succeedWhen(() => {
		    // check that the non-waterlogged lichen was replaced with air, and that no glow lichen was dropped
		    test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 2), true);
		    test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(1, 2, 1), true);
		    test.assertItemEntityCountIs(MinecraftItemTypes.glowLichen, new BlockLocation(1, 2, 1), 1, 0);
		
		    // check that the waterlogged lichen was replaced with water, and that no glow lichen was dropped
		    test.assertBlockPresent(MinecraftBlockTypes.water, new BlockLocation(4, 2, 2), true);
		    testEx.assertBlockProperty("liquid_depth", 1, new BlockLocation(4, 2, 2));
		    test.assertBlockPresent(MinecraftBlockTypes.water, new BlockLocation(4, 2, 1), true);
		    testEx.assertBlockProperty("liquid_depth", 0, new BlockLocation(4, 2, 1));
		    test.assertItemEntityCountIs(MinecraftItemTypes.glowLichen, new BlockLocation(4, 2, 2), 1, 0);
		  });
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "remove_face_if_support_destroyed", (test) => {
		  test.setBlockType(MinecraftBlockTypes.air, new BlockLocation(1, 3, 1)); //Use setBlockType(air) instead of destroyBlock()
		
		  test
		    .startSequence()
		    .thenExecuteAfter(20, () => {
		      test.assertBlockPresent(MinecraftBlockTypes.air, new BlockLocation(1, 3, 1), true);
		      assertLichen(test, new BlockLocation(1, 3, 0), false, WEST);
		      test.assertItemEntityCountIs(MinecraftItemTypes.glowLichen, new BlockLocation(1, 2, 0), 1, 0);
		    })
		    .thenSucceed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "remove_if_has_no_faces", (test) => {
		  const pos = new BlockLocation(0, 2, 0);
		
		  const glowLichenPermutation = MinecraftBlockTypes.glowLichen.createDefaultBlockPermutation();
		  glowLichenPermutation.getProperty(BlockProperties.multiFaceDirectionBits).value = 0;
		  test.setBlockPermutation(glowLichenPermutation, pos);
		
		  // Make sure the glow lichen was placed
		  test.assertBlockPresent(MinecraftBlockTypes.glowLichen, pos, true);
		
		  // Update a neighbor
		  test.setBlockType(MinecraftBlockTypes.blackstone, pos.offset(1, 0, 0));
		
		  // Succeed if the glow lichen was removed
		  test
		    .startSequence()
		    .thenExecuteAfter(2, () => {
		      test.assertBlockPresent(MinecraftBlockTypes.air, pos, true);
		    })
		    .thenSucceed();
		}).tag(GameTest.Tags.suiteDefault);
		
		GameTest.register("MultifaceTests", "default_multiface_block_has_all_sides", (test) => {
		  const pos = new BlockLocation(0, 1, 0);
		
		  const glowLichenPermutation = MinecraftBlockTypes.glowLichen.createDefaultBlockPermutation();
		  test.setBlockPermutation(glowLichenPermutation, pos);
		
		  // Make sure the glow lichen was placed
		  assertLichen(test, pos, false, DOWN, UP, NORTH, SOUTH, WEST, EAST);
		
		  test.succeed();
		}).tag(GameTest.Tags.suiteDefault);
		'''
	Changed script "PathFindingTests.js":
		Total line: 389 (+16, -16)
		          '''
		      1 + import * as GameTest from "mojang-gametest";
		      2 + import { MinecraftBlockTypes, BlockProperties, BlockLocation } from "mojang-minecraft";
		  1     - import * as GameTest from "GameTest";
		  2     - import { MinecraftBlockTypes, BlockProperties, BlockLocation } from "Minecraft";
		  3   3   
		  4   4   ///
		  5   5   // Setup constants
		  6   6   ///
		  7   7   const VERTICAL_TEST_TEMPLATE_NAME = "PathFindingTests:veritcal_template";
		          ...
		193 193       const bedPos = new BlockLocation(1, 2, 4);
		194 194       const aboveBedPos = bedPos.above().above(); // Check 2 blocks above the bed because under rare circumstances the villager hit box may stick out above the bed block when lying down.
		195 195       const spawnPos = new BlockLocation(5, 3, 4);
		196 196   
		197 197       // Do the test
		    198 +     test.assertEntityPresent(villagerEntityType, bedPos, false);
		198     -     test.assertEntityNotPresent(villagerEntityType, bedPos);
		199 199       test.spawn(villagerEntitySpawnType, spawnPos);
		200 200   
		201 201       test.succeedWhen(() => {
		    202 +       test.assertEntityPresent(villagerEntityType, aboveBedPos, false);
		    203 +       test.assertEntityPresent(villagerEntityType, bedPos, true);
		202     -       test.assertEntityNotPresent(villagerEntityType, aboveBedPos);
		203     -       test.assertEntityPresent(villagerEntityType, bedPos);
		204 204   
		205 205         test.killAllEntities(); // Clean up villagers so the VillageManager doesn't waste time looking for points of interest (POIs)
		206 206       });
		207 207     })
		208 208       .structureName(VERTICAL_TEST_TEMPLATE_NAME)
		          ...
		227 227       const bedPos = new BlockLocation(1, 2, 4);
		228 228       const aboveBedPos = bedPos.above().above(); // Check 2 blocks above the bed because under rare circumstances the villager hit box may stick out above the bed block when lying down.
		229 229       const spawnPos = new BlockLocation(5, 3, 4);
		230 230   
		231 231       // Do the test
		    232 +     test.assertEntityPresent(villagerEntityType, bedPos, false);
		232     -     test.assertEntityNotPresent(villagerEntityType, bedPos);
		233 233       test.spawn(villagerEntitySpawnType, spawnPos);
		234 234       test.succeedWhen(() => {
		    235 +       test.assertEntityPresent(villagerEntityType, aboveBedPos, false);
		    236 +       test.assertEntityPresent(villagerEntityType, bedPos, true);
		235     -       test.assertEntityNotPresent(villagerEntityType, aboveBedPos);
		236     -       test.assertEntityPresent(villagerEntityType, bedPos);
		237 237   
		238 238         test.killAllEntities(); // Clean up villagers so the VillageManager doesn't waste time looking for points of interest (POIs)
		239 239       });
		240 240     })
		241 241       .structureName(VERTICAL_TEST_TEMPLATE_NAME)
		          ...
		258 258     test.spawn(villagerEntitySpawnType, new BlockLocation(4, 2, 5));
		259 259     test.spawn(villagerEntitySpawnType, new BlockLocation(2, 2, 5));
		260 260     test.spawn(villagerEntitySpawnType, new BlockLocation(1, 2, 4));
		261 261   
		262 262     test.succeedWhen(() => {
		    263 +     test.assertEntityPresent(villagerEntitySpawnType, new BlockLocation(5, 2, 2), true);
		    264 +     test.assertEntityPresent(villagerEntitySpawnType, new BlockLocation(5, 2, 1), true);
		263     -     test.assertEntityPresent(villagerEntitySpawnType, new BlockLocation(5, 2, 2));
		264     -     test.assertEntityPresent(villagerEntitySpawnType, new BlockLocation(5, 2, 1));
		    265 +     test.assertEntityPresent(villagerEntitySpawnType, new BlockLocation(1, 2, 2), true);
		    266 +     test.assertEntityPresent(villagerEntitySpawnType, new BlockLocation(1, 2, 1), true);
		265     -     test.assertEntityPresent(villagerEntitySpawnType, new BlockLocation(1, 2, 2));
		266     -     test.assertEntityPresent(villagerEntitySpawnType, new BlockLocation(1, 2, 1));
		267 267     });
		268 268   })
		269 269     .padding(TEST_PADDING) // Space out villager tests to stop them from confusing each other
		270 270     .batch("night")
		271 271     .maxTicks(TEST_MAX_TICKS)
		          ...
		275 275   GameTest.register("PathFindingTests", "big_obstacle_course", (test) => {
		276 276     const bedPos = new BlockLocation(4, 3, 6);
		277 277     const spawnPos = new BlockLocation(5, 3, 4);
		278 278     const villagerEntitySpawnType = "minecraft:villager_v2<minecraft:spawn_farmer>";
		279 279   
		    280 +   test.assertEntityPresent(villagerEntitySpawnType, bedPos, false);
		280     -   test.assertEntityNotPresent(villagerEntitySpawnType, bedPos);
		281 281     test.spawn(villagerEntitySpawnType, spawnPos);
		282 282   
		    283 +   test.succeedWhenEntityPresent(villagerEntitySpawnType, bedPos, true);
		283     -   test.succeedWhenEntityPresent(villagerEntitySpawnType, bedPos);
		284 284   })
		285 285     .padding(TEST_PADDING)
		286 286     .maxTicks(TEST_MAX_TICKS)
		287 287     .batch("night")
		288 288     .required(false)
		          ...
		292 292   GameTest.register("PathFindingTests", "simple", (test) => {
		293 293     const bedPos = new BlockLocation(1, 2, 4);
		294 294     const spawnPos = new BlockLocation(5, 3, 4);
		295 295     const villagerEntitySpawnType = "minecraft:villager_v2<minecraft:spawn_farmer>";
		296 296   
		    297 +   test.assertEntityPresent(villagerEntitySpawnType, bedPos, false);
		297     -   test.assertEntityNotPresent(villagerEntitySpawnType, bedPos);
		298 298     test.spawn(villagerEntitySpawnType, spawnPos);
		299 299   
		    300 +   test.succeedWhenEntityPresent(villagerEntitySpawnType, bedPos, true);
		300     -   test.succeedWhenEntityPresent(villagerEntitySpawnType, bedPos);
		301 301   })
		302 302     .maxTicks(TEST_MAX_TICKS)
		303 303     .batch("night")
		304 304     .required(false)
		305 305     .padding(TEST_PADDING)
		          ...
		308 308   GameTest.register("PathFindingTests", "carpet_walk_around", (test) => {
		309 309     const bedPos = new BlockLocation(1, 2, 4);
		310 310     const spawnPos = new BlockLocation(5, 3, 4);
		311 311     const villagerEntitySpawnType = "minecraft:villager_v2<minecraft:spawn_farmer>";
		312 312   
		    313 +   test.assertEntityPresent(villagerEntitySpawnType, bedPos, false);
		313     -   test.assertEntityNotPresent(villagerEntitySpawnType, bedPos);
		314 314     test.spawn(villagerEntitySpawnType, spawnPos);
		315 315   
		    316 +   test.succeedWhenEntityPresent(villagerEntitySpawnType, bedPos, true);
		316     -   test.succeedWhenEntityPresent(villagerEntitySpawnType, bedPos);
		317 317   })
		318 318     .padding(TEST_PADDING)
		319 319     .maxTicks(TEST_MAX_TICKS)
		320 320     .batch("night")
		321 321     .required(false)
		          ...
		          '''
	Changed script "PistonTests.js":
		Total line: 842 (+234, -203)
		            '''
		        1 + import * as GameTest from "mojang-gametest";
		        2 + import { BlockLocation, Location, MinecraftBlockTypes, ItemStack } from "mojang-minecraft";
		        3 + import GameTestExtensions from "./GameTestExtensions.js";
		        4 + 
		        5 + GameTest.register("PistonTests", "honey_block_entity_drag_sideways", (test) => {
		        6 +   const startPos = new BlockLocation(3, 4, 1);
		        7 +   const endPos = new BlockLocation(2, 4, 1);
		        8 +   const pullLeverPos = new BlockLocation(0, 3, 0);
		        9 +   const chickenEntityType = "minecraft:chicken";
		       10 + 
		       11 +   test.assertEntityPresent(chickenEntityType, endPos, false);
		       12 +   test.spawn(chickenEntityType, startPos);
		       13 +   test
		       14 +     .startSequence()
		       15 +     .thenExecuteAfter(1, () => {
		       16 +       test.pullLever(pullLeverPos);
		       17 +     })
		       18 +     .thenWait(() => {
		       19 +       test.assertEntityPresent(chickenEntityType, endPos, true);
		       20 +     })
		       21 +     .thenSucceed();
		       22 + }).tag(GameTest.Tags.suiteDefault);
		       23 + 
		       24 + GameTest.register("PistonTests", "quasiconnectivity", (test) => {
		       25 +   const topStartPos = new BlockLocation(3, 3, 0);
		       26 +   const bottomStartPos = new BlockLocation(3, 2, 0);
		       27 +   const topEndPos = new BlockLocation(2, 3, 0);
		       28 +   const bottomEndPos = new BlockLocation(2, 2, 0);
		       29 +   const pullLeverPos = new BlockLocation(0, 4, 0);
		       30 + 
		       31 +   test.pullLever(pullLeverPos);
		       32 +   test
		       33 +     .startSequence()
		       34 +     .thenWaitWithDelay(3, () => {
		       35 +       test.assertBlockPresent(MinecraftBlockTypes.stone, topStartPos, true);
		       36 +       test.assertBlockPresent(MinecraftBlockTypes.stone, bottomStartPos, true);
		       37 +     })
		       38 +     .thenExecute(() => {
		       39 +       test.pullLever(pullLever);
		       40 +     })
		       41 +     .thenWaitWithDelay(3, () => {
		       42 +       test.assertBlockPresent(MinecraftBlockTypes.stone, topEndPos, true);
		       43 +       test.assertBlockPresent(MinecraftBlockTypes.stone, bottomEndPos, true);
		       44 +     })
		       45 +     .thenSucceed();
		       46 + })
		       47 +   .tag("suite:java_parity")
		       48 +   .tag(GameTest.Tags.suiteDisabled); //There are version differences. Java version has a switch, which can control one piston at the same time, while bedrock version can only control one piston. All the structures have been modified, and the pull rod and its coordinates have been changed to (0, 3, 0) ,next to "quasiconnectivity_bedrock"
		       49 + 
		       50 + GameTest.register("PistonTests", "quasiconnectivity_bedrock", (test) => {
		       51 +   const topStartPos = new BlockLocation(3, 3, 0);
		       52 +   const bottomStartPos = new BlockLocation(3, 2, 0);
		       53 +   const topEndPos = new BlockLocation(2, 3, 0);
		       54 +   const bottomEndPos = new BlockLocation(2, 2, 0);
		       55 +   const pullLeverPos = new BlockLocation(0, 3, 0);
		       56 + 
		       57 +   test.pullLever(pullLeverPos); //There are version differences. Java version has a switch, which can control one piston at the same time, while bedrock version can only control one piston. All the structures have been modified, and the pull rod and its coordinates have been changed to (0, 3, 0)
		       58 + 
		       59 +   test
		       60 +     .startSequence()
		       61 +     .thenIdle(6) //it's not possible to time it exactly due to redstone differences then you can just pull the lever, wait 6 ticks, assert, pull, wait 6, assert.
		       62 +     .thenExecute(() => {
		       63 +       test.assertBlockPresent(MinecraftBlockTypes.stone, topStartPos, true);
		       64 +       test.assertBlockPresent(MinecraftBlockTypes.stone, bottomStartPos, true);
		       65 +     })
		       66 +     .thenExecute(() => {
		       67 +       test.pullLever(pullLeverPos);
		       68 +     })
		       69 +     .thenIdle(6)
		       70 +     .thenExecute(() => {
		       71 +       test.assertBlockPresent(MinecraftBlockTypes.stone, topEndPos, true);
		       72 +       test.assertBlockPresent(MinecraftBlockTypes.stone, bottomEndPos, true);
		       73 +     })
		       74 +     .thenSucceed();
		       75 + }).tag(GameTest.Tags.suiteDefault);
		   1      - import * as GameTest from "GameTest";
		   2      - import { BlockLocation, Location, MinecraftBlockTypes, ItemStack } from "Minecraft";
		   3   76   
		       77 + GameTest.register("PistonTests", "redstone_simple_vertical_bud", (test) => {
		   4      - GameTest.register("PistonTests", "honey_block_entity_drag_sideways", (test) => {
		   5      -   const startPos = new BlockLocation(3, 4, 1);
		       78 +   const blockPos = new BlockLocation(0, 5, 0);
		       79 +   const setblockPos = new BlockLocation(0, 1, 0);
		       80 +   test.setBlockType(MinecraftBlockTypes.stone, setblockPos);
		   6      -   const endPos = new BlockLocation(2, 4, 1);
		   7      -   const pullLeverPos = new BlockLocation(0, 3, 0);
		   8      -   const chickenEntityType = "minecraft:chicken";
		   9   81   
		  10      -   test.assertEntityNotPresent(chickenEntityType, endPos);
		  11      -   test.spawn(chickenEntityType, startPos);
		  12   82     test
		  13   83       .startSequence()
		       84 +     .thenIdle(3)
		       85 +     .thenWait(() => {
		  14      -     .thenExecuteAfter(1, () => {
		       86 +       test.assertBlockPresent(MinecraftBlockTypes.redstoneBlock, blockPos, true);
		  15      -       test.pullLever(pullLeverPos);
		  16   87       })
		       88 +     .thenIdle(1)
		  17   89       .thenWait(() => {
		       90 +       test.assertBlockPresent(MinecraftBlockTypes.air, blockPos, true);
		  18      -       test.assertEntityPresent(chickenEntityType, endPos);
		  19   91       })
		  20   92       .thenSucceed();
		       93 + })
		       94 +   .tag("suite:java_parity")
		       95 +   .tag(GameTest.Tags.suiteDisabled); //The lack of quasi-connectivity in bedrock is parity difference that causes this test not to succeed.
		  21      - }).tag(GameTest.Tags.suiteDefault);
		  22   96   
		       97 + GameTest.register("PistonTests", "redstone_simple_horizontal_bud", (test) => {
		  23      - GameTest.register("PistonTests", "quasiconnectivity", (test) => {
		  24      -   const topStartPos = new BlockLocation(3, 3, 0);
		  25      -   const bottomStartPos = new BlockLocation(3, 2, 0);
		       98 +   const extendedPos = new BlockLocation(3, 2, 0);
		       99 +   const retractedPos = new BlockLocation(2, 2, 0);
		      100 +   test.setBlockType(MinecraftBlockTypes.stone, new BlockLocation(0, 1, 0));
		  26      -   const topEndPos = new BlockLocation(2, 3, 0);
		  27      -   const bottomEndPos = new BlockLocation(2, 2, 0);
		  28      -   const pullLeverPos = new BlockLocation(0, 4, 0);
		  29  101   
		  30      -   test.pullLever(pullLeverPos);
		  31  102     test
		  32  103       .startSequence()
		  33  104       .thenWaitWithDelay(3, () => {
		  34      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, topStartPos);
		  35      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, bottomStartPos);
		  36      -     })
		      105 +       test.assertBlockPresent(MinecraftBlockTypes.redstoneBlock, extendedPos, true);
		      106 +       test.assertBlockPresent(MinecraftBlockTypes.air, retractedPos, true);
		  37      -     .thenExecute(() => {
		  38      -       test.pullLever(pullLever);
		  39  107       })
		  40  108       .thenWaitWithDelay(3, () => {
		      109 +       test.assertBlockPresent(MinecraftBlockTypes.air, extendedPos, true);
		      110 +       test.assertBlockPresent(MinecraftBlockTypes.redstoneBlock, retractedPos, true);
		  41      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, topEndPos);
		  42      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, bottomEndPos);
		  43  111       })
		  44  112       .thenSucceed();
		  45  113   })
		  46  114     .tag("suite:java_parity")
		      115 +   .tag(GameTest.Tags.suiteDisabled); // The lack of quasi-connectivity in bedrock is parity difference that causes this test not to succeed.
		  47      -   .tag(GameTest.Tags.suiteDisabled); //There are version differences. Java version has a switch, which can control one piston at the same time, while bedrock version can only control one piston. All the structures have been modified, and the pull rod and its coordinates have been changed to (0, 3, 0) ,next to "quasiconnectivity_bedrock"
		  48  116   
		      117 + GameTest.register("PistonTests", "redstone_bud", (test) => {
		      118 +   const blockPos = new BlockLocation(0, 3, 5);
		      119 +   const pullLeverPos = new BlockLocation(0, 4, 0);
		  49      - GameTest.register("PistonTests", "quasiconnectivity_bedrock", (test) => {
		      120 +   test.pullLever(pullLeverPos);
		      121 +   test
		      122 +     .startSequence()
		      123 +     .thenWaitWithDelay(3, () => {
		      124 +       test.assertBlockPresent(MinecraftBlockTypes.redstoneBlock, blockPos, true);
		      125 +     })
		      126 +     .thenWaitWithDelay(5, () => {
		      127 +       test.assertBlockPresent(MinecraftBlockTypes.air, blockPos, true);
		      128 +     })
		      129 +     .thenWait(() => {
		      130 +       test.pullLever(pullLeverPos);
		      131 +     })
		      132 +     .thenWaitWithDelay(3, () => {
		      133 +       test.assertBlockPresent(MinecraftBlockTypes.redstoneBlock, blockPos, true);
		  50      -   const topStartPos = new BlockLocation(3, 3, 0);
		  51      -   const bottomStartPos = new BlockLocation(3, 2, 0);
		  52      -   const topEndPos = new BlockLocation(2, 3, 0);
		  53      -   const bottomEndPos = new BlockLocation(2, 2, 0);
		  54      -   const pullLeverPos = new BlockLocation(0, 3, 0);
		  55      - 
		  56      -   test.pullLever(pullLeverPos); //There are version differences. Java version has a switch, which can control one piston at the same time, while bedrock version can only control one piston. All the structures have been modified, and the pull rod and its coordinates have been changed to (0, 3, 0)
		  57      - 
		  58      -   test
		  59      -     .startSequence()
		  60      -     .thenIdle(6) //it's not possible to time it exactly due to redstone differences then you can just pull the lever, wait 6 ticks, assert, pull, wait 6, assert.
		  61      -     .thenExecute(() => {
		  62      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, topStartPos);
		  63      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, bottomStartPos);
		  64  134       })
		      135 +     .thenWaitWithDelay(5, () => {
		      136 +       test.assertBlockPresent(MinecraftBlockTypes.air, blockPos, true);
		  65      -     .thenExecute(() => {
		  66      -       test.pullLever(pullLeverPos);
		  67  137       })
		      138 +     .thenSucceed();
		      139 + })
		      140 +   .setupTicks(10)
		  68      -     .thenIdle(6)
		      141 +   .tag("suite:java_parity")
		      142 +   .tag(GameTest.Tags.suiteDisabled); // The lack of quasi-connectivity in bedrock is parity difference that causes this test not to succeed.
		      143 + 
		      144 + GameTest.register("PistonTests", "slime_block_pull", (test) => {
		      145 +   const targetPos = new BlockLocation(3, 3, 0);
		      146 +   const pullLeverPos = new BlockLocation(0, 4, 0);
		  69      -     .thenExecute(() => {
		  70      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, topEndPos);
		  71      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, bottomEndPos);
		  72      -     })
		  73      -     .thenSucceed();
		  74      - }).tag(GameTest.Tags.suiteDefault);
		  75  147   
		      148 +   test.assertBlockPresent(MinecraftBlockTypes.planks, targetPos, false);
		      149 +   test.pullLever(pullLeverPos);
		  76      - GameTest.register("PistonTests", "redstone_simple_vertical_bud", (test) => {
		  77      -   const blockPos = new BlockLocation(0, 5, 0);
		      150 +   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.planks, targetPos, true);
		      151 + }).tag(GameTest.Tags.suiteDefault);
		  78      -   const setblockPos = new BlockLocation(0, 1, 0);
		  79      -   test.setBlockType(MinecraftBlockTypes.stone, setblockPos);
		  80  152   
		  81      -   test
		  82      -     .startSequence()
		  83      -     .thenIdle(3)
		  84      -     .thenWait(() => {
		      153 + GameTest.register("PistonTests", "normal_extend", (test) => {
		      154 +   const targetPos = new BlockLocation(3, 2, 0);
		      155 +   const pullLeverPos = new BlockLocation(0, 3, 0);
		      156 + 
		      157 +   test.assertBlockPresent(MinecraftBlockTypes.stone, targetPos, false);
		      158 +   test.pullLever(pullLeverPos);
		      159 +   test.succeedOnTickWhen(3, () => {
		      160 +     test.assertBlockPresent(MinecraftBlockTypes.stone, targetPos, true);
		      161 +   });
		      162 + }).tag(GameTest.Tags.suiteDefault);
		  85      -       test.assertBlockTypePresent(MinecraftBlockTypes.redstoneBlock, blockPos);
		  86      -     })
		  87      -     .thenIdle(1)
		  88      -     .thenWait(() => {
		  89      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, blockPos);
		  90      -     })
		  91      -     .thenSucceed();
		  92      - })
		  93      -   .tag("suite:java_parity")
		  94      -   .tag(GameTest.Tags.suiteDisabled); //The lack of quasi-connectivity in bedrock is parity difference that causes this test not to succeed.
		  95  163   
		      164 + GameTest.register("PistonTests", "normal_extend_retract", (test) => {
		  96      - GameTest.register("PistonTests", "redstone_simple_horizontal_bud", (test) => {
		  97  165     const extendedPos = new BlockLocation(3, 2, 0);
		  98  166     const retractedPos = new BlockLocation(2, 2, 0);
		      167 +   const pullLeverPos = new BlockLocation(0, 3, 0);
		      168 + 
		      169 +   test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, false);
		      170 +   test.pullLever(pullLeverPos);
		  99      -   test.setBlockType(MinecraftBlockTypes.stone, new BlockLocation(0, 1, 0));
		 100  171   
		 101  172     test
		 102  173       .startSequence()
		 103  174       .thenWaitWithDelay(3, () => {
		      175 +       test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, true);
		      176 +       test.assertBlockPresent(MinecraftBlockTypes.pistonarmcollision, retractedPos, true);
		      177 +     })
		      178 +     .thenExecute(() => {
		      179 +       test.pullLever(pullLeverPos);
		 104      -       test.assertBlockTypePresent(MinecraftBlockTypes.redstoneBlock, extendedPos);
		 105      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, retractedPos);
		 106  180       })
		      181 +     .thenWaitWithDelay(1, () => {
		      182 +       test.assertBlockPresent(MinecraftBlockTypes.air, retractedPos, true);
		 107      -     .thenWaitWithDelay(3, () => {
		 108      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, extendedPos);
		      183 +       test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, true);
		 109      -       test.assertBlockTypePresent(MinecraftBlockTypes.redstoneBlock, retractedPos);
		 110  184       })
		 111  185       .thenSucceed();
		 112  186   })
		 113      -   .tag("suite:java_parity")
		 114      -   .tag(GameTest.Tags.suiteDisabled); // The lack of quasi-connectivity in bedrock is parity difference that causes this test not to succeed.
		 115      - 
		 116      - GameTest.register("PistonTests", "redstone_bud", (test) => {
		      187 +   .structureName("PistonTests:normal_extend")
		      188 +   .tag("suite:java_parity")
		      189 +   .tag(GameTest.Tags.suiteDisabled); //Pistons react at different speeds in Bedrock, create a new test called normal_extend_retract_bedrock.
		      190 + 
		      191 + GameTest.register("PistonTests", "normal_extend_retract_bedrock", (test) => {
		      192 +   const extendedPos = new BlockLocation(3, 2, 0);
		      193 +   const retractedPos = new BlockLocation(2, 2, 0);
		      194 +   const pullLeverPos = new BlockLocation(0, 3, 0);
		      195 + 
		      196 +   test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, false);
		      197 +   test.pullLever(pullLeverPos);
		      198 + 
		      199 +   //it's not possible to time it exactly due to redstone differences, so just validate assert can pass before given delay.
		      200 +   test
		      201 +     .startSequence()
		      202 +     .thenIdle(6)
		      203 +     .thenExecute(() => {
		      204 +       test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, true);
		      205 +       test.assertBlockPresent(MinecraftBlockTypes.pistonarmcollision, retractedPos, true);
		 117      -   const blockPos = new BlockLocation(0, 3, 5);
		 118      -   const pullLeverPos = new BlockLocation(0, 4, 0);
		 119      -   test.pullLever(pullLeverPos);
		 120      -   test
		 121      -     .startSequence()
		 122      -     .thenWaitWithDelay(3, () => {
		 123      -       test.assertBlockTypePresent(MinecraftBlockTypes.redstoneBlock, blockPos);
		 124      -     })
		 125      -     .thenWaitWithDelay(5, () => {
		 126      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, blockPos);
		 127      -     })
		 128      -     .thenWait(() => {
		 129      -       test.pullLever(pullLeverPos);
		 130      -     })
		 131      -     .thenWaitWithDelay(3, () => {
		 132      -       test.assertBlockTypePresent(MinecraftBlockTypes.redstoneBlock, blockPos);
		 133      -     })
		 134      -     .thenWaitWithDelay(5, () => {
		 135      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, blockPos);
		 136  206       })
		      207 +     .thenExecute(() => {
		 137      -     .thenSucceed();
		 138      - })
		 139      -   .setupTicks(10)
		      208 +       test.pullLever(pullLeverPos);
		      209 +     })
		      210 +     .thenIdle(4)
		      211 +     .thenExecute(() => {
		      212 +       test.assertBlockPresent(MinecraftBlockTypes.air, retractedPos, true);
		      213 +       test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, true);
		      214 +     })
		      215 +     .thenSucceed();
		      216 + })
		      217 +   .structureName("PistonTests:normal_extend")
		      218 +   .tag(GameTest.Tags.suiteDefault);
		 140      -   .tag("suite:java_parity")
		 141      -   .tag(GameTest.Tags.suiteDisabled); // The lack of quasi-connectivity in bedrock is parity difference that causes this test not to succeed.
		 142      - 
		 143      - GameTest.register("PistonTests", "slime_block_pull", (test) => {
		 144      -   const targetPos = new BlockLocation(3, 3, 0);
		 145      -   const pullLeverPos = new BlockLocation(0, 4, 0);
		 146      - 
		 147      -   test.assertBlockTypeNotPresent(MinecraftBlockTypes.planks, targetPos);
		 148      -   test.pullLever(pullLeverPos);
		 149      -   test.succeedWhenBlockTypePresent(MinecraftBlockTypes.planks, targetPos);
		 150      - }).tag(GameTest.Tags.suiteDefault);
		 151  219   
		      220 + GameTest.register("PistonTests", "sticky_extend", (test) => {
		 152      - GameTest.register("PistonTests", "normal_extend", (test) => {
		 153  221     const targetPos = new BlockLocation(3, 2, 0);
		 154  222     const pullLeverPos = new BlockLocation(0, 3, 0);
		 155  223   
		      224 +   test.assertBlockPresent(MinecraftBlockTypes.stone, targetPos, false);
		 156      -   test.assertBlockTypeNotPresent(MinecraftBlockTypes.stone, targetPos);
		 157  225     test.pullLever(pullLeverPos);
		 158  226     test.succeedOnTickWhen(3, () => {
		      227 +     test.assertBlockPresent(MinecraftBlockTypes.stone, targetPos, true);
		 159      -     test.assertBlockTypePresent(MinecraftBlockTypes.stone, targetPos);
		 160  228     });
		 161  229   }).tag(GameTest.Tags.suiteDefault);
		 162  230   
		      231 + GameTest.register("PistonTests", "sticky_extend_retract", (test) => {
		 163      - GameTest.register("PistonTests", "normal_extend_retract", (test) => {
		 164  232     const extendedPos = new BlockLocation(3, 2, 0);
		 165  233     const retractedPos = new BlockLocation(2, 2, 0);
		 166  234     const pullLeverPos = new BlockLocation(0, 3, 0);
		 167  235   
		      236 +   test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, false);
		 168      -   test.assertBlockTypeNotPresent(MinecraftBlockTypes.stone, extendedPos);
		 169  237     test.pullLever(pullLeverPos);
		 170  238   
		 171  239     test
		 172  240       .startSequence()
		 173  241       .thenWaitWithDelay(3, () => {
		      242 +       test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, true);
		      243 +       test.assertBlockPresent(MinecraftBlockTypes.stickypistonarmcollision, retractedPos, true);
		 174      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, extendedPos);
		 175      -       test.assertBlockTypePresent(MinecraftBlockTypes.pistonarmcollision, retractedPos);
		 176  244       })
		 177  245       .thenExecute(() => {
		 178  246         test.pullLever(pullLeverPos);
		 179  247       })
		      248 +     .thenWaitWithDelay(3, () => {
		      249 +       test.assertBlockPresent(MinecraftBlockTypes.stone, retractedPos, true);
		 180      -     .thenWaitWithDelay(1, () => {
		 181      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, retractedPos);
		      250 +       test.assertBlockPresent(MinecraftBlockTypes.air, extendedPos, true);
		 182      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, extendedPos);
		 183  251       })
		 184  252       .thenSucceed();
		 185  253   })
		      254 +   .structureName("PistonTests:sticky_extend")
		 186      -   .structureName("PistonTests:normal_extend")
		 187  255     .tag("suite:java_parity")
		      256 +   .tag(GameTest.Tags.suiteDisabled); //Pistons react at different speeds in Bedrock, create a new test called sticky_extend_retract_bedrock.
		 188      -   .tag(GameTest.Tags.suiteDisabled); //Pistons react at different speeds in Bedrock, create a new test called normal_extend_retract_bedrock.
		 189  257   
		      258 + GameTest.register("PistonTests", "sticky_extend_retract_bedrock", (test) => {
		 190      - GameTest.register("PistonTests", "normal_extend_retract_bedrock", (test) => {
		 191  259     const extendedPos = new BlockLocation(3, 2, 0);
		 192  260     const retractedPos = new BlockLocation(2, 2, 0);
		 193  261     const pullLeverPos = new BlockLocation(0, 3, 0);
		 194  262   
		      263 +   test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, false);
		 195      -   test.assertBlockTypeNotPresent(MinecraftBlockTypes.stone, extendedPos);
		 196  264     test.pullLever(pullLeverPos);
		 197  265   
		 198  266     //it's not possible to time it exactly due to redstone differences, so just validate assert can pass before given delay.
		 199  267     test
		 200  268       .startSequence()
		 201  269       .thenIdle(6)
		 202  270       .thenExecute(() => {
		      271 +       test.assertBlockPresent(MinecraftBlockTypes.stone, extendedPos, true);
		      272 +       test.assertBlockPresent(MinecraftBlockTypes.stickypistonarmcollision, retractedPos, true);
		 203      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, extendedPos);
		 204      -       test.assertBlockTypePresent(MinecraftBlockTypes.pistonarmcollision, retractedPos);
		 205  273       })
		 206  274       .thenExecute(() => {
		 207  275         test.pullLever(pullLeverPos);
		 208  276       })
		      277 +     .thenIdle(6)
		 209      -     .thenIdle(4)
		 210  278       .thenExecute(() => {
		      279 +       test.assertBlockPresent(MinecraftBlockTypes.stone, retractedPos, true);
		      280 +       test.assertBlockPresent(MinecraftBlockTypes.air, extendedPos, true);
		 211      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, retractedPos);
		 212      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, extendedPos);
		 213  281       })
		 214  282       .thenSucceed();
		 215  283   })
		      284 +   .structureName("PistonTests:sticky_extend")
		 216      -   .structureName("PistonTests:normal_extend")
		 217  285     .tag(GameTest.Tags.suiteDefault);
		 218  286   
		      287 + GameTest.register("PistonTests", "push_limit", (test) => {
		      288 +   const underLimitTip = new BlockLocation(0, 2, 6);
		      289 +   const overLimitTip = new BlockLocation(2, 2, 6);
		 219      - GameTest.register("PistonTests", "sticky_extend", (test) => {
		      290 +   const pullLeverPos = new BlockLocation(1, 2, 0);
		      291 +   const underLimitExtendedTip = new BlockLocation(0, 2, 7);
		 220      -   const targetPos = new BlockLocation(3, 2, 0);
		 221      -   const pullLeverPos = new BlockLocation(0, 3, 0);
		 222  292   
		      293 +   test.assertBlockPresent(MinecraftBlockTypes.goldBlock, underLimitTip, true);
		      294 +   test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, overLimitTip, true);
		 223      -   test.assertBlockTypeNotPresent(MinecraftBlockTypes.stone, targetPos);
		 224  295     test.pullLever(pullLeverPos);
		 225      -   test.succeedOnTickWhen(3, () => {
		 226      -     test.assertBlockTypePresent(MinecraftBlockTypes.stone, targetPos);
		 227      -   });
		 228      - }).tag(GameTest.Tags.suiteDefault);
		 229  296   
		      297 +   test.succeedOnTickWhen(3, () => {
		      298 +     test.assertBlockPresent(MinecraftBlockTypes.goldBlock, underLimitExtendedTip, true);
		 230      - GameTest.register("PistonTests", "sticky_extend_retract", (test) => {
		      299 +     test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, overLimitTip, true);
		      300 +   });
		      301 + }).tag(GameTest.Tags.suiteDefault);
		 231      -   const extendedPos = new BlockLocation(3, 2, 0);
		 232      -   const retractedPos = new BlockLocation(2, 2, 0);
		 233      -   const pullLeverPos = new BlockLocation(0, 3, 0);
		 234  302   
		      303 + GameTest.register("PistonTests", "block_leave", (test) => {
		      304 +   const trigger = new BlockLocation(3, 1, 1);
		      305 +   const retracted = new BlockLocation(1, 1, 1);
		 235      -   test.assertBlockTypeNotPresent(MinecraftBlockTypes.stone, extendedPos);
		      306 +   const extended = new BlockLocation(0, 1, 1);
		 236      -   test.pullLever(pullLeverPos);
		 237  307   
		      308 +   test.pulseRedstone(trigger, 2);
		 238  309     test
		 239  310       .startSequence()
		 240  311       .thenWaitWithDelay(3, () => {
		 241      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, extendedPos);
		 242      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickypistonarmcollision, retractedPos);
		 243      -     })
		      312 +       test.assertBlockPresent(MinecraftBlockTypes.concrete, extended, true);
		      313 +       test.assertBlockPresent(MinecraftBlockTypes.air, retracted, true);
		 244      -     .thenExecute(() => {
		 245      -       test.pullLever(pullLeverPos);
		 246  314       })
		      315 +     .thenExecuteAfter(3, () => {
		 247      -     .thenWaitWithDelay(3, () => {
		 248      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, retractedPos);
		      316 +       test.pulseRedstone(trigger, 2);
		 249      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, extendedPos);
		 250  317       })
		      318 +     .thenWaitWithDelay(5, () => {
		 251      -     .thenSucceed();
		 252      - })
		 253      -   .structureName("PistonTests:sticky_extend")
		      319 +       test.assertBlockPresent(MinecraftBlockTypes.concrete, retracted, true);
		      320 +       test.assertBlockPresent(MinecraftBlockTypes.air, extended, true);
		      321 +     })
		      322 +     .thenSucceed();
		      323 + })
		      324 +   .tag("suite:java_parity")
		      325 +   .tag(GameTest.Tags.suiteDisabled); //In Java Edition, pistons finish extending early and start retracting if given a pulse shorter than 3 game ticks (1.5 redstone ticks; 0.15 seconds). These shorter pulses cause sticky pistons to "drop" their block, leaving it behind when trying to push it with a short pulse. Also, this causes the block to end up in its final position earlier.Therefore, the bedrock version can't be modified, and can only be verified according to the piston tension,
		 254      -   .tag("suite:java_parity")
		 255      -   .tag(GameTest.Tags.suiteDisabled); //Pistons react at different speeds in Bedrock, create a new test called sticky_extend_retract_bedrock.
		 256      - 
		 257      - GameTest.register("PistonTests", "sticky_extend_retract_bedrock", (test) => {
		 258      -   const extendedPos = new BlockLocation(3, 2, 0);
		 259      -   const retractedPos = new BlockLocation(2, 2, 0);
		 260      -   const pullLeverPos = new BlockLocation(0, 3, 0);
		 261  326   
		      327 + GameTest.register("PistonTests", "block_leave_bedrock", (test) => {
		      328 +   const trigger = new BlockLocation(3, 1, 1);
		      329 +   const retracted = new BlockLocation(1, 1, 1);
		 262      -   test.assertBlockTypeNotPresent(MinecraftBlockTypes.stone, extendedPos);
		      330 +   const extended = new BlockLocation(0, 1, 1);
		 263      -   test.pullLever(pullLeverPos);
		 264  331   
		      332 +   test.pulseRedstone(trigger, 2);
		 265      -   //it's not possible to time it exactly due to redstone differences, so just validate assert can pass before given delay.
		 266  333     test
		 267  334       .startSequence()
		      335 +     .thenIdle(2)
		      336 +     .thenWait(() => {
		 268      -     .thenIdle(6)
		 269      -     .thenExecute(() => {
		      337 +       test.assertBlockPresent(MinecraftBlockTypes.concrete, extended, true);
		      338 +       test.assertBlockPresent(MinecraftBlockTypes.air, retracted, true);
		 270      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, extendedPos);
		 271      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickypistonarmcollision, retractedPos);
		 272  339       })
		      340 +     .thenExecuteAfter(3, () => {
		      341 +       test.pulseRedstone(trigger, 2);
		 273      -     .thenExecute(() => {
		 274      -       test.pullLever(pullLeverPos);
		 275  342       })
		 276  343       .thenIdle(6)
		      344 +     .thenWait(() => {
		      345 +       test.assertBlockPresent(MinecraftBlockTypes.concrete, retracted, true);
		 277      -     .thenExecute(() => {
		 278      -       test.assertBlockTypePresent(MinecraftBlockTypes.stone, retractedPos);
		      346 +       test.assertBlockPresent(MinecraftBlockTypes.air, extended, true);
		 279      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, extendedPos);
		 280  347       })
		 281  348       .thenSucceed();
		      349 + }).tag(GameTest.Tags.suiteDefault);
		 282      - })
		 283      -   .structureName("PistonTests:sticky_extend")
		 284      -   .tag(GameTest.Tags.suiteDefault);
		 285  350   
		      351 + GameTest.register("PistonTests", "update_order", (test) => {
		      352 +   const posA = new BlockLocation(2, 1, 1);
		 286      - GameTest.register("PistonTests", "push_limit", (test) => {
		 287      -   const underLimitTip = new BlockLocation(0, 2, 6);
		      353 +   const posB = new BlockLocation(2, 1, 0);
		      354 +   const posC = new BlockLocation(3, 1, 0);
		      355 +   const posD = new BlockLocation(1, 1, 0);
		 288      -   const overLimitTip = new BlockLocation(2, 2, 6);
		 289      -   const pullLeverPos = new BlockLocation(1, 2, 0);
		 290      -   const underLimitExtendedTip = new BlockLocation(0, 2, 7);
		 291  356   
		      357 +   const trigger = new BlockLocation(6, 2, 2);
		 292      -   test.assertBlockTypePresent(MinecraftBlockTypes.goldBlock, underLimitTip);
		 293      -   test.assertBlockTypePresent(MinecraftBlockTypes.emeraldBlock, overLimitTip);
		      358 +   test.setBlockType(trigger, MinecraftBlockTypes.greenWool);
		 294      -   test.pullLever(pullLeverPos);
		 295  359   
		      360 +   test
		 296      -   test.succeedOnTickWhen(3, () => {
		 297      -     test.assertBlockTypePresent(MinecraftBlockTypes.goldBlock, underLimitExtendedTip);
		      361 +     .startSequence()
		      362 +     .thenWaitWithDelay(4, () => {
		      363 +       test.assertBlockPresent(MinecraftBlockTypes.yellowWool, posB, true);
		      364 +     })
		      365 +     .thenExecuteAfter(4, () => {
		      366 +       test.setBlockType(trigger, MinecraftBlockTypes.blueWool);
		      367 +     })
		      368 +     .thenWaitWithDelay(6, () => {
		      369 +       test.assertBlockPresent(MinecraftBlockTypes.yellowWool, posC, true);
		      370 +     })
		      371 +     .thenExecuteAfter(4, () => {
		      372 +       test.setBlockType(trigger, MinecraftBlockTypes.purpleWool);
		      373 +     })
		      374 +     .thenWaitWithDelay(6, () => {
		      375 +       test.assertBlockPresent(MinecraftBlockTypes.yellowWool, posD, true);
		 298      -     test.assertBlockTypePresent(MinecraftBlockTypes.emeraldBlock, overLimitTip);
		 299      -   });
		 300      - }).tag(GameTest.Tags.suiteDefault);
		 301      - 
		 302      - GameTest.register("PistonTests", "block_leave", (test) => {
		 303      -   const trigger = new BlockLocation(3, 1, 1);
		 304      -   const retracted = new BlockLocation(1, 1, 1);
		 305      -   const extended = new BlockLocation(0, 1, 1);
		 306      - 
		 307      -   test.pulseRedstone(trigger, 2);
		 308      -   test
		 309      -     .startSequence()
		 310      -     .thenWaitWithDelay(3, () => {
		 311      -       test.assertBlockTypePresent(MinecraftBlockTypes.concrete, extended);
		 312      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, retracted);
		 313  376       })
		      377 +     .thenExecuteAfter(4, () => {
		      378 +       test.setBlockType(trigger, MinecraftBlockTypes.cyanWool);
		 314      -     .thenExecuteAfter(3, () => {
		 315      -       test.pulseRedstone(trigger, 2);
		 316  379       })
		      380 +     .thenWaitWithDelay(6, () => {
		 317      -     .thenWaitWithDelay(5, () => {
		 318      -       test.assertBlockTypePresent(MinecraftBlockTypes.concrete, retracted);
		      381 +       test.assertBlockPresent(MinecraftBlockTypes.yellowWool, posA, true);
		 319      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, extended);
		 320  382       })
		 321  383       .thenSucceed();
		 322  384   })
		      385 +   .required(false)
		 323  386     .tag("suite:java_parity")
		      387 +   .tag(GameTest.Tags.suiteDisabled); //Due to redstone differences, create a new test called update_order_bedrock. Also, use colored glazed terracotta instead of missing colored wool blocks.
		 324      -   .tag(GameTest.Tags.suiteDisabled); //In Java Edition, pistons finish extending early and start retracting if given a pulse shorter than 3 game ticks (1.5 redstone ticks; 0.15 seconds). These shorter pulses cause sticky pistons to "drop" their block, leaving it behind when trying to push it with a short pulse. Also, this causes the block to end up in its final position earlier.Therefore, the bedrock version can't be modified, and can only be verified according to the piston tension,
		 325  388   
		      389 + GameTest.register("PistonTests", "update_order_bedrock", (test) => {
		      390 +   const posA = new BlockLocation(2, 1, 1);
		 326      - GameTest.register("PistonTests", "block_leave_bedrock", (test) => {
		      391 +   const posB = new BlockLocation(2, 1, 0);
		      392 +   const posC = new BlockLocation(3, 1, 0);
		      393 +   const posD = new BlockLocation(1, 1, 0);
		 327      -   const trigger = new BlockLocation(3, 1, 1);
		 328      -   const retracted = new BlockLocation(1, 1, 1);
		 329      -   const extended = new BlockLocation(0, 1, 1);
		 330  394   
		      395 +   const trigger = new BlockLocation(6, 2, 2);
		      396 +   test.setBlockType(MinecraftBlockTypes.greenGlazedTerracotta, trigger);
		 331      -   test.pulseRedstone(trigger, 2);
		 332  397     test
		 333  398       .startSequence()
		      399 +     .thenIdle(5)
		 334      -     .thenIdle(2)
		 335  400       .thenWait(() => {
		      401 +       test.assertBlockPresent(MinecraftBlockTypes.wool, posB, true);
		 336      -       test.assertBlockTypePresent(MinecraftBlockTypes.concrete, extended);
		 337      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, retracted);
		 338  402       })
		      403 +     .thenIdle(4)
		      404 +     .thenWait(() => {
		 339      -     .thenExecuteAfter(3, () => {
		      405 +       test.setBlockType(MinecraftBlockTypes.blueGlazedTerracotta, trigger);
		 340      -       test.pulseRedstone(trigger, 2);
		 341  406       })
		 342  407       .thenIdle(6)
		 343  408       .thenWait(() => {
		      409 +       test.assertBlockPresent(MinecraftBlockTypes.wool, posC, true);
		 344      -       test.assertBlockTypePresent(MinecraftBlockTypes.concrete, retracted);
		 345      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, extended);
		 346  410       })
		      411 +     .thenIdle(4)
		 347      -     .thenSucceed();
		 348      - }).tag(GameTest.Tags.suiteDefault);
		      412 +     .thenWait(() => {
		      413 +       test.setBlockType(MinecraftBlockTypes.purpleGlazedTerracotta, trigger);
		      414 +     })
		      415 +     .thenIdle(6)
		      416 +     .thenWait(() => {
		      417 +       test.assertBlockPresent(MinecraftBlockTypes.wool, posD, true);
		      418 +     })
		      419 +     .thenIdle(4)
		      420 +     .thenWait(() => {
		      421 +       test.setBlockType(MinecraftBlockTypes.cyanGlazedTerracotta, trigger);
		      422 +     })
		      423 +     .thenIdle(6)
		      424 +     .thenWait(() => {
		      425 +       test.assertBlockPresent(MinecraftBlockTypes.wool, posA, true);
		 349      - 
		 350      - GameTest.register("PistonTests", "update_order", (test) => {
		 351      -   const posA = new BlockLocation(2, 1, 1);
		 352      -   const posB = new BlockLocation(2, 1, 0);
		 353      -   const posC = new BlockLocation(3, 1, 0);
		 354      -   const posD = new BlockLocation(1, 1, 0);
		 355      - 
		 356      -   const trigger = new BlockLocation(6, 2, 2);
		 357      -   test.setBlockType(trigger, MinecraftBlockTypes.greenWool);
		 358      - 
		 359      -   test
		 360      -     .startSequence()
		 361      -     .thenWaitWithDelay(4, () => {
		 362      -       test.assertBlockTypePresent(MinecraftBlockTypes.yellowWool, posB);
		 363  426       })
		      427 +     .thenSucceed();
		      428 + })
		      429 + 
		 364      -     .thenExecuteAfter(4, () => {
		      430 +   .required(false)
		      431 +   .tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed as block position doesn't update with the right order.
		      432 + 
		      433 + GameTest.register("PistonTests", "double_extender", (test) => {
		      434 +   const pullLeverPos = new BlockLocation(2, 3, 2);
		      435 +   const blockPresentPosA = new BlockLocation(0, 2, 2);
		      436 +   const blockPresentPosB = new BlockLocation(0, 2, 4);
		      437 + 
		      438 +   test.pullLever(pullLeverPos);
		      439 +   test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosA, true);
		      440 + 
		      441 +   test
		      442 +     .startSequence()
		      443 +     .thenWaitWithDelay(11, () => {
		      444 +       test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosB, true);
		      445 +       test.pullLever(pullLeverPos);
		 365      -       test.setBlockType(trigger, MinecraftBlockTypes.blueWool);
		 366      -     })
		 367      -     .thenWaitWithDelay(6, () => {
		 368      -       test.assertBlockTypePresent(MinecraftBlockTypes.yellowWool, posC);
		 369      -     })
		 370      -     .thenExecuteAfter(4, () => {
		 371      -       test.setBlockType(trigger, MinecraftBlockTypes.purpleWool);
		 372      -     })
		 373      -     .thenWaitWithDelay(6, () => {
		 374      -       test.assertBlockTypePresent(MinecraftBlockTypes.yellowWool, posD);
		 375      -     })
		 376      -     .thenExecuteAfter(4, () => {
		 377      -       test.setBlockType(trigger, MinecraftBlockTypes.cyanWool);
		 378      -     })
		 379      -     .thenWaitWithDelay(6, () => {
		 380      -       test.assertBlockTypePresent(MinecraftBlockTypes.yellowWool, posA);
		 381  446       })
		 382      -     .thenSucceed();
		 383      - })
		 384      -   .required(false)
		 385      -   .tag("suite:java_parity")
		      447 +     .thenWaitWithDelay(12, () => {
		      448 +       test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosA, true);
		      449 +     })
		      450 +     .thenSucceed();
		      451 + })
		      452 +   .tag("suite:java_parity")
		      453 +   .tag(GameTest.Tags.suiteDisabled); //Pistons react at different speeds in Bedrock, create a new test called double_extender_bedrock.
		 386      -   .tag(GameTest.Tags.suiteDisabled); //Due to redstone differences, create a new test called update_order_bedrock. Also, use colored glazed terracotta instead of missing colored wool blocks.
		 387      - 
		 388      - GameTest.register("PistonTests", "update_order_bedrock", (test) => {
		 389      -   const posA = new BlockLocation(2, 1, 1);
		 390      -   const posB = new BlockLocation(2, 1, 0);
		 391      -   const posC = new BlockLocation(3, 1, 0);
		 392      -   const posD = new BlockLocation(1, 1, 0);
		 393  454   
		      455 + GameTest.register("PistonTests", "double_extender_bedrock", (test) => {
		      456 +   const pullLeverPos = new BlockLocation(2, 3, 2);
		 394      -   const trigger = new BlockLocation(6, 2, 2);
		 395      -   test.setBlockType(MinecraftBlockTypes.greenGlazedTerracotta, trigger);
		      457 +   const blockPresentPosA = new BlockLocation(0, 2, 2);
		      458 +   const blockPresentPosB = new BlockLocation(0, 2, 4);
		      459 + 
		      460 +   test.pullLever(pullLeverPos);
		      461 +   test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosA, true);
		      462 + 
		      463 +   //it's not possible to time it exactly due to redstone differences, so just validate assert can pass before given delay.
		      464 +   test
		      465 +     .startSequence()
		      466 +     .thenIdle(17)
		      467 +     .thenExecute(() => {
		      468 +       test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosB, true);
		      469 +       test.pullLever(pullLeverPos);
		 396      -   test
		 397      -     .startSequence()
		 398      -     .thenIdle(5)
		 399      -     .thenWait(() => {
		 400      -       test.assertBlockTypePresent(MinecraftBlockTypes.wool, posB);
		 401      -     })
		 402      -     .thenIdle(4)
		 403      -     .thenWait(() => {
		 404      -       test.setBlockType(MinecraftBlockTypes.blueGlazedTerracotta, trigger);
		 405      -     })
		 406      -     .thenIdle(6)
		 407      -     .thenWait(() => {
		 408      -       test.assertBlockTypePresent(MinecraftBlockTypes.wool, posC);
		 409  470       })
		      471 +     .thenIdle(18)
		      472 +     .thenExecute(() => {
		 410      -     .thenIdle(4)
		 411      -     .thenWait(() => {
		      473 +       test.assertBlockPresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosA, true);
		 412      -       test.setBlockType(MinecraftBlockTypes.purpleGlazedTerracotta, trigger);
		 413  474       })
		      475 +     .thenSucceed();
		      476 + })
		 414      -     .thenIdle(6)
		      477 +   .structureName("PistonTests:double_extender")
		      478 +   .tag(GameTest.Tags.suiteDefault);
		 415      -     .thenWait(() => {
		 416      -       test.assertBlockTypePresent(MinecraftBlockTypes.wool, posD);
		 417      -     })
		      479 + 
		      480 + GameTest.register("PistonTests", "triple_extender", (test) => {
		      481 +   const retracted = new BlockLocation(0, 4, 4);
		      482 +   const extended = new BlockLocation(0, 1, 4);
		      483 +   const trigger = new BlockLocation(0, 8, 0);
		      484 +   const assertBlockPresentA = new BlockLocation(0, 7, 4);
		      485 +   const assertBlockPresentB = new BlockLocation(0, 6, 4);
		      486 +   const assertBlockPresentC = new BlockLocation(0, 5, 4);
		      487 + 
		      488 +   test.pressButton(trigger);
		 418      -     .thenIdle(4)
		 419      -     .thenWait(() => {
		 420      -       test.setBlockType(MinecraftBlockTypes.cyanGlazedTerracotta, trigger);
		 421      -     })
		 422      -     .thenIdle(6)
		 423      -     .thenWait(() => {
		 424      -       test.assertBlockTypePresent(MinecraftBlockTypes.wool, posA);
		 425      -     })
		 426      -     .thenSucceed();
		 427      - })
		 428  489   
		      490 +   test
		      491 +     .startSequence()
		      492 +     .thenIdle(30)
		 429      -   .required(false)
		      493 +     .thenWait(() => {
		 430      -   .tag(GameTest.Tags.suiteDisabled); //Both of Java and Bedrock are failed as block position doesn't update with the right order.
		 431      - 
		      494 +       test.assertBlockPresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentA, true);
		      495 +       test.assertBlockPresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentB, true);
		      496 +       test.assertBlockPresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentC, true);
		      497 +       test.assertBlockPresent(MinecraftBlockTypes.concrete, extended, true);
		      498 +     })
		      499 +     .thenIdle(20)
		      500 +     .thenWait(() => {
		      501 +       test.pressButton(trigger);
		      502 +     })
		      503 +     .thenIdle(42)
		      504 +     .thenWait(() => {
		      505 +       test.assertBlockPresent(MinecraftBlockTypes.stickyPiston, new assertBlockPresentA(), true);
		      506 +       test.assertBlockPresent(MinecraftBlockTypes.stickyPiston, new assertBlockPresentB(), true);
		 432      - GameTest.register("PistonTests", "double_extender", (test) => {
		 433      -   const pullLeverPos = new BlockLocation(2, 3, 2);
		 434      -   const blockPresentPosA = new BlockLocation(0, 2, 2);
		 435      -   const blockPresentPosB = new BlockLocation(0, 2, 4);
		 436      - 
		 437      -   test.pullLever(pullLeverPos);
		 438      -   test.assertBlockTypePresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosA);
		 439      - 
		 440      -   test
		 441      -     .startSequence()
		 442      -     .thenWaitWithDelay(11, () => {
		 443      -       test.assertBlockTypePresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosB);
		 444      -       test.pullLever(pullLeverPos);
		 445      -     })
		      507 +       test.assertBlockPresent(MinecraftBlockTypes.stickyPiston, new assertBlockPresentC(), true);
		      508 +       test.assertBlockPresent(MinecraftBlockTypes.concrete, retracted, true);
		 446      -     .thenWaitWithDelay(12, () => {
		 447      -       test.assertBlockTypePresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosA);
		 448  509       })
		 449  510       .thenSucceed();
		 450  511   })
		 451  512     .tag("suite:java_parity")
		      513 +   .tag(GameTest.Tags.suiteDisabled); // Game parity issue. Create a new test called triple_extender_bedrock using new structure, and updated piston react time.
		 452      -   .tag(GameTest.Tags.suiteDisabled); //Pistons react at different speeds in Bedrock, create a new test called double_extender_bedrock.
		 453  514   
		      515 + GameTest.register("PistonTests", "triple_extender_bedrock", (test) => {
		      516 +   const retracted = new BlockLocation(0, 4, 4);
		 454      - GameTest.register("PistonTests", "double_extender_bedrock", (test) => {
		 455      -   const pullLeverPos = new BlockLocation(2, 3, 2);
		      517 +   const extended = new BlockLocation(0, 1, 4);
		      518 +   const trigger = new BlockLocation(0, 7, 0);
		      519 +   const assertBlockPresentA = new BlockLocation(0, 7, 4);
		      520 +   const assertBlockPresentB = new BlockLocation(0, 6, 4);
		      521 +   const assertBlockPresentC = new BlockLocation(0, 5, 4);
		      522 +   const assertBlockPresentD = new BlockLocation(0, 3, 4);
		      523 +   test.pressButton(trigger);
		 456      -   const blockPresentPosA = new BlockLocation(0, 2, 2);
		 457      -   const blockPresentPosB = new BlockLocation(0, 2, 4);
		 458      - 
		 459      -   test.pullLever(pullLeverPos);
		 460      -   test.assertBlockTypePresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosA);
		 461      - 
		 462      -   //it's not possible to time it exactly due to redstone differences, so just validate assert can pass before given delay.
		 463  524     test
		 464  525       .startSequence()
		 465      -     .thenIdle(17)
		 466      -     .thenExecute(() => {
		 467      -       test.assertBlockTypePresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosB);
		      526 +     .thenWait(() => {
		      527 +       test.assertBlockPresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentA, true);
		      528 +       test.assertBlockPresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentC, true);
		      529 +       test.assertBlockPresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentD, true);
		      530 +       test.assertBlockPresent(MinecraftBlockTypes.concrete, extended, true);
		 468      -       test.pullLever(pullLeverPos);
		 469      -     })
		 470      -     .thenIdle(18)
		 471      -     .thenExecute(() => {
		 472      -       test.assertBlockTypePresent(MinecraftBlockTypes.emeraldBlock, blockPresentPosA);
		 473  531       })
		 474      -     .thenSucceed();
		 475      - })
		 476      -   .structureName("PistonTests:double_extender")
		      532 +     .thenWait(() => {
		      533 +       test.assertBlockPresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentA, true);
		      534 +       test.assertBlockPresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentB, true);
		      535 +       test.assertBlockPresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentC, true);
		      536 +       test.assertBlockPresent(MinecraftBlockTypes.concrete, retracted, true);
		      537 +     })
		      538 +     .thenSucceed();
		      539 + })
		      540 +   .setupTicks(20)
		      541 +   .tag(GameTest.Tags.suiteDefault)
		      542 +   .maxTicks(100);
		 477      -   .tag(GameTest.Tags.suiteDefault);
		 478      - 
		 479      - GameTest.register("PistonTests", "triple_extender", (test) => {
		 480      -   const retracted = new BlockLocation(0, 4, 4);
		 481      -   const extended = new BlockLocation(0, 1, 4);
		 482      -   const trigger = new BlockLocation(0, 8, 0);
		 483      -   const assertBlockPresentA = new BlockLocation(0, 7, 4);
		 484      -   const assertBlockPresentB = new BlockLocation(0, 6, 4);
		 485      -   const assertBlockPresentC = new BlockLocation(0, 5, 4);
		 486      - 
		 487      -   test.pressButton(trigger);
		 488  543   
		      544 + GameTest.register("PistonTests", "monostable", (test) => {
		      545 +   const testEx = new GameTestExtensions(test);
		 489      -   test
		 490      -     .startSequence()
		      546 +   const lampPos = new BlockLocation(0, 3, 5);
		      547 +   const pullLeverPos = new BlockLocation(0, 2, 0);
		      548 + 
		      549 +   testEx.assertBlockProperty("redstone_signal", 0, lampPos);
		      550 +   test.pullLever(pullLeverPos);
		      551 + 
		      552 +   test
		      553 +     .startSequence()
		      554 +     .thenWaitWithDelay(2, () => {
		      555 +       testEx.assertBlockProperty("redstone_signal", 1, lampPos);
		 491      -     .thenIdle(30)
		 492      -     .thenWait(() => {
		 493      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentA);
		 494      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentB);
		 495      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentC);
		 496      -       test.assertBlockTypePresent(MinecraftBlockTypes.concrete, extended);
		 497      -     })
		 498      -     .thenIdle(20)
		 499      -     .thenWait(() => {
		 500      -       test.pressButton(trigger);
		 501  556       })
		 502      -     .thenIdle(42)
		 503      -     .thenWait(() => {
		 504      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickyPiston, new assertBlockPresentA());
		 505      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickyPiston, new assertBlockPresentB());
		      557 +     .thenWaitWithDelay(4, () => {
		      558 +       testEx.assertBlockProperty("redstone_signal", 0, lampPos);
		 506      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickyPiston, new assertBlockPresentC());
		 507      -       test.assertBlockTypePresent(MinecraftBlockTypes.concrete, retracted);
		 508  559       })
		 509  560       .thenSucceed();
		 510  561   })
		 511  562     .tag("suite:java_parity")
		      563 +   .tag(GameTest.Tags.suiteDisabled); //quasi connectivity problem: when the repeater is in the upper right corner of the piston, the bedrock piston will not stretch, but Java will stretch
		 512      -   .tag(GameTest.Tags.suiteDisabled); // Game parity issue. Create a new test called triple_extender_bedrock using new structure, and updated piston react time.
		 513  564   
		 514      - GameTest.register("PistonTests", "triple_extender_bedrock", (test) => {
		 515      -   const retracted = new BlockLocation(0, 4, 4);
		 516      -   const extended = new BlockLocation(0, 1, 4);
		      565 + GameTest.register("PistonTests", "monostable_bedrock", (test) => {
		      566 +   const lampPos = new BlockLocation(0, 3, 5);
		      567 +   const pullLeverPos = new BlockLocation(0, 2, 0);
		      568 + 
		      569 +   test.assertRedstonePower(lampPos, 0);
		      570 + 
		 517      -   const trigger = new BlockLocation(0, 7, 0);
		 518      -   const assertBlockPresentA = new BlockLocation(0, 7, 4);
		 519      -   const assertBlockPresentB = new BlockLocation(0, 6, 4);
		 520      -   const assertBlockPresentC = new BlockLocation(0, 5, 4);
		 521      -   const assertBlockPresentD = new BlockLocation(0, 3, 4);
		 522      -   test.pressButton(trigger);
		 523  571     test
		 524  572       .startSequence()
		      573 +     .thenIdle(10)
		      574 +     .thenExecute(() => {
		      575 +       test.pullLever(pullLeverPos);
		 525      -     .thenWait(() => {
		      576 +     })
		      577 +     .thenIdle(5)
		      578 +     .thenExecute(() => {
		      579 +       test.assertRedstonePower(lampPos, 15);
		 526      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentA);
		 527      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentC);
		 528      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentD);
		 529      -       test.assertBlockTypePresent(MinecraftBlockTypes.concrete, extended);
		 530  580       })
		      581 +     .thenIdle(9)
		 531      -     .thenWait(() => {
		 532      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentA);
		 533      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentB);
		      582 +     .thenExecute(() => {
		      583 +       test.assertRedstonePower(lampPos, 0);
		 534      -       test.assertBlockTypePresent(MinecraftBlockTypes.stickyPiston, assertBlockPresentC);
		 535      -       test.assertBlockTypePresent(MinecraftBlockTypes.concrete, retracted);
		 536  584       })
		 537  585       .thenSucceed();
		 538  586   })
		      587 +   .maxTicks(100)
		      588 +   .tag(GameTest.Tags.suiteDefault);
		      589 + 
		      590 + GameTest.register("PistonTests", "instant_retraction", (test) => {
		      591 +   const airPos = new BlockLocation(2, 1, 1);
		      592 +   const concretePos = new BlockLocation(0, 1, 3);
		 539      -   .setupTicks(20)
		 540      -   .tag(GameTest.Tags.suiteDefault)
		 541      -   .maxTicks(100);
		 542  593   
		      594 +   test.setBlockType(MinecraftBlockTypes.air, airPos);
		      595 +   test.succeedOnTickWhen(3, () => {
		      596 +     test.assertBlockPresent(MinecraftBlockTypes.concrete, concretePos, true);
		 543      - GameTest.register("PistonTests", "monostable", (test) => {
		      597 +   });
		      598 + }).tag(GameTest.Tags.suiteDefault);
		 544      -   const lampPos = new BlockLocation(0, 3, 5);
		 545      -   const pullLeverPos = new BlockLocation(0, 2, 0);
		 546  599   
		      600 + GameTest.register("PistonTests", "instant_repeater", (test) => {
		      601 +   const testEx = new GameTestExtensions(test);
		      602 +   const triggerPos = new BlockLocation(0, 3, 0);
		      603 +   const outputPos = new BlockLocation(0, 3, 25);
		      604 +   test.pullLever(triggerPos);
		 547      -   test.assertBlockState("redstone_signal", 0, lampPos);
		 548      -   test.pullLever(pullLeverPos);
		 549  605   
		 550  606     test
		 551  607       .startSequence()
		      608 +     .thenWaitWithDelay(1, () => {
		      609 +       testEx.assertBlockProperty("redstone_signal", 1, outputPos);
		 552      -     .thenWaitWithDelay(2, () => {
		 553      -       test.assertBlockState("redstone_signal", 1, lampPos);
		 554  610       })
		      611 +     .thenIdle(10) // relaxation time
		      612 +     .thenExecute(() => {
		 555      -     .thenWaitWithDelay(4, () => {
		      613 +       test.pullLever(triggerPos);
		 556      -       test.assertBlockState("redstone_signal", 0, lampPos);
		 557  614       })
		 558      -     .thenSucceed();
		 559      - })
		 560      -   .tag("suite:java_parity")
		      615 +     .thenWaitWithDelay(5, () => {
		      616 +       testEx.assertBlockProperty("redstone_signal", 0, outputPos);
		      617 +     })
		      618 +     .thenSucceed();
		      619 + })
		      620 +   .tag("suite:java_parity")
		      621 +   .tag(GameTest.Tags.suiteDisabled); //Instant repeaters rely on block update detection due to quasi-connectivity and cannot be built in Bedrock.
		 561      -   .tag(GameTest.Tags.suiteDisabled); //quasi connectivity problem: when the repeater is in the upper right corner of the piston, the bedrock piston will not stretch, but Java will stretch
		 562      - 
		 563      - GameTest.register("PistonTests", "monostable_bedrock", (test) => {
		 564      -   const lampPos = new BlockLocation(0, 3, 5);
		 565      -   const pullLeverPos = new BlockLocation(0, 2, 0);
		 566      - 
		 567      -   test.assertRedstonePower(lampPos, 0);
		 568  622   
		 569      -   test
		 570      -     .startSequence()
		 571      -     .thenIdle(10)
		      623 + GameTest.register("PistonTests", "entity_backside", (test) => {
		      624 +   const buttonPos = new BlockLocation(2, 2, 0);
		      625 +   const lampFailPos = new BlockLocation(4, 3, 2);
		      626 + 
		      627 +   test.pressButton(buttonPos);
		      628 +   test
		      629 +     .startSequence()
		      630 +     .thenIdle(30)
		      631 +     .thenWait(() => {
		      632 +       test.assertBlockPresent(MinecraftBlockTypes.redstoneLamp, lampFailPos, false);
		 572      -     .thenExecute(() => {
		 573      -       test.pullLever(pullLeverPos);
		 574      -     })
		 575      -     .thenIdle(5)
		 576      -     .thenExecute(() => {
		 577      -       test.assertRedstonePower(lampPos, 15);
		 578      -     })
		 579      -     .thenIdle(9)
		 580      -     .thenExecute(() => {
		 581      -       test.assertRedstonePower(lampPos, 0);
		 582  633       })
		 583  634       .thenSucceed();
		      635 + }).tag(GameTest.Tags.suiteDefault);
		      636 + 
		      637 + GameTest.register("PistonTests", "redstone_matrix", (test) => {
		 584      - })
		      638 +   const buttonPos = new BlockLocation(1, 3, 1);
		      639 +   const wirePos = new BlockLocation(1, 4, 2);
		 585      -   .maxTicks(100)
		 586      -   .tag(GameTest.Tags.suiteDefault);
		 587  640   
		      641 +   test.pressButton(buttonPos);
		      642 +   test
		 588      - GameTest.register("PistonTests", "instant_retraction", (test) => {
		      643 +     .startSequence()
		      644 +     .thenIdle(30)
		 589      -   const airPos = new BlockLocation(2, 1, 1);
		 590      -   const concretePos = new BlockLocation(0, 1, 3);
		 591      - 
		      645 +     .thenWait(() => {
		      646 +       test.assertBlockPresent(MinecraftBlockTypes.redstoneWire, wirePos, true);
		      647 +     })
		      648 +     .thenSucceed();
		 592      -   test.setBlockType(MinecraftBlockTypes.air, airPos);
		 593      -   test.succeedOnTickWhen(3, () => {
		 594      -     test.assertBlockTypePresent(MinecraftBlockTypes.concrete, concretePos);
		 595      -   });
		 596  649   }).tag(GameTest.Tags.suiteDefault);
		 597  650   
		      651 + GameTest.register("PistonTests", "one_tick_pulse", (test) => {
		      652 +   const retractedPos = new BlockLocation(1, 2, 3);
		 598      - GameTest.register("PistonTests", "instant_repeater", (test) => {
		 599      -   const triggerPos = new BlockLocation(0, 3, 0);
		      653 +   const extendedPos = new BlockLocation(0, 2, 3);
		      654 +   const pressButtonPos = new BlockLocation(2, 2, 0);
		 600      -   const outputPos = new BlockLocation(0, 3, 25);
		 601      -   test.pullLever(triggerPos);
		 602  655   
		 603      -   test
		 604      -     .startSequence()
		 605      -     .thenWaitWithDelay(1, () => {
		 606      -       test.assertBlockState("redstone_signal", 1, outputPos);
		      656 +   test.pressButton(pressButtonPos);
		      657 + 
		      658 +   test
		      659 +     .startSequence()
		      660 + 
		      661 +     .thenWaitWithDelay(2, () => {
		      662 +       test.assertBlockPresent(MinecraftBlockTypes.stainedGlass, extendedPos, true);
		 607      -     })
		 608      -     .thenIdle(10) // relaxation time
		 609      -     .thenExecute(() => {
		 610      -       test.pullLever(triggerPos);
		 611      -     })
		 612      -     .thenWaitWithDelay(5, () => {
		 613      -       test.assertBlockState("redstone_signal", 0, outputPos);
		 614  663       })
		      664 +     .thenIdle(30)
		 615      -     .thenSucceed();
		 616      - })
		      665 +     .thenWait(() => {
		      666 +       test.pressButton(pressButtonPos);
		      667 +     })
		      668 +     .thenWaitWithDelay(4, () => {
		      669 +       test.assertBlockPresent(MinecraftBlockTypes.stainedGlass, retractedPos, true);
		      670 +       test.assertBlockPresent(MinecraftBlockTypes.air, extendedPos, true);
		      671 +     })
		      672 +     .thenSucceed();
		      673 + })
		      674 +   .tag("suite:java_parity")
		      675 +   .tag(GameTest.Tags.suiteDisabled); //It's Gameplay differences. In Java Edition, pistons finish extending early and start retracting if given a pulse shorter than 3 game ticks, this causes the block to end up in its final position earlier.
		      676 + 
		      677 + GameTest.register("PistonTests", "one_tick_pulse_bedrock", (test) => {
		      678 +   const retractedPos = new BlockLocation(1, 2, 3);
		      679 +   const extendedPos = new BlockLocation(0, 2, 3);
		      680 +   const pressButtonPos = new BlockLocation(2, 2, 0);
		 617      -   .tag("suite:java_parity")
		 618      -   .tag(GameTest.Tags.suiteDisabled); //Instant repeaters rely on block update detection due to quasi-connectivity and cannot be built in Bedrock.
		 619      - 
		 620      - GameTest.register("PistonTests", "entity_backside", (test) => {
		 621      -   const buttonPos = new BlockLocation(2, 2, 0);
		 622      -   const lampFailPos = new BlockLocation(4, 3, 2);
		 623      - 
		 624      -   test.pressButton(buttonPos);
		 625      -   test
		 626      -     .startSequence()
		 627      -     .thenIdle(30)
		 628      -     .thenWait(() => {
		 629      -       test.assertBlockTypeNotPresent(MinecraftBlockTypes.redstoneLamp, lampFailPos);
		 630      -     })
		 631      -     .thenSucceed();
		 632      - }).tag(GameTest.Tags.suiteDefault);
		 633  681   
		      682 +   test.pressButton(pressButtonPos);
		 634      - GameTest.register("PistonTests", "redstone_matrix", (test) => {
		 635      -   const buttonPos = new BlockLocation(1, 3, 1);
		 636      -   const wirePos = new BlockLocation(1, 4, 2);
		 637  683   
		 638      -   test.pressButton(buttonPos);
		 639  684     test
		 640  685       .startSequence()
		      686 +     .thenIdle(2)
		 641      -     .thenIdle(30)
		 642  687       .thenWait(() => {
		      688 +       test.assertBlockPresent(MinecraftBlockTypes.stainedGlass, extendedPos, true);
		 643      -       test.assertBlockTypePresent(MinecraftBlockTypes.redstoneWire, wirePos);
		 644  689       })
		      690 +     .thenIdle(30)
		 645      -     .thenSucceed();
		 646      - }).tag(GameTest.Tags.suiteDefault);
		      691 +     .thenWait(() => {
		      692 +       test.pressButton(pressButtonPos);
		      693 +     })
		      694 +     .thenIdle(4)
		      695 +     .thenWait(() => {
		      696 +       test.assertBlockPresent(MinecraftBlockTypes.stainedGlass, retractedPos, true);
		      697 +       test.assertBlockPresent(MinecraftBlockTypes.air, extendedPos, true);
		      698 +     })
		      699 +     .thenSucceed();
		      700 + }).tag(GameTest.Tags.suiteDefault);
		 647      - 
		 648      - GameTest.register("PistonTests", "one_tick_pulse", (test) => {
		 649      -   const retractedPos = new BlockLocation(1, 2, 3);
		 650      -   const extendedPos = new BlockLocation(0, 2, 3);
		 651      -   const pressButtonPos = new BlockLocation(2, 2, 0);
		 652      - 
		 653      -   test.pressButton(pressButtonPos);
		 654      - 
		 655      -   test
		 656      -     .startSequence()
		 657  701   
		      702 + GameTest.register("PistonTests", "backside", (test) => {
		      703 +   var buttonsBlockPos = [
		      704 +     new BlockLocation(3, 3, 0),
		      705 +     new BlockLocation(1, 2, 1),
		      706 +     new BlockLocation(4, 3, 3),
		      707 +     new BlockLocation(1, 4, 3),
		      708 +     new BlockLocation(3, 3, 6),
		      709 +     new BlockLocation(0, 3, 5),
		      710 +   ];
		      711 + 
		      712 +   for (const buttonPos of buttonsBlockPos) {
		      713 +     test.pressButton(buttonPos);
		      714 +   }
		      715 +   test
		      716 +     .startSequence()
		      717 +     .thenIdle(30)
		      718 +     .thenWait(() => {
		      719 +       for (const buttonPos of buttonsBlockPos) {
		      720 +         test.assertBlockPresent(MinecraftBlockTypes.stoneButton, buttonPos, true);
		      721 +       }
		      722 +     })
		      723 +     .thenSucceed();
		      724 + }).tag(GameTest.Tags.suiteDefault);
		 658      -     .thenWaitWithDelay(2, () => {
		 659      -       test.assertBlockTypePresent(MinecraftBlockTypes.stainedGlass, extendedPos);
		 660      -     })
		 661      -     .thenIdle(30)
		 662      -     .thenWait(() => {
		 663      -       test.pressButton(pressButtonPos);
		 664      -     })
		 665      -     .thenWaitWithDelay(4, () => {
		 666      -       test.assertBlockTypePresent(MinecraftBlockTypes.stainedGlass, retractedPos);
		 667      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, extendedPos);
		 668      -     })
		 669      -     .thenSucceed();
		 670      - })
		 671      -   .tag("suite:java_parity")
		 672      -   .tag(GameTest.Tags.suiteDisabled); //It's Gameplay differences. In Java Edition, pistons finish extending early and start retracting if given a pulse shorter than 3 game ticks, this causes the block to end up in its final position earlier.
		 673      - 
		 674      - GameTest.register("PistonTests", "one_tick_pulse_bedrock", (test) => {
		 675      -   const retractedPos = new BlockLocation(1, 2, 3);
		 676      -   const extendedPos = new BlockLocation(0, 2, 3);
		 677      -   const pressButtonPos = new BlockLocation(2, 2, 0);
		 678  725   
		      726 + GameTest.register("PistonTests", "observer_retraction_timing", (test) => {
		      727 +   const testEx = new GameTestExtensions(test);
		      728 +   const levelPos = new BlockLocation(3, 2, 2);
		      729 +   const observerPos = new BlockLocation(2, 2, 1);
		      730 +   test.pullLever(levelPos);
		 679      -   test.pressButton(pressButtonPos);
		 680      - 
		 681  731     test
		 682  732       .startSequence()
		 683  733       .thenIdle(2)
		 684      -     .thenWait(() => {
		 685      -       test.assertBlockTypePresent(MinecraftBlockTypes.stainedGlass, extendedPos);
		 686      -     })
		 687      -     .thenIdle(30)
		      734 +     .thenExecute(() => {
		      735 +       testEx.assertBlockProperty("powered_bit", 0, observerPos);
		 688      -     .thenWait(() => {
		 689      -       test.pressButton(pressButtonPos);
		 690  736       })
		      737 +     .thenIdle(1)
		 691      -     .thenIdle(4)
		 692      -     .thenWait(() => {
		      738 +     .thenExecute(() => {
		      739 +       testEx.assertBlockProperty("powered_bit", 1, observerPos);
		 693      -       test.assertBlockTypePresent(MinecraftBlockTypes.stainedGlass, retractedPos);
		 694      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, extendedPos);
		 695  740       })
		 696  741       .thenSucceed();
		 697  742   }).tag(GameTest.Tags.suiteDefault);
		 698  743   
		      744 + GameTest.register("PistonTests", "random_tick_forcer", (test) => {
		      745 +   const buttonPos = new BlockLocation(1, 3, 0);
		 699      - GameTest.register("PistonTests", "backside", (test) => {
		 700      -   var buttonsBlockPos = [
		      746 +   const flower = new BlockLocation(1, 3, 6);
		      747 +   const aboveFlower = new BlockLocation(1, 4, 6);
		      748 + 
		      749 +   test.pressButton(buttonPos);
		      750 +   test
		      751 +     .startSequence()
		      752 +     .thenIdle(20)
		      753 +     .thenExecute(() => {
		      754 +       test.assertBlockPresent(MinecraftBlockTypes.chorusFlower, flower, true);
		      755 +       test.assertBlockPresent(MinecraftBlockTypes.air, aboveFlower, true);
		      756 +     })
		      757 +     .thenSucceed();
		      758 + })
		      759 +   .batch("no_random_ticks")
		      760 +   .tag("suite:java_parity")
		      761 +   .tag(GameTest.Tags.suiteDisabled); //The parity problem is still being solved
		      762 + 
		      763 + GameTest.register("PistonTests", "random_tick_forcer_bedrock", (test) => {
		      764 +   const buttonPos = new BlockLocation(1, 3, 0);
		      765 +   const flower = new BlockLocation(1, 3, 6);
		      766 +   const aboveFlower = new BlockLocation(1, 4, 6);
		 701      -     new BlockLocation(3, 3, 0),
		 702      -     new BlockLocation(1, 2, 1),
		 703      -     new BlockLocation(4, 3, 3),
		 704      -     new BlockLocation(1, 4, 3),
		 705      -     new BlockLocation(3, 3, 6),
		 706      -     new BlockLocation(0, 3, 5),
		 707      -   ];
		 708      - 
		 709      -   for (const buttonPos of buttonsBlockPos) {
		 710      -     test.pressButton(buttonPos);
		 711      -   }
		 712      -   test
		 713      -     .startSequence()
		 714      -     .thenIdle(30)
		 715      -     .thenWait(() => {
		 716      -       for (const buttonPos of buttonsBlockPos) {
		 717      -         test.assertBlockTypePresent(MinecraftBlockTypes.stoneButton, buttonPos);
		 718      -       }
		 719      -     })
		 720      -     .thenSucceed();
		 721      - }).tag(GameTest.Tags.suiteDefault);
		 722  767   
		 723      - GameTest.register("PistonTests", "observer_retraction_timing", (test) => {
		 724      -   const levelPos = new BlockLocation(3, 2, 2);
		 725      -   const observerPos = new BlockLocation(2, 2, 1);
		      768 +   test.pressButton(buttonPos);
		 726      -   test.pullLever(levelPos);
		 727  769     test
		 728  770       .startSequence()
		 729      -     .thenIdle(2)
		 730      -     .thenExecute(() => {
		 731      -       test.assertBlockState("powered_bit", 0, observerPos);
		 732      -     })
		      771 +     .thenIdle(10)
		 733      -     .thenIdle(1)
		 734  772       .thenExecute(() => {
		 735      -       test.assertBlockState("powered_bit", 1, observerPos);
		 736      -     })
		 737      -     .thenSucceed();
		 738      - }).tag(GameTest.Tags.suiteDefault);
		      773 +       test.assertBlockPresent(MinecraftBlockTypes.chorusFlower, flower, true);
		      774 +       test.assertBlockPresent(MinecraftBlockTypes.air, aboveFlower, true);
		      775 +     })
		      776 +     .thenSucceed();
		      777 + }).tag(GameTest.Tags.suiteDisabled);
		 739      - 
		 740      - GameTest.register("PistonTests", "random_tick_forcer", (test) => {
		 741      -   const buttonPos = new BlockLocation(1, 3, 0);
		 742      -   const flower = new BlockLocation(1, 3, 6);
		 743      -   const aboveFlower = new BlockLocation(1, 4, 6);
		 744  778   
		      779 + GameTest.register("PistonTests", "honey_block_entity_drag_down", (test) => {
		 745      -   test.pressButton(buttonPos);
		 746      -   test
		      780 +   const leverPos = new BlockLocation(1, 1, 0);
		      781 +   const entityTypePos = new BlockLocation(1, 4, 1);
		      782 +   const cowId = "minecraft:cow<minecraft:ageable_grow_up>";
		      783 +   const entityTouchingPos = new Location(1.5, 4.5, 1.5);
		      784 +   const entityNotTouchingTypePos = new Location(1.5, 3.5, 1.5);
		      785 + 
		      786 +   test.spawn(cowId, entityTypePos);
		      787 +   test.assertEntityTouching(cowId, entityTouchingPos, true);
		      788 +   test.assertEntityTouching(cowId, entityNotTouchingTypePos, false);
		      789 + 
		      790 +   const timeBetweenEachLeverPull = 4;
		 747      -     .startSequence()
		 748      -     .thenIdle(20)
		 749      -     .thenExecute(() => {
		 750      -       test.assertBlockTypePresent(MinecraftBlockTypes.chorusFlower, flower);
		 751      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, aboveFlower);
		 752      -     })
		 753      -     .thenSucceed();
		 754      - })
		 755      -   .batch("no_random_ticks")
		 756      -   .tag("suite:java_parity")
		 757      -   .tag(GameTest.Tags.suiteDisabled); //The parity problem is still being solved
		 758  791   
		      792 +   var startSequence = test
		      793 +     .startSequence()
		 759      - GameTest.register("PistonTests", "random_tick_forcer_bedrock", (test) => {
		 760      -   const buttonPos = new BlockLocation(1, 3, 0);
		      794 +     .thenIdle(4)
		      795 +     .thenExecuteAfter(timeBetweenEachLeverPull, () => {
		 761      -   const flower = new BlockLocation(1, 3, 6);
		 762      -   const aboveFlower = new BlockLocation(1, 4, 6);
		 763      - 
		      796 +       test.pullLever(leverPos);
		      797 +     });
		 764      -   test.pressButton(buttonPos);
		 765      -   test
		 766      -     .startSequence()
		      798 +   startSequence;
		      799 + 
		      800 +   for (var i = 0; i < 10; i++) {
		      801 +     startSequence.thenExecuteAfter(timeBetweenEachLeverPull, () => {
		      802 +       test.pullLever(leverPos);
		      803 +     });
		      804 +   }
		 767      -     .thenIdle(10)
		 768      -     .thenExecute(() => {
		 769      -       test.assertBlockTypePresent(MinecraftBlockTypes.chorusFlower, flower);
		 770      -       test.assertBlockTypePresent(MinecraftBlockTypes.air, aboveFlower);
		 771      -     })
		 772      -     .thenSucceed();
		 773      - }).tag(GameTest.Tags.suiteDisabled);
		 774  805   
		      806 +   startSequence
		 775      - GameTest.register("PistonTests", "honey_block_entity_drag_down", (test) => {
		 776      -   const leverPos = new BlockLocation(1, 1, 0);
		 777      -   const entityTypePos = new BlockLocation(1, 4, 1);
		      807 +     .thenExecuteAfter(timeBetweenEachLeverPull, () => {
		      808 +       test.pullLever(leverPos);
		      809 +     })
		      810 +     .thenWait(() => {
		      811 +       test.assertEntityTouching(cowId, entityTouchingPos, true);
		      812 +       test.assertEntityTouching(cowId, entityNotTouchingTypePos, false);
		      813 +     })
		      814 +     .thenSucceed();
		      815 + }).tag(GameTest.Tags.suiteDefault);
		 778      -   const cowId = "minecraft:cow<minecraft:ageable_grow_up>";
		 779      -   const entityTouchingPos = new Location(1.5, 4.5, 1.5);
		 780      -   const entityNotTouchingTypePos = new Location(1.5, 3.5, 1.5);
		 781      - 
		 782      -   test.spawn(cowId, entityTypePos);
		 783      -   test.assertEntityTouching(cowId, entityTouchingPos);
		 784      -   test.assertEntityNotTouching(cowId, entityNotTouchingTypePos);
		 785      - 
		 786      -   const timeBetweenEachLeverPull = 4;
		 787  816   
		      817 + GameTest.register("PistonTests", "backside_fence", (test) => {
		 788      -   var startSequence = test
		 789      -     .startSequence()
		      818 +   const centerPos = new BlockLocation(2, 2, 2);
		      819 +   test.setBlockType(MinecraftBlockTypes.fence, centerPos);
		      820 + 
		      821 +   test.startSequence().thenIdle(30).thenSucceed();
		      822 +   let connectivity = undefined;
		 790      -     .thenIdle(4)
		 791      -     .thenExecuteAfter(timeBetweenEachLeverPull, () => {
		 792      -       test.pullLever(leverPos);
		 793      -     });
		 794      -   startSequence;
		 795  823   
		      824 +   test
		      825 +     .startSequence()
		 796      -   for (var i = 0; i < 10; i++) {
		 797      -     startSequence.thenExecuteAfter(timeBetweenEachLeverPull, () => {
		      826 +     .thenIdle(1)
		      827 +     .thenExecute(() => {
		      828 +       connectivity = test.getFenceConnectivity(centerPos);
		      829 +       test.assert(
		      830 +         connectivity.east && connectivity.west && connectivity.north && connectivity.south,
		      831 +         "Fence should connect to pistons"
		      832 +       );
		 798      -       test.pullLever(leverPos);
		 799      -     });
		 800      -   }
		 801      - 
		 802      -   startSequence
		 803      -     .thenExecuteAfter(timeBetweenEachLeverPull, () => {
		 804      -       test.pullLever(leverPos);
		 805  833       })
		 806  834       .thenWait(() => {
		      835 +       connectivity = test.getFenceConnectivity(centerPos);
		      836 +       test.assert(
		      837 +         !(connectivity.east && connectivity.west && connectivity.north && connectivity.south),
		      838 +         "Fence should stay connected to pistons"
		      839 +       );
		 807      -       test.assertEntityTouching(cowId, entityTouchingPos);
		 808      -       test.assertEntityNotTouching(cowId, entityNotTouchingTypePos);
		 809  840       })
		      841 +     .thenFail("Fence didn't stay connected to pistons");
		 810      -     .thenSucceed();
		 811  842   }).tag(GameTest.Tags.suiteDefault);
		            '''
	Changed script "RedstoneTests.js":
		Total line: 920 (+313, -120)
		            '''
		        1 + import * as GameTest from "mojang-gametest";
		        2 + import { BlockLocation, MinecraftBlockTypes, BlockProperties, World } from "mojang-minecraft";
		        3 + import GameTestExtensions from "./GameTestExtensions.js";
		        4 + 
		        5 + const TicksPerSecond = 20;
		        6 + 
		        7 + GameTest.register("RedstoneTests", "itemframe_override", (test) => {
		        8 +   const itemFrameTest = new BlockLocation(3, 2, 5);
		        9 +   const itemFrameOverrideNoTest = new BlockLocation(3, 2, 10);
		       10 + 
		       11 +   const lever = new BlockLocation(1, 2, 0);
		       12 +   const leverOverrideTest = new BlockLocation(1, 2, 13);
		       13 + 
		       14 +   test.assertRedstonePower(itemFrameTest, 1);
		       15 +   test.assertRedstonePower(itemFrameOverrideNoTest, 1);
		       16 + 
		       17 +   test.pullLever(lever);
		       18 + 
		       19 +   test.succeedWhen(() => {
		       20 +     test.assertRedstonePower(leverOverrideTest, 1);
		       21 +   });
		       22 + })
		       23 +   .tag("suite:java_parity")
		       24 +   .tag(GameTest.Tags.suiteDisabled); // Torches can't be placed on item frames in Bedrock,When the bow and arrow are placed on the item frame, it cannot be linked with red stone. So I changed the location of the red stone link to bedrock
		       25 + 
		       26 + GameTest.register("RedstoneTests", "itemframe_override_bedrock", (test) => {
		       27 +   const itemFrameTest = new BlockLocation(3, 2, 5);
		       28 +   const itemFrameOverrideNoTest = new BlockLocation(2, 2, 10);
		       29 + 
		       30 +   const lever = new BlockLocation(1, 2, 0);
		       31 +   const leverOverrideTest = new BlockLocation(0, 2, 13);
		       32 + 
		       33 +   test
		       34 +     .startSequence()
		       35 +     .thenIdle(3)
		       36 +     .thenExecute(() => {
		       37 +       test.assertRedstonePower(itemFrameTest, 1);
		       38 +       test.assertRedstonePower(itemFrameOverrideNoTest, 1);
		       39 +     })
		       40 +     .thenExecute(() => {
		       41 +       test.pullLever(lever);
		       42 +     })
		       43 +     .thenIdle(10)
		       44 +     .thenExecute(() => {
		       45 +       test.assertRedstonePower(leverOverrideTest, 3);
		       46 +     })
		       47 +     .thenSucceed();
		       48 + }).tag(GameTest.Tags.suiteDefault);
		       49 + 
		       50 + GameTest.register("RedstoneTests", "comparator_container", (test) => {
		       51 +   const aLeft = new BlockLocation(6, 2, 2);
		       52 +   const aRight = new BlockLocation(1, 2, 2);
		       53 + 
		       54 +   test.assertRedstonePower(aLeft, 14);
		       55 +   test.assertRedstonePower(aRight, 15);
		       56 + 
		       57 +   const bLeft = new BlockLocation(6, 2, 7);
		       58 +   const bRight = new BlockLocation(1, 2, 7);
		       59 + 
		       60 +   test.assertRedstonePower(bLeft, 0);
		       61 +   test.assertRedstonePower(bRight, 15);
		       62 + 
		       63 +   const cLeft = new BlockLocation(6, 2, 13);
		       64 +   const cRight = new BlockLocation(1, 2, 13);
		       65 +   test.assertRedstonePower(cLeft, 1);
		       66 +   test.assertRedstonePower(cRight, 15);
		       67 + 
		       68 +   test.succeed();
		       69 + })
		       70 +   .tag("suite:java_parity")
		       71 +   .tag(GameTest.Tags.suiteDisabled); // In the bedrock version, the chest is next to the square, causing the red stone signal to fail to transmit
		       72 + 
		       73 + GameTest.register("RedstoneTests", "comparator_container_bedrock", (test) => {
		       74 +   const aLeft = new BlockLocation(6, 2, 2);
		       75 +   const aRight = new BlockLocation(1, 2, 2);
		       76 +   const bLeft = new BlockLocation(6, 2, 7);
		       77 +   const bRight = new BlockLocation(1, 2, 7);
		       78 +   const cLeft = new BlockLocation(6, 2, 13);
		       79 +   const cRight = new BlockLocation(1, 2, 13);
		       80 + 
		       81 +   test
		       82 +     .startSequence()
		       83 +     .thenExecute(() => {
		       84 +       test.assertRedstonePower(aLeft, 14);
		       85 +       test.assertRedstonePower(aRight, 15);
		       86 +     })
		       87 +     .thenExecute(() => {
		       88 +       test.assertRedstonePower(bLeft, 0);
		       89 +       test.assertRedstonePower(bRight, 0);
		       90 +     })
		       91 +     .thenExecute(() => {
		       92 +       test.assertRedstonePower(cLeft, 0);
		       93 +       test.assertRedstonePower(cRight, 0);
		       94 +     })
		       95 +     .thenSucceed();
		       96 + })
		       97 +   .structureName("RedstoneTests:comparator_container")
		       98 +   .tag(GameTest.Tags.suiteDefault);
		       99 + 
		      100 + GameTest.register("RedstoneTests", "wireredirect_nonconductor", (test) => {
		      101 +   const testEx = new GameTestExtensions(test);
		      102 +   const levers = [new BlockLocation(3, 2, 0), new BlockLocation(1, 2, 0)];
		      103 +   const fenceGatesClosed = [
		      104 +     new BlockLocation(2, 3, 0),
		      105 +     new BlockLocation(2, 3, 2),
		      106 +     new BlockLocation(1, 2, 2),
		      107 +     new BlockLocation(2, 2, 2),
		      108 +     new BlockLocation(3, 2, 2),
		      109 +     new BlockLocation(0, 2, 1),
		      110 +     new BlockLocation(4, 2, 1),
		      111 +   ];
		      112 +   const fenceGatesOpen = [new BlockLocation(3, 3, 1), new BlockLocation(1, 3, 1)];
		      113 + 
		      114 +   test
		      115 +     .startSequence()
		      116 +     .thenExecute(() => {
		      117 +       for (const lever of levers) {
		      118 +         test.pullLever(lever);
		      119 +       }
		      120 +       for (const fenceGateC of fenceGatesClosed) {
		      121 +         testEx.assertBlockProperty("open_bit", 0, fenceGateC);
		      122 +       }
		      123 +       for (const fenceGateO of fenceGatesOpen) {
		      124 +         testEx.assertBlockProperty("open_bit", 1, fenceGateO);
		      125 +       }
		      126 +     })
		      127 +     .thenSucceed();
		      128 + })
		      129 +   .tag("suite:java_parity")
		      130 +   .tag(GameTest.Tags.suiteDisabled); // There is no way to judge the opening and closing state of the fence door, so in is used in open_bit
		      131 + 
		      132 + GameTest.register("RedstoneTests", "wireredirect_nonconductor_bedrock", (test) => {
		      133 +   const testEx = new GameTestExtensions(test);
		      134 +   const levers = [new BlockLocation(3, 2, 0), new BlockLocation(1, 2, 0)];
		      135 +   const fenceGatesClosed = [
		      136 +     new BlockLocation(2, 3, 0),
		      137 +     new BlockLocation(2, 3, 2),
		      138 +     new BlockLocation(1, 2, 2),
		      139 +     new BlockLocation(2, 2, 2),
		      140 +     new BlockLocation(3, 2, 2),
		      141 +     new BlockLocation(0, 2, 1),
		      142 +     new BlockLocation(4, 2, 1),
		      143 +   ];
		      144 +   const fenceGatesOpen = [new BlockLocation(3, 3, 1), new BlockLocation(1, 3, 1)];
		      145 + 
		      146 +   test
		      147 +     .startSequence()
		      148 +     .thenIdle(2)
		      149 +     .thenExecute(() => {
		      150 +       for (const lever of levers) {
		      151 +         test.pullLever(lever);
		      152 +       }
		      153 +     })
		      154 +     .thenIdle(6)
		      155 +     .thenExecute(() => {
		      156 +       for (const fenceGateC of fenceGatesClosed) {
		      157 +         testEx.assertBlockProperty("open_bit", 0, fenceGateC);
		      158 +       }
		      159 +     })
		      160 +     .thenExecute(() => {
		      161 +       for (const fenceGateO of fenceGatesOpen) {
		      162 +         testEx.assertBlockProperty("open_bit", 1, fenceGateO);
		      163 +       }
		      164 +     })
		      165 +     .thenSucceed();
		      166 + }).tag(GameTest.Tags.suiteDefault);
		      167 + 
		      168 + GameTest.register("RedstoneTests", "repeater_regeneration", (test) => {
		      169 +   const testEx = new GameTestExtensions(test);
		      170 +   const input = new BlockLocation(0, 2, 0);
		      171 +   const inactiveOutput = new BlockLocation(6, 3, 4);
		      172 +   const activeOutput = new BlockLocation(6, 3, 3);
		      173 + 
		      174 +   test.setBlockType(MinecraftBlockTypes.redstoneBlock, input);
		      175 +   test.succeedOnTickWhen(2, () => {
		      176 +     testEx.assertBlockProperty("open_bit", 0, inactiveOutput);
		      177 +     testEx.assertBlockProperty("open_bit", 1, activeOutput);
		      178 +   });
		      179 + }).tag(GameTest.Tags.suiteDefault);
		      180 + 
		      181 + GameTest.register("RedstoneTests", "repeater_lock", (test) => {
		      182 +   const testEx = new GameTestExtensions(test);
		      183 +   const input = new BlockLocation(0, 2, 2);
		      184 +   const lock = new BlockLocation(1, 2, 0);
		      185 +   const output = new BlockLocation(2, 2, 1);
		      186 + 
		      187 +   test.setBlockType(MinecraftBlockTypes.redstoneBlock, input);
		      188 + 
		      189 +   test
		      190 +     .startSequence()
		      191 + 
		      192 +     .thenIdle(2)
		      193 +     .thenExecute(() => {
		      194 +       testEx.assertBlockProperty("open_bit", 1, output);
		      195 +     })
		      196 +     .thenExecute(() => {
		      197 +       test.setBlockType(MinecraftBlockTypes.redstoneBlock, lock);
		      198 +       test.setBlockType(MinecraftBlockTypes.air, input);
		      199 +       testEx.assertBlockProperty("open_bit", 1, output);
		      200 +     })
		      201 +     .thenExecuteAfter(2, () => {
		      202 +       test.setBlockType(MinecraftBlockTypes.air, lock);
		      203 +     })
		      204 +     .thenIdle(4)
		      205 +     .thenExecute(() => {
		      206 +       testEx.assertBlockProperty("open_bit", 0, output);
		      207 +     })
		      208 +     .thenSucceed();
		      209 + }).tag(GameTest.Tags.suiteDefault);
		      210 + 
		      211 + GameTest.register("RedstoneTests", "torch_monostable", (test) => {
		      212 +   const testEx = new GameTestExtensions(test);
		      213 +   const input = new BlockLocation(0, 2, 0);
		      214 +   const output = new BlockLocation(2, 2, 1);
		      215 + 
		      216 +   test.pressButton(input);
		      217 +   test
		      218 +     .startSequence()
		      219 +     .thenWaitUntil(2, () => {
		      220 +       testEx.assertBlockProperty("open_bit", 0, output);
		      221 +     })
		      222 +     .thenWaitUntil(2, () => {
		      223 +       testEx.assertBlockProperty("open_bit", 1, output);
		      224 +     })
		      225 +     .thenExecute(() => {
		      226 +       test.failIf(() => {
		      227 +         testEx.assertBlockProperty("open_bit", 0, output);
		      228 +       });
		      229 +     })
		      230 +     .thenWait(() => {
		      231 +       testEx.assertBlockProperty("button_pressed_bit", 0, input);
		      232 +     })
		      233 +     .thenSucceed();
		      234 + })
		      235 +   .tag("suite:java_parity")
		      236 +   .tag(GameTest.Tags.suiteDisabled); // there are tick delay differences between Java and Bedrock.
		   1      - import * as GameTest from "GameTest";
		   2      - import { BlockLocation, MinecraftBlockTypes, BlockProperties, World } from "Minecraft";
		   3  237   
		      238 + GameTest.register("RedstoneTests", "torch_monostable_bedrock", (test) => {
		      239 +   const testEx = new GameTestExtensions(test);
		      240 +   const input = new BlockLocation(0, 2, 0);
		      241 +   const output = new BlockLocation(2, 2, 1);
		   4      - const TicksPerSecond = 20;
		   5  242   
		      243 +   test
		      244 +     .startSequence()
		      245 +     .thenIdle(2)
		   6      - GameTest.register("RedstoneTests", "itemframe_override", (test) => {
		      246 +     .thenWait(() => {
		      247 +       test.pressButton(input);
		      248 +     })
		      249 +     .thenIdle(1)
		      250 +     .thenExecute(() => {
		      251 +       testEx.assertBlockProperty("open_bit", 0, output);
		      252 +     })
		      253 +     .thenIdle(2)
		      254 +     .thenWait(() => {
		      255 +       testEx.assertBlockProperty("open_bit", 1, output);
		      256 +     })
		      257 +     .thenExecute(() => {
		      258 +       test.failIf(() => {
		      259 +         testEx.assertBlockProperty("open_bit", 0, output);
		      260 +       });
		      261 +     })
		      262 +     .thenWait(() => {
		      263 +       testEx.assertBlockProperty("button_pressed_bit", 0, input);
		      264 +     })
		      265 +     .thenSucceed();
		      266 + }).tag(GameTest.Tags.suiteDefault);
		   7      -   const itemFrameTest = new BlockLocation(3, 2, 5);
		   8      -   const itemFrameOverrideNoTest = new BlockLocation(3, 2, 10);
		   9      - 
		  10      -   const lever = new BlockLocation(1, 2, 0);
		  11      -   const leverOverrideTest = new BlockLocation(1, 2, 13);
		  12      - 
		  13      -   test.assertRedstonePower(itemFrameTest, 1);
		  14      -   test.assertRedstonePower(itemFrameOverrideNoTest, 1);
		  15      - 
		  16      -   test.pullLever(lever);
		  17      - 
		  18      -   test.succeedWhen(() => {
		  19      -     test.assertRedstonePower(leverOverrideTest, 1);
		  20      -   });
		  21      - })
		  22      -   .tag("suite:java_parity")
		  23      -   .tag(GameTest.Tags.suiteDisabled); // Torches can't be placed on item frames in Bedrock,When the bow and arrow are placed on the item frame, it cannot be linked with red stone. So I changed the location of the red stone link to bedrock
		  24      - 
		  25      - GameTest.register("RedstoneTests", "itemframe_override_bedrock", (test) => {
		  26      -   const itemFrameTest = new BlockLocation(3, 2, 5);
		  27      -   const itemFrameOverrideNoTest = new BlockLocation(2, 2, 10);
		  28  267   
		      268 + GameTest.register("RedstoneTests", "wire_redirect", (test) => {
		      269 +   const testEx = new GameTestExtensions(test);
		      270 +   const levers = [new BlockLocation(6, 2, 1), new BlockLocation(3, 2, 0), new BlockLocation(0, 2, 1)];
		  29      -   const lever = new BlockLocation(1, 2, 0);
		      271 +   const wires = [new BlockLocation(5, 2, 4), new BlockLocation(3, 2, 4), new BlockLocation(1, 2, 4)];
		  30      -   const leverOverrideTest = new BlockLocation(0, 2, 13);
		  31      - 
		      272 +   const fenceGates = [
		      273 +     new BlockLocation(5, 3, 1),
		      274 +     new BlockLocation(5, 3, 3),
		      275 +     new BlockLocation(3, 3, 1),
		      276 +     new BlockLocation(3, 3, 3),
		      277 +     new BlockLocation(1, 3, 1),
		      278 +     new BlockLocation(1, 3, 3),
		      279 +   ];
		      280 + 
		      281 +   test
		      282 +     .startSequence()
		  32      -   test
		  33      -     .startSequence()
		  34      -     .thenIdle(3)
		  35      -     .thenExecute(() => {
		  36      -       test.assertRedstonePower(itemFrameTest, 1);
		  37      -       test.assertRedstonePower(itemFrameOverrideNoTest, 1);
		  38      -     })
		  39      -     .thenExecute(() => {
		  40      -       test.pullLever(lever);
		  41      -     })
		  42      -     .thenIdle(10)
		  43  283       .thenExecute(() => {
		  44      -       test.assertRedstonePower(leverOverrideTest, 3);
		  45      -     })
		  46      -     .thenSucceed();
		      284 +       for (const lever of levers) {
		      285 +         test.pullLever(lever);
		      286 +       }
		      287 +     })
		      288 +     .thenIdle(6)
		      289 +     .thenExecute(() => {
		      290 +       for (const wire of wires) {
		      291 +         test.assertRedstonePower(wire, 0);
		      292 +       }
		      293 +     })
		      294 +     .thenExecute(() => {
		      295 +       for (const fenceGate of fenceGates) {
		      296 +         testEx.assertBlockProperty("in_wall_bit", 0, fenceGate);
		      297 +       }
		      298 +     })
		      299 +     .thenSucceed();
		      300 + })
		      301 +   .tag("suite:java_parity")
		      302 +   .tag(GameTest.Tags.suiteDisabled); //Floating fence gates are powered differently
		  47      - }).tag(GameTest.Tags.suiteDefault);
		  48      - 
		  49      - GameTest.register("RedstoneTests", "comparator_container", (test) => {
		  50      -   const aLeft = new BlockLocation(6, 2, 2);
		  51      -   const aRight = new BlockLocation(1, 2, 2);
		  52      - 
		  53      -   test.assertRedstonePower(aLeft, 14);
		  54      -   test.assertRedstonePower(aRight, 15);
		  55      - 
		  56      -   const bLeft = new BlockLocation(6, 2, 7);
		  57      -   const bRight = new BlockLocation(1, 2, 7);
		  58      - 
		  59      -   test.assertRedstonePower(bLeft, 0);
		  60      -   test.assertRedstonePower(bRight, 15);
		  61      - 
		  62      -   const cLeft = new BlockLocation(6, 2, 13);
		  63      -   const cRight = new BlockLocation(1, 2, 13);
		  64      -   test.assertRedstonePower(cLeft, 1);
		  65      -   test.assertRedstonePower(cRight, 15);
		  66  303   
		      304 + GameTest.register("RedstoneTests", "wire_redirect_bedrock", (test) => {
		      305 +   const testEx = new GameTestExtensions(test);
		  67      -   test.succeed();
		  68      - })
		      306 +   const levers = [new BlockLocation(6, 2, 1), new BlockLocation(3, 2, 0), new BlockLocation(0, 2, 1)];
		      307 +   const wires = [new BlockLocation(5, 2, 4), new BlockLocation(3, 2, 4), new BlockLocation(1, 2, 4)];
		      308 +   const fenceGates = [
		      309 +     new BlockLocation(5, 3, 1),
		      310 +     new BlockLocation(5, 3, 3),
		      311 +     new BlockLocation(3, 3, 1),
		      312 +     new BlockLocation(3, 3, 3),
		      313 +     new BlockLocation(1, 3, 1),
		      314 +     new BlockLocation(1, 3, 3),
		      315 +   ];
		  69      -   .tag("suite:java_parity")
		  70      -   .tag(GameTest.Tags.suiteDisabled); // In the bedrock version, the chest is next to the square, causing the red stone signal to fail to transmit
		  71      - 
		  72      - GameTest.register("RedstoneTests", "comparator_container_bedrock", (test) => {
		  73      -   const aLeft = new BlockLocation(6, 2, 2);
		  74      -   const aRight = new BlockLocation(1, 2, 2);
		  75      -   const bLeft = new BlockLocation(6, 2, 7);
		  76      -   const bRight = new BlockLocation(1, 2, 7);
		  77      -   const cLeft = new BlockLocation(6, 2, 13);
		  78      -   const cRight = new BlockLocation(1, 2, 13);
		  79  316   
		  80  317     test
		  81  318       .startSequence()
		  82  319       .thenExecute(() => {
		      320 +       for (const lever of levers) {
		      321 +         test.pullLever(lever);
		  83      -       test.assertRedstonePower(aLeft, 14);
		      322 +       }
		  84      -       test.assertRedstonePower(aRight, 15);
		  85  323       })
		      324 +     .thenIdle(6)
		  86  325       .thenExecute(() => {
		      326 +       for (const wire of wires) {
		      327 +         test.assertRedstonePower(wire, 0);
		  87      -       test.assertRedstonePower(bLeft, 0);
		      328 +       }
		  88      -       test.assertRedstonePower(bRight, 0);
		  89  329       })
		  90  330       .thenExecute(() => {
		      331 +       for (const fenceGate of fenceGates) {
		      332 +         testEx.assertBlockProperty("in_wall_bit", 0, fenceGate);
		  91      -       test.assertRedstonePower(cLeft, 0);
		      333 +       }
		  92      -       test.assertRedstonePower(cRight, 0);
		  93  334       })
		  94  335       .thenSucceed();
		      336 + }).tag(GameTest.Tags.suiteDefault);
		      337 + 
		      338 + let observerClock = (test, initialOpenBit) => {
		  95      - })
		      339 +   const testEx = new GameTestExtensions(test);
		      340 +   const outputPos = new BlockLocation(2, 2, 0);
		  96      -   .structureName("RedstoneTests:comparator_container")
		  97      -   .tag(GameTest.Tags.suiteDefault);
		  98  341   
		      342 +   const blockPermutation = MinecraftBlockTypes.trapdoor.createDefaultBlockPermutation();
		  99      - GameTest.register("RedstoneTests", "wireredirect_nonconductor", (test) => {
		 100      -   const levers = [new BlockLocation(3, 2, 0), new BlockLocation(1, 2, 0)];
		 101      -   const fenceGatesClosed = [
		      343 +   blockPermutation.getProperty(BlockProperties.openBit).value = initialOpenBit;
		      344 + 
		      345 +   test.setBlockPermutation(blockPermutation, outputPos);
		      346 + 
		      347 +   let sequence = test.startSequence();
		      348 + 
		      349 +   sequence.thenWait(() => {
		      350 +     testEx.assertBlockProperty("open_bit", 1, outputPos);
		      351 +   });
		 102      -     new BlockLocation(2, 3, 0),
		 103      -     new BlockLocation(2, 3, 2),
		 104      -     new BlockLocation(1, 2, 2),
		 105      -     new BlockLocation(2, 2, 2),
		 106      -     new BlockLocation(3, 2, 2),
		 107      -     new BlockLocation(0, 2, 1),
		 108      -     new BlockLocation(4, 2, 1),
		 109      -   ];
		 110      -   const fenceGatesOpen = [new BlockLocation(3, 3, 1), new BlockLocation(1, 3, 1)];
		 111  352   
		      353 +   for (let i = 0; i < 8; i++) {
		      354 +     sequence
		      355 +       .thenWait(() => {
		 112      -   test
		      356 +         testEx.assertBlockProperty("open_bit", 0, outputPos);
		      357 +       })
		      358 +       .thenWait(() => {
		      359 +         testEx.assertBlockProperty("open_bit", 1, outputPos);
		      360 +       });
		      361 +   }
		      362 +   sequence.thenSucceed();
		      363 + };
		      364 + 
		      365 + GameTest.register("RedstoneTests", "observer_clock", (test) => observerClock(test, false))
		      366 +   .tag("suite:java_parity") // Trapdoors do not always flip open from observer redstone signal when starting closed
		      367 +   .tag(GameTest.Tags.suiteDisabled);
		      368 + 
		      369 + GameTest.register("RedstoneTests", "observer_clock_bedrock", (test) => observerClock(test, true))
		      370 +   .structureName("RedstoneTests:observer_clock")
		      371 +   .tag(GameTest.Tags.suiteDefault);
		 113      -     .startSequence()
		 114      -     .thenExecute(() => {
		 115      -       for (const lever of levers) {
		 116      -         test.pullLever(lever);
		 117      -       }
		 118      -       for (const fenceGateC of fenceGatesClosed) {
		 119      -         test.assertBlockState("open_bit", 0, fenceGateC);
		 120      -       }
		 121      -       for (const fenceGateO of fenceGatesOpen) {
		 122      -         test.assertBlockState("open_bit", 1, fenceGateO);
		 123      -       }
		 124      -     })
		 125      -     .thenSucceed();
		 126      - })
		 127      -   .tag("suite:java_parity")
		 128      -   .tag(GameTest.Tags.suiteDisabled); // There is no way to judge the opening and closing state of the fence door, so in is used in open_bit
		 129  372   
		      373 + GameTest.register("RedstoneTests", "repeater_delay_lines", (test) => {
		 130      - GameTest.register("RedstoneTests", "wireredirect_nonconductor_bedrock", (test) => {
		 131      -   const levers = [new BlockLocation(3, 2, 0), new BlockLocation(1, 2, 0)];
		 132      -   const fenceGatesClosed = [
		      374 +   const inputPos = new BlockLocation(0, 2, 0);
		      375 + 
		      376 +   const linesPos = [
		      377 +     [new BlockLocation(4, 2, 1), new BlockLocation(4, 2, 2), new BlockLocation(4, 2, 3), new BlockLocation(4, 2, 4)], //4-tick delay
		      378 +     [new BlockLocation(3, 2, 1), new BlockLocation(3, 2, 2), new BlockLocation(3, 2, 3), new BlockLocation(3, 2, 4)], //3-tick delay
		      379 +     [new BlockLocation(2, 2, 1), new BlockLocation(2, 2, 2), new BlockLocation(2, 2, 3), new BlockLocation(2, 2, 4)], //2-tick delay
		      380 +     [new BlockLocation(1, 2, 1), new BlockLocation(1, 2, 2), new BlockLocation(1, 2, 3), new BlockLocation(1, 2, 4)], //1-tick delay
		 133      -     new BlockLocation(2, 3, 0),
		 134      -     new BlockLocation(2, 3, 2),
		 135      -     new BlockLocation(1, 2, 2),
		 136      -     new BlockLocation(2, 2, 2),
		 137      -     new BlockLocation(3, 2, 2),
		 138      -     new BlockLocation(0, 2, 1),
		 139      -     new BlockLocation(4, 2, 1),
		 140  381     ];
		 141      -   const fenceGatesOpen = [new BlockLocation(3, 3, 1), new BlockLocation(1, 3, 1)];
		 142  382   
		      383 +   const states = [
		      384 +     "XXX0",
		 143      -   test
		      385 +     "XX01",
		      386 +     "X002",
		      387 +     "0013",
		      388 +     "001X",
		      389 +     "012X",
		      390 +     null,
		      391 +     "113X",
		      392 +     "123X",
		      393 +     "12XX",
		      394 +     null,
		      395 +     "23XX",
		      396 +     null,
		      397 +     null,
		      398 +     "2XXX",
		      399 +     "3XXX",
		      400 +     null,
		      401 +     null,
		      402 +     null,
		      403 +     "XXXX",
		      404 +   ];
		 144      -     .startSequence()
		 145      -     .thenIdle(2)
		 146      -     .thenExecute(() => {
		 147      -       for (const lever of levers) {
		 148      -         test.pullLever(lever);
		 149      -       }
		 150      -     })
		 151      -     .thenIdle(6)
		 152      -     .thenExecute(() => {
		 153      -       for (const fenceGateC of fenceGatesClosed) {
		 154      -         test.assertBlockState("open_bit", 0, fenceGateC);
		 155      -       }
		 156      -     })
		 157      -     .thenExecute(() => {
		 158      -       for (const fenceGateO of fenceGatesOpen) {
		 159      -         test.assertBlockState("open_bit", 1, fenceGateO);
		 160      -       }
		 161      -     })
		 162      -     .thenSucceed();
		 163      - }).tag(GameTest.Tags.suiteDefault);
		 164  405   
		 165      - GameTest.register("RedstoneTests", "repeater_regeneration", (test) => {
		 166      -   const input = new BlockLocation(0, 2, 0);
		 167      -   const inactiveOutput = new BlockLocation(6, 3, 4);
		      406 +   test.pulseRedstone(inputPos, 3);
		 168      -   const activeOutput = new BlockLocation(6, 3, 3);
		 169  407   
		      408 +   let sequence = test.startSequence();
		 170      -   test.setBlockType(MinecraftBlockTypes.redstoneBlock, input);
		 171      -   test.succeedOnTickWhen(2, () => {
		 172      -     test.assertBlockState("open_bit", 0, inactiveOutput);
		      409 +   for (const state of states) {
		      410 +     if (state == null) {
		      411 +       sequence = sequence.thenIdle(2);
		      412 +     } else {
		      413 +       sequence = sequence.thenWaitWithDelay(2, () => {
		      414 +         for (let line = 0; line < 4; line++) {
		      415 +           const expected = state.charAt(line);
		      416 +           const expectedPos = expected == "X" ? -1 : expected - "0";
		      417 +           for (let linePos = 0; linePos < 4; linePos++) {
		      418 +             const blockWorldPos = test.worldBlockLocation(linesPos[line][linePos]);
		      419 +             const block = World.getDimension("overworld").getBlock(blockWorldPos);
		      420 +             const blockPerm = block.getBlockData();
		      421 +             const blockType = blockPerm.getType();
		 173      -     test.assertBlockState("open_bit", 1, activeOutput);
		 174      -   });
		 175      - }).tag(GameTest.Tags.suiteDefault);
		 176      - 
		 177      - GameTest.register("RedstoneTests", "repeater_lock", (test) => {
		 178      -   const input = new BlockLocation(0, 2, 2);
		 179      -   const lock = new BlockLocation(1, 2, 0);
		 180      -   const output = new BlockLocation(2, 2, 1);
		 181      - 
		 182      -   test.setBlockType(MinecraftBlockTypes.redstoneBlock, input);
		 183      - 
		 184      -   test
		 185      -     .startSequence()
		 186  422   
		      423 +             if (linePos == expectedPos) {
		      424 +               test.assert(
		      425 +                 blockType.getName() == "minecraft:powered_repeater",
		 187      -     .thenIdle(2)
		      426 +                 "Unexpected Block State. Expected: powered. Actual: unpowered"
		      427 +               );
		      428 +             } else {
		      429 +               test.assert(
		      430 +                 blockType.getName() == "minecraft:unpowered_repeater",
		      431 +                 "Unexpected Block State. Expected: unpowered. Actual: powered"
		      432 +               );
		      433 +             }
		      434 +           }
		      435 +         }
		      436 +       });
		      437 +     }
		      438 +   }
		      439 +   sequence.thenSucceed();
		      440 + })
		      441 +   .tag("suite:java_parity")
		      442 +   .tag(GameTest.Tags.suiteDisabled); //The speed of the redstone pulse is different between Java and Bedrock.
		 188      -     .thenExecute(() => {
		 189      -       test.assertBlockState("open_bit", 1, output);
		 190      -     })
		 191      -     .thenExecute(() => {
		 192      -       test.setBlockType(MinecraftBlockTypes.redstoneBlock, lock);
		 193      -       test.setBlockType(MinecraftBlockTypes.air, input);
		 194      -       test.assertBlockState("open_bit", 1, output);
		 195      -     })
		 196      -     .thenExecuteAfter(2, () => {
		 197      -       test.setBlockType(MinecraftBlockTypes.air, lock);
		 198      -     })
		 199      -     .thenIdle(4)
		 200      -     .thenExecute(() => {
		 201      -       test.assertBlockState("open_bit", 0, output);
		 202      -     })
		 203      -     .thenSucceed();
		 204      - }).tag(GameTest.Tags.suiteDefault);
		 205  443   
		      444 + GameTest.register("RedstoneTests", "repeater_delay_lines_bedrock", (test) => {
		 206      - GameTest.register("RedstoneTests", "torch_monostable", (test) => {
		 207      -   const input = new BlockLocation(0, 2, 0);
		      445 +   const inputPos = new BlockLocation(0, 2, 0);
		 208      -   const output = new BlockLocation(2, 2, 1);
		 209  446   
		 210      -   test.pressButton(input);
		 211      -   test
		 212      -     .startSequence()
		 213      -     .thenWaitUntil(2, () => {
		      447 +   const linesPos = [
		      448 +     [new BlockLocation(4, 2, 1), new BlockLocation(4, 2, 2), new BlockLocation(4, 2, 3), new BlockLocation(4, 2, 4)], //4-tick delay
		      449 +     [new BlockLocation(3, 2, 1), new BlockLocation(3, 2, 2), new BlockLocation(3, 2, 3), new BlockLocation(3, 2, 4)], //3-tick delay
		      450 +     [new BlockLocation(2, 2, 1), new BlockLocation(2, 2, 2), new BlockLocation(2, 2, 3), new BlockLocation(2, 2, 4)], //2-tick delay
		      451 +     [new BlockLocation(1, 2, 1), new BlockLocation(1, 2, 2), new BlockLocation(1, 2, 3), new BlockLocation(1, 2, 4)], //1-tick delay
		      452 +   ];
		      453 + 
		      454 +   const states = [
		      455 +     "XXX0",
		      456 +     "XX01",
		      457 +     "X002",
		      458 +     "0013",
		      459 +     "001X",
		      460 +     "012X",
		      461 +     null,
		      462 +     "113X",
		      463 +     "123X",
		      464 +     "12XX",
		      465 +     null,
		      466 +     "23XX",
		      467 +     null,
		      468 +     null,
		      469 +     "2XXX",
		      470 +     "3XXX",
		      471 +     null,
		      472 +     null,
		      473 +     null,
		      474 +     "XXXX",
		      475 +   ];
		      476 + 
		      477 +   test.pulseRedstone(inputPos, 3); //Change redstone pulse form 2 ticks to 3.
		      478 + 
		      479 +   let sequence = test.startSequence();
		      480 +   for (const state of states) {
		      481 +     if (state == null) {
		      482 +       sequence = sequence.thenIdle(2);
		      483 +     } else {
		      484 +       sequence = sequence.thenIdle(2).thenExecute(() => {
		      485 +         for (let line = 0; line < 4; line++) {
		      486 +           const expected = state.charAt(line);
		      487 +           const expectedPos = expected == "X" ? -1 : expected - "0";
		      488 +           for (let linePos = 0; linePos < 4; linePos++) {
		      489 +             const blockWorldPos = test.worldBlockLocation(linesPos[line][linePos]);
		      490 +             const block = World.getDimension("overworld").getBlock(blockWorldPos);
		      491 +             const blockPerm = block.getBlockData();
		      492 +             const blockType = blockPerm.getType();
		 214      -       test.assertBlockState("open_bit", 0, output);
		 215      -     })
		 216      -     .thenWaitUntil(2, () => {
		 217      -       test.assertBlockState("open_bit", 1, output);
		 218      -     })
		 219      -     .thenExecute(() => {
		 220      -       test.failIf(() => {
		 221      -         test.assertBlockState("open_bit", 0, output);
		 222      -       });
		 223      -     })
		 224      -     .thenWait(() => {
		 225      -       test.assertBlockState("button_pressed_bit", 0, input);
		 226      -     })
		 227      -     .thenSucceed();
		 228      - })
		 229      -   .tag("suite:java_parity")
		 230      -   .tag(GameTest.Tags.suiteDisabled); // there are tick delay differences between Java and Bedrock.
		 231      - 
		 232      - GameTest.register("RedstoneTests", "torch_monostable_bedrock", (test) => {
		 233      -   const input = new BlockLocation(0, 2, 0);
		 234      -   const output = new BlockLocation(2, 2, 1);
		 235      - 
		 236      -   test
		 237      -     .startSequence()
		 238      -     .thenIdle(2)
		 239      -     .thenWait(() => {
		 240      -       test.pressButton(input);
		 241      -     })
		 242      -     .thenIdle(1)
		 243      -     .thenExecute(() => {
		 244      -       test.assertBlockState("open_bit", 0, output);
		 245      -     })
		 246      -     .thenIdle(2)
		 247      -     .thenWait(() => {
		 248      -       test.assertBlockState("open_bit", 1, output);
		 249      -     })
		 250      -     .thenExecute(() => {
		 251      -       test.failIf(() => {
		 252      -         test.assertBlockState("open_bit", 0, output);
		 253      -       });
		 254      -     })
		 255      -     .thenWait(() => {
		 256      -       test.assertBlockState("button_pressed_bit", 0, input);
		 257      -     })
		 258      -     .thenSucceed();
		 259      - }).tag(GameTest.Tags.suiteDefault);
		 260  493   
		      494 +             if (linePos == expectedPos) {
		 261      - GameTest.register("RedstoneTests", "wire_redirect", (test) => {
		 262      -   const levers = [new BlockLocation(6, 2, 1), new BlockLocation(3, 2, 0), new BlockLocation(0, 2, 1)];
		 263      -   const wires = [new BlockLocation(5, 2, 4), new BlockLocation(3, 2, 4), new BlockLocation(1, 2, 4)];
		      495 +               test.assert(
		      496 +                 blockType.getName() == "minecraft:powered_repeater",
		      497 +                 "Unexpected Block State. Expected: powered. Actual: unpowered"
		      498 +               );
		      499 +             } else {
		      500 +               test.assert(
		      501 +                 blockType.getName() == "minecraft:unpowered_repeater",
		      502 +                 "Unexpected Block State. Expected: unpowered. Actual: powered"
		      503 +               );
		      504 +             }
		      505 +           }
		      506 +         }
		      507 +       });
		      508 +     }
		      509 +   }
		      510 +   sequence.thenSucceed();
		      511 + })
		      512 +   .structureName("RedstoneTests:repeater_delay_lines")
		      513 +   .tag(GameTest.Tags.suiteDefault);
		      514 + 
		      515 + GameTest.register("RedstoneTests", "repeater_clock", (test) => {
		      516 +   const testEx = new GameTestExtensions(test);
		      517 +   const startPos = new BlockLocation(0, 4, 0);
		      518 +   const stagesPos = [
		      519 +     new BlockLocation(0, 1, 0),
		      520 +     new BlockLocation(2, 1, 0),
		      521 +     new BlockLocation(2, 1, 2),
		      522 +     new BlockLocation(0, 1, 2),
		      523 +   ];
		      524 + 
		      525 +   test.pulseRedstone(startPos, 2);
		 264      -   const fenceGates = [
		 265      -     new BlockLocation(5, 3, 1),
		 266      -     new BlockLocation(5, 3, 3),
		 267      -     new BlockLocation(3, 3, 1),
		 268      -     new BlockLocation(3, 3, 3),
		 269      -     new BlockLocation(1, 3, 1),
		 270      -     new BlockLocation(1, 3, 3),
		 271      -   ];
		 272      - 
		 273      -   test
		 274      -     .startSequence()
		 275      -     .thenExecute(() => {
		 276      -       for (const lever of levers) {
		 277      -         test.pullLever(lever);
		 278      -       }
		 279      -     })
		 280      -     .thenIdle(6)
		 281      -     .thenExecute(() => {
		 282      -       for (const wire of wires) {
		 283      -         test.assertRedstonePower(wire, 0);
		 284      -       }
		 285      -     })
		 286      -     .thenExecute(() => {
		 287      -       for (const fenceGate of fenceGates) {
		 288      -         test.assertBlockState("in_wall_bit", 0, fenceGate);
		 289      -       }
		 290      -     })
		 291      -     .thenSucceed();
		 292      - })
		 293      -   .tag("suite:java_parity")
		 294      -   .tag(GameTest.Tags.suiteDisabled); //Floating fence gates are powered differently
		 295  526   
		      527 +   let sequence = test.startSequence();
		      528 +   for (let i = 0; i < 32; i++) {
		      529 +     const active = i % 4;
		 296      - GameTest.register("RedstoneTests", "wire_redirect_bedrock", (test) => {
		      530 +     sequence = sequence.thenWaitWithDelay(i == 0 ? 0 : 2, () => {
		      531 +       for (let b = 0; b < 4; b++) {
		      532 +         testEx.assertBlockProperty("open_bit", b == active ? 1 : 0, stagesPos[b]);
		      533 +       }
		      534 +     });
		      535 +   }
		      536 +   sequence.thenSucceed();
		      537 + })
		      538 +   .tag("suite:java_parity")
		      539 +   .tag(GameTest.Tags.suiteDisabled); //The speed of the redstone pulse is different between Java and Bedrock.
		 297      -   const levers = [new BlockLocation(6, 2, 1), new BlockLocation(3, 2, 0), new BlockLocation(0, 2, 1)];
		 298      -   const wires = [new BlockLocation(5, 2, 4), new BlockLocation(3, 2, 4), new BlockLocation(1, 2, 4)];
		 299      -   const fenceGates = [
		 300      -     new BlockLocation(5, 3, 1),
		 301      -     new BlockLocation(5, 3, 3),
		 302      -     new BlockLocation(3, 3, 1),
		 303      -     new BlockLocation(3, 3, 3),
		 304      -     new BlockLocation(1, 3, 1),
		 305      -     new BlockLocation(1, 3, 3),
		 306      -   ];
		 307  540   
		 308      -   test
		 309      -     .startSequence()
		 310      -     .thenExecute(() => {
		      541 + GameTest.register("RedstoneTests", "repeater_clock_bedrock", (test) => {
		      542 +   const testEx = new GameTestExtensions(test);
		      543 +   const startPos = new BlockLocation(0, 4, 0);
		      544 +   const stagesPos = [
		      545 +     new BlockLocation(0, 1, 0),
		      546 +     new BlockLocation(2, 1, 0),
		      547 +     new BlockLocation(2, 1, 2),
		      548 +     new BlockLocation(0, 1, 2),
		      549 +   ];
		      550 + 
		      551 +   test.pulseRedstone(startPos, 3); //Change redstone pulse form 2 ticks to 3.
		      552 + 
		      553 +   let sequence = test.startSequence();
		      554 +   for (let i = 0; i < 32; i++) {
		      555 +     const active = i % 4;
		      556 +     sequence = sequence.thenIdle(2).thenExecute(() => {
		      557 +       for (let b = 0; b < 4; b++) {
		      558 +         testEx.assertBlockProperty("open_bit", b == active ? 1 : 0, stagesPos[b]);
		      559 +       }
		      560 +     });
		      561 +   }
		      562 +   sequence.thenSucceed();
		      563 + })
		      564 +   .structureName("RedstoneTests:repeater_clock")
		      565 +   .tag(GameTest.Tags.suiteDefault);
		 311      -       for (const lever of levers) {
		 312      -         test.pullLever(lever);
		 313      -       }
		 314      -     })
		 315      -     .thenIdle(6)
		 316      -     .thenExecute(() => {
		 317      -       for (const wire of wires) {
		 318      -         test.assertRedstonePower(wire, 0);
		 319      -       }
		 320      -     })
		 321      -     .thenExecute(() => {
		 322      -       for (const fenceGate of fenceGates) {
		 323      -         test.assertBlockState("in_wall_bit", 0, fenceGate);
		 324      -       }
		 325      -     })
		 326      -     .thenSucceed();
		 327      - }).tag(GameTest.Tags.suiteDefault);
		 328      - 
		 329      - let observerClock = (test, initialOpenBit) => {
		 330      -   const outputPos = new BlockLocation(2, 2, 0);
		 331      - 
		 332      -   const blockPermutation = MinecraftBlockTypes.trapdoor.createDefaultBlockPermutation();
		 333      -   blockPermutation.getProperty(BlockProperties.openBit).value = initialOpenBit;
		 334      - 
		 335      -   test.setBlockPermutation(blockPermutation, outputPos);
		 336  566   
		      567 + GameTest.register("RedstoneTests", "torch_nor", (test) => {
		      568 +   const testEx = new GameTestExtensions(test);
		      569 +   const inputA = new BlockLocation(4, 2, 0);
		      570 +   const inputB = new BlockLocation(0, 2, 0);
		 337      -   let sequence = test.startSequence();
		 338      - 
		      571 +   const output = new BlockLocation(2, 3, 0);
		      572 +   const FlatNorthSouth = 0;
		      573 +   const FlatEastWest = 1;
		 339      -   sequence.thenWait(() => {
		 340      -     test.assertBlockState("open_bit", 1, outputPos);
		 341      -   });
		 342  574   
		      575 +   test
		      576 +     .startSequence()
		 343      -   for (let i = 0; i < 8; i++) {
		      577 +     .thenExecute(() => test.pullLever(inputA))
		      578 +     .thenIdle(2)
		      579 +     .thenWait(() => {
		      580 +       testEx.assertBlockProperty("open_bit", FlatEastWest, output);
		      581 +     })
		      582 +     .thenExecute(() => test.pullLever(inputA))
		      583 +     .thenIdle(2)
		      584 +     .thenWait(() => {
		      585 +       testEx.assertBlockProperty("open_bit", FlatEastWest, output);
		      586 +     })
		 344      -     sequence
		 345      -       .thenWait(() => {
		 346      -         test.assertBlockState("open_bit", 0, outputPos);
		 347      -       })
		 348      -       .thenWait(() => {
		 349      -         test.assertBlockState("open_bit", 1, outputPos);
		 350      -       });
		 351      -   }
		 352      -   sequence.thenSucceed();
		 353      - };
		 354  587   
		      588 +     .thenExecute(() => test.pullLever(inputB))
		      589 +     .thenIdle(2)
		 355      - GameTest.register("RedstoneTests", "observer_clock", (test) => observerClock(test, false))
		      590 +     .thenWait(() => {
		      591 +       testEx.assertBlockProperty("open_bit", FlatNorthSouth, output);
		 356      -   .tag("suite:java_parity") // Trapdoors do not always flip open from observer redstone signal when starting closed
		 357      -   .tag(GameTest.Tags.suiteDisabled);
		 358      - 
		      592 +     })
		      593 +     .thenExecute(() => test.pullLever(inputB))
		      594 +     .thenIdle(2)
		      595 +     .thenWait(() => {
		      596 +       testEx.assertBlockProperty("open_bit", FlatEastWest, output);
		      597 +     })
		 359      - GameTest.register("RedstoneTests", "observer_clock_bedrock", (test) => observerClock(test, true))
		 360      -   .structureName("RedstoneTests:observer_clock")
		 361      -   .tag(GameTest.Tags.suiteDefault);
		 362      - 
		 363      - GameTest.register("RedstoneTests", "repeater_delay_lines", (test) => {
		 364      -   const inputPos = new BlockLocation(0, 2, 0);
		 365  598   
		      599 +     .thenExecute(() => {
		 366      -   const linesPos = [
		 367      -     [new BlockLocation(4, 2, 1), new BlockLocation(4, 2, 2), new BlockLocation(4, 2, 3), new BlockLocation(4, 2, 4)], //4-tick delay
		 368      -     [new BlockLocation(3, 2, 1), new BlockLocation(3, 2, 2), new BlockLocation(3, 2, 3), new BlockLocation(3, 2, 4)], //3-tick delay
		      600 +       test.pullLever(inputA);
		      601 +       test.pullLever(inputB);
		      602 +     })
		 369      -     [new BlockLocation(2, 2, 1), new BlockLocation(2, 2, 2), new BlockLocation(2, 2, 3), new BlockLocation(2, 2, 4)], //2-tick delay
		 370      -     [new BlockLocation(1, 2, 1), new BlockLocation(1, 2, 2), new BlockLocation(1, 2, 3), new BlockLocation(1, 2, 4)], //1-tick delay
		 371      -   ];
		 372  603   
		 373      -   const states = [
		 374      -     "XXX0",
		 375      -     "XX01",
		      604 +     .thenIdle(2)
		      605 +     .thenWait(() => {
		      606 +       testEx.assertBlockProperty("open_bit", FlatNorthSouth, output);
		      607 +     })
		      608 +     .thenExecute(() => {
		      609 +       test.pullLever(inputA);
		      610 +       test.pullLever(inputB);
		      611 +     })
		      612 +     .thenIdle(2)
		      613 +     .thenWait(() => {
		      614 +       testEx.assertBlockProperty("open_bit", FlatEastWest, output);
		      615 +     })
		      616 +     .thenSucceed();
		      617 + }).tag(GameTest.Tags.suiteDefault);
		      618 + 
		      619 + GameTest.register("RedstoneTests", "rs_latch", (test) => {
		      620 +   const testEx = new GameTestExtensions(test);
		      621 +   const r = new BlockLocation(1, 2, 0);
		      622 +   const s = new BlockLocation(2, 2, 5);
		 376      -     "X002",
		 377      -     "0013",
		 378      -     "001X",
		 379      -     "012X",
		 380      -     null,
		 381      -     "113X",
		 382      -     "123X",
		 383      -     "12XX",
		 384      -     null,
		 385      -     "23XX",
		 386      -     null,
		 387      -     null,
		 388      -     "2XXX",
		 389      -     "3XXX",
		 390      -     null,
		 391      -     null,
		 392      -     null,
		 393      -     "XXXX",
		 394      -   ];
		 395  623   
		      624 +   const q = new BlockLocation(0, 4, 2);
		      625 +   const notQ = new BlockLocation(3, 4, 3);
		 396      -   test.pulseRedstone(inputPos, 3);
		 397  626   
		      627 +   test
		 398      -   let sequence = test.startSequence();
		 399      -   for (const state of states) {
		      628 +     .startSequence()
		      629 +     .thenExecute(() => test.pulseRedstone(r, 2))
		      630 +     .thenIdle(4)
		      631 +     .thenWait(() => {
		      632 +       testEx.assertBlockProperty("open_bit", 1, q);
		      633 +       testEx.assertBlockProperty("open_bit", 0, notQ);
		      634 +     })
		      635 +     .thenExecute(() => test.pulseRedstone(r, 2))
		      636 +     .thenExecuteAfter(4, () => {
		      637 +       testEx.assertBlockProperty("open_bit", 1, q);
		      638 +       testEx.assertBlockProperty("open_bit", 0, notQ);
		      639 +     })
		 400      -     if (state == null) {
		 401      -       sequence = sequence.thenIdle(2);
		 402      -     } else {
		 403      -       sequence = sequence.thenWaitWithDelay(2, () => {
		 404      -         for (let line = 0; line < 4; line++) {
		 405      -           const expected = state.charAt(line);
		 406      -           const expectedPos = expected == "X" ? -1 : expected - "0";
		 407      -           for (let linePos = 0; linePos < 4; linePos++) {
		 408      -             const blockWorldPos = test.worldBlockLocation(linesPos[line][linePos]);
		 409      -             const block = World.getDimension("overworld").getBlock(blockWorldPos);
		 410      -             const blockPerm = block.getBlockData();
		 411      -             const blockType = blockPerm.getType();
		 412  640   
		      641 +     .thenExecute(() => test.pulseRedstone(s, 2))
		 413      -             if (linePos == expectedPos) {
		 414      -               test.assert(
		      642 +     .thenIdle(4)
		      643 +     .thenWait(() => {
		      644 +       testEx.assertBlockProperty("open_bit", 0, q);
		      645 +       testEx.assertBlockProperty("open_bit", 1, notQ);
		      646 +     })
		      647 + 
		      648 +     .thenExecute(() => test.pulseRedstone(s, 2))
		      649 +     .thenExecuteAfter(4, () => {
		      650 +       testEx.assertBlockProperty("open_bit", 0, q);
		      651 +       testEx.assertBlockProperty("open_bit", 1, notQ);
		      652 +     })
		      653 +     .thenSucceed();
		      654 + }).tag(GameTest.Tags.suiteDisabled); // Redstone timing inconsistencies between java and bedrock.
		      655 + 
		      656 + GameTest.register("RedstoneTests", "rs_latch_bedrock", (test) => {
		      657 +   const testEx = new GameTestExtensions(test);
		      658 +   const r = new BlockLocation(1, 2, 0);
		      659 +   const s = new BlockLocation(2, 2, 5);
		 415      -                 blockType.getName() == "minecraft:powered_repeater",
		 416      -                 "Unexpected Block State. Expected: powered. Actual: unpowered"
		 417      -               );
		 418      -             } else {
		 419      -               test.assert(
		 420      -                 blockType.getName() == "minecraft:unpowered_repeater",
		 421      -                 "Unexpected Block State. Expected: unpowered. Actual: powered"
		 422      -               );
		 423      -             }
		 424      -           }
		 425      -         }
		 426      -       });
		 427      -     }
		 428      -   }
		 429      -   sequence.thenSucceed();
		 430      - })
		 431      -   .tag("suite:java_parity")
		 432      -   .tag(GameTest.Tags.suiteDisabled); //The speed of the redstone pulse is different between Java and Bedrock.
		 433  660   
		      661 +   const q = new BlockLocation(0, 4, 2);
		      662 +   const notQ = new BlockLocation(3, 4, 3);
		 434      - GameTest.register("RedstoneTests", "repeater_delay_lines_bedrock", (test) => {
		 435      -   const inputPos = new BlockLocation(0, 2, 0);
		 436  663   
		      664 +   test
		      665 +     .startSequence()
		      666 +     .thenIdle(2)
		      667 +     .thenExecute(() => test.pulseRedstone(r, 4))
		      668 +     .thenIdle(6)
		      669 +     .thenWait(() => {
		      670 +       testEx.assertBlockProperty("open_bit", 0, q);
		      671 +       testEx.assertBlockProperty("open_bit", 1, notQ);
		      672 +     })
		      673 +     .thenExecute(() => test.pulseRedstone(r, 4))
		      674 +     .thenExecuteAfter(6, () => {
		      675 +       testEx.assertBlockProperty("open_bit", 0, q);
		      676 +       testEx.assertBlockProperty("open_bit", 1, notQ);
		      677 +     })
		      678 + 
		      679 +     .thenExecute(() => test.pulseRedstone(s, 4))
		      680 +     .thenIdle(6)
		      681 +     .thenWait(() => {
		      682 +       testEx.assertBlockProperty("open_bit", 1, q);
		      683 +       testEx.assertBlockProperty("open_bit", 0, notQ);
		      684 +     })
		      685 + 
		      686 +     .thenExecute(() => test.pulseRedstone(s, 4))
		      687 +     .thenExecuteAfter(6, () => {
		      688 +       testEx.assertBlockProperty("open_bit", 1, q);
		      689 +       testEx.assertBlockProperty("open_bit", 0, notQ);
		      690 +     })
		      691 +     .thenSucceed();
		      692 + }).tag(GameTest.Tags.suiteDefault);
		      693 + 
		      694 + GameTest.register("RedstoneTests", "repeater_delay", (test) => {
		      695 +   test.setBlockType(MinecraftBlockTypes.stone, new BlockLocation(0, 2, 5));
		 437      -   const linesPos = [
		 438      -     [new BlockLocation(4, 2, 1), new BlockLocation(4, 2, 2), new BlockLocation(4, 2, 3), new BlockLocation(4, 2, 4)], //4-tick delay
		 439      -     [new BlockLocation(3, 2, 1), new BlockLocation(3, 2, 2), new BlockLocation(3, 2, 3), new BlockLocation(3, 2, 4)], //3-tick delay
		 440      -     [new BlockLocation(2, 2, 1), new BlockLocation(2, 2, 2), new BlockLocation(2, 2, 3), new BlockLocation(2, 2, 4)], //2-tick delay
		 441      -     [new BlockLocation(1, 2, 1), new BlockLocation(1, 2, 2), new BlockLocation(1, 2, 3), new BlockLocation(1, 2, 4)], //1-tick delay
		 442      -   ];
		 443      - 
		 444      -   const states = [
		 445      -     "XXX0",
		 446      -     "XX01",
		 447      -     "X002",
		 448      -     "0013",
		 449      -     "001X",
		 450      -     "012X",
		 451      -     null,
		 452      -     "113X",
		 453      -     "123X",
		 454      -     "12XX",
		 455      -     null,
		 456      -     "23XX",
		 457      -     null,
		 458      -     null,
		 459      -     "2XXX",
		 460      -     "3XXX",
		 461      -     null,
		 462      -     null,
		 463      -     null,
		 464      -     "XXXX",
		 465      -   ];
		 466  696   
		      697 +   const lamp1 = new BlockLocation(1, 2, 0);
		      698 +   const lamp2 = new BlockLocation(3, 2, 0);
		 467      -   test.pulseRedstone(inputPos, 3); //Change redstone pulse form 2 ticks to 3.
		 468  699   
		      700 +   test
		 469      -   let sequence = test.startSequence();
		 470      -   for (const state of states) {
		      701 +     .startSequence()
		      702 +     .thenWait(() => {
		      703 +       test.assertRedstonePower(lamp1, 15);
		      704 +     })
		      705 +     .thenExecute(() => {
		      706 +       test.assertRedstonePower(lamp2, 15);
		      707 +     })
		      708 +     .thenWait(() => {
		      709 +       test.assertRedstonePower(lamp1, 0);
		      710 +     })
		      711 +     .thenExecute(() => {
		      712 +       test.assertRedstonePower(lamp2, 0);
		      713 +     })
		      714 +     .thenSucceed();
		      715 + })
		      716 +   .maxTicks(TicksPerSecond * 10)
		      717 +   .tag(GameTest.Tags.suiteDisabled); //The ticks of Redstone repeater is too short in structure, causing the Redstone lamp will not go out.
		      718 + 
		      719 + GameTest.register("RedstoneTests", "repeater_delay_bedrock", (test) => {
		      720 +   test.setBlockType(MinecraftBlockTypes.stone, new BlockLocation(0, 2, 5));
		      721 + 
		      722 +   const lamp1 = new BlockLocation(1, 2, 0);
		      723 +   const lamp2 = new BlockLocation(3, 2, 0);
		      724 + 
		      725 +   test
		      726 +     .startSequence()
		      727 +     .thenWait(() => {
		      728 +       test.assertRedstonePower(lamp1, 15);
		      729 +     })
		      730 +     .thenExecute(() => {
		      731 +       test.assertRedstonePower(lamp2, 15);
		      732 +     })
		      733 +     .thenWait(() => {
		      734 +       test.assertRedstonePower(lamp1, 0);
		      735 +     })
		      736 +     .thenExecute(() => {
		      737 +       test.assertRedstonePower(lamp2, 0);
		      738 +     })
		      739 +     .thenSucceed();
		      740 + })
		      741 +   .maxTicks(TicksPerSecond * 10)
		      742 +   .tag(GameTest.Tags.suiteDefault); //Change the ticks of Redstone repeater to the longest in structure.
		 471      -     if (state == null) {
		 472      -       sequence = sequence.thenIdle(2);
		 473      -     } else {
		 474      -       sequence = sequence.thenIdle(2).thenExecute(() => {
		 475      -         for (let line = 0; line < 4; line++) {
		 476      -           const expected = state.charAt(line);
		 477      -           const expectedPos = expected == "X" ? -1 : expected - "0";
		 478      -           for (let linePos = 0; linePos < 4; linePos++) {
		 479      -             const blockWorldPos = test.worldBlockLocation(linesPos[line][linePos]);
		 480      -             const block = World.getDimension("overworld").getBlock(blockWorldPos);
		 481      -             const blockPerm = block.getBlockData();
		 482      -             const blockType = blockPerm.getType();
		 483      - 
		 484      -             if (linePos == expectedPos) {
		 485      -               test.assert(
		 486      -                 blockType.getName() == "minecraft:powered_repeater",
		 487      -                 "Unexpected Block State. Expected: powered. Actual: unpowered"
		 488      -               );
		 489      -             } else {
		 490      -               test.assert(
		 491      -                 blockType.getName() == "minecraft:unpowered_repeater",
		 492      -                 "Unexpected Block State. Expected: unpowered. Actual: powered"
		 493      -               );
		 494      -             }
		 495      -           }
		 496      -         }
		 497      -       });
		 498      -     }
		 499      -   }
		 500      -   sequence.thenSucceed();
		 501      - })
		 502      -   .structureName("RedstoneTests:repeater_delay_lines")
		 503      -   .tag(GameTest.Tags.suiteDefault);
		 504      - 
		 505      - GameTest.register("RedstoneTests", "repeater_clock", (test) => {
		 506      -   const startPos = new BlockLocation(0, 4, 0);
		 507      -   const stagesPos = [
		 508      -     new BlockLocation(0, 1, 0),
		 509      -     new BlockLocation(2, 1, 0),
		 510      -     new BlockLocation(2, 1, 2),
		 511      -     new BlockLocation(0, 1, 2),
		 512      -   ];
		 513  743   
		      744 + function distManhattan(pos, loc) {
		      745 +   const xd = Math.abs(pos.x - loc.x);
		      746 +   const yd = Math.abs(pos.y - loc.y);
		      747 +   const zd = Math.abs(pos.z - loc.z);
		 514      -   test.pulseRedstone(startPos, 2);
		 515  748   
		 516      -   let sequence = test.startSequence();
		 517      -   for (let i = 0; i < 32; i++) {
		 518      -     const active = i % 4;
		      749 +   return xd + yd + zd;
		      750 + }
		      751 + 
		      752 + GameTest.register("RedstoneTests", "dust_loop_depowering", (test) => {
		      753 +   const source = new BlockLocation(2, 2, 0);
		      754 +   const input = new BlockLocation(2, 2, 1);
		      755 +   const pointA = new BlockLocation(4, 2, 1);
		      756 +   const pointB = new BlockLocation(0, 2, 16);
		      757 +   const pointC = new BlockLocation(4, 2, 1);
		      758 +   const pointD = new BlockLocation(0, 2, 16);
		 519      -     sequence = sequence.thenWaitWithDelay(i == 0 ? 0 : 2, () => {
		 520      -       for (let b = 0; b < 4; b++) {
		 521      -         test.assertBlockState("open_bit", b == active ? 1 : 0, stagesPos[b]);
		 522      -       }
		 523      -     });
		 524      -   }
		 525      -   sequence.thenSucceed();
		 526      - })
		 527      -   .tag("suite:java_parity")
		 528      -   .tag(GameTest.Tags.suiteDisabled); //The speed of the redstone pulse is different between Java and Bedrock.
		 529  759   
		 530      - GameTest.register("RedstoneTests", "repeater_clock_bedrock", (test) => {
		 531      -   const startPos = new BlockLocation(0, 4, 0);
		 532      -   const stagesPos = [
		      760 +   test.setBlockType(MinecraftBlockTypes.redstoneBlock, source);
		      761 + 
		      762 +   pointA.blocksBetween(pointB).forEach((p) => {
		      763 +     test.assertRedstonePower(p, Math.max(0, 15 - distManhattan(p, input)));
		      764 +   });
		 533      -     new BlockLocation(0, 1, 0),
		 534      -     new BlockLocation(2, 1, 0),
		 535      -     new BlockLocation(2, 1, 2),
		 536      -     new BlockLocation(0, 1, 2),
		 537      -   ];
		 538  765   
		      766 +   test.setBlockType(MinecraftBlockTypes.air, source);
		 539      -   test.pulseRedstone(startPos, 3); //Change redstone pulse form 2 ticks to 3.
		 540  767   
		 541      -   let sequence = test.startSequence();
		 542      -   for (let i = 0; i < 32; i++) {
		 543      -     const active = i % 4;
		 544      -     sequence = sequence.thenIdle(2).thenExecute(() => {
		      768 +   test.succeedWhen(() => {
		      769 +     pointC.blocksBetween(pointD).forEach((p) => {
		      770 +       test.assertRedstonePower(p, 0);
		 545      -       for (let b = 0; b < 4; b++) {
		 546      -         test.assertBlockState("open_bit", b == active ? 1 : 0, stagesPos[b]);
		 547      -       }
		 548  771       });
		 549      -   }
		 550      -   sequence.thenSucceed();
		 551      - })
		      772 +   });
		      773 + }).tag(GameTest.Tags.suiteDisabled); //In Java the redstone signal is sent as soon as the redstone block is placed but in Bedrock it need to take a tick or two
		 552      -   .structureName("RedstoneTests:repeater_clock")
		 553      -   .tag(GameTest.Tags.suiteDefault);
		 554  774   
		      775 + GameTest.register("RedstoneTests", "dust_loop_depowering_bedrock", (test) => {
		      776 +   const source = new BlockLocation(2, 2, 0);
		 555      - GameTest.register("RedstoneTests", "torch_nor", (test) => {
		      777 +   const input = new BlockLocation(2, 2, 1);
		      778 +   const pointA = new BlockLocation(4, 2, 1);
		      779 +   const pointB = new BlockLocation(0, 2, 16);
		      780 +   const pointC = new BlockLocation(4, 2, 1);
		      781 +   const pointD = new BlockLocation(0, 2, 16);
		 556      -   const inputA = new BlockLocation(4, 2, 0);
		 557      -   const inputB = new BlockLocation(0, 2, 0);
		 558      -   const output = new BlockLocation(2, 3, 0);
		 559      -   const FlatNorthSouth = 0;
		 560      -   const FlatEastWest = 1;
		 561  782   
		 562      -   test
		 563      -     .startSequence()
		 564      -     .thenExecute(() => test.pullLever(inputA))
		      783 +   test.setBlockType(MinecraftBlockTypes.redstoneBlock, source);
		      784 + 
		      785 +   test.runAfterDelay(2, () => {
		      786 +     pointA.blocksBetween(pointB).forEach((p) => {
		      787 +       test.assertRedstonePower(p, Math.max(0, 15 - distManhattan(p, input)));
		      788 +     });
		      789 +   });
		      790 + 
		      791 +   test.setBlockType(MinecraftBlockTypes.air, source);
		 565      -     .thenIdle(2)
		 566      -     .thenWait(() => {
		 567      -       test.assertBlockState("open_bit", FlatEastWest, output);
		 568      -     })
		 569      -     .thenExecute(() => test.pullLever(inputA))
		 570      -     .thenIdle(2)
		 571      -     .thenWait(() => {
		 572      -       test.assertBlockState("open_bit", FlatEastWest, output);
		 573      -     })
		 574  792   
		 575      -     .thenExecute(() => test.pullLever(inputB))
		 576      -     .thenIdle(2)
		 577      -     .thenWait(() => {
		 578      -       test.assertBlockState("open_bit", FlatNorthSouth, output);
		      793 +   test.succeedWhen(() => {
		      794 +     pointC.blocksBetween(pointD).forEach((p) => {
		      795 +       test.assertRedstonePower(p, 0);
		      796 +     });
		      797 +   });
		      798 + }).tag(GameTest.Tags.suiteDefault);
		 579      -     })
		 580      -     .thenExecute(() => test.pullLever(inputB))
		 581      -     .thenIdle(2)
		 582      -     .thenWait(() => {
		 583      -       test.assertBlockState("open_bit", FlatEastWest, output);
		 584      -     })
		 585  799   
		      800 + GameTest.register("RedstoneTests", "lever_power", (test) => {
		      801 +   const powered = [
		 586      -     .thenExecute(() => {
		 587      -       test.pullLever(inputA);
		      802 +     new BlockLocation(1, 2, 0),
		      803 +     new BlockLocation(1, 2, 3),
		 588      -       test.pullLever(inputB);
		 589      -     })
		 590  804   
		 591      -     .thenIdle(2)
		 592      -     .thenWait(() => {
		 593      -       test.assertBlockState("open_bit", FlatNorthSouth, output);
		      805 +     new BlockLocation(2, 2, 1),
		      806 +     new BlockLocation(2, 2, 2),
		      807 + 
		      808 +     new BlockLocation(0, 2, 1),
		      809 +     new BlockLocation(0, 2, 2),
		      810 + 
		      811 +     new BlockLocation(1, 3, 1),
		      812 +     new BlockLocation(1, 3, 2),
		      813 + 
		      814 +     new BlockLocation(1, 1, 1),
		      815 +     new BlockLocation(1, 1, 2),
		 594      -     })
		 595      -     .thenExecute(() => {
		 596      -       test.pullLever(inputA);
		 597      -       test.pullLever(inputB);
		 598      -     })
		 599      -     .thenIdle(2)
		 600      -     .thenWait(() => {
		 601      -       test.assertBlockState("open_bit", FlatEastWest, output);
		 602      -     })
		 603      -     .thenSucceed();
		 604      - }).tag(GameTest.Tags.suiteDefault);
		 605  816   
		      817 +     new BlockLocation(1, 2, 2),
		 606      - GameTest.register("RedstoneTests", "rs_latch", (test) => {
		 607      -   const r = new BlockLocation(1, 2, 0);
		      818 +   ];
		 608      -   const s = new BlockLocation(2, 2, 5);
		 609  819   
		      820 +   const leverPos = new BlockLocation(1, 2, 1);
		      821 +   test.pullLever(leverPos);
		 610      -   const q = new BlockLocation(0, 4, 2);
		 611      -   const notQ = new BlockLocation(3, 4, 3);
		 612  822   
		 613      -   test
		 614      -     .startSequence()
		 615      -     .thenExecute(() => test.pulseRedstone(r, 2))
		      823 +   const pointA = new BlockLocation(0, 1, 0);
		      824 +   const pointB = new BlockLocation(2, 3, 3);
		      825 + 
		      826 +   test.succeedIf(() => {
		      827 +     pointA
		      828 +       .blocksBetween(pointB)
		      829 +       .filter((p) => !p.equals(leverPos))
		      830 +       .forEach((p) => test.assertRedstonePower(p, powered.includes(p) ? 15 : 0));
		      831 +   });
		      832 + }).tag(GameTest.Tags.suiteDefault);
		 616      -     .thenIdle(4)
		 617      -     .thenWait(() => {
		 618      -       test.assertBlockState("open_bit", 1, q);
		 619      -       test.assertBlockState("open_bit", 0, notQ);
		 620      -     })
		 621      -     .thenExecute(() => test.pulseRedstone(r, 2))
		 622      -     .thenExecuteAfter(4, () => {
		 623      -       test.assertBlockState("open_bit", 1, q);
		 624      -       test.assertBlockState("open_bit", 0, notQ);
		 625      -     })
		 626  833   
		 627      -     .thenExecute(() => test.pulseRedstone(s, 2))
		 628      -     .thenIdle(4)
		 629      -     .thenWait(() => {
		      834 + GameTest.register("RedstoneTests", "dust_propagation", (test) => {
		      835 +   let levels = new Map();
		      836 +   const origin = new BlockLocation(2, 2, 1);
		 630      -       test.assertBlockState("open_bit", 0, q);
		 631      -       test.assertBlockState("open_bit", 1, notQ);
		 632      -     })
		 633  837   
		      838 +   {
		 634      -     .thenExecute(() => test.pulseRedstone(s, 2))
		 635      -     .thenExecuteAfter(4, () => {
		 636      -       test.assertBlockState("open_bit", 0, q);
		      839 +     origin
		      840 +       .blocksBetween(new BlockLocation(2, 2, 17))
		      841 +       .forEach((p) => levels.set(p, Math.max(15 - distManhattan(origin, p), 0)));
		      842 +   }
		 637      -       test.assertBlockState("open_bit", 1, notQ);
		 638      -     })
		 639      -     .thenSucceed();
		 640      - }).tag(GameTest.Tags.suiteDisabled); // Redstone timing inconsistencies between java and bedrock.
		 641  843   
		      844 +   {
		      845 +     levels.set(new BlockLocation(3, 2, 2), 13);
		      846 +     levels.set(new BlockLocation(3, 2, 9), 6);
		 642      - GameTest.register("RedstoneTests", "rs_latch_bedrock", (test) => {
		      847 +     const leftRoot = new BlockLocation(4, 2, 2);
		      848 +     leftRoot
		      849 +       .blocksBetween(new BlockLocation(4, 2, 14))
		      850 +       .forEach((p) => levels.set(p, Math.max(12 - distManhattan(leftRoot, p), 0)));
		      851 +   }
		 643      -   const r = new BlockLocation(1, 2, 0);
		 644      -   const s = new BlockLocation(2, 2, 5);
		 645      - 
		 646      -   const q = new BlockLocation(0, 4, 2);
		 647      -   const notQ = new BlockLocation(3, 4, 3);
		 648  852   
		 649      -   test
		 650      -     .startSequence()
		 651      -     .thenIdle(2)
		 652      -     .thenExecute(() => test.pulseRedstone(r, 4))
		      853 +   {
		      854 +     levels.set(new BlockLocation(1, 2, 3), 12);
		      855 +     const rightRoot = new BlockLocation(0, 2, 3);
		      856 +     rightRoot
		      857 +       .blocksBetween(new BlockLocation(0, 2, 14))
		      858 +       .forEach((p) => levels.set(p, Math.max(11 - distManhattan(rightRoot, p), 0)));
		      859 +   }
		      860 + 
		      861 +   const source = new BlockLocation(2, 2, 0);
		      862 +   test.setBlockType(MinecraftBlockTypes.redstoneBlock, source);
		 653      -     .thenIdle(6)
		 654      -     .thenWait(() => {
		 655      -       test.assertBlockState("open_bit", 0, q);
		 656      -       test.assertBlockState("open_bit", 1, notQ);
		 657      -     })
		 658      -     .thenExecute(() => test.pulseRedstone(r, 4))
		 659      -     .thenExecuteAfter(6, () => {
		 660      -       test.assertBlockState("open_bit", 0, q);
		 661      -       test.assertBlockState("open_bit", 1, notQ);
		 662      -     })
		 663  863   
		      864 +   for (let [pos, level] of levels) {
		 664      -     .thenExecute(() => test.pulseRedstone(s, 4))
		 665      -     .thenIdle(6)
		      865 +     test.assertRedstonePower(pos, level);
		      866 +   }
		      867 + 
		      868 +   test.setBlockType(MinecraftBlockTypes.air, source);
		 666      -     .thenWait(() => {
		 667      -       test.assertBlockState("open_bit", 1, q);
		 668      -       test.assertBlockState("open_bit", 0, notQ);
		 669      -     })
		 670  869   
		 671      -     .thenExecute(() => test.pulseRedstone(s, 4))
		 672      -     .thenExecuteAfter(6, () => {
		 673      -       test.assertBlockState("open_bit", 1, q);
		      870 +   test.succeedIf(() => {
		      871 +     for (let pos of levels.keys()) {
		      872 +       test.assertRedstonePower(pos, 0);
		      873 +     }
		 674      -       test.assertBlockState("open_bit", 0, notQ);
		 675      -     })
		 676      -     .thenSucceed();
		 677      - }).tag(GameTest.Tags.suiteDefault);
		 678      - 
		      874 +   });
		      875 + }).tag(GameTest.Tags.suiteDisabled); //In Java the redstone signal is sent as soon as the redstone block is placed but in Bedrock it need to take a tick or two
		 679      - GameTest.register("RedstoneTests", "repeater_delay", (test) => {
		 680      -   test.setBlockType(MinecraftBlockTypes.stone, new BlockLocation(0, 2, 5));
		 681  876   
		      877 + GameTest.register("RedstoneTests", "dust_propagation_bedrock", (test) => {
		      878 +   let levels = new Map();
		 682      -   const lamp1 = new BlockLocation(1, 2, 0);
		      879 +   const origin = new BlockLocation(2, 2, 1);
		 683      -   const lamp2 = new BlockLocation(3, 2, 0);
		 684  880   
		      881 +   {
		      882 +     origin
		 685      -   test
		      883 +       .blocksBetween(new BlockLocation(2, 2, 17))
		      884 +       .forEach((p) => levels.set(p, Math.max(15 - distManhattan(origin, p), 0)));
		      885 +   }
		      886 + 
		      887 +   {
		      888 +     levels.set(new BlockLocation(3, 2, 2), 13);
		      889 +     levels.set(new BlockLocation(3, 2, 9), 6);
		      890 +     const leftRoot = new BlockLocation(4, 2, 2);
		      891 +     leftRoot
		      892 +       .blocksBetween(new BlockLocation(4, 2, 14))
		      893 +       .forEach((p) => levels.set(p, Math.max(12 - distManhattan(leftRoot, p), 0)));
		      894 +   }
		      895 + 
		      896 +   {
		      897 +     levels.set(new BlockLocation(1, 2, 3), 12);
		      898 +     const rightRoot = new BlockLocation(0, 2, 3);
		      899 +     rightRoot
		      900 +       .blocksBetween(new BlockLocation(0, 2, 14))
		      901 +       .forEach((p) => levels.set(p, Math.max(11 - distManhattan(rightRoot, p), 0)));
		      902 +   }
		 686      -     .startSequence()
		 687      -     .thenWait(() => {
		 688      -       test.assertRedstonePower(lamp1, 15);
		 689      -     })
		 690      -     .thenExecute(() => {
		 691      -       test.assertRedstonePower(lamp2, 15);
		 692      -     })
		 693      -     .thenWait(() => {
		 694      -       test.assertRedstonePower(lamp1, 0);
		 695      -     })
		 696      -     .thenExecute(() => {
		 697      -       test.assertRedstonePower(lamp2, 0);
		 698      -     })
		 699      -     .thenSucceed();
		 700      - })
		 701      -   .maxTicks(TicksPerSecond * 10)
		 702      -   .tag(GameTest.Tags.suiteDisabled); //The ticks of Redstone repeater is too short in structure, causing the Redstone lamp will not go out.
		 703      - 
		 704      - GameTest.register("RedstoneTests", "repeater_delay_bedrock", (test) => {
		 705      -   test.setBlockType(MinecraftBlockTypes.stone, new BlockLocation(0, 2, 5));
		 706  903   
		      904 +   const source = new BlockLocation(2, 2, 0);
		      905 +   test.setBlockType(MinecraftBlockTypes.redstoneBlock, source);
		 707      -   const lamp1 = new BlockLocation(1, 2, 0);
		 708      -   const lamp2 = new BlockLocation(3, 2, 0);
		 709  906   
		 710      -   test
		 711      -     .startSequence()
		 712      -     .thenWait(() => {
		 713      -       test.assertRedstonePower(lamp1, 15);
		      907 +   test.runAfterDelay(2, () => {
		      908 +     for (let [pos, level] of levels) {
		      909 +       test.assertRedstonePower(pos, level);
		      910 +     }
		      911 +   });
		      912 + 
		      913 +   test.setBlockType(MinecraftBlockTypes.air, source);
		      914 + 
		      915 +   test.succeedIf(() => {
		      916 +     for (let pos of levels.keys()) {
		      917 +       test.assertRedstonePower(pos, 0);
		      918 +     }
		      919 +   });
		      920 + }).tag(GameTest.Tags.suiteDefault);
		 714      -     })
		 715      -     .thenExecute(() => {
		 716      -       test.assertRedstonePower(lamp2, 15);
		 717      -     })
		 718      -     .thenWait(() => {
		 719      -       test.assertRedstonePower(lamp1, 0);
		 720      -     })
		 721      -     .thenExecute(() => {
		 722      -       test.assertRedstonePower(lamp2, 0);
		 723      -     })
		 724      -     .thenSucceed();
		 725      - })
		 726      -   .maxTicks(TicksPerSecond * 10)
		 727      -   .tag(GameTest.Tags.suiteDefault); //Change the ticks of Redstone repeater to the longest in structure.
		            '''
	Changed script "SmallMobTests.js":
		Total line: 42 (+5, -5)
		        '''
		    1 + import * as GameTest from "mojang-gametest";
		    2 + import { BlockLocation, Location } from "mojang-minecraft";
		 1    - import * as GameTest from "GameTest";
		 2    - import { BlockLocation, Location } from "Minecraft";
		 3  3   
		 4  4   GameTest.register("SmallMobTests", "fence_corner", (test) => {
		 5  5     const piglinEntityType = "minecraft:piglin<minecraft:entity_born>";
		 6  6     const entityLoc = new Location(0.8, 2, 0.8);
		 7  7     const piglin = test.spawnWithoutBehaviorsAtLocation(piglinEntityType, entityLoc);
		 8  8   
		 9  9     const targetPos = new BlockLocation(3, 2, 3);
		10 10     test.walkTo(piglin, targetPos, 1);
		   11 +   test.succeedWhenEntityPresent(piglinEntityType, targetPos, true);
		11    -   test.succeedWhenEntityPresent(piglinEntityType, targetPos);
		12 12   })
		13 13     .rotateTest(true)
		14 14     .tag(GameTest.Tags.suiteDefault);
		15 15   
		16 16   GameTest.register("SmallMobTests", "fence_side", (test) => {
		        ...
		18 18     const entityLoc = new Location(2.8, 2, 2.05);
		19 19     const piglin = test.spawnWithoutBehaviorsAtLocation(piglinEntityType, entityLoc);
		20 20   
		21 21     const targetPos = new BlockLocation(0, 2, 2);
		22 22     test.walkTo(piglin, targetPos, 1);
		   23 +   test.succeedWhenEntityPresent(piglinEntityType, targetPos, true);
		23    -   test.succeedWhenEntityPresent(piglinEntityType, targetPos);
		24 24     test.runAfterDelay(10, () => {
		25 25       test.assertCanReachLocation(piglin, targetPos, false);
		26 26       test.succeed();
		27 27     });
		28 28   })
		        ...
		34 34     const entityLoc = new BlockLocation(1, 2, 1);
		35 35     const chicken = test.spawnWithoutBehaviors(chickenEntityType, entityLoc);
		36 36   
		37 37     const targetPos = new BlockLocation(3, 2, 3);
		38 38     test.walkTo(chicken, targetPos, 1);
		   39 +   test.succeedWhenEntityPresent(chickenEntityType, targetPos, true);
		39    -   test.succeedWhenEntityPresent(chickenEntityType, targetPos);
		40 40   })
		41 41     .tag("suite:java_parity")
		42 42     .tag(GameTest.Tags.suiteDisabled); //game parity,the chicken cannot walk between the fenceposts
		        '''
	Changed script "TntTests.js":
		Total line: 103 (+2, -2)
		          '''
		      1 + import * as GameTest from "mojang-gametest";
		      2 + import { BlockLocation, MinecraftBlockTypes } from "mojang-minecraft";
		  1     - import * as GameTest from "GameTest";
		  2     - import { BlockLocation, MinecraftBlockTypes } from "Minecraft";
		  3   3   
		  4   4   function locToStr(loc) {
		  5   5     return [loc.x.toFixed(3), loc.y.toFixed(3), loc.z.toFixed(3)].join(", ");
		  6   6   }
		  7   7   
		          ...
		          '''