/* Converted by CmpMigrator 0.1.9 */
settings {
    aliases {
        s = @serializers/
        t = @structure_tags/
        temp = @structures/template/
    }
}
base inherit temp/base_multiple_pack_files {
    $ name = "entities"
    $ file_field = "entity"
    $ pack_type = "behavior pack"
    $ allow_file_moves = false
    $ structure = @entity
}
entity_types_type [#dict, #list]
range [#dict, #list]
trigger_type [#dict, #list]
entity inherit temp/SortedKeymap {
    keys = {
        "format_version" = :Key {types = #str}
        "definitions" = :Key {types = #dict, structure = @definitions, tags = [@t/outdated]}
        "use_beta_features" = :Key {types = #bool}
        "minecraft:entity" = :Key {types = #dict, structure = :Normalizer {
            outer_types = #dict
            inner_types = #dict
            functions = :Function {
                function = %delete_keys
                arguments = {"keys" = ["minecraft:physics", "minecraft:pushable", "minecraft:conditional_bandwidth_optimization", "minecraft:raid_persistence"]}
            }
            structure = inherit temp/SortedKeymap {
                keys = {
                    "format_version" = :Key {types = [#float, #str], tags = [@t/outdated]}
                    "version" = :Key {types = @temp/decimal, tags = [@t/outdated]}
                    "description" = :Key {types = #dict, structure = @description}
                    "component_groups" = :Key {types = #dict, structure = @component_groups}
                    "components" = :Key {types = #dict, structure = @components}
                    "events" = :Key {types = #dict, structure = @events}
                }
                delegate = :Delegate {
                    delegate_class = %DefaultDelegate
                    arguments = {"sort" = %sort_by_component_order}
                }
            }
        }}
        "version" = :Key {types = @temp/decimal, tags = [@t/outdated]}
    }
}
definitions inherit temp/Dict {
    value_types = #dict
    value_structure = @temp/empty
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "definition", "sort" = %sort_by_key, "measure_length" = true}
    }
}
description inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "identifier" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "is_spawnable" = :Key {types = #bool}
        "is_summonable" = :Key {types = #bool}
        "is_experimental" = :Key {types = #bool}
        "minecraft:identifier" = :Key {types = #dict, structure = @description.identifier, tags = [@t/outdated]}
        "minecraft:is_experimental" = :Key {types = #dict, structure = @description.old_item, tags = [@t/outdated]}
        "minecraft:is_summonable" = :Key {types = #dict, structure = @description.old_item, tags = [@t/outdated]}
        "minecraft:spawn_egg" = :Key {types = #dict, structure = @description.old_item, tags = [@t/outdated]}
        "properties" = :Key {types = #dict, structure = @properties}
        "spawn_category" = :Key {types = #str}
    }
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"sort" = %sort_by_key, "field" = "description"}
    }
}
description.identifier inherit temp/SortedKeymap {
    keys = {
        "id" = :Key {types = #str}
    }
}
description.old_item inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = #bool}
    }
}
properties inherit temp/Dict {
    value_types = #dict
    value_structure = @property
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "property", "sort" = %sort_by_key, "measure_length" = true}
    }
}
property inherit temp/SortedKeymap {
    keys = {
        "type" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "client_sync" = :Key {types = #bool}
        "default" = :Key {types = [#bool, #str, #int]}
        "range" = :Key {types = #list, structure = @range_list_int}
        "values" = :Key {types = #list, structure = @property:values}
    }
}
property:values inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "possible property", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
events inherit temp/Dict {
    key_weight = 1
    value_weight = 2
    value_types = #dict
    key_structure = @temp/string_remove_minecraft_prefix
    value_structure = @events_event
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "event", "sort" = %sort_by_key, "measure_length" = true}
    }
}
events_event :Normalizer {
    outer_types = #dict
    inner_types = #dict
    functions = :Function {
        function = %delete_key
        arguments = {"key" = "minecraft:transformation"}
    }
    structure = inherit temp/SortedKeymap {
        keys = {
            "trigger" = :Key {types = [#str, #dict], structure = @event_target_or_str}
            "weight" = :Key {types = #int}
            "add" = :Key {types = #dict, structure = @component_groups_add_remove}
            "drop_item" = :Key {types = #dict, structure = @event:drop_item}
            "emit_particle" = :Key {types = #dict, structure = @event:emit_particle}
            "emit_vibration" = :Key {types = #dict, structure = @event:emit_vibration}
            "execute_event_on_home_block" = :Key {types = #dict, structure = @event}
            "filters" = :Key {types = #dict, structure = @filter}
            "first_valid" = :Key {types = #list, structure = @event:first_valid}
            "play_sound" = :Key {types = #dict, structure = @event:play_sound}
            "randomize" = :Key {types = #list, structure = @event:randomize}
            "remove" = :Key {types = #dict, structure = @component_groups_add_remove}
            "reset_target" = :Key {types = #dict, structure = @temp/empty}
            "sequence" = :Key {types = #list, structure = @event:sequence}
            "set_home_position" = :Key {types = #dict, structure = @temp/empty}
            "set_property" = :Key {types = #dict, structure = @event:set_property}
            "stop_movement" = :Key {types = #dict, structure = @temp/empty}
        }
        delegate = :Delegate {
            delegate_class = %DefaultDelegate
            arguments = {"sort" = %sort_by_component_order}
        }
    }
}
component_groups_add_remove :Normalizer {
    outer_types = #dict
    inner_types = #dict
    functions = :Function {
        // https://bugs.mojang.com/browse/MCPE-178417
        function = %delete_keys
        arguments = {"keys" = ["minecraft:silverfish_calm", "minecraft:silverfish_angry", "minecraft:enderman_calm", "minecraft:enderman_angry", "minecraft:sheep_sheared", "minecraft:sheep_dyeable"]}
    }
    structure = inherit temp/SortedKeymap {
        keys = {
            "component_groups" = :Key {types = #list, structure = @component_group_list}
        }
    }
}
component_group_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = @temp/string_remove_minecraft_prefix
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "component group", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
component_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "component", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
component_list_or_component :Union {
    substructures = [
        :Key {types = #list, structure = @component_list},
        :Key {types = #str},
    ]
}
event:drop_item inherit temp/SortedKeymap {
    keys = {
        "slot" = :Key {types = #str}
    }
}
event:emit_particle inherit temp/SortedKeymap {
    keys = {
        "particle" = :Key {types = #str}
    }
}
event:emit_vibration inherit temp/SortedKeymap {
    keys = {
        "vibration" = :Key {types = #str}
    }
}
event:first_valid inherit temp/Dict {
    this_types = #list
    key_types = #int
    key_weight = 2
    value_weight = 8
    value_types = #dict
    value_structure = @events_event
}
event:play_sound inherit temp/SortedKeymap {
    keys = {
        "sound" = :Key {types = #str, structure = @temp/string, delegate_arguments = {"always_print" = true}}
    }
}
event:randomize inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @events_event
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "randomize item", "show_item_key" = false, "measure_length" = true}
    }
}
event:sequence inherit temp/Dict {
    allow_key_moves = false
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @events_event
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "sequence item", "measure_length" = true}
    }
}
event:set_property inherit temp/Dict {
    value_types = [#bool, #str]
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "property", "sort" = %sort_by_key, "measure_length" = true}
    }
}
component_groups inherit temp/Dict {
    value_types = #dict
    key_structure = @temp/string
    key_weight = 5
    value_weight = 7
    value_structure = @components
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "component group", "sort" = %sort_by_key, "measure_length" = true}
    }
}
components :Normalizer {
    outer_types = #dict
    inner_types = #dict
    functions = :Function {
        function = %delete_key
        arguments = {"key" = "minecart:on_hurt_by_player"}
    }
    structure = @components_dict
}
components_dict inherit temp/SortedKeymap {
    tags = [@t/entity_component]
    keys = {
        "minecraft:absorption" = :Key {types = #dict, structure = @component.absorption, tags = [@t/outdated]}
        "minecraft:addrider" = :Key {types = #dict, structure = @component.addrider}
        "minecraft:admire_item" = :Key {types = #dict, structure = @component.admire_item}
        "minecraft:ageable" = :Key {types = #dict, structure = @component.ageable}
        "minecraft:agent_command" = :Key {types = #dict, structure = @temp/empty, tags = [@t/outdated]}
        "minecraft:ambient_sound_interval" = :Key {types = #dict, structure = @component.ambient_sound_interval}
        "minecraft:anger_level" = :Key {types = #dict, structure = @component.anger_level}
        "minecraft:angry" = :Key {types = #dict, structure = @component.angry}
        "minecraft:annotation.break_door" = :Key {types = #dict, structure = @component.annotation.break_door}
        "minecraft:annotation.open_door" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:area_attack" = :Key {types = #dict, structure = @component.area_attack}
        "minecraft:attack" = :Key {types = #dict, structure = @component.attack}
        "minecraft:attack_cooldown" = :Key {types = #dict, structure = @component.attack_cooldown}
        "minecraft:attack_damage" = :Key {types = #dict, structure = @component.attack_damage}
        "minecraft:body_rotation_blocked" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:balloon" = :Key {types = #dict, structure = @component.balloon, tags = [@t/not_in_documentation]}
        "minecraft:balloonable" = :Key {types = #dict, structure = @component.balloonable}
        "minecraft:barter" = :Key {types = #dict, structure = @component.barter}
        "minecraft:block_climber" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:block_sensor" = :Key {types = #dict, structure = @component.block_sensor}
        "minecraft:body_rotation_always_follows_head" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:body_rotation_axis_aligned" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:boostable" = :Key {types = #dict, structure = @component.boostable}
        "minecraft:boss" = :Key {types = #dict, structure = @component.boss}
        "minecraft:break_blocks" = :Key {types = #dict, structure = @component.break_blocks}
        "minecraft:breathable" = :Key {types = #dict, structure = @component.breathable}
        "breathable" = :Key {types = #dict, structure = @component.breathable, tags = [@t/outdated]}
        "minecraft:breedable" = :Key {types = #dict, structure = @component.breedable}
        "minecraft:bribeable" = :Key {types = #dict, structure = @component.bribeable}
        "minecraft:bucketable" = :Key {types = #dict, structure = @temp/empty, tags = [@t/outdated]}
        "minecraft:buoyant" = :Key {types = #dict, structure = @component.buoyant}
        "minecraft:burns_in_daylight" = :Key {types = [#bool, #dict], structure = @component.burns_in_daylight}
        "minecraft:can_climb" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:can_fly" = :Key {types = #dict, structure = @component.can_fly}
        "minecraft:can_join_raid" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:can_power_jump" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:can_swim" = :Key {types = #dict, structure = @temp/empty, tags = [@t/outdated]}
        "minecraft:cannot_be_attacked" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:caster" = :Key {types = #dict, structure = @temp/empty, tags = [@t/outdated]}
        "minecraft:celebrate_hunt" = :Key {types = #dict, structure = @component.celebrate_hunt}
        "minecraft:collision_box" = :Key {types = #dict, structure = @component.collision_box, tags = [@t/not_in_documentation]}
        "minecraft:color" = :Key {types = #dict, structure = @component.color}
        "minecraft:color2" = :Key {types = #dict, structure = @component.color2}
        "minecraft:combat_regeneration" = :Key {types = #dict, structure = @component.combat_regeneration}
        "minecraft:conditional_bandwidth_optimization" = :Key {types = #dict, structure = @component.conditional_bandwidth_optimization}
        "minecraft:custom_hit_test" = :Key {types = #dict, structure = @component.custom_hit_test}
        "minecraft:damage_over_time" = :Key {types = #dict, structure = @component.damage_over_time}
        "minecraft:damage_sensor" = :Key {types = [#dict, #list], structure = @component.damage_sensor:group}
        "minecraft:dash_action" = :Key {types = #dict, structure = @component.dash}
        "minecraft:dash" = :Key {types = #dict, structure = @component.dash, tags = [@t/outdated]}
        "minecraft:default_look_angle" = :Key {types = #dict, structure = @component.default_look_angle}
        "minecraft:despawn" = :Key {types = #dict, structure = @component.despawn}
        "minecraft:dimension_bound" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:drying_out_timer" = :Key {types = #dict, structure = @component.drying_out_timer}
        "minecraft:dweller" = :Key {types = #dict, structure = @component.dweller}
        "minecraft:economy_trade_table" = :Key {types = #dict, structure = @component.economy_trade_table}
        "minecraft:entity_sensor" = :Key {types = #dict, structure = @component.entity_sensor}
        "minecraft:environment_sensor" = :Key {types = [#dict, #list], structure = @component.environment_sensor:group}
        "minecraft:equip_item" = :Key {types = #dict, structure = @component.equip_item}
        "minecraft:equipment" = :Key {types = #dict, structure = @component.equipment}
        "minecraft:equippable" = :Key {types = #dict, structure = @component.equippable}
        "minecraft:exhaustion_values" = :Key {types = #dict, structure = @component.exhaustion_values}
        "minecraft:experience_reward" = :Key {types = #dict, structure = @component.experience_reward}
        "minecraft:explode" = :Key {types = #dict, structure = @component.explode}
        "minecraft:fall_damage" = :Key {types = #dict, structure = @component.fall_damage, tags = [@t/outdated]}
        "minecraft:fire_immune" = :Key {types = [#bool, #dict], structure = @component.fire_immune}
        "minecraft:float_wander" = :Key {types = #dict, structure = @component.float_wander, tags = [@t/outdated]}
        "minecraft:floats_in_liquid" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:flocking" = :Key {types = #dict, structure = @component.flocking}
        "minecraft:flying_speed" = :Key {types = #dict, structure = @component.flying_speed}
        "minecraft:follow_range" = :Key {types = [#dict, #int], structure = @component.follow_range:group}
        "minecraft:free_camera_controlled" = :Key {types = #dict, structure = @component.free_camera_controlled}
        "minecraft:friction_modifier" = :Key {types = #dict, structure = @component.friction_modifier}
        "minecraft:game_event_movement_tracking" = :Key {types = #dict, structure = @component.game_event_movement_tracking}
        "minecraft:genetics" = :Key {types = #dict, structure = @component.genetics}
        "minecraft:giveable" = :Key {types = #dict, structure = @component.giveable}
        "minecraft:ground_offset" = :Key {types = #dict, structure = @component.ground_offset}
        "minecraft:group_size" = :Key {types = #dict, structure = @component.group_size}
        "minecraft:grows_crop" = :Key {types = #dict, structure = @component.grows_crop}
        "minecraft:healable" = :Key {types = #dict, structure = @component.healable}
        "minecraft:health" = :Key {types = #dict, structure = @component.health}
        "minecraft:heartbeat" = :Key {types = #dict, structure = @component.heartbeat}
        "minecraft:hide" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:home" = :Key {types = #dict, structure = @component.home}
        "minecraft:horse.jump_strength" = :Key {types = #dict, structure = @component.horse.jump_strength}
        "minecraft:hurt_on_condition" = :Key {types = #dict, structure = @component.hurt_on_condition}
        "minecraft:hurt_when_wet" = :Key {types = #dict, structure = @component.hurt_when_wet, tags = [@t/outdated]}
        "minecraft:identifier" = :Key {types = #dict, structure = @component.identifier, tags = [@t/outdated], delegate_arguments = {"always_print" = true}}
        "minecraft:input_air_controlled" = :Key {types = #dict, structure = @component.input_air_controlled}
        "minecraft:input_ground_controlled" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:inside_block_notifier" = :Key {types = #dict, structure = @component.inside_block_notifier}
        "minecraft:insomnia" = :Key {types = #dict, structure = @component.insomnia}
        "minecraft:instant_despawn" = :Key {types = #dict, structure = @component.instant_despawn}
        "minecraft:interact" = :Key {types = [#dict, #list], structure = @component.interact:group}
        "minecraft:inventory" = :Key {types = #dict, structure = @component.inventory}
        "minecraft:is_baby" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:is_charged" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:is_chested" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:is_collidable" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:is_dyeable" = :Key {types = #dict, structure = @component.is_dyeable}
        "minecraft:is_hidden_when_invisible" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:is_ignited" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:is_illager_captain" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:is_pregnant" = :Key {types = #dict, structure = @temp/empty, tags = [@t/not_in_documentation]}
        "minecraft:is_saddled" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:is_shaking" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:is_sheared" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:is_stackable" = :Key {types = #dict, structure = @component.is_stackable}
        "minecraft:is_stunned" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:is_tamed" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:is_trap" = :Key {types = #dict, structure = @temp/empty, tags = [@t/outdated]}
        "minecraft:item_command_block" = :Key {types = #dict, structure = @component.item_command_block, tags = [@t/outdated]}
        "minecraft:item_controllable" = :Key {types = #dict, structure = @component.item_controllable}
        "minecraft:item_hopper" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:jump.dynamic" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:jump.static" = :Key {types = #dict, structure = @component.jump.static}
        "minecraft:knockback_resistance" = :Key {types = #dict, structure = @component.knockback_resistance}
        "minecraft:lava_movement" = :Key {types = #dict, structure = @component.lava_movement}
        "minecraft:leashable" = :Key {types = #dict, structure = @component.leashable}
        "minecraft:leashable_to" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:looked_at" = :Key {types = #dict, structure = @component.looked_at}
        "minecraft:lookat" = :Key {types = #dict, structure = @component.lookat}
        "minecraft:loot" = :Key {types = #dict, structure = @component.loot}
        "minecraft:managed_wandering_trader" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:mark_variant" = :Key {types = #dict, structure = @component.mark_variant}
        "minecraft:mob_effect" = :Key {types = #dict, structure = @component.mob_effect}
        "minecraft:mob_effect_immunity" = :Key {types = #dict, structure = @component.mob_effect_immunity}
        "minecraft:monster" = :Key {types = #dict, structure = @temp/empty, tags = [@t/outdated]}
        "minecraft:movement" = :Key {types = #dict, structure = @component.movement}
        "minecraft:movement.amphibious" = :Key {types = #dict, structure = @component.movement.amphibious}
        "minecraft:movement.basic" = :Key {types = #dict, structure = @component.movement.basic}
        "minecraft:movement.dolphin" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:movement.fly" = :Key {types = #dict, structure = @component.movement.fly}
        "minecraft:movement.generic" = :Key {types = #dict, structure = @component.movement.generic}
        "minecraft:movement.glide" = :Key {types = #dict, structure = @component.movement.glide}
        "minecraft:movement.hover" = :Key {types = #dict, structure = @component.movement.hover}
        "minecraft:movement.jump" = :Key {types = #dict, structure = @component.movement.jump}
        "minecraft:movement.skip" = :Key {types = #dict, structure = @component.movement.skip}
        "minecraft:movement_sound_distance_offset" = :Key {types = #dict, structure = @component.movement_sound_distance_offset}
        "minecraft:movement.sway" = :Key {types = #dict, structure = @component.movement.sway}
        "minecraft:movement.vex" = :Key {types = #dict, structure = @temp/empty, tags = [@t/outdated]}
        "minecraft:nameable" = :Key {types = #dict, structure = @component.nameable}
        "minecraft:navigation.climb" = :Key {types = #dict, structure = @component.navigation}
        "minecraft:navigation.float" = :Key {types = #dict, structure = @component.navigation}
        "minecraft:navigation.fly" = :Key {types = #dict, structure = @component.navigation}
        "minecraft:navigation.generic" = :Key {types = #dict, structure = @component.navigation}
        "minecraft:navigation.hover" = :Key {types = #dict, structure = @component.navigation}
        "minecraft:navigation.swim" = :Key {types = #dict, structure = @component.navigation}
        "minecraft:navigation.walk" = :Key {types = #dict, structure = @component.navigation}
        "minecraft:npc" = :Key {types = #dict, structure = @component.npc, tags = [@t/not_in_documentation]}
        "minecraft:on_calm" = :Key {types = #dict, structure = @event_target, tags = [@t/outdated]}
        "minecraft:on_death" = :Key {types = #dict, structure = @event_target, tags = [@t/not_in_documentation]}
        "minecraft:on_friendly_anger" = :Key {types = #dict, structure = @event_target, tags = [@t/not_in_documentation]}
        "minecraft:on_hurt" = :Key {types = #dict, structure = @event_target, tags = [@t/not_in_documentation]}
        "minecraft:on_hurt_by_player" = :Key {types = #dict, structure = @event_target, tags = [@t/not_in_documentation]}
        "minecraft:on_start_landing" = :Key {types = #dict, structure = @event_target, tags = [@t/not_in_documentation]}
        "minecraft:on_start_takeoff" = :Key {types = #dict, structure = @event_target, tags = [@t/not_in_documentation]}
        "minecraft:on_target_acquired" = :Key {types = #dict, structure = @event_target_filters, tags = [@t/not_in_documentation]}
        "minecraft:on_target_escape" = :Key {types = #dict, structure = @event_target_filters, tags = [@t/not_in_documentation]}
        "minecraft:on_wake_with_owner" = :Key {types = #dict, structure = @event_target, tags = [@t/not_in_documentation]}
        "minecraft:out_of_control" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:peek" = :Key {types = #dict, structure = @component.peek}
        "minecraft:persist_sit" = :Key {types = #dict, structure = @temp/empty, tags = [@t/outdated]}
        "minecraft:persistent" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:physics" = :Key {types = #dict, structure = @component.physics}
        "minecraft:player.exhaustion" = :Key {types = #dict, structure = @component.player.exhaustion}
        "minecraft:player.experience" = :Key {types = #dict, structure = @component.player.experience}
        "minecraft:player.level" = :Key {types = #dict, structure = @component.player.level}
        "minecraft:player.saturation" = :Key {types = #dict, structure = @component.player.saturation}
        "minecraft:player_ride_tamed" = :Key {types = #dict, structure = @temp/empty, tags = [@t/outdated]}
        "minecraft:preferred_path" = :Key {types = #dict, structure = @component.preferred_path}
        "minecraft:projectile" = :Key {types = #dict, structure = @component.projectile}
        "minecraft:push_through" = :Key {types = #dict, structure = @component.push_through}
        "minecraft:pushable" = :Key {types = #dict, structure = @component.pushable}
        "minecraft:raid_trigger" = :Key {types = #dict, structure = @component.raid_trigger}
        "minecraft:rail_movement" = :Key {types = #dict, structure = @component.rail_movement}
        "minecraft:rail_sensor" = :Key {types = #dict, structure = @component.rail_sensor}
        "minecraft:ravager_blocked" = :Key {types = #dict, structure = @component.ravager_blocked}
        "minecraft:reflect_projectiles" = :Key {types = #dict, structure = @component.reflect_projectiles, tags = [@t/not_in_documentation]}
        "minecraft:remove_in_peaceful" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:renders_when_invisible" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:rideable" = :Key {types = #dict, structure = @component.rideable}
        "minecraft:rotation_axis_aligned" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:scaffolding_climber" = :Key {types = #dict, structure = @temp/empty, tags = [@t/deprecated]}
        "minecraft:scale" = :Key {types = #dict, structure = @component.scale}
        "minecraft:scale_by_age" = :Key {types = #dict, structure = @component.scale_by_age}
        "minecraft:scheduler" = :Key {types = [#dict, #list], structure = @component.scheduler:group}
        "minecraft:shareables" = :Key {types = #dict, structure = @component.shareables}
        "minecraft:shooter" = :Key {types = #dict, structure = @component.shooter}
        "minecraft:sittable" = :Key {types = #dict, structure = @component.sittable}
        "minecraft:skin_id" = :Key {types = #dict, structure = @component.skin_id}
        "minecraft:sound_volume" = :Key {types = #dict, structure = @component.sound_volume}
        "minecraft:spawn_entity" = :Key {types = [#dict, #list], structure = @component.spawn_entity:group}
        "minecraft:spell_effects" = :Key {types = #dict, structure = @component.spell_effects}
        "minecraft:strength" = :Key {types = #dict, structure = @component.strength}
        "minecraft:suspect_tracking" = :Key {types = #dict, structure = @temp/empty, tags = [@t/not_in_documentation]}
        "minecraft:tameable" = :Key {types = #dict, structure = @component.tameable}
        "minecraft:tamemount" = :Key {types = #dict, structure = @component.tamemount}
        "minecraft:target_nearby_sensor" = :Key {types = #dict, structure = @component.target_nearby_sensor}
        "minecraft:teleport" = :Key {types = #dict, structure = @component.teleport}
        "minecraft:tick_world" = :Key {types = #dict, structure = @component.tick_world}
        "minecraft:timer" = :Key {types = #dict, structure = @component.timer}
        "minecraft:trade_resupply" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:trade_table" = :Key {types = #dict, structure = @component.trade_table}
        "minecraft:trail" = :Key {types = #dict, structure = @component.trail}
        "minecraft:transformation" = :Key {types = #dict, structure = @component.transformation}
        "minecraft:transient" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:trust" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:trusting" = :Key {types = #dict, structure = @component.trusting}
        "minecraft:turtle_command" = :Key {types = #dict, structure = @temp/empty, tags = [@t/outdated]}
        "minecraft:type_family" = :Key {types = #dict, structure = @component.type_family}
        "minecraft:underwater_movement" = :Key {types = #dict, structure = @component.underwater_movement}
        "minecraft:variant" = :Key {types = #dict, structure = @component.variant}
        "minecraft:walk_animation_speed" = :Key {types = #dict, structure = @component.walk_animation_speed}
        "minecraft:wants_jockey" = :Key {types = #dict, structure = @temp/empty}
        "minecraft:water_movement" = :Key {types = #dict, structure = @component.water_movement}
        "minecraft:wind_burst" = :Key {types = #dict, structure = @component.wind_burst, tags = [@t/not_in_documentation]}
        "minecraft:variable_max_auto_step" = :Key {types = #dict, structure = @component.variable_max_auto_step}
        "minecraft:vertical_movement_action" = :Key {types = #dict, structure = @component.vertical_movement_action}
        "minecraft:vibration_damper" = :Key {types = #dict, structure = @temp/empty, tags = [@t/not_in_documentation]}
        "minecraft:vibration_listener" = :Key {types = #dict, structure = @temp/empty, tags = [@t/not_in_documentation]}
        "minecraft:wither_target_highest_damage" = :Key {types = #dict, structure = @component.wither_target_highest_damage, tags = [@t/outdated]}
        "minecraft:zombie.spawn_reinforcements" = :Key {types = #dict, structure = @component.zombie.spawn_reinforcements, tags = [@t/outdated]}
        "minecraft:behavior.admire_item" = :Key {types = #dict, structure = @behavior.admire_item}
        "minecraft:behavior.attack_spell_goal" = :Key {types = #dict, structure = @behavior.summon_entity, tags = [@t/outdated]}
        "minecraft:behavior.avoid_block" = :Key {types = #dict, structure = @behavior.avoid_block}
        "minecraft:behavior.avoid_mob_type" = :Key {types = #dict, structure = @behavior.avoid_mob_type}
        "minecraft:behavior:avoid_mob_type" = :Key {types = #dict, structure = @behavior.avoid_mob_type, tags = [@t/outdated]}
        "minecraft:behavior.barter" = :Key {types = #dict, structure = @behavior.barter}
        "minecraft:behavior.beg" = :Key {types = #dict, structure = @behavior.beg}
        "minecraft:behavior.break_door" = :Key {types = #dict, structure = @behavior.break_door, tags = [@t/deprecated]}
        "minecraft:behavior.breathe_air" = :Key {types = #dict, structure = @behavior.breathe_air, tags = [@t/outdated]}
        "minecraft:behavior.breed" = :Key {types = #dict, structure = @behavior.breed}
        "minecraft:behavior.casting_spell_goal" = :Key {types = #dict, structure = @behavior.casting_spell_goal, tags = [@t/outdated]}
        "minecraft:behavior.celebrate" = :Key {types = #dict, structure = @behavior.celebrate}
        "minecraft:behavior.celebrate_survive" = :Key {types = #dict, structure = @behavior.celebrate_survive}
        "minecraft:behavior.charge_attack" = :Key {types = #dict, structure = @behavior.charge_attack}
        "minecraft:behavior.charge_held_item" = :Key {types = #dict, structure = @behavior.charge_held_item}
        "minecraft:behavior.circle_around_anchor" = :Key {types = #dict, structure = @behavior.circle_around_anchor}
        "minecraft:behavior.controlled_by_player" = :Key {types = #dict, structure = @behavior.controlled_by_player}
        "minecraft:behavior.croak" = :Key {types = #dict, structure = @behavior.croak}
        "minecraft:behavior.defend_trusted_target" = :Key {types = #dict, structure = @behavior.defend_trusted_target}
        "minecraft:behavior.defend_village_target" = :Key {types = #dict, structure = @behavior.defend_village_target}
        "minecraft:behavior.delayed_attack" = :Key {types = #dict, structure = @behavior.delayed_attack}
        "minecraft:behavior.dig" = :Key {types = #dict, structure = @behavior.dig}
        "minecraft:behavior.drink_milk" = :Key {types = #dict, structure = @behavior.drink_milk}
        "minecraft:behavior.door_interact" = :Key {types = #dict, structure = @behavior.door_interact}
        "minecraft:behavior.dragonchargeplayer" = :Key {types = #dict, structure = @behavior.dragonchargeplayer}
        "minecraft:behavior.dragondeath" = :Key {types = #dict, structure = @behavior.dragondeath}
        "minecraft:behavior.dragonflaming" = :Key {types = #dict, structure = @behavior.dragonflaming}
        "minecraft:behavior.dragonholdingpattern" = :Key {types = #dict, structure = @behavior.dragonholdingpattern}
        "minecraft:behavior.dragonlanding" = :Key {types = #dict, structure = @behavior.dragonlanding}
        "minecraft:behavior.dragonscanning" = :Key {types = #dict, structure = @behavior.dragonscanning}
        "minecraft:behavior.dragonstrafeplayer" = :Key {types = #dict, structure = @behavior.dragonstrafeplayer}
        "minecraft:behavior.dragontakeoff" = :Key {types = #dict, structure = @behavior.dragontakeoff}
        "minecraft:behavior.drink_potion" = :Key {types = #dict, structure = @behavior.drink_potion}
        "minecraft:behavior.drop_item_for" = :Key {types = #dict, structure = @behavior.drop_item_for}
        "minecraft:behavior.eat_block" = :Key {types = #dict, structure = @behavior.eat_block}
        "minecraft:behavior.eat_carried_item" = :Key {types = #dict, structure = @behavior.eat_carried_item}
        "minecraft:behavior.eat_mob" = :Key {types = #dict, structure = @behavior.eat_mob}
        "minecraft:behavior.emerge" = :Key {types = #dict, structure = @behavior.emerge}
        "minecraft:behavior.enderman_leave_block" = :Key {types = #dict, structure = @behavior.enderman_leave_block}
        "minecraft:behavior.enderman_take_block" = :Key {types = #dict, structure = @behavior.enderman_take_block}
        "minecraft:behavior.equip_item" = :Key {types = #dict, structure = @behavior.equip_item}
        "minecraft:behavior.execute_command" = :Key {types = #dict, structure = @behavior.execute_command, tags = [@t/outdated]}
        "minecraft:behavior.explore_outskirts" = :Key {types = #dict, structure = @behavior.explore_outskirts}
        "minecraft:behavior.feeling_happy" = :Key {types = #dict, structure = @behavior.feeling_happy, tags = [@t/outdated]}
        "minecraft:behavior.fertilize_farm_block" = :Key {types = #dict, structure = @behavior.fertilize_farm_block}
        "minecraft:behavior.find_cover" = :Key {types = #dict, structure = @behavior.find_cover}
        "minecraft:behavior.find_mount" = :Key {types = #dict, structure = @behavior.find_mount}
        "minecraft:behavior.find_underwater_treasure" = :Key {types = #dict, structure = @behavior.find_underwater_treasure}
        "minecraft:behavior.fire_at_target" = :Key {types = #dict, structure = @behavior.fire_at_target, tags = [@t/not_in_documentation]}
        "minecraft:behavior.flee_sun" = :Key {types = #dict, structure = @behavior.flee_sun}
        "minecraft:behavior.float" = :Key {types = #dict, structure = @behavior.float}
        "minecraft:behavior.float_tempt" = :Key {types = #dict, structure = @behavior.float_tempt}
        "minecraft:behavior.float_wander" = :Key {types = #dict, structure = @behavior.float_wander}
        "minecraft:behavior.follow_caravan" = :Key {types = #dict, structure = @behavior.follow_caravan}
        "minecraft:behavior.follow_flock" = :Key {types = #dict, structure = @behavior.follow_flock, tags = [@t/outdated]}
        "minecraft:behavior.follow_mob" = :Key {types = #dict, structure = @behavior.follow_mob}
        "minecraft:behavior.follow_owner" = :Key {types = #dict, structure = @behavior.follow_owner}
        "minecraft:behavior.follow_parent" = :Key {types = #dict, structure = @behavior.follow_parent}
        "minecraft:behavior.follow_target_captain" = :Key {types = #dict, structure = @behavior.follow_target_captain}
        "minecraft:behavior.go_and_give_items_to_noteblock" = :Key {types = #dict, structure = @behavior.go_and_give_item_to_noteblock}
        "minecraft:behavior.go_and_give_items_to_owner" = :Key {types = #dict, structure = @behavior.go_and_give_item_to_owner}
        "minecraft:behavior.go_home" = :Key {types = #dict, structure = @behavior.go_home}
        "minecraft:behavior.guardian_attack" = :Key {types = #dict, structure = @behavior.guardian_attack}
        "minecraft:behavior.harvest_farm_block" = :Key {types = #dict, structure = @behavior.harvest_farm_block}
        "minecraft:behavior.hide" = :Key {types = #dict, structure = @behavior.hide}
        "minecraft:behavior.hold_ground" = :Key {types = #dict, structure = @behavior.hold_ground}
        "minecraft:behavior.hurt_by_target" = :Key {types = #dict, structure = @behavior.hurt_by_target}
        "minecraft:behavior.inspect_bookshelf" = :Key {types = #dict, structure = @behavior.inspect_bookshelf}
        "minecraft:behavior.investigate_suspicious_location" = :Key {types = #dict, structure = @behavior.investigate_suspicious_location}
        "minecraft:behavior.jump_around_target" = :Key {types = #dict, structure = @behavior.jump_around_target, tags = [@t/not_in_documentation]}
        "minecraft:behavior.jump_to_block" = :Key {types = #dict, structure = @behavior.jump_to_block}
        "minecraft:behavior.knockback_roar" = :Key {types = #dict, structure = @behavior.knockback_roar}
        "minecraft:behavior.lay_down" = :Key {types = #dict, structure = @behavior.lay_down}
        "minecraft:behavior.lay_egg" = :Key {types = #dict, structure = @behavior.lay_egg}
        "minecraft:behavior.leap_at_target" = :Key {types = #dict, structure = @behavior.leap_at_target}
        "minecraft:behavior.look_at_entity" = :Key {types = #dict, structure = @behavior.look_at_entity}
        "minecraft:behavior.look_at_player" = :Key {types = #dict, structure = @behavior.look_at_player}
        "minecraft:behavior.look_at_target" = :Key {types = #dict, structure = @behavior.look_at_target}
        "minecraft:behavior.look_at_trading_player" = :Key {types = #dict, structure = @behavior.look_at_trading_player}
        "minecraft:behavior.make_love" = :Key {types = #dict, structure = @behavior.make_love}
        "minecraft:behavior.melee_attack" = :Key {types = #dict, structure = @behavior.melee_attack}
        "minecraft:behavior.melee_box_attack" = :Key {types = #dict, structure = @behavior.melee_box_attack}
        "minecraft:behavior.mingle" = :Key {types = #dict, structure = @behavior.mingle}
        "minecraft:behavior.mount_pathing" = :Key {types = #dict, structure = @behavior.mount_pathing}
        "minecraft:behavior.move_around_target" = :Key {types = #dict, structure = @behavior.move_aorund_target}
        "minecraft:behavior.move_away_from_target" = :Key {types = #dict, structure = @behavior.move_away_from_target, tags = [@t/not_in_documentation]}
        "minecraft:behavior.move_indoors" = :Key {types = #dict, structure = @behavior.move_indoors}
        "minecraft:behavior.move_outdoors" = :Key {types = #dict, structure = @behavior.move_outdoors}
        "minecraft:behavior.move_through_village" = :Key {types = #dict, structure = @behavior.move_through_village}
        "minecraft:behavior.move_to_block" = :Key {types = #dict, structure = @behavior.move_to_block}
        "minecraft:behavior.move_to_land" = :Key {types = #dict, structure = @behavior.move_to_land}
        "minecraft:behavior.move_to_lava" = :Key {types = #dict, structure = @behavior.move_to_lava}
        "minecraft:behavior.move_to_liquid" = :Key {types = #dict, structure = @behavior.move_to_liquid}
        "minecraft:behavior.move_to_random_block" = :Key {types = #dict, structure = @behavior.move_to_random_block}
        "minecraft:behavior.move_to_village" = :Key {types = #dict, structure = @behavior.move_to_village}
        "minecraft:behavior.move_to_water" = :Key {types = #dict, structure = @behavior.move_to_water}
        "minecraft:behavior.move_towards_dwelling_restriction" = :Key {types = #dict, structure = @behavior.move_towards_dwelling_restriction}
        "minecraft:behavior.move_towards_home_restriction" = :Key {types = #dict, structure = @behavior.move_towards_home_restriction}
        "minecraft:behavior.move_towards_restriction" = :Key {types = #dict, structure = @behavior.move_towards_restriction, tags = [@t/outdated]}
        "minecraft:behavior.move_towards_target" = :Key {types = #dict, structure = @behavior.move_towards_target}
        "minecraft:behavior.nap" = :Key {types = #dict, structure = @behavior.nap}
        "minecraft:behavior.nearest_attackable_target" = :Key {types = #dict, structure = @behavior.nearest_attackable_target}
        "minecraft:behavior.nearest_prioritized_attackable_target" = :Key {types = #dict, structure = @behavior.nearest_prioritized_attackable_target}
        "minecraft:behavior.ocelot_sit_on_block" = :Key {types = #dict, structure = @behavior.ocelot_sit_on_block}
        "minecraft:behavior.ocelotattack" = :Key {types = #dict, structure = @behavior.ocelotattack}
        "minecraft:behavior.offer_flower" = :Key {types = #dict, structure = @behavior.offer_flower}
        "minecraft:behavior.open_door" = :Key {types = #dict, structure = @behavior.open_door}
        "minecraft:behavior.owner_hurt_by_target" = :Key {types = #dict, structure = @behavior.owner_hurt_by_target}
        "minecraft:behavior.owner_hurt_target" = :Key {types = #dict, structure = @behavior.owner_hurt_target}
        "minecraft:behavior.panic" = :Key {types = #dict, structure = @behavior.panic}
        "minecraft:behavior:panic" = :Key {types = #dict, structure = @behavior.panic, tags = [@t/outdated]}
        "minecraft:behavior.peek" = :Key {types = #dict, structure = @behavior.peek}
        "minecraft:behavior.pet_sleep_with_owner" = :Key {types = #dict, structure = @behavior.pet_sleep_with_owner}
        "minecraft:behavior.pickup_items" = :Key {types = #dict, structure = @behavior.pickup_items}
        "minecraft:behavior.pig_zombie_anger_target" = :Key {types = #dict, structure = @behavior.pig_zombie_anger_target, tags = [@t/outdated]}
        "minecraft:behavior.pig_zombie_hurt_by_other" = :Key {types = #dict, structure = @behavior.pig_zombie_hurt_by_other, tags = [@t/outdated]}
        "minecraft:behavior.place_block" = :Key {types = #dict, structure = @behavior.place_block}
        "minecraft:behavior.play" = :Key {types = #dict, structure = @behavior.play}
        "minecraft:behavior.play_dead" = :Key {types = #dict, structure = @behavior.play_dead}
        "minecraft:behavior.player_ride_tamed" = :Key {types = #dict, structure = @behavior.player_ride_tamed}
        "minecraft:behavior.rabbit_panic" = :Key {types = #dict, structure = @behavior.rabbit_panic, tags = [@t/outdated]}
        "minecraft:behavior.raid_garden" = :Key {types = #dict, structure = @behavior.raid_garden}
        "minecraft:behavior.ram_attack" = :Key {types = #dict, structure = @behavior.ram_attack}
        "minecraft:behavior.random_breach" = :Key {types = #dict, structure = @behavior.random_breach}
        "minecraft:behavior.random_fly" = :Key {types = #dict, structure = @behavior.random_fly}
        "minecraft:behavior.random_hover" = :Key {types = #dict, structure = @behavior.random_hover}
        "minecraft:behavior.random_look_around_and_sit" = :Key {types = #dict, structure = @behavior.random_look_around_and_sit}
        "minecraft:behavior.random_look_around" = :Key {types = #dict, structure = @behavior.random_look_around}
        "minecraft:behavior.random_search_and_dig" = :Key {types = #dict, structure = @behavior.random_search_and_dig}
        "minecraft:behavior.random_sitting" = :Key {types = #dict, structure = @behavior.random_sitting}
        "minecraft:behavior.random_stroll" = :Key {types = #dict, structure = @behavior.random_stroll}
        "minecraft:behavior.random_swim" = :Key {types = #dict, structure = @behavior.random_swim}
        "minecraft:behavior.ranged_attack" = :Key {types = #dict, structure = @behavior.ranged_attack}
        "minecraft:behavior.receive_love" = :Key {types = #dict, structure = @behavior.receive_love, tags = [@t/not_in_documentation]}
        "minecraft:behavior.restrict_open_door" = :Key {types = #dict, structure = @behavior.restrict_open_door, tags = [@t/not_in_documentation]}
        "minecraft:behavior.restrict_sun" = :Key {types = #dict, structure = @behavior.restrict_sun}
        "minecraft:behavior.rise_to_liquid_level" = :Key {types = #dict, structure = @behavior.rise_to_liquid_level}
        "minecraft:behavior.rising" = :Key {types = #dict, structure = @behavior.rising, tags = [@t/outdated]}
        "minecraft:behavior.river_follow" = :Key {types = #dict, structure = @behavior.river_follow, tags = [@t/outdated]}
        "minecraft:behavior.roar" = :Key {types = #dict, structure = @behavior.roar}
        "minecraft:behavior.roll" = :Key {types = #dict, structure = @behavior.roll}
        "minecraft:behavior.run_around_like_crazy" = :Key {types = #dict, structure = @behavior.run_around_like_crazy}
        "minecraft:behavior.scared" = :Key {types = #dict, structure = @behavior.scared}
        "minecraft:behavior.scenting" = :Key {types = #dict, structure = @behavior.scenting, tags = [@t/outdated]}
        "minecraft:behavior.send_event" = :Key {types = #dict, structure = @behavior.send_event}
        "minecraft:behavior.share_items" = :Key {types = #dict, structure = @behavior.share_items}
        "minecraft:behavior.silverfish_merge_with_stone" = :Key {types = #dict, structure = @behavior.silverfish_merge_with_stone}
        "minecraft:behavior.silverfish_wake_up_friends" = :Key {types = #dict, structure = @behavior.silverfish_wake_up_friends}
        "minecraft:behavior.skeleton_horse_trap" = :Key {types = #dict, structure = @behavior.skeleton_horse_trap}
        "minecraft:behavior.sleep" = :Key {types = #dict, structure = @behavior.sleep}
        "minecraft:behavior.slime_attack" = :Key {types = #dict, structure = @behavior.slime_attack}
        "minecraft:behavior.slime_float" = :Key {types = #dict, structure = @behavior.slime_float}
        "minecraft:behavior.slime_keep_on_jumping" = :Key {types = #dict, structure = @behavior.slime_keep_on_jumping}
        "minecraft:behavior.slime_random_direction" = :Key {types = #dict, structure = @behavior.slime_random_direction}
        "minecraft:behavior.snacking" = :Key {types = #dict, structure = @behavior.snacking}
        "minecraft:behavior.sneeze" = :Key {types = #dict, structure = @behavior.sneeze}
        "minecraft:behavior.sniff" = :Key {types = #dict, structure = @behavior.sniff}
        "minecraft:behavior.sonic_boom" = :Key {types = #dict, structure = @behavior.sonic_boom}
        "minecraft:behavior.squid_dive" = :Key {types = #dict, structure = @behavior.squid_dive}
        "minecraft:behavior.squid_flee" = :Key {types = #dict, structure = @behavior.squid_flee}
        "minecraft:behavior.squid_idle" = :Key {types = #dict, structure = @behavior.squid_idle}
        "minecraft:behavior.squid_move_away_from_ground" = :Key {types = #dict, structure = @behavior.squid_move_away_from_ground}
        "minecraft:behavior.squid_out_of_water" = :Key {types = #dict, structure = @behavior.squid_out_of_water}
        "minecraft:behavior.stalk_and_pounce_on_target" = :Key {types = #dict, structure = @behavior.stalk_and_pounce_on_target}
        "minecraft:behavior.stay_near_noteblock" = :Key {types = #dict, structure = @behavior.stay_near_note_block}
        "minecraft:behavior.stay_while_sitting" = :Key {types = #dict, structure = @behavior.stay_while_sitting}
        "minecraft:behavior.stomp_attack" = :Key {types = #dict, structure = @behavior.stomp_attack}
        "minecraft:behavior.stomp_turtle_egg" = :Key {types = #dict, structure = @behavior.stomp_turtle_egg}
        "minecraft:behavior.stroll_towards_village" = :Key {types = #dict, structure = @behavior.stroll_towards_village}
        "minecraft:behavior.summon_entity" = :Key {types = #dict, structure = @behavior.summon_entity}
        "minecraft:behavior.summon_spell_goal" = :Key {types = #dict, structure = @behavior.summon_spell_goal, tags = [@t/outdated]}
        "minecraft:behavior.swell" = :Key {types = #dict, structure = @behavior.swell}
        "minecraft:behavior.swim_idle" = :Key {types = #dict, structure = @behavior.swim_idle}
        "minecraft:behavior.swim_up_for_breath" = :Key {types = #dict, structure = @behavior.swim_up_for_breath}
        "minecraft:behavior.swim_wander" = :Key {types = #dict, structure = @behavior.swim_wander}
        "minecraft:behavior.swim_with_mob" = :Key {types = #dict, structure = @behavior.swim_with_entity, tags = [@t/outdated]}
        "minecraft:behavior.swim_with_entity" = :Key {types = #dict, structure = @behavior.swim_with_entity}
        "minecraft:behavior.swoop_attack" = :Key {types = #dict, structure = @behavior.swoop_attack}
        "minecraft:behavior.take_block" = :Key {types = #dict, structure = @behavior.take_block}
        "minecraft:behavior.take_flower" = :Key {types = #dict, structure = @behavior.take_flower}
        "minecraft:behavior.target_when_pushed" = :Key {types = #dict, structure = @behavior.target_when_pushed}
        "minecraft:behavior.teleport_to_owner" = :Key {types = #dict, structure = @behavior.teleport_to_owner}
        "minecraft:behavior.tempt" = :Key {types = #dict, structure = @behavior.tempt}
        "minecraft:behavior.timer_flag_1" = :Key {types = #dict, structure = @behavior.timer_flag}
        "minecraft:behavior.timer_flag_2" = :Key {types = #dict, structure = @behavior.timer_flag}
        "minecraft:behavior.timer_flag_3" = :Key {types = #dict, structure = @behavior.timer_flag}
        "minecraft:behavior.trade_interest" = :Key {types = #dict, structure = @behavior.trade_intereset}
        "minecraft:behavior.trade_with_player" = :Key {types = #dict, structure = @behavior.trade_with_player}
        "minecraft:behavior.transport_items" = :Key {types = #dict, structure = @behavior.transport_items}
        "minecraft:behavior.vex_copy_owner_target" = :Key {types = #dict, structure = @behavior.vex_copy_owner_target}
        "minecraft:behavior.vex_random_move" = :Key {types = #dict, structure = @behavior.vex_random_move}
        "minecraft:behavior.wither_random_attack_pos_goal" = :Key {types = #dict, structure = @behavior.wither_random_attack_pos_goal}
        "minecraft:behavior.wither_target_highest_damage" = :Key {types = #dict, structure = @behavior.wither_target_highest_damage}
        "minecraft:behavior.wololo_spell_goal" = :Key {types = #dict, structure = @behavior.wololo_spell_goal, tags = [@t/outdated]}
        "minecraft:behavior.work" = :Key {types = #dict, structure = @behavior.work}
        "minecraft:behavior.work_composter" = :Key {types = #dict, structure = @behavior.work_composter}
    }
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "component", "sort" = %sort_by_component_order, "measure_length" = true}
    }
}
armor_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = @temp/string
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "armor", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
block_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = @temp/string_remove_minecraft_prefix
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "block", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
block_list_or_block :Union {
    substructures = [
        :Key {types = #list, structure = @block_list},
        :Key {types = #str},
    ]
}
block_states inherit temp/Dict {
    value_types = [#bool, #int, #str]
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"sort" = %sort_by_key, "field" = "state"}
    }
}
damage_source_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = @temp/string
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "damage source", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
entity_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = @temp/string_remove_minecraft_prefix
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "entity", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
entity_list_or_entity :Union {
    substructures = [
        :Key {types = #list, structure = @entity_list},
        :Key {types = #str},
    ]
}
entity_types :Union {
    substructures = [
        :Key {types = #dict, structure = @entity_types.item},
        :Key {types = #list, structure = @entity_types.list},
    ]
}
entity_types.list inherit temp/Dict {
    key_weight = 0
    allow_same_key_optimization = true
    key_types = #int
    this_types = #list
    value_types = #dict
    min_value_similarity_threshold = 0.3
    value_structure = @entity_types.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "entity type", "show_item_key" = false, "measure_length" = true}
    }
}
entity_types.item inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "attack_interval" = :Key {types = #int, tags = [@t/outdated]}
        "check_if_outnumbered" = :Key {types = #bool}
        "cooldown" = :Key {types = #int, tags = [@t/not_in_documentation]}
        "entity_filter" = :Key {types = [#list, #str], structure = @entity_list_or_entity, tags = [@t/outdated], similarity_weight = 7}
        "filters" = :Key {types = #dict, structure = @filter, similarity_weight = 7}
        "max_dist" = :Key {types = @temp/decimal}
        "max_distance" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "max_flee" = :Key {types = #int, tags = [@t/not_in_documentation]}
        "must_reach" = :Key {types = #bool, tags = [@t/outdated]}
        "must_see" = :Key {types = #bool}
        "must_see_forget_duration" = :Key {types = @temp/decimal}
        "num_to_spawn" = :Key {types = #int}
        "priority" = :Key {types = #int, tags = [@t/not_in_documentation]}
        "reevaluate_description" = :Key {types = #bool, tags = [@t/not_in_documentation]}
        "sprint_speed_modifier" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "sprint_speed_multiplier" = :Key {types = @temp/decimal}
        "walk_speed_modifier" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "walk_speed_multiplier" = :Key {types = @temp/decimal}
        "within_default" = :Key {types = #int, tags = [@t/not_in_documentation]}
    } + @component.spawn_entity:entities.item:keys
}
environment_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "environment", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
environment_list_or_environment :Union {
    substructures = [
        :Key {types = #list, structure = @environment_list},
        :Key {types = #str},
    ]
}
event inherit temp/SortedKeymap {
    keys = {
        "event" = :Key {types = #str}
    }
}
event_target inherit temp/SortedKeymap {
    keys = {
        "event" = :Key {types = #str}
        "target" = :Key {types = #str}
    }
}
event_target_filters inherit temp/SortedKeymap {
    keys = {
        "event" = :Key {types = #str}
        "filter" = :Key {types = #str}
        "filters" = :Key {types = #dict, structure = @filter}
        "target" = :Key {types = #str}
    }
}
event_target_filters_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @event_target_filters
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "event", "show_item_key" = false, "measure_length" = true}
    }
}
event_target_filters_or_filter_list inherit temp/SortedKeymap {
    keys = {
        "event" = :Key {types = #str}
        "filters" = :Key {types = [#dict, #list], structure = @filter_or_filter_list}
        "target" = :Key {types = #str}
    }
}
event_target_or_str :Union {
    substructures = [
        :Key {types = #dict, structure = @event_target},
        :Key {types = #str},
    ]
}
family_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_structure = null
    allow_same_key_optimization = false
    value_types = #str
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"measure_length" = true, "field" = "family", "show_item_key" = false, "sort" = %sort_by_value}
    }
}
family_or_family_list :Union {
    substructures = [
        :Key {types = #list, structure = @family_list},
        :Key {types = #str},
    ]
}
filter inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    min_value_similarity_threshold = 0.9
    keys = {
        "all_of" = :Key {types = #list, structure = @filter_list}
        "any_of" = :Key {types = #list, structure = @filter_list}
        "domain" = :Key {types = #str}
        "none_of" = :Key {types = [#dict, #list], structure = @filter_or_filter_list}
        "operator" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "subject" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "test" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "value" = :Key {types = [#bool, @temp/decimal, #str], delegate_arguments = {"always_print" = true}}
    } + @filter_old
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "filter property"}
    }
}
filter_old {
    "is_game_rule_false" = :Key {types = #str, tags = [@t/outdated]}
    "is_not_in_caravan" = :Key {types = #str, tags = [@t/outdated]}
    "is_world_difficulty" = :Key {types = #str, tags = [@t/outdated]}
    "other_is_owner" = :Key {types = #bool, tags = [@t/outdated]}
    "other_with_color" = :Key {types = #int, tags = [@t/outdated]}
    "other_with_components" = :Key {types = #str, tags = [@t/outdated]}
    "other_with_families" = :Key {types = [#list, #str], structure = @family_or_family_list}
    "other_with_item" = :Key {types = [#list, #str], structure = @item_list_or_item, tags = [@t/outdated]}
    "other_without_armor" = :Key {types = #list, structure = @armor_list, tags = [@t/outdated]}
    "other_without_components" = :Key {types = [#list, #str], structure = @component_list_or_component, tags = [@t/outdated]}
    "other_without_families" = :Key {types = [#list, #str], structure = @family_or_family_list, tags = [@t/outdated]}
    "player_with_instabuild" = :Key {types = #bool, tags = [@t/outdated]}
    "self_without_components" = :Key {types = #str, tags = [@t/outdated]}
    "sender_with_components" = :Key {types = #str, tags = [@t/outdated]}
    "sender_with_families" = :Key {types = #str, tags = [@t/outdated]}
    "sender_with_item" = :Key {types = #str, tags = [@t/outdated]}
    "sender_without_components" = :Key {types = #str, tags = [@t/outdated]}
    "sender_without_families" = :Key {types = #str, tags = [@t/outdated]}
    "target_with_families" = :Key {types = #list, structure = @family_list, tags = [@t/outdated]}
    "target_without_components" = :Key {types = #list, structure = @component_list, tags = [@t/outdated]}
    "with_components" = :Key {types = [#list, #str], structure = @component_list_or_component, tags = [@t/outdated]}
    "with_damage_fatal" = :Key {types = #bool, tags = [@t/outdated]}
    "with_environment_any" = :Key {types = [#list, #str], structure = @environment_list_or_environment, tags = [@t/outdated]}
    "with_environment_every" = :Key {types = #list, structure = @environment_list, tags = [@t/outdated]}
    "without_components" = :Key {types = [#list, #str], structure = @component_list_or_component, tags = [@t/outdated]}
    "without_environment_every" = :Key {types = #list, structure = @environment_list, tags = [@t/outdated]}
}
filter_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @filter
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "filter", "show_item_key" = false, "measure_length" = true}
    }
}
filter_or_filter_list :Union {
    substructures = [
        :Key {types = #dict, structure = @filter},
        :Key {types = #list, structure = @filter_list},
    ]
}
item_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = @temp/string
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "item", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
item_list_or_item :Union {
    substructures = [
        :Key {types = #list, structure = @item_list},
        :Key {types = #str},
    ]
}
projectile_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "projectile", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
range_decimal_or_decimal :Union {
    substructures = [
        :Key {types = @temp/decimal},
        :Key {types = #dict, structure = @range_dict_decimal},
        :Key {types = #list, structure = @range_list_decimal},
    ]
}
range_dict_decimal inherit temp/SortedKeymap {
    keys = {
        "range_max" = :Key {types = @temp/decimal}
        "range_min" = :Key {types = @temp/decimal}
    }
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"sort" = %sort_by_component_order, "print_all" = true}
    }
}
range_dict_int inherit temp/SortedKeymap {
    keys = {
        "range_max" = :Key {types = #int}
        "range_min" = :Key {types = #int}
    }
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"sort" = %sort_by_component_order, "print_all" = true}
    }
}
range_group_decimal :Union {
    substructures = [
        :Key {types = #dict, structure = @range_dict_decimal},
        :Key {types = #list, structure = @range_list_decimal},
    ]
}
range_group_int :Union {
    substructures = [
        :Key {types = #dict, structure = @range_dict_int},
        :Key {types = #list, structure = @range_list_int},
    ]
}
range_int_or_int :Union {
    substructures = [
        :Key {types = #dict, structure = @range_dict_int},
        :Key {types = #int},
        :Key {types = #list, structure = @range_list_int},
    ]
}
range_list_decimal inherit temp/Dict {
    allow_key_moves = false
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = @temp/decimal
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "range item", "print_all" = true, "print_flat" = true}
    }
}
range_list_int inherit temp/Dict {
    allow_key_moves = false
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #int
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "range item", "print_all" = true, "print_flat" = true}
    }
}
trigger :Union {
    substructures = [
        :Key {types = #dict, structure = @event_target_filters},
        :Key {types = #list, structure = @event_target_filters_list},
    ]
}
vector_decimal inherit temp/Dict {
    allow_key_moves = false
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = @temp/decimal
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "vector item", "print_all" = true, "print_flat" = true}
    }
}
vector_int inherit temp/Dict {
    allow_key_moves = false
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #int
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "vector item", "print_all" = true, "print_flat" = true}
    }
}
component.absorption inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = #int}
    }
}
component.addrider inherit temp/SortedKeymap {
    keys = {
        "entity_type" = :Key {types = #str}
        "spawn_event" = :Key {types = #str}
    }
}
component.admire_item inherit temp/SortedKeymap {
    keys = {
        "cooldown_after_being_attacked" = :Key {types = #int}
        "duration" = :Key {types = #int}
    }
}
component.ageable inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "drop_items" = :Key {types = #list, structure = @item_list}
        "duration" = :Key {types = #int}
        "event" = :Key {types = #dict, structure = @component.ageable:event, tags = [@t/outdated]}
        "feed_items" = :Key {types = [#list, #str], structure = @component.ageable:feed_items_group}
        "feedItems" = :Key {types = [#list, #str], structure = @component.ageable:feed_items_group, tags = [@t/outdated]}
        "grow_up" = :Key {types = #dict, structure = @event_target}
        "interact_filters" = :Key {types = #dict, structure = @filter}
        "on_grow" = :Key {types = #dict, structure = @event_target, tags = [@t/outdated]}
        "threshold" = :Key {types = #int, tags = [@t/outdated]}
        "transform_to_item" = :Key {types = #str, tags = [@t/not_in_documentation]}
    }
}
component.ageable:event inherit temp/SortedKeymap {
    keys = {
        "target" = :Key {types = #str}
        "type" = :Key {types = #str}
    }
}
component.ageable:feed_items_group :Union {
    substructures = [
        :Key {types = #list, structure = @component.ageable:feed_items},
        :Key {types = #str},
    ]
}
component.ageable:feed_items inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = [#dict, #str]
    value_structure = @component.ageable:feed_items.item_group
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "item", "show_item_key" = false, "measure_length" = true}
    }
}
component.ageable:feed_items.item_group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.ageable:feed_items.dict_item},
        :Key {types = #str},
    ]
}
component.ageable:feed_items.dict_item inherit temp/SortedKeymap {
    keys = {
        "item" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "growth" = :Key {types = @temp/decimal}
    }
}
component.ambient_sound_interval inherit temp/SortedKeymap {
    keys = {
        "event_name" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "event_names" = :Key {types = #list, structure = @component.ambient_sound_interval:event_names, delegate_arguments = {"always_print" = true}}
        "range" = :Key {types = @temp/decimal}
        "value" = :Key {types = @temp/decimal}
    }
}
component.ambient_sound_interval:event_names inherit temp/Dict {
    allow_key_moves = false
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.ambient_sound_interval:event_names.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "event", "measure_length" = true}
    }
}
component.ambient_sound_interval:event_names.item inherit temp/SortedKeymap {
    keys = {
        "condition" = :Key {types = #str}
        "event_name" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.anger_level inherit temp/SortedKeymap {
    keys = {
        "anger_decrement_interval" = :Key {types = @temp/decimal}
        "angry_boost" = :Key {types = #int}
        "angry_threshold" = :Key {types = #int}
        "default_annoyingness" = :Key {types = #int}
        "default_projectile_annoyingness" = :Key {types = #int}
        "max_anger" = :Key {types = #int}
        "nuisance_filter" = :Key {types = #dict, structure = @filter}
        "on_increase_sounds" = :Key {types = #list, structure = @component.anger_level:on_increase_sounds}
        "remove_targets_below_angry_threshold" = :Key {types = #bool}
    }
}
component.anger_level:on_increase_sounds inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.anger_level:on_increase_sounds.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "sound", "show_item_key" = false, "measure_length" = true}
    }
}
component.anger_level:on_increase_sounds.item inherit temp/SortedKeymap {
    keys = {
        "condition" = :Key {types = #str}
        "sound" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.angry inherit temp/SortedKeymap {
    keys = {
        "angry_sound" = :Key {types = #str}
        "broadcast_anger" = :Key {types = #bool}
        "broadcast_anger_on_attack" = :Key {types = #bool}
        "broadcast_anger_on_being_attacked" = :Key {types = #bool}
        "broadcast_anger_when_dying" = :Key {types = #bool}
        "broadcast_filters" = :Key {types = #dict, structure = @filter}
        "broadcast_range" = :Key {types = #int}
        "broadcast_targets" = :Key {types = #list, structure = @entity_list}
        "broadcastAnger" = :Key {types = #bool, tags = [@t/deprecated]}
        "broadcastRange" = :Key {types = #int, tags = [@t/deprecated]}
        "calm_event" = :Key {types = #dict, structure = @event_target}
        "duration" = :Key {types = #int}
        "duration_delta" = :Key {types = #int}
        "filters" = :Key {types = #dict, structure = @filter}
        "sound_interval" = :Key {types = @range, structure = @range_group_decimal}
    }
}
component.annotation.break_door inherit temp/SortedKeymap {
    keys = {
        "break_time" = :Key {types = #int}
        "min_difficulty" = :Key {types = #str}
    }
}
component.area_attack inherit temp/SortedKeymap {
    keys = {
        "cause" = :Key {types = #str}
        "entity_filter" = :Key {types = #dict, structure = @filter}
        "damage_cooldown" = :Key {types = @temp/decimal}
        "damage_per_tick" = :Key {types = #int}
        "damage_range" = :Key {types = @temp/decimal}
    }
}
component.attack inherit temp/SortedKeymap {
    keys = {
        "damage" = :Key {types = [@temp/decimal, #dict, #list], structure = @component.attack:damage, delegate_arguments = {"always_print" = true}}
        "effect_duration" = :Key {types = #int}
        "effect_name" = :Key {types = #str}
    }
}
component.attack:damage :Union {
    substructures = [
        :Key {types = @temp/decimal},
        :Key {types = #dict, structure = @range_dict_decimal},
        :Key {types = #list, structure = @range_list_decimal},
    ]
}
component.attack_cooldown inherit temp/SortedKeymap {
    keys = {
        "attack_cooldown_complete_event" = :Key {types = #dict, structure = @event_target}
        "attack_cooldown_time" = :Key {types = [@temp/decimal, @range], structure = @range_decimal_or_decimal}
    }
}
component.attack_damage inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = #int}
    }
}
component.balloon inherit temp/SortedKeymap {
    keys = {
        "lift_force" = :Key {types = #list, structure = @vector_decimal}
    }
}
component.balloonable inherit temp/SortedKeymap {
    keys = {
        "mass" = :Key {types = @temp/decimal}
        "max_distance" = :Key {types = @temp/decimal}
        "on_balloon" = :Key {types = #str}
        "on_unballoon" = :Key {types = #str}
        "soft_distance" = :Key {types = @temp/decimal}
    }
}
component.barter inherit temp/SortedKeymap {
    keys = {
        "barter_table" = :Key {types = #str}
        "cooldown_after_being_attacked" = :Key {types = #int}
    }
}
component.block_sensor inherit temp/SortedKeymap {
    keys = {
        "on_break" = :Key {types = #list, structure = @component.block_sensor:on_break}
        "sensor_radius" = :Key {types = @temp/decimal}
        "sources" = :Key {types = #list, structure = @filter_list}
    }
}
component.block_sensor:on_break inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.block_sensor:on_break.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "event", "show_item_key" = false, "measure_length" = true}
    }
}
component.block_sensor:on_break.item inherit temp/SortedKeymap {
    keys = {
        "block_list" = :Key {types = #list, structure = @block_list}
        "on_block_broken" = :Key {types = #str}
    }
}
component.boostable inherit temp/SortedKeymap {
    keys = {
        "boost_items" = :Key {types = #list, structure = @component.boostable:boost_items}
        "duration" = :Key {types = @temp/decimal}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
component.boostable:boost_items inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.boostable:boost_items.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "item", "show_item_key" = false, "measure_length" = true}
    }
}
component.boostable:boost_items.item inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "damage" = :Key {types = #int}
        "item" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "item_damage" = :Key {types = #int, tags = [@t/outdated], delegate_arguments = {"always_print" = true}}
        "replace_item" = :Key {types = #str}
        "replaceItem" = :Key {types = #str, tags = [@t/outdated]}
    }
}
component.boss inherit temp/SortedKeymap {
    keys = {
        "hud_range" = :Key {types = #int}
        "name" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "should_darken_sky" = :Key {types = #bool}
    }
}
component.break_blocks inherit temp/SortedKeymap {
    keys = {
        "breakable_blocks" = :Key {types = #list, structure = @block_list}
    }
}
component.breathable inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "breathe_blocks" = :Key {types = #list, structure = @block_list}
        "breathes_air" = :Key {types = #bool}
        "breathes_lava" = :Key {types = #bool}
        "breathes_solids" = :Key {types = #bool}
        "breathes_water" = :Key {types = #bool}
        "breathesAir" = :Key {types = #bool, tags = [@t/outdated]}
        "breathesLava" = :Key {types = #bool, tags = [@t/outdated]}
        "breathesWater" = :Key {types = #bool, tags = [@t/outdated]}
        "generates_bubbles" = :Key {types = #bool}
        "generatesBubbles" = :Key {types = #bool, tags = [@t/outdated]}
        "inhale_time" = :Key {types = @temp/decimal}
        "inhaleTime" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "non_breathe_blocks" = :Key {types = #list, structure = @block_list}
        "suffocate_time" = :Key {types = #int}
        "suffocateTime" = :Key {types = #int}
        "total_supply" = :Key {types = #int}
        "totalSupply" = :Key {types = #int}
    }
}
component.breedable inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "allow_sitting" = :Key {types = #bool}
        "allowSitting" = :Key {types = #bool, tags = [@t/outdated]}
        "blend_attributes" = :Key {types = #bool}
        "breed_cooldown" = :Key {types = @temp/decimal}
        "breed_items" = :Key {types = [#list, #str], structure = @item_list_or_item}
        "breedItems" = :Key {types = [#list, #str], structure = @item_list_or_item, tags = [@t/outdated]}
        "breeds_with" = :Key {types = [#dict, #list], structure = @component.breedable:breeds_with_group}
        "breedsWith" = :Key {types = [#dict, #list], structure = @component.breedable:breeds_with_group, tags = [@t/outdated]}
        "causes_pregnancy" = :Key {types = #bool}
        "combine_parent_colors" = :Key {types = #bool}
        "deny_parents_variant" = :Key {types = #dict, structure = @component.breedable:deny_parents_variant}
        "environment_requirements" = :Key {types = #dict, structure = @component.breedable:environment_requirements}
        "extra_baby_chance" = :Key {types = @temp/decimal}
        "inherit_tamed" = :Key {types = #bool}
        "inheritTamed" = :Key {types = #bool, tags = [@t/outdated]}
        "love_filters" = :Key {types = #dict, structure = @filter}
        "max_number_of_children" = :Key {types = #int, tags = [@t/outdated]}
        "min_number_of_children" = :Key {types = #int, tags = [@t/outdated]}
        "mutation_factor" = :Key {types = #dict, structure = @component.breedable:mutation_factor}
        "mutation_strategy" = :Key {types = #str}
        "parent_centric_attribute_blending" = :Key {types = #list, structure = @component.breedable:parent_centric_attribute_blending}
        "property_inheritance" = :Key {types = #dict, structure = @component.breedable:property_inheritance}
        "random_extra_variant_mutation_interval" = :Key {types = @range, structure = @range_group_int}
        "random_variant_mutation_interval" = :Key {types = @range, structure = @range_group_int}
        "require_full_health" = :Key {types = #bool}
        "require_tame" = :Key {types = #bool}
        "requireTame" = :Key {types = #bool, tags = [@t/outdated]}
        "transform_to_item" = :Key {types = #str, tags = [@t/not_in_documentation]}
    }
}
component.breedable:breeds_with_group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.breedable:breeds_with.item},
        :Key {types = #list, structure = @component.breedable:breeds_with},
    ]
}
component.breedable:breeds_with inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.breedable:breeds_with.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "entity", "show_item_key" = false, "measure_length" = true}
    }
}
component.breedable:breeds_with.item inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "baby_type" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "babyType" = :Key {types = #str, tags = [@t/outdated], delegate_arguments = {"always_print" = true}}
        "breed_event" = :Key {types = [#dict, #str], structure = @event_target_or_str}
        "mateType" = :Key {types = #str, tags = [@t/outdated], delegate_arguments = {"always_print" = true}}
        "mate_type" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.breedable:deny_parents_variant inherit temp/SortedKeymap {
    keys = {
        "chance" = :Key {types = @temp/decimal}
        "max_variant" = :Key {types = #int}
        "min_variant" = :Key {types = #int}
    }
}
component.breedable:environment_requirements inherit temp/SortedKeymap {
    keys = {
        "blocks" = :Key {types = [#list, #str], structure = @block_list_or_block}
        "count" = :Key {types = #int}
        "radius" = :Key {types = @temp/decimal}
    }
}
component.breedable:mutation_factor inherit temp/SortedKeymap {
    keys = {
        "color" = :Key {types = @temp/decimal}
        "extra_baby_chance" = :Key {types = @temp/decimal}
        "extra_variant" = :Key {types = @temp/decimal}
        "inherit_tamed" = :Key {types = #bool}
        "variant" = :Key {types = @temp/decimal}
    }
}
component.breedable:parent_centric_attribute_blending inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "attribute", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
component.breedable:property_inheritance inherit temp/Dict {
    value_types = #dict
    value_structure = @temp/empty
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "property", "measure_length" = true}
    }
}
component.bribeable inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "bribe_cooldown" = :Key {types = @temp/decimal}
        "bribe_items" = :Key {types = [#list, #str], structure = @item_list_or_item}
        "bribeItems" = :Key {types = [#list, #str], structure = @item_list_or_item, tags = [@t/outdated]}
    }
}
component.buoyant inherit temp/SortedKeymap {
    keys = {
        "apply_gravity" = :Key {types = #bool}
        "base_buoyancy" = :Key {types = @temp/decimal}
        "big_wave_probability" = :Key {types = @temp/decimal}
        "big_wave_speed" = :Key {types = @temp/decimal}
        "drag_down_on_buoyancy_removed" = :Key {types = @temp/decimal}
        "liquid_blocks" = :Key {types = #list, structure = @block_list}
        "simulate_waves" = :Key {types = #bool}
    }
}
component.burns_in_daylight :Union {
    substructures = [
        :Key {types = #bool},
        :Key {types = #dict, structure = @temp/empty},
    ]
}
component.can_fly inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = #bool, tags = [@t/outdated]}
    }
}
component.celebrate_hunt inherit temp/SortedKeymap {
    keys = {
        "broadcast" = :Key {types = #bool}
        "celebration_targets" = :Key {types = #dict, structure = @filter}
        "celebrate_sound" = :Key {types = #str}
        "duration" = :Key {types = #int}
        "radius" = :Key {types = @temp/decimal}
        "sound_interval" = :Key {types = @range, structure = @range_group_decimal}
    }
}
component.collision_box inherit temp/SortedKeymap {
    keys = {
        "height" = :Key {types = @temp/decimal}
        "width" = :Key {types = @temp/decimal}
    }
}
component.color inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = #int}
    }
}
component.color2 inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = #int}
    }
}
component.combat_regeneration inherit temp/SortedKeymap {
    keys = {
        "apply_to_family" = :Key {types = #bool}
        "apply_to_self" = :Key {types = #bool}
        "regeneration_duration" = :Key {types = #int}
    }
}
component.conditional_bandwidth_optimization inherit temp/SortedKeymap {
    keys = {
        "conditional_values" = :Key {types = #list, structure = @component.conditional_bandwidth_optimization:conditional_values}
        "default_values" = :Key {types = #dict, structure = @component.conditional_bandwidth_optimization:default_values}
    }
}
component.conditional_bandwidth_optimization:conditional_values inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.conditional_bandwidth_optimization:conditional_values.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "condition", "show_item_key" = false, "measure_length" = true}
    }
}
component.conditional_bandwidth_optimization:conditional_values.item inherit temp/SortedKeymap {
    keys = {
        "conditional_values" = :Key {types = #list, structure = @filter_list}
        "max_dropped_ticks" = :Key {types = #int}
        "max_optimized_distance" = :Key {types = @temp/decimal}
        "use_motion_prediction_hints" = :Key {types = #bool}
    }
}
component.conditional_bandwidth_optimization:default_values inherit temp/SortedKeymap {
    keys = {
        "max_dropped_ticks" = :Key {types = #int}
        "max_optimized_distance" = :Key {types = @temp/decimal}
        "use_motion_prediction_hints" = :Key {types = #bool}
    }
}
component.custom_hit_test inherit temp/SortedKeymap {
    keys = {
        "hitboxes" = :Key {types = #list, structure = @component.custom_hit_test:hitboxes}
    }
}
component.custom_hit_test:hitboxes inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.custom_hit_test:hitboxes.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "hitbox", "show_item_key" = false, "measure_length" = true}
    }
}
component.custom_hit_test:hitboxes.item inherit temp/SortedKeymap {
    keys = {
        "height" = :Key {types = @temp/decimal}
        "width" = :Key {types = @temp/decimal}
        "pivot" = :Key {types = #list, structure = @vector_decimal}
    }
}
component.damage_over_time inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "damage_per_hurt" = :Key {types = #int}
        "damagePerHurt" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "time_between_hurt" = :Key {types = @temp/decimal}
        "timeBetweenHurt" = :Key {types = @temp/decimal, tags = [@t/outdated]}
    }
}
component.damage_sensor:group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.damage_sensor},
        :Key {types = #list, structure = @component.damage_sensor:trigger_list},
    ]
}
component.damage_sensor inherit temp/SortedKeymap {
    keys = {
        "triggers" = :Key {types = [#dict, #list], structure = @component.damage_sensor:triggers_group}
    } + @component.damage_sensor:trigger:keys
}
component.damage_sensor:triggers_group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.damage_sensor:trigger},
        :Key {types = #list, structure = @component.damage_sensor:trigger_list},
    ]
}
component.damage_sensor:trigger_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.damage_sensor:trigger
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "trigger", "show_item_key" = false, "measure_length" = true}
    }
}
component.damage_sensor:trigger:keys {
    "cause" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    "damage_modifier" = :Key {types = @temp/decimal}
    "damage_multiplier" = :Key {types = @temp/decimal}
    "deals_damage" = :Key {types = [#bool, #str]}
    "on_damage" = :Key {types = #dict, structure = @event_target_filters_or_filter_list}
    "on_damage_sound_event" = :Key {types = #str}
}
component.damage_sensor:trigger inherit temp/SortedKeymap {
    keys = @component.damage_sensor:trigger:keys
}
component.dash inherit temp/SortedKeymap {
    keys = {
        "cooldown_time" = :Key {types = @temp/decimal}
        "horizontal_momentum" = :Key {types = @temp/decimal}
        "vertical_momentum" = :Key {types = @temp/decimal}
    }
}
component.default_look_angle inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = @temp/decimal}
    }
}
component.despawn inherit temp/SortedKeymap {
    keys = {
        "despawn_from_distance" = :Key {types = #dict, structure = @component.despawn:despawn_from_distance}
        "despawn_from_chance" = :Key {types = #bool}
        "despawn_from_inactivity" = :Key {types = #bool}
        "despawn_from_simulation_edge" = :Key {types = #bool}
        "filters" = :Key {types = #dict, structure = @filter}
        "min_range_inactivity_timer" = :Key {types = #int}
        "remove_child_entities" = :Key {types = #bool}
    }
}
component.despawn:despawn_from_distance inherit temp/SortedKeymap {
    keys = {
        "max_distance" = :Key {types = #int}
        "min_distance" = :Key {types = #int}
    }
}
component.drying_out_timer inherit temp/SortedKeymap {
    keys = {
        "total_time" = :Key {types = @temp/decimal}
        "dried_out_event" = :Key {types = #dict, structure = @event}
        "recover_after_dried_out_event" = :Key {types = #dict, structure = @event}
        "stopped_drying_out_event" = :Key {types = #dict, structure = @event}
        "water_bottle_refill_time" = :Key {types = @temp/decimal}
    }
}
component.dweller inherit temp/SortedKeymap {
    keys = {
        "dwelling_type" = :Key {types = #str}
        "dweller_role" = :Key {types = #str}
        "update_interval_base" = :Key {types = @temp/decimal}
        "update_interval_variant" = :Key {types = @temp/decimal}
        "can_find_poi" = :Key {types = #bool}
        "first_founding_reward" = :Key {types = #int}
        "can_migrate" = :Key {types = #bool}
        "dwelling_bounds_tolerance" = :Key {types = #float}
        "preferred_profession" = :Key {types = #str}
    }
}
component.economy_trade_table inherit temp/SortedKeymap {
    keys = {
        "convert_trades_economy" = :Key {types = #bool}
        "cured_discount" = :Key {types = @range, structure = @range_group_int}
        "display_name" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "hero_demand_discount" = :Key {types = #int}
        "max_cured_discount" = :Key {types = @range, structure = @range_group_int}
        "max_nearby_cured_discount" = :Key {types = #int}
        "nearby_cured_discount" = :Key {types = #int}
        "new_screen" = :Key {types = #bool}
        "persist_trades" = :Key {types = #bool}
        "show_trade_screen" = :Key {types = #bool}
        "table" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "use_legacy_price_formula" = :Key {types = #bool}
    }
}
component.entity_sensor inherit temp/SortedKeymap {
    keys = {
        "cooldown" = :Key {types = @temp/decimal}
        "event_filters" = :Key {types = #dict, structure = @filter}
        "event" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "find_players_only" = :Key {types = #bool}
        "maximum_count" = :Key {types = #int}
        "minimum_count" = :Key {types = #int}
        "range" = :Key {types = [@temp/decimal, @range], structure = @range_decimal_or_decimal}
        "relative_range" = :Key {types = #bool}
        "require_all" = :Key {types = #bool}
        "sensor_range" = :Key {types = @temp/decimal}
        "subsensors" = :Key {types = #list, structure = @component.entity_sensor:subsensors}
        "y_offset" = :Key {types = @temp/decimal}
    }
}
component.entity_sensor:subsensors inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.entity_sensor
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "subsensor", "show_item_key" = false, "measure_length" = true}
    }
}
component.environment_sensor:group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.environment_sensor},
        :Key {types = #list, structure = @component.environment_sensor:trigger_list},
    ]
}
component.environment_sensor inherit temp/SortedKeymap {
    keys = {
        "event" = :Key {types = #str, tags = [@t/outdated]}
        "filters" = :Key {types = #dict, structure = @filter, tags = [@t/outdated]}
        "on_environment" = :Key {types = #dict, structure = @event_target_filters, tags = [@t/outdated]}
        "triggers" = :Key {types = [#dict, #list], structure = @component.environment_sensor:triggers_group}
    }
}
component.environment_sensor:triggers_group :Union {
    substructures = [
        :Key {types = #dict, structure = @event_target_filters},
        :Key {types = #list, structure = @component.environment_sensor:trigger_list},
    ]
}
component.environment_sensor:trigger_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @event_target_filters
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "trigger", "show_item_key" = false, "measure_length" = true}
    }
}
component.equip_item inherit temp/SortedKeymap {
    keys = {
        "can_wear_armor" = :Key {types = #bool}
        "excluded_items" = :Key {types = #list, structure = @component.equip_item:excluded_items}
    }
}
component.equip_item:excluded_items inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.equip_item:excluded_items.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"measure_length" = true, "show_item_key" = false, "field" = "item"}
    }
}
component.equip_item:excluded_items.item inherit temp/SortedKeymap {
    keys = {
        "item" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.equipment inherit temp/SortedKeymap {
    keys = {
        "slot_drop_chance" = :Key {types = #list, structure = @component.equipment:slot_drop_chance}
        "table" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.equipment:slot_drop_chance inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.equipment:slot_drop_chance.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "slot", "show_item_key" = false, "measure_length" = true}
    }
}
component.equipment:slot_drop_chance.item inherit temp/SortedKeymap {
    keys = {
        "drop_chance" = :Key {types = @temp/decimal}
        "slot" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.equippable inherit temp/SortedKeymap {
    keys = {
        "slots" = :Key {types = #list, structure = @component.equippable:slots}
    }
}
component.equippable:slots inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.equippable:slots.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "slot", "show_item_key" = false, "measure_length" = true}
    }
}
component.equippable:slots.item inherit temp/SortedKeymap {
    keys = {
        "accepted_items" = :Key {types = #list, structure = @item_list}
        "interact_text" = :Key {types = #str}
        "item" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "on_equip" = :Key {types = #dict, structure = @event_target}
        "on_unequip" = :Key {types = #dict, structure = @event}
        "slot" = :Key {types = #int, delegate_arguments = {"always_print" = true}}
    }
}
component.exhaustion_values inherit temp/SortedKeymap {
    keys = {
        "attack" = :Key {types = @temp/decimal}
        "damage" = :Key {types = @temp/decimal}
        "heal" = :Key {types = @temp/decimal}
        "jump" = :Key {types = @temp/decimal}
        "mine" = :Key {types = @temp/decimal}
        "sprint" = :Key {types = @temp/decimal}
        "sprint_jump" = :Key {types = @temp/decimal}
        "swim" = :Key {types = @temp/decimal}
        "walk" = :Key {types = @temp/decimal}
    }
}
component.experience_reward inherit temp/SortedKeymap {
    keys = {
        "on_bred" = :Key {types = #str}
        "on_death" = :Key {types = #str}
    }
}
component.explode inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "allow_damage_underwater" = :Key {types = #bool, tags = [@t/outdated]}
        "allow_underwater" = :Key {types = #bool}
        "breaks_blocks" = :Key {types = #bool}
        "causes_fire" = :Key {types = #bool}
        "causesFire" = :Key {types = #bool, tags = [@t/outdated]}
        "damage_scaling" = :Key {types = #int}
        "destroy_affected_by_griefing" = :Key {types = #bool}
        "destroyAffectedByGriefing" = :Key {types = #bool, tags = [@t/outdated]}
        "fire_affected_by_griefing" = :Key {types = #bool}
        "fireAffectedByGriefing" = :Key {types = #bool, tags = [@t/outdated]}
        "fuse_length" = :Key {types = [@temp/decimal, @range], structure = @range_decimal_or_decimal}
        "fuseLength" = :Key {types = [@temp/decimal, @range], structure = @range_decimal_or_decimal, tags = [@t/outdated]}
        "fuse_lit" = :Key {types = #bool}
        "fuseLit" = :Key {types = #bool, tags = [@t/outdated]}
        "knockback_scaling" = :Key {types = @temp/decimal}
        "max_resistance" = :Key {types = @temp/decimal}
        "maxResistance" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "negates_fall_damage" = :Key {types = #bool}
        "on_activate" = :Key {types = #dict, structure = @temp/empty, tags = [@t/outdated]}
        "particle_effect" = :Key {types = #str}
        "power" = :Key {types = @temp/decimal, delegate_arguments = {"always_print" = true}}
        "sound_effect" = :Key {types = #str}
        "toggles_blocks" = :Key {types = #bool}
    }
}
component.fall_damage inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = @temp/decimal}
    }
}
component.fire_immune :Union {
    substructures = [
        :Key {types = #bool},
        :Key {types = #dict, structure = @temp/empty},
    ]
}
component.float_wander inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "xz_dist" = :Key {types = #int}
        "y_dist" = :Key {types = #int}
        "y_offset" = :Key {types = @temp/decimal}
    }
}
component.flocking inherit temp/SortedKeymap {
    keys = {
        "acceleration" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "block_distance" = :Key {types = @temp/decimal}
        "block_weight" = :Key {types = @temp/decimal}
        "breach_influence" = :Key {types = @temp/decimal}
        "cohesion_threshold" = :Key {types = @temp/decimal}
        "cohesion_weight" = :Key {types = @temp/decimal}
        "goal_weight" = :Key {types = @temp/decimal}
        "high_flock_limit" = :Key {types = #int}
        "in_water" = :Key {types = #bool}
        "influence_radius" = :Key {types = @temp/decimal}
        "innner_cohesion_threshold" = :Key {types = @temp/decimal}
        "loner_chance" = :Key {types = @temp/decimal}
        "low_flock_limit" = :Key {types = #int}
        "match_variants" = :Key {types = #bool}
        "max_flee_speed" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "max_height" = :Key {types = @temp/decimal}
        "max_speed" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "min_height" = :Key {types = @temp/decimal}
        "rotation_speed" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "separation_threshold" = :Key {types = @temp/decimal}
        "separation_weight" = :Key {types = @temp/decimal}
        "terrain_avoid_distance" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "use_center_of_mass" = :Key {types = #bool}
    }
}
component.flying_speed inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = @temp/decimal}
    }
}
component.follow_range:group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.follow_range},
        :Key {types = #int},
    ]
}
component.follow_range inherit temp/SortedKeymap {
    keys = {
        "max" = :Key {types = @temp/decimal}
        "value" = :Key {types = @temp/decimal}
    }
}
component.free_camera_controlled inherit temp/SortedKeymap {
    keys = {
        "strafe_speed_modifier" = :Key {types = @temp/decimal}
        "backwards_movement_modifier" = :Key {types = @temp/decimal}
    }
}
component.friction_modifier inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = @temp/decimal}
    }
}
component.game_event_movement_tracking inherit temp/SortedKeymap {
    keys = {
        "emit_flap" = :Key {types = #bool}
        "emit_move" = :Key {types = #bool}
        "emit_swim" = :Key {types = #bool}
    }
}
component.genetics inherit temp/SortedKeymap {
    keys = {
        "genes" = :Key {types = #list, structure = @component.genetics:genes}
        "mutation_rate" = :Key {types = @temp/decimal}
    }
}
component.genetics:genes inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.genetics:genes.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "gene", "show_item_key" = false, "measure_length" = true}
    }
}
component.genetics:genes.item inherit temp/SortedKeymap {
    keys = {
        "allele_range" = :Key {types = [#dict, #int, #list], structure = @range_int_or_int}
        "genetic_variants" = :Key {types = #list, structure = @component.genetics:genes.item.genetic_variants}
        "name" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "use_simplified_breeding" = :Key {types = #bool, tags = [@t/not_in_documentation]}
    }
}
component.genetics:genes.item.genetic_variants inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.genetics:genes.item.genetic_variants.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "genetic variant", "show_item_key" = false, "measure_length" = true}
    }
}
component.genetics:genes.item.genetic_variants.item inherit temp/SortedKeymap {
    keys = {
        "birth_event" = :Key {types = #dict, structure = @event_target}
        "both_allele" = :Key {types = [#dict, #int, #list], structure = @range_int_or_int}
        "either_allele" = :Key {types = [#dict, #int, #list], structure = @range_int_or_int}
        "hidden_allele" = :Key {types = [#dict, #int, #list], structure = @range_int_or_int}
        "main_allele" = :Key {types = [#dict, #int, #list], structure = @range_int_or_int}
        "mutation_rate" = :Key {types = @temp/decimal}
    }
}
component.giveable inherit temp/SortedKeymap {
    keys = {
        "cooldown" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "items" = :Key {types = #list, structure = @item_list, tags = [@t/outdated]}
        "on_give" = :Key {types = #dict, structure = @event_target, tags = [@t/outdated]}
        "triggers" = :Key {types = #dict, structure = @component.giveable:triggers}
    }
}
component.giveable:triggers inherit temp/SortedKeymap {
    keys = {
        "cooldown" = :Key {types = @temp/decimal}
        "items" = :Key {types = #list, structure = @item_list}
        "on_give" = :Key {types = #dict, structure = @event_target}
    }
}
component.ground_offset inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = @temp/decimal}
    }
}
component.group_size inherit temp/SortedKeymap {
    keys = {
        "filters" = :Key {types = #dict, structure = @filter}
        "radius" = :Key {types = @temp/decimal}
    }
}
component.grows_crop inherit temp/SortedKeymap {
    keys = {
        "chance" = :Key {types = @temp/decimal}
        "charges" = :Key {types = #int}
    }
}
component.healable inherit temp/SortedKeymap {
    keys = {
        "filters" = :Key {types = #dict, structure = @filter}
        "force_use" = :Key {types = #bool}
        "items" = :Key {types = #list, structure = @component.healable:items}
    }
}
component.healable:items inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = [#dict, #str]
    value_structure = @component.healable:items.group
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "item", "show_item_key" = false, "measure_length" = true}
    }
}
component.healable:items.group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.healable:items.item},
        :Key {types = #str},
    ]
}
component.healable:items.item inherit temp/SortedKeymap {
    keys = {
        "effects" = :Key {types = #list, structure = @component.healable:items.item.effects, tags = [@t/not_in_documentation]}
        "heal_amount" = :Key {types = #int}
        "item" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.healable:items.item.effects inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.healable:items.item.effects.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "effect", "show_item_key" = false, "measure_length" = true}
    }
}
component.healable:items.item.effects.item inherit temp/SortedKeymap {
    keys = {
        "amplifier" = :Key {types = #int}
        "chance" = :Key {types = @temp/decimal}
        "duration" = :Key {types = #int}
        "name" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.health inherit temp/SortedKeymap {
    keys = {
        "max" = :Key {types = [#dict, #int, #list], structure = @range_int_or_int}
        "min" = :Key {types = #int, tags = [@t/outdated]}
        "value" = :Key {types = [#dict, #int, #list], structure = @range_int_or_int}
    }
}
component.heartbeat inherit temp/SortedKeymap {
    keys = {
        "interval" = :Key {types = #str}
        "sound_event" = :Key {types = #str}
    }
}
component.home inherit temp/SortedKeymap {
    keys = {
        "home_block_list" = :Key {types = #list, structure = @block_list}
        "restriction_radius" = :Key {types = #int}
        "restriction_type" = :Key {types = #str}
    }
}
component.horse.jump_strength inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = [@temp/decimal, #dict, #list], structure = @range_decimal_or_decimal}
    }
}
component.hurt_on_condition inherit temp/SortedKeymap {
    keys = {
        "damage_conditions" = :Key {types = #list, structure = @component.hurt_on_condition:damage_conditions}
    }
}
component.hurt_on_condition:damage_conditions inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.hurt_on_condition:damage_conditions.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"measure_length" = true, "show_item_key" = false, "field" = "damage condition"}
    }
}
component.hurt_on_condition:damage_conditions.item inherit temp/SortedKeymap {
    keys = {
        "filters" = :Key {types = #dict, structure = @filter}
        "cause" = :Key {types = #str}
        "damage_per_tick" = :Key {types = #int}
    }
}
component.hurt_when_wet inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = #bool}
    }
}
component.identifier inherit temp/SortedKeymap {
    keys = {
        "id" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.input_air_controlled inherit temp/SortedKeymap {
    keys = {
        "strafe_speed_modifier" = :Key {types = @temp/decimal}
        "backwards_movement_modifier" = :Key {types = @temp/decimal}
    }
}
component.inside_block_notifier inherit temp/SortedKeymap {
    keys = {
        "block_list" = :Key {types = #list, structure = @component.inside_block_notifier:block_list}
    }
}
component.inside_block_notifier:block_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.inside_block_notifier:block_list.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "block", "show_item_key" = false, "measure_length" = true}
    }
}
component.inside_block_notifier:block_list.item inherit temp/SortedKeymap {
    keys = {
        "block" = :Key {types = #dict, structure = @component.inside_block_notifier:block_list.item.block}
        "entered_block_event" = :Key {types = #dict, structure = @event_target}
        "exited_block_event" = :Key {types = #dict, structure = @event_target}
    }
}
component.inside_block_notifier:block_list.item.block inherit temp/SortedKeymap {
    keys = {
        "name" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "states" = :Key {types = #dict, structure = @block_states}
    }
}
component.insomnia inherit temp/SortedKeymap {
    keys = {
        "days_until_insomnia" = :Key {types = @temp/decimal}
    }
}
component.instant_despawn inherit temp/SortedKeymap {
    keys = {
        "remove_child_entities" = :Key {types = #bool}
    }
}
component.interact:group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.interact},
        :Key {types = #list, structure = @component.interact:interactions},
    ]
}
component.interact inherit temp/SortedKeymap {
    keys = {
        "interactions" = :Key {types = [#dict, #list], structure = @component.interact:interactions_group}
    } + @component.interact:interactions.item:keys
}
component.interact:interactions_group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.interact:interactions.item},
        :Key {types = #list, structure = @component.interact:interactions},
    ]
}
component.interact:interactions inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.interact:interactions.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "interaction", "show_item_key" = false, "measure_length" = true}
    }
}
component.interact:interactions.item:keys {
    "add_items" = :Key {types = #dict, structure = @component.interact:add_items}
    "admire" = :Key {types = #bool, tags = [@t/not_in_documentation]}
    "barter" = :Key {types = #bool, tags = [@t/not_in_documentation]}
    "cooldown" = :Key {types = @temp/decimal}
    "cooldown_after_being_attacked" = :Key {types = @temp/decimal}
    "drop_item_slot" = :Key {types = [#int, #str]}
    "drop_item_y_offset" = :Key {types = @temp/decimal}
    "equip_item_slot" = :Key {types = [#int, #str]}
    "event" = :Key {types = #str, tags = [@t/outdated]}
    "filters" = :Key {types = #dict, structure = @filter, tags = [@t/outdated]}
    "give_item" = :Key {types = #bool}
    "health_amount" = :Key {types = #int}
    "hurt_item" = :Key {types = #int}
    "interact_text" = :Key {types = #str}
    "on_interact" = :Key {types = #dict, structure = @event_target_filters}
    "particle_on_start" = :Key {types = #dict, structure = @component.interact:particle_on_start}
    "play_sounds" = :Key {types = #str}
    "repair_entity_item" = :Key {types = #dict, structure = @component.interact:repair_entity_item}
    "spawn_entities" = :Key {types = #str}
    "spawn_items" = :Key {types = [#dict, #list], structure = @component.interact:spawn_items.group}
    "swing" = :Key {types = #bool}
    "take_item" = :Key {types = #bool}
    "target" = :Key {types = #str, tags = [@t/outdated]}
    "transform_to_item" = :Key {types = #str}
    "use_item" = :Key {types = [#bool, #str]}
    "vibration" = :Key {types = #str}
}
component.interact:interactions.item inherit temp/SortedKeymap {
    keys = @component.interact:interactions.item:keys
}
component.interact:add_items inherit temp/SortedKeymap {
    keys = {
        "table" = :Key {types = #str}
    }
}
component.interact:particle_on_start inherit temp/SortedKeymap {
    keys = {
        "copper_event" = :Key {types = #str}
        "particle_offset_towards_interactor" = :Key {types = #bool}
        "particle_type" = :Key {types = #str}
        "particle_y_offset" = :Key {types = @temp/decimal}
    }
}
component.interact:repair_entity_item inherit temp/SortedKeymap {
    keys = {
        "amount" = :Key {types = #int}
        "slot" = :Key {types = #str}
    }
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"print_all" = true}
    }
}
component.interact:spawn_items.group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.interact:spawn_items},
        :Key {types = #list, structure = @item_list},
    ]
}
component.interact:spawn_items inherit temp/SortedKeymap {
    keys = {
        "table" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "y_offset" = :Key {types = @temp/decimal}
    }
}
component.inventory inherit temp/SortedKeymap {
    keys = {
        "additional_slots_per_strength" = :Key {types = #int}
        "can_be_siphoned_from" = :Key {types = #bool}
        "container_type" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "inventory_size" = :Key {types = #int, delegate_arguments = {"always_print" = true}}
        "private" = :Key {types = #bool}
        "restrict_to_owner" = :Key {types = #bool}
    }
}
component.is_dyeable inherit temp/SortedKeymap {
    keys = {
        "interact_text" = :Key {types = #str}
    }
}
component.is_stackable inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = #bool}
    }
}
component.item_command_block inherit temp/SortedKeymap {
    keys = {
        "current_tick_count" = :Key {types = #int}
        "ticking" = :Key {types = #bool}
        "ticks_per_command" = :Key {types = #int}
    }
}
component.item_controllable inherit temp/SortedKeymap {
    keys = {
        "control_items" = :Key {types = [#list, #str], structure = @item_list_or_item}
    }
}
component.jump.static inherit temp/SortedKeymap {
    keys = {
        "jump_power" = :Key {types = @temp/decimal}
    }
}
component.knockback_resistance inherit temp/SortedKeymap {
    keys = {
        "max" = :Key {types = @temp/decimal}
        "value" = :Key {types = @temp/decimal}
    }
}
component.lava_movement inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = @temp/decimal}
    }
}
component.leashable inherit temp/SortedKeymap {
    keys = {
        "can_be_stolen" = :Key {types = #bool}
        "hard_distance" = :Key {types = @temp/decimal}
        "max_distance" = :Key {types = @temp/decimal}
        "on_leash" = :Key {types = #dict, structure = @event_target}
        "on_unleash" = :Key {types = #dict, structure = @event_target}
        "presets" = :Key {types = #list, structure = @component.leashable:presets}
        "soft_distance" = :Key {types = @temp/decimal}
    }
}
component.leashable:presets inherit temp/Dict {
    this_types = #list
    key_types = #int
    key_weight = 0
    value_types = #dict
    value_structure = @component.leashable:preset
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "preset", "measure_length" = true, "show_item_key" = false}
    }
}
component.leashable:preset inherit temp/SortedKeymap {
    keys = {
        "filter" = :Key {types = #dict, structure = @filter}
        "spring_type" = :Key {types = #str}
        "rotation_adjustment" = :Key {types = #int}
        "soft_distance" = :Key {types = @temp/decimal}
        "hard_distance" = :Key {types = @temp/decimal}
        "max_distance" = :Key {types = @temp/decimal}
    }
}
component.looked_at inherit temp/SortedKeymap {
    keys = {
        "field_of_view" = :Key {types = #int}
        "filters" = :Key {types = #dict, structure = @filter}
        "find_players_only" = :Key {types = #bool}
        "line_of_sight_obstruction_type" = :Key {types = #str}
        "look_at_locations" = :Key {types = #list, structure = @component.looked_at:look_at_locations}
        "looked_at_cooldown" = :Key {types = @temp/decimal}
        "looked_at_event" = :Key {types = @trigger_type, structure = @trigger}
        "min_looked_at_duration" = :Key {types = @temp/decimal}
        "not_looked_at_event" = :Key {types = @trigger_type, structure = @trigger}
        "scale_fov_by_distance" = :Key {types = #bool}
        "search_radius" = :Key {types = @temp/decimal}
        "set_target" = :Key {types = #str}
    }
}
component.looked_at:look_at_locations inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = [#str, #dict]
    value_structure = :Union {
        substructures = [
            :Key {types = #str, structure = @temp/string},
            :Key {types = #dict, structure = inherit temp/SortedKeymap {
                keys = {
                    "location" = :Key {types = #str, structure = @temp/string}
                    "vertical_offset" = :Key {types = @temp/decimal}
                }
            }},
        ]
    }
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "location", "show_item_key" = false, "measure_length" = true}
    }
}
component.lookat inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "allow_invulnerable" = :Key {types = #bool}
        "filters" = :Key {types = #dict, structure = @filter}
        "look_cooldown" = :Key {types = [@temp/decimal, #dict, #list], structure = @range_decimal_or_decimal}
        "look_event" = :Key {types = #str}
        "search_radius" = :Key {types = @temp/decimal}
        "searchRadius" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "set_target" = :Key {types = #bool}
        "setTarget" = :Key {types = #bool, tags = [@t/outdated]}
    }
}
component.loot inherit temp/SortedKeymap {
    keys = {
        "table" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.mark_variant inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = #int}
    }
}
component.mob_effect inherit temp/SortedKeymap {
    keys = {
        "cooldown_time" = :Key {types = #int}
        "entity_filter" = :Key {types = #dict, structure = @filter}
        "effect_range" = :Key {types = @temp/decimal}
        "effect_time" = :Key {types = #int}
        "mob_effect" = :Key {types = #str}
    }
}
component.mob_effect_immunity inherit temp/SortedKeymap {
    keys = {
        "mob_effects" = :Key {types = #list, structure = @component.mob_effect_immunity:mob_effects}
    }
}
component.mob_effect_immunity:mob_effects inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "mob effect", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
component.movement inherit temp/SortedKeymap {
    keys = {
        "max" = :Key {types = @temp/decimal}
        "value" = :Key {types = [@temp/decimal, @range], structure = @range_decimal_or_decimal}
    }
}
component.movement.amphibious inherit temp/SortedKeymap {
    keys = {
        "max_turn" = :Key {types = @temp/decimal}
    }
}
component.movement.basic inherit temp/SortedKeymap {
    keys = {
        "max_turn" = :Key {types = @temp/decimal}
    }
}
component.movement.fly inherit temp/SortedKeymap {
    keys = {
        "start_speed" = :Key {types = @temp/decimal}
        "speed_when_turning" = :Key {types = @temp/decimal}
    }
}
component.movement.generic inherit temp/SortedKeymap {
    keys = {
        "max_turn" = :Key {types = @temp/decimal}
    }
}
component.movement.glide inherit temp/SortedKeymap {
    keys = {
        "speed_when_turning" = :Key {types = @temp/decimal}
        "start_speed" = :Key {types = @temp/decimal}
    }
}
component.movement.hover inherit temp/SortedKeymap {
    keys = {
        "max_turn" = :Key {types = @temp/decimal}
    }
}
component.movement.jump inherit temp/SortedKeymap {
    keys = {
        "jump_delay" = :Key {types = @range, structure = @range_group_decimal}
        "max_turn" = :Key {types = @temp/decimal}
    }
}
component.movement.skip inherit temp/SortedKeymap {
    keys = {
        "max_turn" = :Key {types = @temp/decimal}
    }
}
component.movement_sound_distance_offset inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = @temp/decimal}
    }
}
component.movement.sway inherit temp/SortedKeymap {
    keys = {
        "max_turn" = :Key {types = @temp/decimal}
        "sway_amplitude" = :Key {types = @temp/decimal}
        "sway_frequency" = :Key {types = @temp/decimal}
        "value" = :Key {types = @temp/decimal, tags = [@t/outdated]}
    }
}
component.nameable inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "allow_name_tag_renaming" = :Key {types = #bool}
        "allowNameTagRenaming" = :Key {types = #bool, tags = [@t/outdated]}
        "always_show" = :Key {types = #bool}
        "alwaysShow" = :Key {types = #bool, tags = [@t/outdated]}
        "default_trigger" = :Key {types = [#dict, #str], structure = @event_target_or_str}
        "name_actions" = :Key {types = #list, structure = @component.nameable:name_actions}
    }
}
component.nameable:name_actions inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.nameable:name_actions.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"measure_length" = true, "show_item_key" = false, "field" = "name action"}
    }
}
component.nameable:name_actions.item inherit temp/SortedKeymap {
    keys = {
        "name_filter" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "on_named" = :Key {types = #dict, structure = @event_target}
    }
}
component.navigation inherit temp/SortedKeymap {
    keys = {
        "avoid_damage_blocks" = :Key {types = #bool}
        "avoid_portals" = :Key {types = #bool}
        "avoid_powder_snow" = :Key {types = #bool, tags = [@t/outdated]}
        "avoid_sun" = :Key {types = #bool}
        "avoid_water" = :Key {types = #bool}
        "blocks_to_avoid" = :Key {types = #list, structure = @component.navigation:blocks_to_avoid}
        "can_breach" = :Key {types = #bool}
        "can_break_doors" = :Key {types = #bool}
        "can_float" = :Key {types = #bool, tags = [@t/not_in_documentation]}
        "can_jump" = :Key {types = #bool}
        "can_open_doors" = :Key {types = #bool}
        "can_open_iron_doors" = :Key {types = #bool}
        "can_pass_doors" = :Key {types = #bool}
        "can_path_from_air" = :Key {types = #bool}
        "can_path_over_lava" = :Key {types = #bool}
        "can_path_over_water" = :Key {types = #bool}
        "can_sink" = :Key {types = #bool}
        "can_swim" = :Key {types = #bool}
        "can_walk" = :Key {types = #bool}
        "can_walk_in_lava" = :Key {types = #bool}
        "is_amphibious" = :Key {types = #bool}
    }
}
component.navigation:blocks_to_avoid inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.navigation:blocks_to_avoid.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "block", "show_item_key" = false, "measure_length" = true}
    }
}
component.navigation:blocks_to_avoid.item inherit temp/SortedKeymap {
    keys = {
        "name" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "tags" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.npc inherit temp/SortedKeymap {
    keys = {
        "npc_data" = :Key {types = #dict, structure = @component.npc:npc_data}
    }
}
component.npc:npc_data inherit temp/SortedKeymap {
    keys = {
        "picker_offsets" = :Key {types = #dict, structure = @component.npc:npc_data.picker_offsets}
        "portrait_offsets" = :Key {types = #dict, structure = @component.npc:npc_data.portrait_offsets}
        "skin_list" = :Key {types = #list, structure = @component.npc:npc_data.skin_list}
    }
}
component.npc:npc_data.picker_offsets inherit temp/SortedKeymap {
    keys = {
        "scale" = :Key {types = #list, structure = @vector_decimal}
        "translate" = :Key {types = #list, structure = @vector_int}
    }
}
component.npc:npc_data.portrait_offsets inherit temp/SortedKeymap {
    keys = {
        "scale" = :Key {types = #list, structure = @vector_decimal}
        "translate" = :Key {types = #list, structure = @vector_int}
    }
}
component.npc:npc_data.skin_list inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.npc:npc_data.skin_list.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"measure_length" = true, "show_item_key" = false, "field" = "skin"}
    }
}
component.npc:npc_data.skin_list.item inherit temp/SortedKeymap {
    keys = {
        "variant" = :Key {types = #int}
    }
}
component.peek inherit temp/SortedKeymap {
    keys = {
        "on_close" = :Key {types = #dict, structure = @event}
        "on_open" = :Key {types = #dict, structure = @event}
        "on_target_open" = :Key {types = #dict, structure = @event}
    }
}
component.physics inherit temp/SortedKeymap {
    keys = {
        "has_collision" = :Key {types = #bool}
        "has_gravity" = :Key {types = #bool}
        "push_towards_closest_space" = :Key {types = #bool}
    }
}
component.player.exhaustion inherit temp/SortedKeymap {
    keys = {
        "max" = :Key {types = #int}
        "value" = :Key {types = #int}
    }
}
component.player.experience inherit temp/SortedKeymap {
    keys = {
        "max" = :Key {types = #int}
        "value" = :Key {types = #int}
    }
}
component.player.level inherit temp/SortedKeymap {
    keys = {
        "max" = :Key {types = #int}
        "value" = :Key {types = #int}
    }
}
component.player.saturation inherit temp/SortedKeymap {
    keys = {
        "max" = :Key {types = #int}
        "value" = :Key {types = #int}
    }
}
component.preferred_path inherit temp/SortedKeymap {
    keys = {
        "default_block_cost" = :Key {types = @temp/decimal, delegate_arguments = {"always_print" = true}}
        "jump_cost" = :Key {types = #int, delegate_arguments = {"always_print" = true}}
        "max_fall_blocks" = :Key {types = #int, delegate_arguments = {"always_print" = true}}
        "preferred_path_blocks" = :Key {types = #list, structure = @component.preferred_path:preferred_path_blocks}
    }
}
component.preferred_path:preferred_path_blocks inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.preferred_path:preferred_path_blocks.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "block category", "show_item_key" = false, "measure_length" = true}
    }
}
component.preferred_path:preferred_path_blocks.item inherit temp/SortedKeymap {
    keys = {
        "cost" = :Key {types = #int, delegate_arguments = {"always_print" = true}}
        "blocks" = :Key {types = #list, structure = @block_list}
    }
}
component.projectile inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 5
    value_weight = 1
    key_structure = @temp/string
    keys = {
        "anchor" = :Key {types = #int}
        "angle_offset" = :Key {types = @temp/decimal}
        "angleoffset" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "catch_fire" = :Key {types = #bool}
        "catchFire" = :Key {types = #bool, tags = [@t/outdated]}
        "crit_particle_on_hurt" = :Key {types = #bool}
        "critParticleOnHurt" = :Key {types = #bool, tags = [@t/outdated]}
        "damage" = :Key {types = #int, tags = [@t/outdated]}
        "destroyOnHurt" = :Key {types = #bool}
        "filter" = :Key {types = #dict, structure = @filter}
        "fire_affected_by_griefing" = :Key {types = #bool}
        "gravity" = :Key {types = @temp/decimal}
        "hit_ground_sound" = :Key {types = #str}
        "hit_nearest_passenger" = :Key {types = #bool}
        "hitGroundSound" = :Key {types = #str, tags = [@t/outdated]}
        "hit_sound" = :Key {types = #str}
        "hitSound" = :Key {types = #str, tags = [@t/outdated]}
        "hit_water" = :Key {types = #bool}
        "hitWater" = :Key {types = #bool, tags = [@t/outdated]}
        "homing" = :Key {types = #bool}
        "ignored_entities" = :Key {types = #list, structure = @entity_list}
        "inertia" = :Key {types = @temp/decimal}
        "is_dangerous" = :Key {types = #bool}
        "isdangerous" = :Key {types = #bool, tags = [@t/outdated]}
        "knockback" = :Key {types = #bool}
        "lightning" = :Key {types = #bool}
        "liquid_inertia" = :Key {types = @temp/decimal}
        "multiple_targets" = :Key {types = #bool}
        "multipletargets" = :Key {types = #bool, tags = [@t/outdated]}
        "offset" = :Key {types = #list, structure = @vector_decimal}
        "on_fire_time" = :Key {types = @temp/decimal}
        "on_hit" = :Key {types = #dict, structure = @component.projectile:on_hit}
        "onHit" = :Key {types = #dict, structure = @component.projectile:on_hit, tags = [@t/outdated]}
        "particle" = :Key {types = #str}
        "power" = :Key {types = @temp/decimal}
        "reflect_immunity" = :Key {types = @temp/decimal}
        "reflect_on_hurt" = :Key {types = #bool}
        "reflectOnHurt" = :Key {types = #bool, tags = [@t/outdated]}
        "semi_random_diff_damage" = :Key {types = #bool, tags = [@t/not_in_documentation]}
        "semirandomdiffdamage" = :Key {types = #bool, tags = [@t/not_in_documentation, @t/outdated]}
        "shoot_sound" = :Key {types = #str}
        "shootSound" = :Key {types = #str, tags = [@t/outdated]}
        "shoot_target" = :Key {types = #bool}
        "shoottarget" = :Key {types = #bool, tags = [@t/outdated]}
        "should_bounce" = :Key {types = #bool}
        "shouldbounce" = :Key {types = #bool, tags = [@t/outdated]}
        "splash_potion" = :Key {types = #bool}
        "splash_range" = :Key {types = @temp/decimal}
        "stop_on_hurt" = :Key {types = #bool}
        "stopOnHurt" = :Key {types = #bool, tags = [@t/outdated]}
        "uncertainty_base" = :Key {types = @temp/decimal}
        "uncertaintyBase" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "uncertainty_multiplier" = :Key {types = @temp/decimal}
        "uncertaintyMultiplier" = :Key {types = @temp/decimal, tags = [@t/outdated]}
    }
}
component.projectile:on_hit inherit temp/SortedKeymap {
    keys = {
        "arrow_effect" = :Key {types = #dict, structure = @component.projectile:on_hit:arrow_effect, tags = [@t/not_in_documentation]}
        "catch_fire" = :Key {types = [#bool, #dict], structure = @component.projectile:on_hit.catch_fire_group}
        "definition_event" = :Key {types = #dict, structure = @component.projectile:on_hit.definition_event}
        "douse_fire" = :Key {types = [#bool, #dict], structure = @component.projectiles:on_hit.douse_fire}
        "freeze_on_hit" = :Key {types = #dict, structure = @component.projectile:on_hit.freeze_on_hit}
        "grant_xp" = :Key {types = #dict, structure = @component.projectile:on_hit.grant_xp}
        "hurt_owner" = :Key {types = #dict, structure = @component.projectile:on_hit.hurt_owner}
        "ignite" = :Key {types = #bool}
        "impact_damage" = :Key {types = #dict, structure = @component.projectile:on_hit.impact_damage}
        "mob_effect" = :Key {types = #dict, structure = @component.projectile:on_hit.mob_effect}
        "on_fire_time" = :Key {types = #float}
        "particle_on_hit" = :Key {types = #dict, structure = @component.projectile:on_hit.particle_on_hit}
        "potion_effect" = :Key {types = [#dict, #int], structure = @component.projectile:on_hit.potion_effect.group}
        "remove_on_hit" = :Key {types = #dict, structure = @temp/empty}
        "spawn_aoe_cloud" = :Key {types = [#bool, #dict], structure = @component.projectile:on_hit.spawn_aoe_cloud_group}
        "spawn_chance" = :Key {types = #dict, structure = @component.projectile:on_hit.spawn_chance}
        "stick_in_ground" = :Key {types = #dict, structure = @component.projectile:on_hit.stick_in_ground}
        "teleport_owner" = :Key {types = [#bool, #dict], structure = @component.projectile:on_hit.teleport_owner}
        "thrown_potion_effect" = :Key {types = #dict, structure = @temp/empty}
        "wind_burst_on_hit" = :Key {types = #dict, structure = @temp/empty}
    }
}
component.projectile:on_hit:arrow_effect inherit temp/SortedKeymap {
    keys = {
        "apply_effect_to_blocking_targets" = :Key {types = #bool}
    }
}
component.projectile:on_hit.catch_fire_group :Union {
    substructures = [
        :Key {types = #bool},
        :Key {types = #dict, structure = @component.projectiles:on_hit.catch_fire},
    ]
}
component.projectiles:on_hit.catch_fire inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "fire_affected_by_griefing" = :Key {types = #bool}
        "fireAffectedByGriefing" = :Key {types = #bool, tags = [@t/outdated]}
    }
}
component.projectile:on_hit.definition_event inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "affect_projectile" = :Key {types = #bool}
        "affectProjectile" = :Key {types = #bool, tags = [@t/outdated]}
        "affect_shooter" = :Key {types = #bool}
        "affect_splash_area" = :Key {types = #bool}
        "splash_area" = :Key {types = @temp/decimal}
        "affect_target" = :Key {types = #bool}
        "event_trigger" = :Key {types = #dict, structure = @event_target_filters}
        "eventTrigger" = :Key {types = #dict, structure = @event_target_filters, tags = [@t/outdated]}
    }
}
component.projectiles:on_hit.douse_fire :Union {
    substructures = [
        :Key {types = #bool},
        :Key {types = #dict, structure = @temp/empty},
    ]
}
component.projectile:on_hit.freeze_on_hit inherit temp/SortedKeymap {
    keys = {
        "shape" = :Key {types = #str}
        "size" = :Key {types = @temp/decimal}
        "snap_to_block" = :Key {types = #bool}
    }
}
component.projectile:on_hit.grant_xp inherit temp/SortedKeymap {
    keys = {
        "maxXP" = :Key {types = #int}
        "minXP" = :Key {types = #int}
    }
}
component.projectile:on_hit.hurt_owner inherit temp/SortedKeymap {
    keys = {
        "ignite" = :Key {types = #bool}
        "knockback" = :Key {types = #bool}
        "owner_damage" = :Key {types = @temp/decimal}
    }
}
component.projectile:on_hit.impact_damage inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "catch_fire" = :Key {types = #bool}
        "catchFire" = :Key {types = #bool, tags = [@t/outdated]}
        "channeling" = :Key {types = #bool}
        "damage" = :Key {types = [@temp/decimal, @range], structure = @range_decimal_or_decimal}
        "destroy_on_hit" = :Key {types = #bool}
        "destroy_on_hit_requires_damage" = :Key {types = #bool}
        "destroyonhit" = :Key {types = #bool, tags = [@t/outdated]}
        "filter" = :Key {types = [#dict, #str], structure = @component:projectile:on_hit.impact_damage.filter}
        "knockback" = :Key {types = #bool}
        "max_critical_damage" = :Key {types = @temp/decimal}
        "maxcriticaldamage" = :Key {types = #int, tags = [@t/outdated]}
        "min_critical_damage" = :Key {types = #int}
        "mincriticaldamage" = :Key {types = #int, tags = [@t/outdated]}
        "power_multiplier" = :Key {types = @temp/decimal}
        "powermultiplier" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "semi_random_diff_damage" = :Key {types = #bool}
        "semirandomdiffdamage" = :Key {types = #bool, tags = [@t/outdated]}
        "set_last_hurt_requires_damage" = :Key {types = #bool}
        "should_bounce" = :Key {types = #bool}
        "shouldbounce" = :Key {types = #bool, tags = [@t/outdated]}
    }
}
component:projectile:on_hit.impact_damage.filter :Union {
    substructures = [
        :Key {types = #dict, structure = @filter},
        :Key {types = #str},
    ]
}
component.projectile:on_hit.mob_effect inherit temp/SortedKeymap {
    keys = {
        "amplifier" = :Key {types = #int}
        "ambient" = :Key {types = #bool}
        "duration" = :Key {types = #int}
        "durationeasy" = :Key {types = #int}
        "durationhard" = :Key {types = #int}
        "durationnormal" = :Key {types = #int}
        "effect" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "visible" = :Key {types = #bool}
    }
}
component.projectile:on_hit.particle_on_hit inherit temp/SortedKeymap {
    keys = {
        "particle_item_name" = :Key {types = [#str, #dict], structure = @component.projectile:on_hit.particle_on_hit.particle_item_name, delegate_arguments = {"always_print" = true}}
        "particle_type" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "on_other_hit" = :Key {types = #bool}
        "on_entity_hit" = :Key {types = #bool}
        "num_particles" = :Key {types = @temp/decimal}
    }
}
component.projectile:on_hit.particle_on_hit.particle_item_name :Union {
    substructures = [
        :Key {types = #str},
        :Key {types = #dict, structure = inherit temp/Dict {
            value_types = #dict
            value_structure = @filter
            delegate = :Delegate {
                delegate_class = %DefaultDelegate
                arguments = {"field" = "item", "measure_length" = true}
            }
        }},
    ]
}
component.projectile:on_hit.potion_effect.group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.projectile:on_hit.potion_effect},
        :Key {types = #int},
    ]
}
component.projectile:on_hit.potion_effect inherit temp/SortedKeymap {
    keys = {
        "durationeasy" = :Key {types = #int}
        "durationhard" = :Key {types = #int}
        "durationnormal" = :Key {types = #int}
        "effect" = :Key {types = #int, delegate_arguments = {"always_print" = true}}
    }
}
component.projectile:on_hit.spawn_aoe_cloud_group :Union {
    substructures = [
        :Key {types = #bool},
        :Key {types = #dict, structure = @component.projectile:on_hit.spawn_aoe_cloud},
    ]
}
component.projectile:on_hit.spawn_aoe_cloud inherit temp/SortedKeymap {
    keys = {
        "affect_owner" = :Key {types = #bool}
        "color" = :Key {types = #list, structure = @vector_int}
        "duration" = :Key {types = #int}
        "particle" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "potion" = :Key {types = #int}
        "radius" = :Key {types = @temp/decimal}
        "radius_on_use" = :Key {types = @temp/decimal}
        "reapplication_delay" = :Key {types = #int}
    }
}
component.projectile:on_hit.spawn_chance inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "first_spawn_chance" = :Key {types = #int, tags = [@t/not_in_documentation]}
        "first_spawn_count" = :Key {types = #int}
        "first_spawn_percent_chance" = :Key {types = @temp/decimal}
        "firstSpawnChance" = :Key {types = #int, tags = [@t/outdated]}
        "firstSpawnCount" = :Key {types = #int, tags = [@t/outdated]}
        "firstSpawnPercentChance" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "on_spawn" = :Key {types = [#dict, #list], structure = @trigger}
        "second_spawn_chance" = :Key {types = @temp/decimal}
        "second_spawn_count" = :Key {types = #int}
        "secondSpawnChance" = :Key {types = #int, tags = [@t/outdated]}
        "secondSpawnCount" = :Key {types = #int, tags = [@t/outdated]}
        "spawn_baby" = :Key {types = #bool}
        "spawn_definition" = :Key {types = #str}
        "spawnBaby" = :Key {types = #bool, tags = [@t/outdated]}
        "spawnDefinition" = :Key {types = #str, tags = [@t/outdated]}
        "spawnMob" = :Key {types = #str, tags = [@t/outdated]}
    }
}
component.projectile:on_hit.stick_in_ground inherit temp/SortedKeymap {
    keys = {
        "shake_time" = :Key {types = @temp/decimal}
    }
}
component.projectile:on_hit.teleport_owner :Union {
    substructures = [
        :Key {types = #bool},
        :Key {types = #dict, structure = @temp/empty},
    ]
}
component.push_through inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = @temp/decimal}
    }
}
component.pushable inherit temp/SortedKeymap {
    keys = {
        "is_pushable" = :Key {types = #bool}
        "is_pushable_by_piston" = :Key {types = #bool}
    }
}
component.raid_trigger inherit temp/SortedKeymap {
    keys = {
        "triggered_event" = :Key {types = #dict, structure = @event_target}
    }
}
component.rail_movement inherit temp/SortedKeymap {
    keys = {
        "max_speed" = :Key {types = @temp/decimal}
    }
}
component.rail_sensor inherit temp/SortedKeymap {
    keys = {
        "check_block_types" = :Key {types = #bool}
        "eject_on_activate" = :Key {types = #bool}
        "eject_on_deactivate" = :Key {types = #bool}
        "on_activate" = :Key {types = #dict, structure = @event_target_filters}
        "on_deactivate" = :Key {types = #dict, structure = @event_target_filters}
        "tick_command_block_on_activate" = :Key {types = #bool}
        "tick_command_block_on_deactivate" = :Key {types = #bool}
    }
}
component.ravager_blocked inherit temp/SortedKeymap {
    keys = {
        "knockback_strength" = :Key {types = @temp/decimal}
        "reaction_choices" = :Key {types = #list, structure = @component.ravager_blocked:reaction_choices}
    }
}
component.ravager_blocked:reaction_choices inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.ravager_blocked:reaction_choices.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"measure_length" = true, "show_item_key" = false, "field" = "choice"}
    }
}
component.ravager_blocked:reaction_choices.item inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = #dict, structure = @event_target}
        "weight" = :Key {types = #int}
    }
}
component.reflect_projectiles inherit temp/SortedKeymap {
    keys = {
        "azimuth_angle" = :Key {types = #str}
        "reflected_projectiles" = :Key {types = #list, structure = @projectile_list}
        "reflection_scale" = :Key {types = #str}
    }
}
component.rideable inherit temp/SortedKeymap {
    keys = {
        "controlling_seat" = :Key {types = #int}
        "crouching_skip_interact" = :Key {types = #bool}
        "dismount_mode" = :Key {types = #str}
        "family_types" = :Key {types = #list, structure = @family_list}
        "interact_text" = :Key {types = #str}
        "on_rider_enter_event" = :Key {types = #str}
        "on_rider_exit_event" = :Key {types = #str}
        "passenger_max_width" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int, tags = [@t/deprecated]}
        "pull_in_entities" = :Key {types = #bool}
        "rider_can_interact" = :Key {types = #bool}
        "seat_count" = :Key {types = #int}
        "seats" = :Key {types = [#dict, #list], structure = @component.rideable:seats_group}
    }
}
component.rideable:seats_group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.rideable:seats.item},
        :Key {types = #list, structure = @component.rideable:seats},
    ]
}
component.rideable:seats inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.rideable:seats.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "seat", "show_item_key" = false, "measure_length" = true}
    }
}
component.rideable:seats.item inherit temp/SortedKeymap {
    keys = {
        "camera_relax_distance_smoothing" = :Key {types = @temp/decimal}
        "lock_rider_rotation" = :Key {types = @temp/decimal}
        "max_rider_count" = :Key {types = #int}
        "min_rider_count" = :Key {types = #int}
        "position" = :Key {types = #list, structure = @vector_decimal}
        "rotate_rider_by" = :Key {types = [#int, #str]}
        "third_person_camera_radius" = :Key {types = @temp/decimal}
    }
}
component.scale inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = @temp/decimal}
    }
}
component.scale_by_age inherit temp/SortedKeymap {
    keys = {
        "end_scale" = :Key {types = @temp/decimal}
        "start_scale" = :Key {types = @temp/decimal}
    }
}
component.scheduler:group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.scheduler},
        :Key {types = #list, structure = @component.scheduler:scheduled_events},
    ]
}
component.scheduler inherit temp/SortedKeymap {
    keys = {
        "scheduled_events" = :Key {types = #list, structure = @component.scheduler:scheduled_events}
        "max_delay_secs" = :Key {types = @temp/decimal}
        "min_delay_secs" = :Key {types = @temp/decimal}
    }
}
component.scheduler:scheduled_events inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.scheduler:scheduled_events.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"measure_length" = true, "show_item_key" = false, "field" = "scheduled event"}
    }
}
component.scheduler:scheduled_events.item inherit temp/SortedKeymap {
    keys = {
        "event" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "filters" = :Key {types = [#dict, #list], structure = @filter_or_filter_list}
        "scheduled_event" = :Key {types = #dict, structure = @component.scheduler:scheduled_events.item, tags = [@t/outdated]}
    }
}
component.shareables inherit temp/SortedKeymap {
    keys = {
        "all_items" = :Key {types = #bool}
        "all_items_max_amount" = :Key {types = #int}
        "all_items_surplus_amount" = :Key {types = #int}
        "all_items_want_amount" = :Key {types = #int}
        "items" = :Key {types = #list, structure = @component.shareables:items}
        "singular_pickup" = :Key {types = #bool, tags = [@t/not_in_documentation]}
    }
}
component.shareables:items inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.shareables:items.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "item", "show_item_key" = false, "measure_length" = true}
    }
}
component.shareables:items.item inherit temp/SortedKeymap {
    keys = {
        "admire" = :Key {types = #bool}
        "barter" = :Key {types = #bool}
        "consume_item" = :Key {types = #bool}
        "craft_into" = :Key {types = #str}
        "item" = :Key {types = #str, structure = @temp/string_remove_minecraft_prefix, delegate_arguments = {"always_print" = true}, similarity_weight = 16}
        "item_aux" = :Key {types = #int, tags = [@t/outdated], delegate_arguments = {"always_print" = true}, similarity_weight = 4}
        "max_amount" = :Key {types = #int}
        "pickup_limit" = :Key {types = #int}
        "pickup_only" = :Key {types = #bool}
        "priority" = :Key {types = #int}
        "singular_pickup" = :Key {types = #bool}
        "stored_in_inventory" = :Key {types = #bool}
        "surplus_amount" = :Key {types = #int}
        "want_amount" = :Key {types = #int}
    }
}
component.shooter inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "aux_val" = :Key {types = #int, delegate_arguments = {"always_print" = true}}
        "auxVal" = :Key {types = #int, tags = [@t/outdated], delegate_arguments = {"always_print" = true}}
        "def" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "magic" = :Key {types = #bool}
        "power" = :Key {types = @temp/decimal}
        "projectiles" = :Key {types = #list, structure = @component.shooter:projectiles}
        "sound" = :Key {types = #str}
        "type" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.shooter:projectiles inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.shooter:projectiles.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "projectile", "show_item_key" = false, "measure_length" = true}
    }
}
component.shooter:projectiles.item inherit temp/SortedKeymap {
    keys = {
        "aux_val" = :Key {types = #int, delegate_arguments = {"always_print" = true}}
        "chance" = :Key {types = @temp/decimal}
        "def" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "filters" = :Key {types = #dict, structure = @filter}
        "lose_target" = :Key {types = #bool, tags = [@t/not_in_documentation]}
    }
}
component.sittable inherit temp/SortedKeymap {
    keys = {
        "sit_event" = :Key {types = #dict, structure = @event_target}
        "stand_event" = :Key {types = #dict, structure = @event_target}
    }
}
component.skin_id inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = #int}
    }
}
component.sound_volume inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = @temp/decimal}
    }
}
component.spawn_entity:group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.spawn_entity},
        :Key {types = #list, structure = @component.spawn_entity:entities},
    ]
}
component.spawn_entity inherit temp/SortedKeymap {
    keys = {
        "entities" = :Key {types = [#dict, #list], structure = @component.spawn_entity:entities_group}
    } + @component.spawn_entity:entities.item:keys
}
component.spawn_entity:entities_group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.spawn_entity:entities.item},
        :Key {types = #list, structure = @component.spawn_entity:entities},
    ]
}
component.spawn_entity:entities inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.spawn_entity:entities.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"measure_length" = true, "show_item_key" = false, "field" = "entity"}
    }
}
component.spawn_entity:entities.item:keys {
    "entities" = :Key {types = @entity_types_type, structure = @entity_types}
    "filters" = :Key {types = [#dict, #list], structure = @filter_or_filter_list}
    "max_wait_time" = :Key {types = #int}
    "min_wait_time" = :Key {types = #int}
    "num_to_spawn" = :Key {types = #int}
    "should_leash" = :Key {types = #bool}
    "single_use" = :Key {types = #bool}
    "spawn_entity" = :Key {types = #str}
    "spawn_event" = :Key {types = #str}
    "spawn_item" = :Key {types = #str}
    "spawn_item_event" = :Key {types = [#dict, #str], structure = @event_target_or_str}
    "spawn_method" = :Key {types = #str}
    "spawn_sound" = :Key {types = #str}
}
component.spawn_entity:entities.item inherit temp/SortedKeymap {
    keys = @component.spawn_entity:entities.item:keys
}
component.spell_effects inherit temp/SortedKeymap {
    keys = {
        "add_effects" = :Key {types = [#dict, #list], structure = @component.spell_effects:add_effects.group}
        "remove_effects" = :Key {types = [#list, #str], structure = @component.spell_effects:remove_effects_group}
    }
}
component.spell_effects:add_effects.group :Union {
    substructures = [
        :Key {types = #dict, structure = @component.spell_effects:add_effects.item},
        :Key {types = #list, structure = @component.spell_effects:add_effects},
    ]
}
component.spell_effects:add_effects inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_structure = @component.spell_effects:add_effects.item
    value_types = #dict
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "effect", "show_item_key" = false, "measure_length" = true}
    }
}
component.spell_effects:add_effects.item inherit temp/SortedKeymap {
    keys = {
        "ambient" = :Key {types = #bool}
        "amplifier" = :Key {types = #int}
        "display_on_screen_animation" = :Key {types = #bool}
        "duration" = :Key {types = #int}
        "effect" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "visible" = :Key {types = #bool}
    }
}
component.spell_effects:remove_effects_group :Union {
    substructures = [
        :Key {types = #list, structure = @component.spell_effects:remove_effects},
        :Key {types = #str},
    ]
}
component.spell_effects:remove_effects inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_structure = null
    value_types = #str
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"measure_length" = true, "show_item_key" = false, "sort" = %sort_by_value, "field" = "effect"}
    }
}
component.strength inherit temp/SortedKeymap {
    keys = {
        "max" = :Key {types = #int}
        "value" = :Key {types = #int}
    }
}
component.tameable inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "probability" = :Key {types = @temp/decimal}
        "tame_event" = :Key {types = #dict, structure = @event_target}
        "tame_items" = :Key {types = [#list, #str], structure = @item_list_or_item}
        "tameItems" = :Key {types = [#list, #str], structure = @item_list_or_item, tags = [@t/outdated]}
    }
}
component.tamemount inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "attempt_temper_mod" = :Key {types = #int}
        "auto_reject_items" = :Key {types = #list, structure = @component.tamemount:auto_reject_items}
        "autoRejectItems" = :Key {types = #list, structure = @component.tamemount:auto_reject_items, tags = [@t/outdated]}
        "feed_items" = :Key {types = #list, structure = @component.tamemount:feed_items}
        "feedItems" = :Key {types = #list, structure = @component.tamemount:feed_items, tags = [@t/outdated]}
        "feed_text" = :Key {types = #str}
        "max_temper" = :Key {types = #int}
        "maxTemper" = :Key {types = #int, tags = [@t/outdated]}
        "min_temper" = :Key {types = #int}
        "minTemper" = :Key {types = #int, tags = [@t/outdated]}
        "ride_text" = :Key {types = #str}
        "tame_event" = :Key {types = #dict, structure = @event_target}
    }
}
component.tamemount:auto_reject_items inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_structure = @component.tamemount:auto_reject_items.item
    value_types = #dict
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "item", "show_item_key" = false, "measure_length" = true}
    }
}
component.tamemount:auto_reject_items.item inherit temp/SortedKeymap {
    keys = {
        "item" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.tamemount:feed_items inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_structure = @component.tamemount:feed_items.item
    value_types = #dict
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "item", "show_item_key" = false, "measure_length" = true}
    }
}
component.tamemount:feed_items.item inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "item" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "temper_mod" = :Key {types = #int}
        "temperMod" = :Key {types = #int, tags = [@t/outdated]}
    }
}
component.target_nearby_sensor inherit temp/SortedKeymap {
    keys = {
        "inside_range" = :Key {types = @temp/decimal}
        "must_see" = :Key {types = #bool}
        "on_inside_range" = :Key {types = #dict, structure = @event_target_filters}
        "on_outside_range" = :Key {types = #dict, structure = @event_target}
        "on_vision_lost_inside_range" = :Key {types = #dict, structure = @event_target}
        "outside_range" = :Key {types = @temp/decimal}
    }
}
component.teleport inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "dark_teleport_chance" = :Key {types = @temp/decimal}
        "light_teleport_chance" = :Key {types = @temp/decimal}
        "lightTeleportChance" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "max_random_teleport_time" = :Key {types = @temp/decimal}
        "maxRandomTeleportTime" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "min_random_teleport_time" = :Key {types = @temp/decimal}
        "random_teleport_cube" = :Key {types = #list, structure = @vector_int}
        "randomTeleportCube" = :Key {types = #list, structure = @vector_int, tags = [@t/outdated]}
        "random_teleports" = :Key {types = #bool}
        "randomTeleports" = :Key {types = #bool, tags = [@t/outdated]}
        "target_distance" = :Key {types = @temp/decimal}
        "targetDistance" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "target_teleport_chance" = :Key {types = @temp/decimal}
    }
}
component.tick_world inherit temp/SortedKeymap {
    keys = {
        "distance_to_players" = :Key {types = @temp/decimal}
        "never_despawn" = :Key {types = #bool}
        "radius" = :Key {types = #int}
    }
}
component.timer inherit temp/SortedKeymap {
    keys = {
        "looping" = :Key {types = #bool}
        "randomInterval" = :Key {types = #bool}
        "random_time_choices" = :Key {types = #list, structure = @component.timer:random_time_choices}
        "time" = :Key {types = [@temp/decimal, #dict, #list], structure = @range_decimal_or_decimal}
        "time_down_event" = :Key {types = #dict, structure = @event_target}
    }
}
component.timer:random_time_choices inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @component.timer:random_time_choices.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "choice", "show_item_key" = false, "measure_length" = true}
    }
}
component.timer:random_time_choices.item inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = #int}
        "weight" = :Key {types = #int}
    }
}
component.trade_table inherit temp/SortedKeymap {
    keys = {
        "convert_trades_economy" = :Key {types = #bool}
        "display_name" = :Key {types = #str}
        "new_screen" = :Key {types = #bool}
        "persist_trades" = :Key {types = #bool}
        "table" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
component.trail inherit temp/SortedKeymap {
    keys = {
        "block_type" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "spawn_filter" = :Key {types = #dict, structure = @filter}
        "spawn_offset" = :Key {types = #list, structure = @vector_decimal}
    }
}
component.transformation inherit temp/SortedKeymap {
    keys = {
        "add" = :Key {types = #list, structure = @component.transformation:add}
        "begin_transform_sound" = :Key {types = #str}
        "delay" = :Key {types = [@temp/decimal, #dict], structure = @component.transformation:delay_group}
        "drop_equipment" = :Key {types = #bool}
        "drop_inventory" = :Key {types = #bool}
        "into" = :Key {types = #str}
        "keep_level" = :Key {types = #bool}
        "keep_owner" = :Key {types = #bool}
        "preserve_equipment" = :Key {types = #bool}
        "transformation_sound" = :Key {types = #str}
    }
}
component.transformation:add inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    allow_same_key_optimization = true
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "component group", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
component.transformation:delay_group :Union {
    substructures = [
        :Key {types = @temp/decimal},
        :Key {types = #dict, structure = @component.transformation:delay},
    ]
}
component.transformation:delay inherit temp/SortedKeymap {
    keys = {
        "block_assist_chance" = :Key {types = @temp/decimal}
        "block_chance" = :Key {types = @temp/decimal}
        "block_max" = :Key {types = #int}
        "block_radius" = :Key {types = #int}
        "block_types" = :Key {types = #list, structure = @block_list}
        "range_max" = :Key {types = @temp/decimal}
        "range_min" = :Key {types = @temp/decimal}
        "value" = :Key {types = @temp/decimal}
    }
}
component.trusting inherit temp/SortedKeymap {
    keys = {
        "probability" = :Key {types = @temp/decimal}
        "trust_event" = :Key {types = [#dict, #str], structure = @event_target_or_str}
        "trust_items" = :Key {types = #list, structure = @item_list}
    }
}
component.type_family inherit temp/SortedKeymap {
    keys = {
        "family" = :Key {types = [#list, #str], structure = @component.type_family:family_group}
    }
}
component.type_family:family_group :Union {
    substructures = [
        :Key {types = #list, structure = @component.type_family:family},
        :Key {types = #str},
    ]
}
component.type_family:family inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "family", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
component.underwater_movement inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = @temp/decimal}
    }
}
component.variant inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = #int}
    }
}
component.walk_animation_speed inherit temp/SortedKeymap {
    keys = {
        "value" = :Key {types = @temp/decimal}
    }
}
component.water_movement inherit temp/SortedKeymap {
    keys = {
        "drag_factor" = :Key {types = @temp/decimal}
    }
}
component.wind_burst inherit temp/SortedKeymap {
    keys = {
        "knockback_scaling" = :Key {types = @temp/decimal}
        "negates_fall_damage" = :Key {types = #bool}
        "particle_effect" = :Key {types = #str}
        "radius" = :Key {types = @temp/decimal}
        "sound_effect" = :Key {types = #str}
    }
}
component.variable_max_auto_step inherit temp/SortedKeymap {
    keys = {
        "base_value" = :Key {types = @temp/decimal}
        "controlled_value" = :Key {types = @temp/decimal}
        "jump_prevented_value" = :Key {types = @temp/decimal}
    }
}
component.vertical_movement_action inherit temp/SortedKeymap {
    keys = {
        "vertical_velocity" = :Key {types = @temp/decimal}
    }
}
component.wither_target_highest_damage inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
component.zombie.spawn_reinforcements inherit temp/SortedKeymap {
    keys = {
        "max" = :Key {types = #int}
        "value" = :Key {types = #int}
    }
}
behavior.admire_item inherit temp/SortedKeymap {
    keys = {
        "admire_item_sound" = :Key {types = #str}
        "sound_interval" = :Key {types = @range, structure = @range_group_decimal}
        "on_admire_item_start" = :Key {types = @trigger_type, structure = @trigger}
        "on_admire_item_stop" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
    }
}
behavior.avoid_block inherit temp/SortedKeymap {
    keys = {
        "avoid_block_sound" = :Key {types = #str}
        "on_escape" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "sound_interval" = :Key {types = @range, structure = @range_group_decimal}
        "sprint_speed_modifier" = :Key {types = @temp/decimal}
        "target_blocks" = :Key {types = #list, structure = @block_list}
        "target_selection_method" = :Key {types = #str}
        "tick_interval" = :Key {types = #int}
        "walk_speed_modifier" = :Key {types = @temp/decimal}
    }
}
behavior.avoid_mob_type inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "avoid_mob_sound" = :Key {types = #str}
        "avoid_target_xz" = :Key {types = #int}
        "avoid_target_y" = :Key {types = #int}
        "avoid_types" = :Key {types = #list, structure = @entity_list, tags = [@t/outdated]}
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "ignore_visibility" = :Key {types = #bool}
        "max_dist" = :Key {types = @temp/decimal}
        "max_flee" = :Key {types = @temp/decimal}
        "on_escape_event" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "probability_per_strength" = :Key {types = @temp/decimal}
        "remove_target" = :Key {types = #bool}
        "sound_interval" = :Key {types = @range, structure = @range_group_decimal}
        "sprint_distance" = :Key {types = @temp/decimal}
        "sprint_speed_multiplier" = :Key {types = @temp/decimal}
        "walk_speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.barter inherit temp/SortedKeymap {
    keys = {
        "goal_radius" = :Key {types = #int, tags = [@t/outdated]}
        "max_dist" = :Key {types = #int, tags = [@t/outdated]}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal, tags = [@t/outdated]}
    }
}
behavior.beg inherit temp/SortedKeymap {
    keys = {
        "items" = :Key {types = #list, structure = @item_list}
        "look_distance" = :Key {types = @temp/decimal}
        "look_time" = :Key {types = @range, structure = @range_group_decimal}
        "priority" = :Key {types = #int}
    }
}
behavior.break_door inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.breathe_air inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.breed inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "speed_modifier" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.casting_spell_goal inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.celebrate inherit temp/SortedKeymap {
    keys = {
        "celebration_sound" = :Key {types = #str}
        "duration" = :Key {types = @temp/decimal}
        "jump_interval" = :Key {types = @range, structure = @range_group_decimal}
        "on_celebration_end_event" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "sound_interval" = :Key {types = @range, structure = @range_group_decimal}
    }
}
behavior.celebrate_survive inherit temp/SortedKeymap {
    keys = {
        "celebration_sound" = :Key {types = #str}
        "duration" = :Key {types = @temp/decimal}
        "fireworks_interval" = :Key {types = @range, structure = @range_group_decimal, tags = [@t/not_in_documentation]}
        "jump_interval" = :Key {types = @range, structure = @range_group_decimal}
        "on_celebration_end_event" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "sound_interval" = :Key {types = @range, structure = @range_group_decimal}
    }
}
behavior.charge_attack inherit temp/SortedKeymap {
    keys = {
        "max_distance" = :Key {types = @temp/decimal}
        "min_distance" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "success_rate" = :Key {types = @temp/decimal}
    }
}
behavior.charge_held_item inherit temp/SortedKeymap {
    keys = {
        "items" = :Key {types = #list, structure = @item_list}
        "priority" = :Key {types = #int}
    }
}
behavior.circle_around_anchor inherit temp/SortedKeymap {
    keys = {
        "angle_change" = :Key {types = @temp/decimal}
        "goal_radius" = :Key {types = @temp/decimal}
        "height_above_target_range" = :Key {types = @range, structure = @range_group_decimal}
        "height_adjustment_chance" = :Key {types = @temp/decimal}
        "height_change_chance" = :Key {types = @temp/decimal, tags = [@t/deprecated]}
        "height_offset_range" = :Key {types = @range, structure = @range_group_decimal}
        "priority" = :Key {types = #int}
        "radius_adjustment_chance" = :Key {types = @temp/decimal}
        "radius_change_chance" = :Key {types = @temp/decimal, tags = [@t/deprecated]}
        "radius_change" = :Key {types = @temp/decimal}
        "radius_range" = :Key {types = @range, structure = @range_group_decimal}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.controlled_by_player inherit temp/SortedKeymap {
    keys = {
        "fractional_rotation" = :Key {types = @temp/decimal}
        "fractional_rotation_limit" = :Key {types = @temp/decimal}
        "mount_speed_multiplier" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
    }
}
behavior.croak inherit temp/SortedKeymap {
    keys = {
        "duration" = :Key {types = [@temp/decimal, @range], structure = @range_decimal_or_decimal}
        "filters" = :Key {types = #dict, structure = @filter}
        "interval" = :Key {types = @range, structure = @range_group_decimal}
        "priority" = :Key {types = #int}
    }
}
behavior.defend_trusted_target inherit temp/SortedKeymap {
    keys = {
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "aggro_sound" = :Key {types = #str}
        "attack_interval" = :Key {types = #int}
        "cooldown" = :Key {types = @temp/decimal}
        "must_see" = :Key {types = #bool}
        "must_see_forget_duration" = :Key {types = @temp/decimal}
        "reevaluate_description" = :Key {types = #bool}
        "on_defend_start" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "sound_chance" = :Key {types = @temp/decimal}
        "within_radius" = :Key {types = @temp/decimal}
    }
}
behavior.defend_village_target inherit temp/SortedKeymap {
    keys = {
        "attack_chance" = :Key {types = @temp/decimal}
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "must_reach" = :Key {types = #bool}
        "priority" = :Key {types = #int}
    }
}
behavior.delayed_attack inherit temp/SortedKeymap {
    keys = {
        "attack_duration" = :Key {types = @temp/decimal}
        "attack_once" = :Key {types = #bool}
        "attack_types" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "cooldown_time" = :Key {types = @temp/decimal}
        "hit_delay_pct" = :Key {types = @temp/decimal}
        "inner_boundary_time_increase" = :Key {types = @temp/decimal}
        "max_dist" = :Key {types = @temp/decimal}
        "max_path_time" = :Key {types = @temp/decimal}
        "melee_fov" = :Key {types = @temp/decimal}
        "min_path_time" = :Key {types = @temp/decimal}
        "on_attack" = :Key {types = @trigger_type, structure = @trigger}
        "outer_boundary_time_increase" = :Key {types = @temp/decimal}
        "path_fail_time_increase" = :Key {types = @temp/decimal}
        "path_inner_boundary" = :Key {types = @temp/decimal}
        "path_outer_boundary" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "random_stop_interval" = :Key {types = #int}
        "reach_multiplier" = :Key {types = @temp/decimal}
        "require_complete_path" = :Key {types = #bool}
        "set_persistent" = :Key {types = #bool}
        "sound_event" = :Key {types = #str, tags = [@t/outdated]}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "target_dist" = :Key {types = @temp/decimal, tags = [@t/unused]}
        "track_target" = :Key {types = #bool}
        "x_max_rotation" = :Key {types = @temp/decimal}
        "y_max_head_rotation" = :Key {types = @temp/decimal}
    }
}
behavior.dig inherit temp/SortedKeymap {
    keys = {
        "allow_dig_when_named" = :Key {types = #bool}
        "digs_in_daylight" = :Key {types = #bool}
        "duration" = :Key {types = @temp/decimal}
        "idle_time" = :Key {types = @temp/decimal}
        "on_start" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "suspicion_is_disturbance" = :Key {types = #bool}
        "vibration_is_disturbance" = :Key {types = #bool}
    }
}
behavior.drink_milk inherit temp/SortedKeymap {
    keys = {
        "cooldown_seconds" = :Key {types = @temp/decimal}
        "filters" = :Key {types = #dict, structure = @filter}
        "priority" = :Key {types = #int}
    }
}
behavior.door_interact inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.dragonchargeplayer inherit temp/SortedKeymap {
    keys = {
        "active_speed" = :Key {types = @temp/decimal}
        "continue_charge_threshold_time" = :Key {types = @temp/decimal}
        "flight_speed" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "target_zone" = :Key {types = @range, structure = @range_group_decimal}
        "turn_speed" = :Key {types = @temp/decimal}
    }
}
behavior.dragondeath inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.dragonflaming inherit temp/SortedKeymap {
    keys = {
        "cooldown_time" = :Key {types = @temp/decimal}
        "flame_time" = :Key {types = @temp/decimal}
        "ground_flame_count" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "roar_time" = :Key {types = @temp/decimal}
    }
}
behavior.dragonholdingpattern inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.dragonlanding inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.dragonscanning inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.dragonstrafeplayer inherit temp/SortedKeymap {
    keys = {
        "active_speed" = :Key {types = @temp/decimal}
        "fireball_range" = :Key {types = @temp/decimal}
        "flight_speed" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "switch_direction_probability" = :Key {types = @temp/decimal}
        "target_in_range_and_in_view_time" = :Key {types = @temp/decimal}
        "target_zone" = :Key {types = @range, structure = @range_group_decimal}
        "turn_speed" = :Key {types = @temp/decimal}
        "view_angle" = :Key {types = @temp/decimal}
    }
}
behavior.dragontakeoff inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.drink_potion inherit temp/SortedKeymap {
    keys = {
        "potions" = :Key {types = #list, structure = @behavior.drink_potion:potions}
        "priority" = :Key {types = #int}
        "speed_modifier" = :Key {types = @temp/decimal}
    }
}
behavior.drink_potion:potions inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @behavior.drink_potion:potions.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "potion", "show_item_key" = false, "measure_length" = true}
    }
}
behavior.drink_potion:potions.item inherit temp/SortedKeymap {
    keys = {
        "chance" = :Key {types = @temp/decimal}
        "filters" = :Key {types = #dict, structure = @filter}
        "id" = :Key {types = #int, delegate_arguments = {"always_print" = true}}
    }
}
behavior.drop_item_for inherit temp/SortedKeymap {
    keys = {
        "cooldown" = :Key {types = @temp/decimal}
        "drop_item_chance" = :Key {types = @temp/decimal}
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "goal_radius" = :Key {types = @temp/decimal}
        "loot_table" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "max_dist" = :Key {types = #int, tags = [@t/outdated]}
        "max_head_look_at_height" = :Key {types = @temp/decimal}
        "minimum_teleport_distance" = :Key {types = @temp/decimal}
        "offering_distance" = :Key {types = @temp/decimal}
        "on_drop_attempt" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "search_count" = :Key {types = #int}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "seconds_before_pickup" = :Key {types = @temp/decimal}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "target_range" = :Key {types = #list, structure = @vector_decimal}
        "teleport_offset" = :Key {types = #list, structure = @vector_decimal}
        "time_of_day_range" = :Key {types = @range, structure = @range_group_decimal}
    }
}
behavior.eat_block inherit temp/SortedKeymap {
    keys = {
        "eat_and_replace_block_pairs" = :Key {types = #list, structure = @behavior.eat_block:eat_and_replace_block_pairs}
        "on_eat" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "success_chance" = :Key {types = #str}
        "time_until_eat" = :Key {types = @temp/decimal}
    }
}
behavior.eat_block:eat_and_replace_block_pairs inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_structure = @behavior.eat_block:eat_and_replace_block_pairs.item
    value_types = #dict
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"measure_length" = true, "show_item_key" = false, "field" = "block pair"}
    }
}
behavior.eat_block:eat_and_replace_block_pairs.item inherit temp/SortedKeymap {
    keys = {
        "eat_block" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "replace_block" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
    }
}
behavior.eat_carried_item inherit temp/SortedKeymap {
    keys = {
        "delay_before_eating" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
    }
}
behavior.eat_mob inherit temp/SortedKeymap {
    keys = {
        "eat_animation_time" = :Key {types = @temp/decimal}
        "eat_mob_sound" = :Key {types = #str}
        "item_drop" = :Key {types = #str, tags = [@t/outdated]}
        "loot_table" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "mob_loot" = :Key {types = #list, structure = @behavior.eat_mob:mob_loot, tags = [@t/outdated]}
        "priority" = :Key {types = #int}
        "pull_in_force" = :Key {types = @temp/decimal}
        "reach_mob_distance" = :Key {types = @temp/decimal}
        "run_speed" = :Key {types = @temp/decimal}
    }
}
behavior.eat_mob:mob_loot inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @behavior.eat_mob:mob_loot.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "mob", "show_item_key" = false, "measure_length" = true}
    }
}
behavior.eat_mob:mob_loot.item inherit temp/SortedKeymap {
    keys = {
        "loot" = :Key {types = #str, delegate_arguments = {"always_print" = true}, structure = @temp/string}
        "mob" = :Key {types = #str, delegate_arguments = {"always_print" = true}, structure = @temp/string}
    }
}
behavior.emerge inherit temp/SortedKeymap {
    keys = {
        "cooldown_time" = :Key {types = #int}
        "duration" = :Key {types = @temp/decimal}
        "on_done" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
    }
}
behavior.enderman_leave_block inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.enderman_take_block inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.equip_item inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.execute_command inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.explore_outskirts inherit temp/SortedKeymap {
    keys = {
        "dist_from_boundary" = :Key {types = #list, structure = @vector_decimal}
        "explore_dist" = :Key {types = @temp/decimal}
        "max_travel_time" = :Key {types = @temp/decimal}
        "max_wait_time" = :Key {types = @temp/decimal}
        "min_dist_from_target" = :Key {types = @temp/decimal}
        "min_perimeter" = :Key {types = @temp/decimal}
        "min_wait_time" = :Key {types = @temp/decimal}
        "next_xz" = :Key {types = #int}
        "next_y" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "timer_ratio" = :Key {types = @temp/decimal}
        "wait_time" = :Key {types = #int, tags = [@t/outdated]}
    }
}
behavior.feeling_happy inherit temp/SortedKeymap {
    keys = {
        "cooldown_range" = :Key {types = @temp/decimal}
        "duration_range" = :Key {types = @range, structure = @range_group_decimal}
        "on_end" = :Key {types = #dict, structure = @event_target}
        "priority" = :Key {types = #int}
    }
}
behavior.fertilize_farm_block inherit temp/SortedKeymap {
    keys = {
        "goal_radius" = :Key {types = @temp/decimal}
        "max_fertilizer_usage" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "search_cooldown_max_seconds" = :Key {types = @temp/decimal}
        "search_count" = :Key {types = #int}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.find_cover inherit temp/SortedKeymap {
    keys = {
        "cooldown_time" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.find_mount inherit temp/SortedKeymap {
    keys = {
        "avoid_water" = :Key {types = #bool}
        "max_failed_attempts" = :Key {types = #int, tags = [@t/not_in_documentation]}
        "mount_distance" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "start_delay" = :Key {types = #int}
        "target_needed" = :Key {types = #bool}
        "within_radius" = :Key {types = @temp/decimal}
    }
}
behavior.find_underwater_treasure inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "stop_distance" = :Key {types = @temp/decimal}
    }
}
behavior.fire_at_target inherit temp/SortedKeymap {
    keys = {
        "attack_cooldown" = :Key {types = @temp/decimal}
        "attack_range" = :Key {types = @range, structure = @range_group_int}
        "filters" = :Key {types = #dict, structure = @filter}
        "owner_anchor" = :Key {types = #int}
        "owner_offset" = :Key {types = #list, structure = @vector_decimal}
        "post_shoot_delay" = :Key {types = @temp/decimal}
        "pre_shoot_delay" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "projectile_def" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "ranged_fov" = :Key {types = @temp/decimal}
        "target_anchor" = :Key {types = #int}
        "target_offset" = :Key {types = #list, structure = @vector_decimal}
    }
}
behavior.flee_sun inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.float inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "sink_with_passengers" = :Key {types = #bool}
    }
}
behavior.float_tempt inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "can_tempt_vertically" = :Key {types = #bool}
        "items" = :Key {types = #list, structure = @item_list}
        "within_radius" = :Key {types = #int}
        "stop_distance" = :Key {types = #int}
        "on_tempt_end" = :Key {types = #dict, structure = @event}
    }
}
behavior.float_wander inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "additional_collision_buffer" = :Key {types = #bool}
        "allow_navigating_through_liquids" = :Key {types = #bool}
        "float_duration" = :Key {types = @range, structure = @range_group_decimal}
        "float_wander_has_move_control" = :Key {types = #bool}
        "must_reach" = :Key {types = #bool}
        "navigate_around_surface" = :Key {types = #bool}
        "priority" = :Key {types = #int}
        "random_reselect" = :Key {types = #bool}
        "surface_xz_dist" = :Key {types = #int}
        "surface_y_dist" = :Key {types = #int}
        "use_home_position_restriction" = :Key {types = #bool}
        "xz_dist" = :Key {types = #int}
        "xz_distance" = :Key {types = #int, tags = [@t/outdated]}
        "y_dist" = :Key {types = #int}
        "y_distance" = :Key {types = #int, tags = [@t/outdated]}
        "y_offset" = :Key {types = @temp/decimal}
    }
}
behavior.follow_caravan inherit temp/SortedKeymap {
    keys = {
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "entity_count" = :Key {types = #int}
        "cooldown" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "filters" = :Key {types = #dict, structure = @filter}
        "max_dist" = :Key {types = @temp/decimal}
        "must_see" = :Key {types = #bool}
        "must_see_forget_duration" = :Key {types = @temp/decimal}
        "reevaluate_description" = :Key {types = #bool}
        "sprint_speed_multiplier" = :Key {types = @temp/decimal}
        "walk_speed_multiplier" = :Key {types = @temp/decimal}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.follow_flock inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.follow_mob inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "filters" = :Key {types = [#dict, #list], structure = @filter_or_filter_list}
        "preferred_actor_type" = :Key {types = #str}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "stop_distance" = :Key {types = @temp/decimal}
        "use_home_position_restriction" = :Key {types = #bool}
    }
}
behavior.follow_owner inherit temp/SortedKeymap {
    keys = {
        "can_teleport" = :Key {types = #bool}
        "ignore_vibration" = :Key {types = #bool}
        "max_distance" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "start_distance" = :Key {types = @temp/decimal}
        "stop_distance" = :Key {types = @temp/decimal}
    }
}
behavior.follow_parent inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "speed_modifier" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.follow_target_captain inherit temp/SortedKeymap {
    keys = {
        "follow_distance" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "within_radius" = :Key {types = @temp/decimal}
    }
}
behavior.go_and_give_item_to_noteblock inherit temp/SortedKeymap {
    keys = {
        "listen_time" = :Key {types = @temp/decimal}
        "on_item_throw" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "reach_block_distance" = :Key {types = @temp/decimal}
        "run_speed" = :Key {types = @temp/decimal}
        "throw_force" = :Key {types = @temp/decimal}
        "throw_sound" = :Key {types = #str}
        "vertical_throw_mul" = :Key {types = @temp/decimal}
    }
}
behavior.go_and_give_item_to_owner inherit temp/SortedKeymap {
    keys = {
        "on_item_throw" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "reach_mob_distance" = :Key {types = @temp/decimal}
        "run_speed" = :Key {types = @temp/decimal}
        "throw_force" = :Key {types = @temp/decimal}
        "throw_sound" = :Key {types = #str}
        "vertical_throw_mul" = :Key {types = @temp/decimal}
    }
}
behavior.go_home inherit temp/SortedKeymap {
    keys = {
        "calculate_new_path_radius" = :Key {types = @temp/decimal}
        "goal_radius" = :Key {types = @temp/decimal}
        "interval" = :Key {types = #int}
        "on_failed" = :Key {types = @trigger_type, structure = @trigger}
        "on_home" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.guardian_attack inherit temp/SortedKeymap {
    keys = {
        "elder_extra_magic_damage" = :Key {types = #int}
        "hard_mode_extra_magic_damage" = :Key {types = #int}
        "magic_damage" = :Key {types = #int}
        "min_distance" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "sound_delay_time" = :Key {types = @temp/decimal}
        "x_max_rotation" = :Key {types = @temp/decimal}
        "y_max_rotation" = :Key {types = @temp/decimal}
    }
}
behavior.harvest_farm_block inherit temp/SortedKeymap {
    keys = {
        "goal_radius" = :Key {types = @temp/decimal}
        "max_seconds_before_search" = :Key {types = @temp/decimal}
        "search_cooldown_max_seconds" = :Key {types = @temp/decimal}
        "search_count" = :Key {types = #int}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "seconds_until_new_task" = :Key {types = @temp/decimal}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
    }
}
behavior.hide inherit temp/SortedKeymap {
    keys = {
        "duration" = :Key {types = @temp/decimal}
        "poi_type" = :Key {types = #str}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "timeout_cooldown" = :Key {types = @temp/decimal}
    }
}
behavior.hold_ground inherit temp/SortedKeymap {
    keys = {
        "broadcast" = :Key {types = #bool}
        "broadcast_range" = :Key {types = @temp/decimal}
        "hurt_by_target_event" = :Key {types = #dict, structure = @event_target, tags = [@t/outdated]}
        "min_radius" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "within_radius_event" = :Key {types = #dict, structure = @event_target}
    }
}
behavior.hurt_by_target inherit temp/SortedKeymap {
    keys = {
        "alert_same_type" = :Key {types = #bool}
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "cooldown" = :Key {types = @temp/decimal}
        "filters" = :Key {types = #dict, structure = @filter}
        "max_dist" = :Key {types = @temp/decimal}
        "must_see" = :Key {types = #bool}
        "must_see_forget_duration" = :Key {types = @temp/decimal}
        "not_entity_types" = :Key {types = [#list, #str], structure = @entity_list_or_entity, tags = [@t/outdated]}
        "reevaluate_description" = :Key {types = #bool}
        "sprint_speed_multiplier" = :Key {types = @temp/decimal}
        "walk_speed_multiplier" = :Key {types = @temp/decimal}
        "hurt_owner" = :Key {types = #bool}
        "priority" = :Key {types = #int}
    }
}
behavior.inspect_bookshelf inherit temp/SortedKeymap {
    keys = {
        "goal_radius" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "search_count" = :Key {types = #int}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.investigate_suspicious_location inherit temp/SortedKeymap {
    keys = {
        "goal_radius" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.jump_around_target inherit temp/SortedKeymap {
    keys = {
        "check_collision" = :Key {types = #bool}
        "entity_bounding_box_scale" = :Key {types = @temp/decimal}
        "filters" = :Key {types = #dict, structure = @filter}
        "jump_angles" = :Key {types = #list, structure = @behavior.jump_around_target:jump_angles}
        "jump_cooldown_duration" = :Key {types = @temp/decimal}
        "jump_cooldown_when_hurt_duration" = :Key {types = @temp/decimal}
        "landing_distance_from_target" = :Key {types = @range, structure = @range_group_decimal}
        "landing_position_spread_degrees" = :Key {types = @temp/decimal}
        "last_hurt_duration" = :Key {types = @temp/decimal}
        "line_of_sight_obstruction_height_ignore" = :Key {types = #int}
        "max_jump_velocity" = :Key {types = @temp/decimal}
        "prepare_jump_duration" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "required_vertical_space" = :Key {types = #int}
        "snap_to_surface_block_range" = :Key {types = #int}
        "valid_distance_to_target" = :Key {types = @range, structure = @range_group_decimal}
    }
}
behavior.jump_around_target:jump_angles inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = @temp/decimal
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "angle", "show_item_key" = false, "sort" = %sort_by_value, "measure_length" = true}
    }
}
behavior.jump_to_block inherit temp/SortedKeymap {
    keys = {
        "cooldown_range" = :Key {types = @range, structure = @range_group_decimal}
        "forbidden_blocks" = :Key {types = #list, structure = @block_list}
        "max_velocity" = :Key {types = @temp/decimal}
        "minimum_distance" = :Key {types = #int}
        "minimum_path_length" = :Key {types = #int}
        "preferred_blocks" = :Key {types = #list, structure = @block_list}
        "preferred_blocks_chance" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "scale_factor" = :Key {types = @temp/decimal}
        "search_height" = :Key {types = #int}
        "search_width" = :Key {types = #int}
    }
}
behavior.knockback_roar inherit temp/SortedKeymap {
    keys = {
        "attack_time" = :Key {types = @temp/decimal}
        "cooldown_time" = :Key {types = @temp/decimal}
        "damage_filters" = :Key {types = #dict, structure = @filter}
        "duration" = :Key {types = @temp/decimal}
        "knockback_damage" = :Key {types = #int}
        "knockback_filters" = :Key {types = #dict, structure = @filter}
        "knockback_height_cap" = :Key {types = @temp/decimal}
        "knockback_horizontal_strength" = :Key {types = #int}
        "knockback_range" = :Key {types = #int}
        "knockback_strength" = :Key {types = #int, tags = [@t/outdated]}
        "knockback_vertical_strength" = :Key {types = #int}
        "on_roar_end" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
    }
}
behavior.lay_down inherit temp/SortedKeymap {
    keys = {
        "interval" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "random_stop_interval" = :Key {types = #int}
    }
}
behavior.lay_egg inherit temp/SortedKeymap {
    keys = {
        "allow_laying_from_below" = :Key {types = #bool}
        "egg_type" = :Key {types = #str}
        "goal_radius" = :Key {types = @temp/decimal}
        "lay_egg_sound" = :Key {types = #str}
        "lay_seconds" = :Key {types = @temp/decimal}
        "on_lay" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "target_blocks" = :Key {types = #list, structure = @block_list}
        "target_materials_above_block" = :Key {types = #list, structure = @block_list}
        "use_default_animation" = :Key {types = #bool}
    }
}
behavior.leap_at_target inherit temp/SortedKeymap {
    keys = {
        "must_be_on_ground" = :Key {types = #bool}
        "priority" = :Key {types = #int}
        "set_persistent" = :Key {types = #bool}
        "target_dist" = :Key {types = @temp/decimal}
        "yd" = :Key {types = @temp/decimal}
    }
}
behavior.look_at_entity inherit temp/SortedKeymap {
    keys = {
        "angle_of_view_horizontal" = :Key {types = #int}
        "angle_of_view_vertical" = :Key {types = #int}
        "filters" = :Key {types = #dict, structure = @filter}
        "look_distance" = :Key {types = @temp/decimal}
        "look_time" = :Key {types = @range, structure = @range_group_decimal}
        "priority" = :Key {types = #int, tags = [@t/not_in_documentation]}
        "probability" = :Key {types = @temp/decimal}
    }
}
behavior.look_at_player inherit temp/SortedKeymap {
    keys = {
        "angle_of_view_horizontal" = :Key {types = #int}
        "angle_of_view_vertical" = :Key {types = #int}
        "look_distance" = :Key {types = @temp/decimal}
        "look_time" = :Key {types = @range, structure = @range_group_decimal}
        "max_look_time" = :Key {types = #int}
        "min_look_time" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "probability" = :Key {types = @temp/decimal}
        "target_distance" = :Key {types = @temp/decimal}
    }
}
behavior.look_at_target inherit temp/SortedKeymap {
    keys = {
        "angle_of_view_horizontal" = :Key {types = #int}
        "angle_of_view_vertical" = :Key {types = #int}
        "look_distance" = :Key {types = @temp/decimal}
        "look_time" = :Key {types = @range, structure = @range_group_decimal}
        "priority" = :Key {types = #int}
        "probability" = :Key {types = @temp/decimal}
    }
}
behavior.look_at_trading_player inherit temp/SortedKeymap {
    keys = {
        "angle_of_view_horizontal" = :Key {types = #int}
        "angle_of_view_vertical" = :Key {types = #int}
        "look_distance" = :Key {types = @temp/decimal}
        "look_time" = :Key {types = @range, structure = @range_group_decimal}
        "priority" = :Key {types = #int}
        "probability" = :Key {types = @temp/decimal}
    }
}
behavior.make_love inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.melee_attack inherit temp/SortedKeymap {
    keys = {
        "attack_once" = :Key {types = #bool}
        "attack_types" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "can_spread_on_fire" = :Key {types = #bool, tags = [@t/outdated]}
        "cooldown_time" = :Key {types = @temp/decimal}
        "inner_boundary_time_increase" = :Key {types = @temp/decimal}
        "look_distance" = :Key {types = #int, tags = [@t/outdated]}
        "max_dist" = :Key {types = @temp/decimal, tags = [@t/unused]}
        "max_path_time" = :Key {types = @temp/decimal}
        "melee_fov" = :Key {types = @temp/decimal}
        "min_path_time" = :Key {types = @temp/decimal}
        "on_attack" = :Key {types = @trigger_type, structure = @trigger}
        "on_kill" = :Key {types = @trigger_type, structure = @trigger}
        "outer_boundary_time_increase" = :Key {types = @temp/decimal}
        "path_fail_time_increase" = :Key {types = @temp/decimal}
        "path_inner_boundary" = :Key {types = @temp/decimal}
        "path_outer_boundary" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "random_stop_interval" = :Key {types = @temp/decimal}
        "reach_multiplier" = :Key {types = @temp/decimal}
        "require_complete_path" = :Key {types = #bool}
        "set_persistent" = :Key {types = #bool}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "target_dist" = :Key {types = @temp/decimal, tags = [@t/unused]}
        "target_tracking" = :Key {types = #dict, structure = @behavior.melee_attack:target_tracking, tags = [@t/outdated]}
        "track_target" = :Key {types = #bool}
        "untrackable_cooldown_delay" = :Key {types = #int, tags = [@t/outdated]}
        "x_max_rotation" = :Key {types = @temp/decimal}
        "y_max_head_rotation" = :Key {types = @temp/decimal}
    }
}
behavior.melee_attack:target_tracking inherit temp/SortedKeymap {
    keys = {
        "backoff" = :Key {types = #list, structure = @behavior.melee_attack:target_tracking.backoff}
        "refresh_period_max" = :Key {types = #int}
        "refresh_period_min" = :Key {types = #int}
    }
}
behavior.melee_attack:target_tracking.backoff inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @behavior.melee_attack:target_tracking.backoff.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "backoff", "show_item_key" = false, "measure_length" = true}
    }
}
behavior.melee_attack:target_tracking.backoff.item inherit temp/SortedKeymap {
    keys = {
        "distance_squared_gt" = :Key {types = #int}
        "refresh_period_delta" = :Key {types = #int}
    }
}
behavior.melee_box_attack inherit temp/SortedKeymap {
    keys = {
        "attack_once" = :Key {types = #bool}
        "attack_types" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "can_spread_on_fire" = :Key {types = #bool}
        "cooldown_time" = :Key {types = @temp/decimal}
        "horizontal_reach" = :Key {types = @temp/decimal}
        "inner_boundary_time_increase" = :Key {types = @temp/decimal}
        "max_dist" = :Key {types = @temp/decimal, tags = [@t/unused]}
        "max_path_time" = :Key {types = @temp/decimal}
        "melee_fov" = :Key {types = @temp/decimal}
        "min_path_time" = :Key {types = @temp/decimal}
        "on_attack" = :Key {types = @trigger_type, structure = @trigger}
        "on_kill" = :Key {types = @trigger_type, structure = @trigger, tags = [@t/not_in_documentation]}
        "outer_boundary_time_increase" = :Key {types = @temp/decimal}
        "path_fail_time_increase" = :Key {types = @temp/decimal}
        "path_inner_boundary" = :Key {types = @temp/decimal}
        "path_outer_boundary" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "random_stop_interval" = :Key {types = #int}
        "reach_multiplier" = :Key {types = @temp/decimal}
        "require_complete_path" = :Key {types = #bool}
        "set_persistent" = :Key {types = #bool}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "target_dist" = :Key {types = @temp/decimal, tags = [@t/unused]}
        "track_target" = :Key {types = #bool}
        "x_max_rotation" = :Key {types = @temp/decimal}
        "y_max_head_rotation" = :Key {types = @temp/decimal}
    }
}
behavior.mingle inherit temp/SortedKeymap {
    keys = {
        "cooldown_time" = :Key {types = @temp/decimal}
        "duration" = :Key {types = @temp/decimal}
        "mingle_distance" = :Key {types = @temp/decimal}
        "mingle_partner_type" = :Key {types = [#list, #str], structure = @entity_list_or_entity}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.mount_pathing inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "target_dist" = :Key {types = @temp/decimal}
        "track_target" = :Key {types = #bool}
    }
}
behavior.move_aorund_target inherit temp/SortedKeymap {
    keys = {
        "destination_pos_spread_degrees" = :Key {types = #int}
        "destination_position_range" = :Key {types = @range, structure = @range_group_decimal}
        "filters" = :Key {types = #dict, structure = @filter}
        "movement_speed" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
    }
}
behavior.move_away_from_target inherit temp/SortedKeymap {
    keys = {
        "destination_pos_spread_degrees" = :Key {types = #int}
        "destination_position_range" = :Key {types = @range, structure = @range_group_decimal}
        "filters" = :Key {types = #dict, structure = @filter}
        "movement_speed" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
    }
}
behavior.move_indoors inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "timeout_cooldown" = :Key {types = @temp/decimal}
    }
}
behavior.move_outdoors inherit temp/SortedKeymap {
    keys = {
        "goal_radius" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "search_count" = :Key {types = #int}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "timeout_cooldown" = :Key {types = @temp/decimal}
    }
}
behavior.move_through_village inherit temp/SortedKeymap {
    keys = {
        "only_at_night" = :Key {types = #bool}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.move_to_block inherit temp/SortedKeymap {
    keys = {
        "goal_radius" = :Key {types = @temp/decimal}
        "interval" = :Key {types = #int, tags = [@t/outdated]}
        "on_reach" = :Key {types = @trigger_type, structure = @trigger}
        "on_stay_completed" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "search_count" = :Key {types = #int, tags = [@t/outdated]}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "start_chance" = :Key {types = @temp/decimal}
        "stay_duration" = :Key {types = @temp/decimal}
        "target_block_filters" = :Key {types = #dict, structure = @filter, tags = [@t/not_in_documentation]}
        "target_blocks" = :Key {types = #list, structure = @block_list}
        "target_offset" = :Key {types = #list, structure = @vector_decimal}
        "target_selection_method" = :Key {types = #str}
        "tick_interval" = :Key {types = #int}
    }
}
behavior.move_to_land inherit temp/SortedKeymap {
    keys = {
        "goal_radius" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "search_count" = :Key {types = #int}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.move_to_lava inherit temp/SortedKeymap {
    keys = {
        "goal_radius" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "search_count" = :Key {types = #int}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.move_to_liquid inherit temp/SortedKeymap {
    keys = {
        "goal_radius" = :Key {types = @temp/decimal}
        "material_type" = :Key {types = #str}
        "priority" = :Key {types = #int}
        "search_count" = :Key {types = #int}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.move_to_random_block inherit temp/SortedKeymap {
    keys = {
        "block_distance" = :Key {types = @temp/decimal}
        "within_radius" = :Key {types = @temp/decimal}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
    }
}
behavior.move_to_village inherit temp/SortedKeymap {
    keys = {
        "cooldown_time" = :Key {types = @temp/decimal}
        "goal_radius" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.move_to_water inherit temp/SortedKeymap {
    keys = {
        "goal_radius" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "search_count" = :Key {types = #int}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.move_towards_dwelling_restriction inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.move_towards_home_restriction inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.move_towards_restriction inherit temp/SortedKeymap {
    keys = {
        "control_flags" = :Key {types = #list, structure = @behavior.move_towards_restriction:control_flags}
        "priority" = :Key {types = #int}
        "speed_modifier" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.move_towards_restriction:control_flags inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #str
    value_structure = null
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "control flag", "show_item_key" = false, "measure_length" = true, "print_flat" = true, "sort" = %sort_by_value, "print_all" = true}
    }
}
behavior.move_towards_target inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal, tags = [@t/not_in_documentation]}
        "within_radius" = :Key {types = @temp/decimal}
    }
}
behavior.nap inherit temp/SortedKeymap {
    keys = {
        "can_nap_filters" = :Key {types = #dict, structure = @filter, tags = [@t/not_in_documentation]}
        "cooldown_max" = :Key {types = @temp/decimal}
        "cooldown_min" = :Key {types = @temp/decimal}
        "mob_detect_dist" = :Key {types = @temp/decimal}
        "mob_detect_height" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "wake_mob_exceptions" = :Key {types = #dict, structure = @filter, tags = [@t/not_in_documentation]}
    }
}
behavior.nearest_attackable_target inherit temp/SortedKeymap {
    keys = {
        "attack_interval" = :Key {types = #int}
        "attack_interval_min" = :Key {types = @temp/decimal}
        "attack_owner" = :Key {types = #bool}
        "entity_types" = :Key {types = [#dict, #list, #str], structure = @behavior.nearest_attackable_target:entity_types}
        "must_reach" = :Key {types = #bool}
        "must_see" = :Key {types = #bool}
        "must_see_forget_duration" = :Key {types = @temp/decimal}
        "not_entity_types" = :Key {types = #str, tags = [@t/outdated]}
        "persist_time" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "reevaluate_description" = :Key {types = #bool}
        "reselect_targets" = :Key {types = #bool}
        "scan_interval" = :Key {types = #int}
        "set_persistent" = :Key {types = #bool}
        "target_invisible_multiplier" = :Key {types = @temp/decimal}
        "target_search_height" = :Key {types = @temp/decimal}
        "target_sneak_visibility_multiplier" = :Key {types = @temp/decimal}
        "within_default" = :Key {types = #int, tags = [@t/outdated]}
        "within_radius" = :Key {types = @temp/decimal}
    }
}
behavior.nearest_attackable_target:entity_types :Union {
    substructures = [
        :Key {types = #dict, structure = @entity_types.item},
        :Key {types = #list, structure = @entity_types.list},
        :Key {types = #str},
    ]
}
behavior.nearest_prioritized_attackable_target inherit temp/SortedKeymap {
    keys = {
        "attack_interval" = :Key {types = #int}
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "cooldown" = :Key {types = @temp/decimal}
        "must_reach" = :Key {types = #bool}
        "must_see" = :Key {types = #bool}
        "must_see_forget_duration" = :Key {types = @temp/decimal}
        "persist_time" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "reevaluate_description" = :Key {types = #bool}
        "reselect_targets" = :Key {types = #bool}
        "scan_interval" = :Key {types = #int}
        "set_persistent" = :Key {types = #bool}
        "target_search_height" = :Key {types = @temp/decimal}
        "within_radius" = :Key {types = @temp/decimal}
    }
}
behavior.ocelot_sit_on_block inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.ocelotattack inherit temp/SortedKeymap {
    keys = {
        "cooldown_time" = :Key {types = @temp/decimal}
        "max_distance" = :Key {types = @temp/decimal}
        "max_sneak_range" = :Key {types = @temp/decimal}
        "max_sprint_range" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "reach_multiplier" = :Key {types = @temp/decimal}
        "sneak_speed_multiplier" = :Key {types = @temp/decimal}
        "sprint_speed_multiplier" = :Key {types = @temp/decimal}
        "walk_speed_multiplier" = :Key {types = @temp/decimal}
        "x_max_rotation" = :Key {types = @temp/decimal}
        "y_max_head_rotation" = :Key {types = @temp/decimal}
    }
}
behavior.offer_flower inherit temp/SortedKeymap {
    keys = {
        "filters" = :Key {types = #dict, structure = @filter, tags = [@t/not_in_documentation]}
        "priority" = :Key {types = #int}
    }
}
behavior.open_door inherit temp/SortedKeymap {
    keys = {
        "close_door_after" = :Key {types = #bool}
        "priority" = :Key {types = #int}
    }
}
behavior.owner_hurt_by_target inherit temp/SortedKeymap {
    keys = {
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "cooldown" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "filters" = :Key {types = #dict, structure = @filter}
        "max_dist" = :Key {types = @temp/decimal}
        "must_see" = :Key {types = #bool}
        "must_see_forget_duration" = :Key {types = @temp/decimal}
        "reevaluate_description" = :Key {types = #bool}
        "sprint_speed_multiplier" = :Key {types = @temp/decimal}
        "walk_speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.owner_hurt_target inherit temp/SortedKeymap {
    keys = {
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "cooldown" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "filters" = :Key {types = #dict, structure = @filter}
        "max_dist" = :Key {types = @temp/decimal}
        "must_see" = :Key {types = #bool}
        "must_see_forget_duration" = :Key {types = @temp/decimal}
        "reevaluate_description" = :Key {types = #bool}
        "sprint_speed_multiplier" = :Key {types = @temp/decimal}
        "walk_speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.panic inherit temp/SortedKeymap {
    keys = {
        "damage_sources" = :Key {types = #list, structure = @damage_source_list}
        "force" = :Key {types = #bool}
        "ignore_mob_damage" = :Key {types = #bool}
        "panic_sound" = :Key {types = #str}
        "prefer_water" = :Key {types = #bool}
        "priority" = :Key {types = #int}
        "sound_interval" = :Key {types = @range, structure = @range_group_decimal}
        "speed_modifier" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.peek inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.pet_sleep_with_owner inherit temp/SortedKeymap {
    keys = {
        "goal_radius" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "search_height" = :Key {types = #int}
        "search_radius" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.pickup_items inherit temp/SortedKeymap {
    keys = {
        "can_pickup_any_item" = :Key {types = #bool}
        "can_pickup_to_hand_or_equipment" = :Key {types = #bool}
        "cooldown_after_being_attacked" = :Key {types = @temp/decimal}
        "excluded_items" = :Key {types = #list, structure = @item_list}
        "goal_radius" = :Key {types = @temp/decimal}
        "items" = :Key {types = #list, structure = @item_list, tags = [@t/outdated]}
        "max_dist" = :Key {types = @temp/decimal}
        "pickup_based_on_chance" = :Key {types = #bool}
        "pickup_same_items_as_in_hand" = :Key {types = #bool, tags = [@t/not_in_documentation]}
        "priority" = :Key {types = #int}
        "search_height" = :Key {types = #int, tags = [@t/not_in_documentation]}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "track_target" = :Key {types = #bool}
    }
}
behavior.pig_zombie_anger_target :Normalizer {
    outer_types = #dict
    inner_types = #dict
    functions = :Function {
        function = %delete_key
        arguments = {"key" = "priotiry"}
    }
    structure = inherit temp/SortedKeymap {
        keys = {
            "priority" = :Key {types = #int}
        }
    }
}
behavior.pig_zombie_hurt_by_other inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.place_block inherit temp/SortedKeymap {
    keys = {
        "affected_by_griefing_rule" = :Key {types = #bool}
        "on_place" = :Key {types = #dict, structure = @event_target}
        "priority" = :Key {types = #int}
        "xz_range" = :Key {types = #int}
        "y_range" = :Key {types = [#int, @range], structure = @range_int_or_int}
        "chance" = :Key {types = @temp/decimal}
        "randomly_placeable_blocks" = :Key {types = #list, structure = @behavior.place_block:randomly_placeable_blocks}
    }
}
behavior.place_block:randomly_placeable_blocks inherit temp/Set {
    $ field = "block"
    value_types = #dict
    value_structure = @behavior.place_block:randomly_placeable_block
}
behavior.place_block:randomly_placeable_block inherit temp/SortedKeymap {
    keys = {
        "block" = :Key {types = #dict, structure = @behavior.place_block:block}
        "filter" = :Key {types = #dict, structure = @filter}
    }
}
behavior.place_block:block inherit temp/SortedKeymap {
    keys = {
        "name" = :Key {types = #str}
        "states" = :Key {types = #dict, structure = @block_states}
    }
}
behavior.play inherit temp/SortedKeymap {
    keys = {
        "chance_to_start" = :Key {types = @temp/decimal}
        "filters" = :Key {types = #dict, structure = @filter}
        "follow_distance" = :Key {types = #int}
        "friend_search_area" = :Key {types = #list, structure = @vector_decimal}
        "friend_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "max_play_duration_seconds" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "random_pos_search_height" = :Key {types = #int}
        "random_pos_search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.play_dead inherit temp/SortedKeymap {
    keys = {
        "apply_regeneration" = :Key {types = #bool}
        "damage_sources" = :Key {types = #list, structure = @damage_source_list}
        "duration" = :Key {types = @temp/decimal}
        "filters" = :Key {types = #dict, structure = @filter}
        "force_below_health" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "random_damage_range" = :Key {types = @range, structure = @range_group_decimal}
        "random_start_chance" = :Key {types = @temp/decimal}
    }
}
behavior.player_ride_tamed inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.rabbit_panic inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "speed_modifier" = :Key {types = @temp/decimal}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.raid_garden inherit temp/SortedKeymap {
    keys = {
        "blocks" = :Key {types = #list, structure = @block_list}
        "eat_delay" = :Key {types = @temp/decimal}
        "full_delay" = :Key {types = @temp/decimal}
        "goal_radius" = :Key {types = @temp/decimal}
        "initial_eat_delay" = :Key {types = #int}
        "max_to_eat" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.ram_attack inherit temp/SortedKeymap {
    keys = {
        "baby_knockback_modifier" = :Key {types = @temp/decimal}
        "cooldown_range" = :Key {types = @range, structure = @range_group_decimal}
        "knockback_force" = :Key {types = @temp/decimal}
        "knockback_height" = :Key {types = @temp/decimal}
        "min_ram_distance" = :Key {types = @temp/decimal}
        "on_start" = :Key {types = @trigger_type, structure = @trigger}
        "pre_ram_sound" = :Key {types = #str}
        "priority" = :Key {types = #int}
        "ram_distance" = :Key {types = @temp/decimal}
        "ram_impact_sound" = :Key {types = #str}
        "ram_speed" = :Key {types = @temp/decimal}
        "run_speed" = :Key {types = @temp/decimal}
    }
}
behavior.random_breach inherit temp/SortedKeymap {
    keys = {
        "cooldown_time" = :Key {types = @temp/decimal}
        "interval" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "xz_dist" = :Key {types = #int}
        "y_dist" = :Key {types = #int}
    }
}
behavior.random_fly inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "avoid_damage_blocks" = :Key {types = #bool}
        "can_land_on_trees" = :Key {types = #bool}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "xz_dist" = :Key {types = #int}
        "xz_distance" = :Key {types = #int, tags = [@t/outdated]}
        "y_dist" = :Key {types = #int}
        "y_distance" = :Key {types = #int, tags = [@t/outdated]}
        "y_offset" = :Key {types = #int}
    }
}
behavior.random_hover inherit temp/SortedKeymap {
    keys = {
        "hover_height" = :Key {types = @range, structure = @range_group_decimal}
        "interval" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "xz_dist" = :Key {types = #int}
        "y_dist" = :Key {types = #int}
        "y_offset" = :Key {types = @temp/decimal}
    }
}
behavior.random_look_around_and_sit inherit temp/SortedKeymap {
    keys = {
        "continue_if_leashed" = :Key {types = #bool}
        "continue_sitting_on_reload" = :Key {types = #bool}
        "max_angle_of_view_horizontal" = :Key {types = @temp/decimal}
        "max_look_count" = :Key {types = #int}
        "max_look_time" = :Key {types = #int}
        "min_angle_of_view_horizontal" = :Key {types = @temp/decimal}
        "min_look_count" = :Key {types = #int}
        "min_look_time" = :Key {types = #int}
        "priority" = :Key {types = #int, tags = [@t/not_in_documentation]}
        "probability" = :Key {types = @temp/decimal}
        "random_look_around_cooldown" = :Key {types = #int}
    }
}
behavior.random_look_around inherit temp/SortedKeymap {
    keys = {
        "angle_of_view_horizontal" = :Key {types = #int}
        "angle_of_view_vertical" = :Key {types = #int}
        "look_distance" = :Key {types = @temp/decimal}
        "look_time" = :Key {types = @range, structure = @range_group_decimal}
        "priority" = :Key {types = #int}
        "probability" = :Key {types = @temp/decimal}
    }
}
behavior.random_search_and_dig inherit temp/SortedKeymap {
    keys = {
        "cooldown_range" = :Key {types = [@temp/decimal, @range], structure = @range_decimal_or_decimal}
        "digging_duration_range" = :Key {types = @range, structure = @range_group_decimal}
        "find_valid_position_retries" = :Key {types = @temp/decimal}
        "goal_radius" = :Key {types = @temp/decimal}
        "item_table" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "item" = :Key {types = #str, tags = [@t/outdated]}
        "items" = :Key {types = #list, structure = @behavior.random_search_and_dig:items, tags = [@t/outdated]}
        "on_digging_start" = :Key {types = @trigger_type, structure = @trigger}
        "on_fail_during_digging" = :Key {types = @trigger_type, structure = @trigger}
        "on_fail_during_searching" = :Key {types = @trigger_type, structure = @trigger}
        "on_item_found" = :Key {types = @trigger_type, structure = @trigger}
        "on_searching_start" = :Key {types = @trigger_type, structure = @trigger}
        "on_success" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int, tags = [@t/not_in_documentation]}
        "search_range_xz" = :Key {types = @temp/decimal}
        "search_range_y" = :Key {types = @temp/decimal}
        "spawn_item_after_seconds" = :Key {types = @temp/decimal}
        "spawn_item_pos_offset" = :Key {types = @temp/decimal}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "target_blocks" = :Key {types = #list, structure = @block_list}
        "target_dig_position_offset" = :Key {types = @temp/decimal}
    }
}
behavior.random_search_and_dig:items inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @behavior.random_search_and_dig:items.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "item", "show_item_key" = false, "measure_length" = true}
    }
}
behavior.random_search_and_dig:items.item inherit temp/SortedKeymap {
    keys = {
        "item" = :Key {types = #str, delegate_arguments = {"always_print" = true}, structure = @temp/string}
        "weight" = :Key {types = #int, delegate_arguments = {"always_print" = true}}
    }
}
behavior.random_sitting inherit temp/SortedKeymap {
    keys = {
        "cooldown" = :Key {types = @temp/decimal}
        "min_sit_time" = :Key {types = @temp/decimal}
        "start_chance" = :Key {types = @temp/decimal}
        "stop_chance" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
    }
}
behavior.random_stroll inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "interval" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "speed_modifier" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "xz_dist" = :Key {types = @temp/decimal}
        "xz_distance" = :Key {types = #int, tags = [@t/outdated]}
        "y_dist" = :Key {types = #int}
        "y_distance" = :Key {types = #int, tags = [@t/outdated]}
    }
}
behavior.random_swim inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "avoid_surface" = :Key {types = #bool}
        "interval" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "xz_dist" = :Key {types = #int}
        "xz_distance" = :Key {types = #int, tags = [@t/outdated]}
        "y_dist" = :Key {types = #int}
        "y_distance" = :Key {types = #int, tags = [@t/outdated]}
    }
}
behavior.ranged_attack inherit temp/SortedKeymap {
    keys = {
        "attack_interval" = :Key {types = @temp/decimal}
        "attack_interval_max" = :Key {types = @temp/decimal}
        "attack_interval_min" = :Key {types = @temp/decimal}
        "attack_radius" = :Key {types = @temp/decimal}
        "attack_radius_min" = :Key {types = @temp/decimal}
        "burst_interval" = :Key {types = @temp/decimal}
        "burst_shots" = :Key {types = #int}
        "charge_charged_trigger" = :Key {types = @temp/decimal}
        "charge_shoot_trigger" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "ranged_fov" = :Key {types = @temp/decimal}
        "set_persistent" = :Key {types = #bool}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "swing" = :Key {types = #bool}
        "target_in_sight_time" = :Key {types = @temp/decimal}
        "x_max_rotation" = :Key {types = @temp/decimal}
        "y_max_head_rotation" = :Key {types = @temp/decimal}
    }
}
behavior.receive_love inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.restrict_open_door inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.restrict_sun inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.rise_to_liquid_level inherit temp/SortedKeymap {
    keys = {
        "liquid_y_offset" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "rise_delta" = :Key {types = @temp/decimal}
        "sink_delta" = :Key {types = @temp/decimal}
    }
}
behavior.rising inherit temp/SortedKeymap {
    keys = {
        "cooldown_range" = :Key {types = @temp/decimal}
        "duration_range" = :Key {types = @range, structure = @range_group_decimal}
        "on_end" = :Key {types = #dict, structure = @event_target}
        "priority" = :Key {types = #int}
    }
}
behavior.river_follow inherit temp/SortedKeymap {
    keys = {
        "centered_gap" = :Key {types = @temp/decimal}
        "follow_speed" = :Key {types = @temp/decimal}
        "look_ahead" = :Key {types = @temp/decimal}
        "priority" = :Key {types = @temp/decimal}
    }
}
behavior.roar inherit temp/SortedKeymap {
    keys = {
        "duration" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
    }
}
behavior.roll inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "probability" = :Key {types = @temp/decimal}
    }
}
behavior.run_around_like_crazy inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.scared inherit temp/SortedKeymap {
    keys = {
        "sound_interval" = :Key {types = #int}
        "priority" = :Key {types = #int}
    }
}
behavior.scenting inherit temp/SortedKeymap {
    keys = {
        "cooldown_range" = :Key {types = @range, structure = @range_group_decimal}
        "duration_range" = :Key {types = @temp/decimal}
        "on_end" = :Key {types = #dict, structure = @event_target}
        "priority" = :Key {types = #int}
    }
}
behavior.send_event inherit temp/SortedKeymap {
    keys = {
        "event_choices" = :Key {types = #list, structure = @behavior.send_event:event_choices}
        "priority" = :Key {types = #int, tags = [@t/not_in_documentation]}
    }
}
behavior.send_event:event_choices inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @behavior.send_event:event_choices.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"measure_length" = true, "show_item_key" = false, "field" = "choice"}
    }
}
behavior.send_event:event_choices.item inherit temp/SortedKeymap {
    keys = {
        "cast_duration" = :Key {types = @temp/decimal}
        "cooldown_time" = :Key {types = @temp/decimal, tags = [@t/not_in_documentation]}
        "filters" = :Key {types = #dict, structure = @filter, tags = [@t/not_in_documentation]}
        "look_at_target" = :Key {types = #bool}
        "max_activation_range" = :Key {types = @temp/decimal, tags = [@t/not_in_documentation]}
        "min_activation_range" = :Key {types = @temp/decimal, tags = [@t/not_in_documentation]}
        "particle_color" = :Key {types = #str, tags = [@t/not_in_documentation]}
        "priority" = :Key {types = #int}
        "sequence" = :Key {types = #list, structure = @behavior.send_event:event_choices.item.sequence}
        "start_sound_event" = :Key {types = #str, tags = [@t/not_in_documentation]}
        "weight" = :Key {types = #int, tags = [@t/not_in_documentation]}
    }
}
behavior.send_event:event_choices.item.sequence inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @behavior.send_event:event_choices.item.sequence.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "event", "show_item_key" = false, "measure_length" = true}
    }
}
behavior.send_event:event_choices.item.sequence.item inherit temp/SortedKeymap {
    keys = {
        "base_delay" = :Key {types = @temp/decimal}
        "event" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "sound_event" = :Key {types = #str}
    }
}
behavior.share_items inherit temp/SortedKeymap {
    keys = {
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "cooldown" = :Key {types = @temp/decimal}
        "filters" = :Key {types = #dict, structure = @filter, tags = [@t/outdated]}
        "goal_radius" = :Key {types = @temp/decimal}
        "items_filter" = :Key {types = #list, structure = @behavior.share_items:items_filter, tags = [@t/outdated]}
        "max_dist" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "target_entity_filter" = :Key {types = #list, structure = @entity_list, tags = [@t/outdated]}
        "target_entity_items" = :Key {types = #list, structure = @behavior.share_items:target_entity_items, tags = [@t/outdated]}
    }
}
behavior.share_items:items_filter inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @behavior.share_items:items_filter.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "item", "show_item_key" = false, "measure_length" = true}
    }
}
behavior.share_items:items_filter.item inherit temp/SortedKeymap {
    keys = {
        "craft_into" = :Key {types = #str, structure = @temp/string}
        "item" = :Key {types = #str, delegate_arguments = {"always_print" = true}, structure = @temp/string}
        "min_count" = :Key {types = #int}
    }
}
behavior.share_items:target_entity_items inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @behavior.share_items:target_entity_items.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "item", "show_item_key" = false, "measure_length" = true}
    }
}
behavior.share_items:target_entity_items.item inherit temp/SortedKeymap {
    keys = {
        "item" = :Key {types = #str, delegate_arguments = {"always_print" = true}, structure = @temp/string}
        "max_count" = :Key {types = #int}
    }
}
behavior.silverfish_merge_with_stone inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.silverfish_wake_up_friends inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.skeleton_horse_trap inherit temp/SortedKeymap {
    keys = {
        "duration" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "within_radius" = :Key {types = @temp/decimal}
    }
}
behavior.sleep inherit temp/SortedKeymap {
    keys = {
        "can_sleep_while_riding" = :Key {types = #bool}
        "cooldown_time" = :Key {types = @temp/decimal}
        "goal_radius" = :Key {types = @temp/decimal, tags = [@t/not_in_documentation]}
        "priority" = :Key {types = #int}
        "sleep_collider_height" = :Key {types = @temp/decimal}
        "sleep_collider_width" = :Key {types = @temp/decimal}
        "sleep_y_offset" = :Key {types = @temp/decimal}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "timeout_cooldown" = :Key {types = @temp/decimal}
    }
}
behavior.slime_attack inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "set_persistent" = :Key {types = #bool}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "x_max_rotation" = :Key {types = @temp/decimal}
        "y_max_rotation" = :Key {types = @temp/decimal}
    }
}
behavior.slime_float inherit temp/SortedKeymap {
    keys = {
        "jump_chance_percentage" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.slime_keep_on_jumping inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.slime_random_direction inherit temp/SortedKeymap {
    keys = {
        "add_random_time_range" = :Key {types = #int}
        "min_change_direction_time" = :Key {types = @temp/decimal}
        "turn_range" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
    }
}
behavior.snacking inherit temp/SortedKeymap {
    keys = {
        "items" = :Key {types = #list, structure = @item_list}
        "priority" = :Key {types = #int}
        "snacking_cooldown" = :Key {types = @temp/decimal}
        "snacking_cooldown_min" = :Key {types = @temp/decimal}
        "snacking_stop_chance" = :Key {types = @temp/decimal}
    }
}
behavior.sneeze inherit temp/SortedKeymap {
    keys = {
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "cooldown_time" = :Key {types = @temp/decimal}
        "drop_item_chance" = :Key {types = @temp/decimal}
        "loot_table" = :Key {types = #str}
        "prepare_sound" = :Key {types = #str}
        "prepare_time" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "probability" = :Key {types = @temp/decimal}
        "sound" = :Key {types = #str}
        "within_radius" = :Key {types = @temp/decimal}
    }
}
behavior.sniff inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "cooldown_range" = :Key {types = @range, structure = @range_group_decimal}
        "duration" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "sniffing_radius" = :Key {types = @temp/decimal}
        "suspicion_radius" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "suspicion_radius_horizontal" = :Key {types = @temp/decimal}
        "suspicion_radius_vertical" = :Key {types = @temp/decimal}
    }
}
behavior.sonic_boom inherit temp/SortedKeymap {
    keys = {
        "attack_cooldown" = :Key {types = @temp/decimal}
        "attack_damage" = :Key {types = @temp/decimal}
        "attack_range_horizontal" = :Key {types = @temp/decimal}
        "attack_range_vertical" = :Key {types = @temp/decimal}
        "attack_sound" = :Key {types = #str}
        "charge_sound" = :Key {types = #str}
        "duration" = :Key {types = @temp/decimal}
        "duration_until_attack_sound" = :Key {types = @temp/decimal}
        "knockback_height_cap" = :Key {types = @temp/decimal}
        "knockback_horizontal_strength" = :Key {types = @temp/decimal}
        "knockback_vertical_strength" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.squid_dive inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.squid_flee inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.squid_idle inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.squid_move_away_from_ground inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.squid_out_of_water inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.stalk_and_pounce_on_target inherit temp/SortedKeymap {
    keys = {
        "interest_time" = :Key {types = @temp/decimal}
        "leap_dist" = :Key {types = @temp/decimal, tags = [@t/not_in_documentation]}
        "leap_height" = :Key {types = @temp/decimal}
        "max_stalk_dist" = :Key {types = @temp/decimal}
        "pounce_max_dist" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "set_persistent" = :Key {types = #bool}
        "stalk_speed" = :Key {types = @temp/decimal}
        "strike_dist" = :Key {types = @temp/decimal}
        "stuck_blocks" = :Key {types = #dict, structure = @filter, tags = [@t/not_in_documentation]}
        "stuck_time" = :Key {types = @temp/decimal}
    }
}
behavior.stay_near_note_block inherit temp/SortedKeymap {
    keys = {
        "listen_time" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "speed" = :Key {types = @temp/decimal}
        "start_distance" = :Key {types = @temp/decimal}
        "stop_distance" = :Key {types = @temp/decimal}
    }
}
behavior.stay_while_sitting inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.stomp_attack inherit temp/SortedKeymap {
    keys = {
        "attack_once" = :Key {types = #bool}
        "attack_types" = :Key {types = #str}
        "cooldown_time" = :Key {types = @temp/decimal}
        "inner_boundary_time_increase" = :Key {types = @temp/decimal}
        "max_dist" = :Key {types = @temp/decimal, tags = [@t/unused]}
        "max_path_time" = :Key {types = @temp/decimal}
        "melee_fov" = :Key {types = @temp/decimal}
        "min_path_time" = :Key {types = @temp/decimal}
        "no_damage_range_multiplier" = :Key {types = @temp/decimal}
        "on_attack" = :Key {types = @trigger_type, structure = @trigger}
        "outer_boundary_time_increase" = :Key {types = @temp/decimal}
        "path_fail_time_increase" = :Key {types = @temp/decimal}
        "path_inner_boundary" = :Key {types = @temp/decimal}
        "path_outer_boundary" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "random_stop_interval" = :Key {types = #int}
        "reach_multiplier" = :Key {types = @temp/decimal}
        "require_complete_path" = :Key {types = #bool}
        "set_persistent" = :Key {types = #bool}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "stomp_range_multiplier" = :Key {types = @temp/decimal}
        "target_dist" = :Key {types = @temp/decimal, tags = [@t/unused]}
        "track_target" = :Key {types = #bool}
        "x_max_rotation" = :Key {types = @temp/decimal}
        "y_max_head_rotation" = :Key {types = @temp/decimal}
    }
}
behavior.stomp_turtle_egg inherit temp/SortedKeymap {
    keys = {
        "goal_radius" = :Key {types = @temp/decimal}
        "interval" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "search_count" = :Key {types = #int, tags = [@t/outdated]}
        "search_height" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.stroll_towards_village inherit temp/SortedKeymap {
    keys = {
        "cooldown_time" = :Key {types = @temp/decimal}
        "goal_radius" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "search_range" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "start_chance" = :Key {types = @temp/decimal}
    }
}
behavior.summon_entity inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "attacks" = :Key {types = #list, structure = @behavior.summon_entity:summon_choices, tags = [@t/outdated]}
        "priority" = :Key {types = #int}
        "summon_choices" = :Key {types = #list, structure = @behavior.summon_entity:summon_choices}
    }
}
behavior.summon_entity:summon_choices inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @behavior.summon_entity:summon_choices.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "choice", "show_item_key" = false, "measure_length" = true}
    }
}
behavior.summon_entity:summon_choices.item inherit temp/SortedKeymap {
    allow_key_moves = true
    key_weight = 1
    value_weight = 5
    keys = {
        "attack_type" = :Key {types = #str, tags = [@t/outdated]}
        "base_delay" = :Key {types = #int, tags = [@t/outdated]}
        "cast_duration" = :Key {types = @temp/decimal}
        "circles" = :Key {types = #list, structure = @behavior.summon_entity:summon_choices.item:sequence, tags = [@t/outdated]}
        "cooldown_time" = :Key {types = @temp/decimal}
        "delay_between_spawns" = :Key {types = #int, tags = [@t/outdated]}
        "do_casting" = :Key {types = #bool}
        "filters" = :Key {types = #dict, structure = @filter}
        "max_activation_range" = :Key {types = @temp/decimal}
        "min_activation_range" = :Key {types = @temp/decimal}
        "particle_color" = :Key {types = #str}
        "priority" = :Key {types = #int, tags = [@t/outdated]}
        "range" = :Key {types = #int, tags = [@t/outdated]}
        "start_sound_event" = :Key {types = #str}
        "summon_type" = :Key {types = #str, tags = [@t/outdated]}
        "weight" = :Key {types = @temp/decimal}
        "sequence" = :Key {types = #list, structure = @behavior.summon_entity:summon_choices.item:sequence}
    }
}
behavior.summon_entity:summon_choices.item:sequence inherit temp/Dict {
    allow_key_moves = false
    key_weight = 0
    key_types = #int
    this_types = #list
    value_types = #dict
    value_structure = @behavior.summon_entity:summon_choices.item:sequence.item
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "spell sequence step", "show_item_key" = false, "measure_length" = true}
    }
}
behavior.summon_entity:summon_choices.item:sequence.item inherit temp/SortedKeymap {
    keys = {
        "base_delay" = :Key {types = @temp/decimal}
        "delay" = :Key {types = #int, tags = [@t/outdated]}
        "delay_per_summon" = :Key {types = @temp/decimal}
        "entity_lifespan" = :Key {types = @temp/decimal}
        "entity_type" = :Key {types = #str}
        "num_entities_spawned" = :Key {types = #int}
        "radius" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "shape" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "size" = :Key {types = @temp/decimal}
        "sound_event" = :Key {types = #str}
        "summon_cap" = :Key {types = #int}
        "summon_cap_radius" = :Key {types = @temp/decimal}
        "summon_event" = :Key {types = #str}
        "target" = :Key {types = #str}
    }
}
behavior.summon_spell_goal inherit temp/SortedKeymap {
    keys = {
        "entity_type" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "mobs_per_summon" = :Key {types = #int}
        "priority" = :Key {types = #int}
        "summon_cap" = :Key {types = #int}
    }
}
behavior.swell inherit temp/SortedKeymap {
    keys = {
        "stop_distance" = :Key {types = @temp/decimal}
        "start_distance" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
    }
}
behavior.swim_idle inherit temp/SortedKeymap {
    keys = {
        "idle_time" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "success_rate" = :Key {types = @temp/decimal}
    }
}
behavior.swim_up_for_breath inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.swim_wander inherit temp/SortedKeymap {
    keys = {
        "interval" = :Key {types = @temp/decimal}
        "look_ahead" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "wander_time" = :Key {types = @temp/decimal}
    }
}
behavior.swim_with_entity inherit temp/SortedKeymap {
    keys = {
        "catch_up_multiplier" = :Key {types = @temp/decimal}
        "catch_up_threshold" = :Key {types = @temp/decimal}
        "chance_to_stop" = :Key {types = @temp/decimal}
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "match_direction_threshold" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "search_range" = :Key {types = @temp/decimal}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "state_check_interval" = :Key {types = @temp/decimal}
        "stop_distance" = :Key {types = @temp/decimal}
        "success_rate" = :Key {types = @temp/decimal}
    }
}
behavior.swoop_attack inherit temp/SortedKeymap {
    keys = {
        "damage_reach" = :Key {types = @temp/decimal}
        "delay_range" = :Key {types = @range, structure = @range_group_decimal}
        "priority" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.take_block inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "xz_range" = :Key {types = #int}
        "y_range" = :Key {types = @range, structure = @range_group_decimal}
        "chance" = :Key {types = @temp/decimal}
        "blocks" = :Key {types = #list, structure = @block_list}
    }
}
behavior.take_flower inherit temp/SortedKeymap {
    keys = {
        "filters" = :Key {types = #dict, structure = @filter, tags = [@t/not_in_documentation]}
        "priority" = :Key {types = #int}
    }
}
behavior.target_when_pushed inherit temp/SortedKeymap {
    keys = {
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "percent_chance" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
    }
}
behavior.teleport_to_owner inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "filters" = :Key {types = #dict, structure = @filter}
    }
}
behavior.tempt inherit temp/SortedKeymap {
    keys = {
        "can_get_scared" = :Key {types = #bool}
        "can_tempt_vertically" = :Key {types = #bool}
        "can_tempt_while_ridden" = :Key {types = #bool}
        "items" = :Key {types = #list, structure = @item_list}
        "on_tempt_end" = :Key {types = #dict, structure = @event}
        "priority" = :Key {types = #int}
        "sound_interval" = :Key {types = @range, structure = @range_group_decimal}
        "speed_modifier" = :Key {types = @temp/decimal, tags = [@t/outdated]}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "tempt_sound" = :Key {types = #str}
        "within_radius" = :Key {types = @temp/decimal}
    }
}
behavior.timer_flag inherit temp/SortedKeymap {
    keys = {
        "control_flags" = :Key {types = #list, structure = @behavior.timer_flag:control_flags}
        "cooldown_range" = :Key {types = [@temp/decimal, @range], structure = @range_decimal_or_decimal}
        "duration_range" = :Key {types = [@temp/decimal, @range], structure = @range_decimal_or_decimal}
        "on_end" = :Key {types = @trigger_type, structure = @trigger}
        "on_start" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int, tags = [@t/not_in_documentation]}
    }
}
behavior.timer_flag:control_flags inherit temp/Dict {
    key_weight = 0
    key_types = #int
    this_types = #list
    value_structure = null
    value_types = #str
    delegate = :Delegate {
        delegate_class = %DefaultDelegate
        arguments = {"field" = "control flag", "show_item_key" = false, "measure_length" = true, "sort" = %sort_by_value, "print_flat" = true}
    }
}
behavior.trade_intereset inherit temp/SortedKeymap {
    keys = {
        "carried_item_switch_time" = :Key {types = @temp/decimal}
        "cooldown" = :Key {types = @temp/decimal}
        "interest_time" = :Key {types = @temp/decimal}
        "priority" = :Key {types = #int}
        "remove_item_time" = :Key {types = @temp/decimal}
        "within_radius" = :Key {types = @temp/decimal}
    }
}
behavior.trade_with_player inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "filters" = :Key {types = #dict, structure = @filter}
        "max_distance_from_player" = :Key {types = @temp/decimal}
    }
}
behavior.transport_items inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
        "source_container_types" = :Key {types = #list, structure = @temp/named_list{$name="container"}}
        "destination_container_types" = :Key {types = #list, structure = @temp/named_list{$name="container"}}
        "max_stack_size" = :Key {types = #int}
        "interaction_time" = :Key {types = @temp/decimal}
        "allow_simultaneous_interaction" = :Key {types = #bool}
        "search_strategy" = :Key {types = #str}
        "search_distance" = :Key {types = #list, structure = @range_list_int}
        "max_visited_containers" = :Key {types = #int}
        "initial_cooldown" = :Key {types = #int}
        "idle_cooldown" = :Key {types = #int}
        "place_strategy" = :Key {types = #str}
    }
}
behavior.vex_copy_owner_target inherit temp/SortedKeymap {
    keys = {
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "priority" = :Key {types = #int}
    }
}
behavior.vex_random_move inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.wither_random_attack_pos_goal inherit temp/SortedKeymap {
    keys = {
        "priority" = :Key {types = #int}
    }
}
behavior.wither_target_highest_damage inherit temp/SortedKeymap {
    keys = {
        "entity_types" = :Key {types = @entity_types_type, structure = @entity_types}
        "priority" = :Key {types = #int}
        "cooldown" = :Key {types = @temp/decimal}
        "filters" = :Key {types = #dict, structure = @filter}
        "max_dist" = :Key {types = @temp/decimal}
        "must_see" = :Key {types = #bool}
        "must_see_forget_duration" = :Key {types = @temp/decimal}
        "reevaluate_description" = :Key {types = #bool}
        "sprint_speed_multiplier" = :Key {types = @temp/decimal}
        "walk_speed_multiplier" = :Key {types = @temp/decimal}
    }
}
behavior.wololo_spell_goal inherit temp/SortedKeymap {
    keys = {
        "change_color" = :Key {types = #str}
        "priority" = :Key {types = #int}
        "range" = :Key {types = #int}
        "target_color" = :Key {types = #str}
        "target_types" = :Key {types = #list, structure = @entity_list}
    }
}
behavior.work inherit temp/SortedKeymap {
    keys = {
        "active_time" = :Key {types = #int}
        "can_work_in_rain" = :Key {types = #bool}
        "goal_cooldown" = :Key {types = #int}
        "on_arrival" = :Key {types = @trigger_type, structure = @trigger}
        "sound_delay_max" = :Key {types = #int}
        "sound_delay_min" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "work_in_rain_tolerance" = :Key {types = #int}
        "priority" = :Key {types = #int}
    }
}
behavior.work_composter inherit temp/SortedKeymap {
    keys = {
        "active_time" = :Key {types = #int}
        "block_interaction_max" = :Key {types = #int}
        "can_empty_composter" = :Key {types = #bool}
        "can_fill_composter" = :Key {types = #bool}
        "can_work_in_rain" = :Key {types = #bool}
        "goal_cooldown" = :Key {types = #int}
        "items_per_use_max" = :Key {types = #int}
        "min_item_count" = :Key {types = #int}
        "on_arrival" = :Key {types = @trigger_type, structure = @trigger}
        "priority" = :Key {types = #int}
        "sound_delay_max" = :Key {types = #int}
        "sound_delay_min" = :Key {types = #int}
        "speed_multiplier" = :Key {types = @temp/decimal}
        "use_block_max" = :Key {types = #int}
        "use_block_min" = :Key {types = #int}
        "work_in_rain_tolerance" = :Key {types = #int}
    }
}