/* Converted by CmpMigrator 0.1.9 */
settings {
    aliases {
        item_modifier = @structures/data/loot_tables/item_modifier/
        misc = @structures/misc/misc/
        temp = @structures/misc/template/
        t = @structure_tags/
        pred = @structures/misc/predicate/
    }
}
entry_list inherit temp/Sequence {
    $ field = "entry"
    value_types = #dict
    value_structure = @entry
}
entry :Switch {
    switch_function = :Function {
        function = %get_key
        arguments = {"key" = "type"}
    }
    substructures = {
        "minecraft:alternatives" = :Key {types = #dict, structure = @entry.alternatives}
        "minecraft:dynamic" = :Key {types = #dict, structure = @entry.dynamic}
        "empty" = :Key {types = #dict, structure = @entry.empty, tags = @t/outdated}
        "minecraft:empty" = :Key {types = #dict, structure = @entry.empty}
        "minecraft:group" = :Key {types = #dict, structure = @entry.group}
        "item" = :Key {types = #dict, structure = @entry.item, tags = @t/outdated}
        "minecraft:item" = :Key {types = #dict, structure = @entry.item}
        "loot_table" = :Key {types = #dict, structure = @entry.loot_table, tags = @t/outdated}
        "minecraft:loot_table" = :Key {types = #dict, structure = @entry.loot_table}
        "minecraft:sequence" = :Key {types = #dict, structure = @entry.sequence}
        "minecraft:tag" = :Key {types = #dict, structure = @entry.tag}
    }
}
entry:all {
    "type" = :Key {types = #str, delegate_arguments = {"always_print" = true}, similarity_weight = 0}
}
entry:singleton {
    "conditions" = :Key {types = #list, structure = @pred/predicate_list}
    "functions" = :Key {types = #list, structure = @item_modifier/item_modifier_list}
    "weight" = :Key {types = #int}
    "quality" = :Key {types = #int}
}
entry:composite {
    "conditions" = :Key {types = #list, structure = @pred/predicate_list}
    "children" = :Key {types = #list, structure = @entry_list}
}
entry.alternatives inherit temp/SortedKeymap {
    keys = @entry:all + @entry:composite
}
entry.dynamic inherit temp/SortedKeymap {
    keys = @entry:all + @entry:singleton + {
        "name" = :Key {types = #str, structure = @misc/string, delegate_arguments = {"always_print" = true}, similarity_weight = 5}
    }
}
entry.empty inherit temp/SortedKeymap {
    keys = @entry:all + @entry:singleton
}
entry.group inherit temp/SortedKeymap {
    keys = @entry:all + @entry:composite
}
entry.item inherit temp/SortedKeymap {
    keys = @entry:all + @entry:singleton + {
        "name" = :Key {types = #str, structure = @misc/string, delegate_arguments = {"always_print" = true}, similarity_weight = 5}
    }
}
entry.loot_table inherit temp/SortedKeymap {
    keys = @entry:all + @entry:singleton + {
        "name" = :Key {types = #str, structure = @misc/string, tags = @t/outdated, similarity_weight = 5}
        "luck" = :Key {types = #int, tags = @t/outdated}
        "value" = :Key {types = [#str, #dict], structure = @structures/data/loot_tables/loot_tables/loot_table_or_id}
    }
}
entry.sequence inherit temp/SortedKeymap {
    keys = @entry:all + @entry:composite
}
entry.tag inherit temp/SortedKeymap {
    keys = @entry:all + {
        "name" = :Key {types = #str, structure = @misc/string, delegate_arguments = {"always_print" = true}, similarity_weight = 5}
        "expand" = :Key {types = #bool}
        "conditions" = :Key {types = #list, structure = @pred/predicate_list}
        "functions" = :Key {types = #list, structure = @item_modifier/item_modifier_list}
        "weight" = :Key {types = #int}
        "quality" = :Key {types = #int}
    }
}