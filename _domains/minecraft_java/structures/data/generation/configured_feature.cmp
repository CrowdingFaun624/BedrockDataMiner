/* Converted by CmpMigrator 0.1.9 */
settings {
    aliases {
        a = @structures/misc/types/
        bs = @structures/misc/block_state/
        bpl = @structures/misc/block_placer/
        bpred = @structures/misc/block_predicate/
        bsp = @structures/misc/provider/block_state_provider/
        d = @structures/data/generation/decorator/
        foliage_placer = @structures/data/generation/tree/foliage_placer/
        fp = @structures/misc/provider/float_provider/
        hp = @structures/misc/provider/height_provider/
        ip = @structures/misc/provider/int_provider/
        minimum_size = @structures/data/generation/tree/minimum_size/
        misc = @structures/misc/misc/
        pf = @structures/data/generation/placed_feature/
        pl = @structures/data/generation/processor_list/
        root_placer = @structures/data/generation/tree/root_placer/
        rt = @structures/data/generation/rule_test/
        temp = @structures/misc/template/
        tree_decorator = @structures/data/generation/tree/decorator/
        trunk_placer = @structures/data/generation/tree/trunk_placer/
        t = @structure_tags/
        vector = @structures/misc/vector/
    }
}
base inherit temp/base_multiple_pack_files {
    $ name = "feature"
    $ pack_type = "data pack"
    $ structure = @feature
}
feature_list_or_feature :Union {
    substructures = [
        :Key {types = #str},
        :Key {types = #dict, structure = @feature},
        :Key {types = #list, structure = @feature_or_id_list},
    ]
}
feature_or_id :Union {
    substructures = [
        :Key {types = #str},
        :Key {types = #dict, structure = @feature},
    ]
}
feature_or_id_list inherit temp/Set {
    $ field = "feature"
    value_types = [#str, #dict]
    value_structure = @feature_or_id
}
feature :Switch {
    switch_function = :Function {
        function = %old_type_choose
    }
    substructures = {
        "minecraft:bamboo" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.bamboo}}
        "minecraft:basalt_columns" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.basalt_columns}}
        "minecraft:basalt_pillar" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:block_column" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.block_column}}
        "minecraft:block_pile" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.block_pile}}
        "minecraft:blue_ice" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:bonus_chest" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:central_block_scattered_features" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.central_block_scattered_features}, tags = @t/outdated}
        "minecraft:chorus_plant" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:coral_claw" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:coral_mushroom" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:coral_tree" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:decorated" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.decorated}, tags = @t/outdated}
        "minecraft:delta_feature" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.delta_feature}}
        "minecraft:desert_well" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:disk" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.disk}}
        "minecraft:dripstone_cluster" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.dripstone_cluster}}
        "minecraft:emerald_ore" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.emerald_ore}, tags = @t/outdated}
        "minecraft:end_gateway" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.end_gateway}}
        "minecraft:end_island" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:end_platform" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:end_spike" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.end_spike}}
        "minecraft:fallen_tree" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.fallen_tree}}
        "minecraft:fill_layer" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.fill_layer}}
        "minecraft:flower" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.random_patch}}
        "minecraft:forest_rock" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.forest_rock}}
        "minecraft:fossil" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.fossil}}
        "minecraft:freeze_top_layer" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:geode" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.geode}}
        "minecraft:glow_lichen" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.multiface_growth}, tags = @t/outdated}
        "minecraft:glowstone_blob" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:growing_plant" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.growing_plant}, tags = @t/outdated}
        "minecraft:huge_brown_mushroom" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.huge_mushroom}}
        "minecraft:huge_fungus" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.huge_fungus}}
        "minecraft:huge_red_mushroom" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.huge_mushroom}}
        "minecraft:ice_patch" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.disk}, tags = @t/outdated}
        "minecraft:ice_spike" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:iceberg" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.iceberg}}
        "minecraft:kelp" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:lake" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.lake}}
        "minecraft:large_dripstone" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.large_dripstone}}
        "minecraft:monster_room" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:multiface_growth" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.multiface_growth}}
        "minecraft:nether_forest_vegetation" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.nether_forest_vegetation}}
        "minecraft:netherrack_replace_blobs" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.netherrack_replace_blobs}}
        "minecraft:no_bonemeal_flower" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.random_patch}}
        "minecraft:no_op" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:no_surface_ore" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.ore}, tags = @t/outdated}
        "minecraft:ore" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.ore}}
        "minecraft:pointed_dripstone" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.pointed_dripstone}}
        "minecraft:random_boolean_selector" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.random_boolean_selector}}
        "minecraft:random_selector" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.random_selector}}
        "minecraft:random_patch" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.random_patch}}
        "minecraft:replace_single_block" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.replace_single_block}}
        "minecraft:root_system" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.root_system}}
        "minecraft:scattered_ore" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.ore}}
        "minecraft:sculk_patch" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.sculk_patch}}
        "minecraft:seagrass" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.seagrass}}
        "minecraft:sea_pickle" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.sea_pickle}}
        "minecraft:simple_block" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.simple_block}}
        "minecraft:simple_random_selector" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.simple_random_selector}}
        "minecraft:small_dripstone" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.small_dripstone}, tags = @t/outdated}
        "minecraft:spring_feature" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.spring_feature}}
        "minecraft:surface_disk" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.disk}, tags = @t/outdated}
        "minecraft:tree" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.tree}}
        "minecraft:twisting_vines" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.twisting_vines}}
        "minecraft:underwater_magma" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.underwater_magma}}
        "minecraft:vegetation_patch" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.vegetation_patch}}
        "minecraft:vines" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:void_start_platform" = :Key {types = #dict, structure = @feature:abstract}
        "minecraft:waterlogged_vegetation_patch" = :Key {types = #dict, structure = @feature:abstract{$imports=@config.vegetation_patch}}
        "minecraft:weeping_vines" = :Key {types = #dict, structure = @feature:abstract}
    }
}
feature:abstract inherit temp/SortedKeymap {
    $ (dict) imports = {}
    keys = {
        "type" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "name" = :Key {types = #str, delegate_arguments = {"always_print" = true}}
        "config" = :Key {types = #dict, structure = @config:abstract{$imports=imports}}
    }
}
config:abstract abstract inherit temp/SortedKeymap {
    $ (dict) imports
    keys = imports
}
config.bamboo {
    "probability" = :Key {types = #float}
}
config.basalt_columns {
    "reach" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "height" = :Key {types = [#int, #dict], structure = @ip/int_provider}
}
config.block_column {
    "direction" = :Key {types = #str}
    "allowed_placement" = :Key {types = #dict, structure = @bpred/block_predicate}
    "prioritize_tip" = :Key {types = #bool}
    "layers" = :Key {types = #list, structure = @config.block_columns:layers}
}
config.block_columns:layers inherit temp/Set {
    $ field = "layer"
    value_types = #dict
    value_structure = @config.block_columns:layer
}
config.block_columns:layer inherit temp/SortedKeymap {
    keys = {
        "height" = :Key {types = [#int, #dict], structure = @ip/int_provider}
        "provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
    }
}
config.block_pile {
    "state_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
}
config.central_block_scattered_features {
    "feature_count_min" = :Key {types = #int}
    "feature_count_max" = :Key {types = #int}
    "max_feature_distance" = :Key {types = #int}
    "surface" = :Key {types = #str}
    "vertical_range" = :Key {types = #int}
    "can_place_central_block_on" = :Key {types = #str},
    "central_state" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "scattered_feature" = :Key {types = #str}
    "central_feature" = :Key {types = #str}
}
config.decorated {
    "decorator" = :Key {types = #dict, structure = @d/decorator}
    "feature" = :Key {types = #dict, structure = @feature}
}
config.delta_feature {
    "contents" = :Key {types = @a/compound, structure = @bs/block_state}
    "rim" = :Key {types = @a/compound, structure = @bs/block_state}
    "size" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "rim_size" = :Key {types = [#int, #dict], structure = @ip/int_provider}
}
config.disk {
    "state" = :Key {types = @a/compound, structure = @bs/block_state, tags = @t/outdated}
    "state_provider" = :Key {types = #dict, structure = @config.disk:state_provider}
    "radius" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "half_height" = :Key {types = #int}
    "target" = :Key {types = #dict, structure = @bpred/block_predicate}
    "targets" = :Key {types = @a/list, structure = @bs/block_state_list}
    "can_origin_replace" = :Key {types = [#str, #list], structure = @misc/named_list_or_item{$name = "block"}, tags = @t/outdated}
}
config.disk:state_provider inherit temp/SortedKeymap {
    keys = {
        "fallback" = :Key {types = #dict, structure = @bsp/block_state_provider}
        "rules" = :Key {types = #list, structure = @config.disk:rules}
    }
}
config.disk:rules inherit temp/Set {
    $ field = "rule"
    value_types = #dict
    value_structure = @config.disk:rule
}
config.disk:rule inherit temp/SortedKeymap {
    keys = {
        "if_true" = :Key {types = #dict, structure = @bpred/block_predicate}
        "then" = :Key {types = #dict, structure = @bsp/block_state_provider}
    }
}
config.dripstone_cluster {
    "floor_to_ceiling_search_range" = :Key {types = #int}
    "height" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "radius" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "max_stalagmite_stalactite_height_diff" = :Key {types = #int}
    "height_deviation" = :Key {types = #int}
    "dripstone_block_layer_thickness" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "density" = :Key {types = [#float, #dict], structure = @fp/float_provider}
    "wetness" = :Key {types = [#float, #dict], structure = @fp/float_provider}
    "wetness_deviation" = :Key {types = #float, tags = @t/outdated}
    "wetness_mean" = :Key {types = #float, tags = @t/outdated}
    "chance_of_dripstone_column_at_max_distance_from_center" = :Key {types = #float}
    "max_distance_from_edge_affecting_chance_of_dripstone_column" = :Key {types = #int}
    "max_distance_from_center_affecting_chance_of_dripstone_column" = :Key {types = #int, tags = @t/outdated}
    "max_distance_from_center_affecting_height_bias" = :Key {types = #int}
}
config.emerald_ore {
    "target" = :Key {types = @a/compound, structure = @bs/block_state}
    "state" = :Key {types = @a/compound, structure = @bs/block_state}
}
config.end_gateway {
    "exact" = :Key {types = #bool}
    "exit" = :Key {types = #list, structure = @vector/vector.int}
}
config.end_spike {
    "crystal_invulnerable" = :Key {types = #bool}
    "crystal_beam_target" = :Key {types = #list, structure = @vector/vector.int}
    "spikes" = :Key {types = #list, structure = @config.end_spike:spikes}
}
config.end_spike:spikes inherit temp/Set {
    $ field = "spike"
    value_types = #dict
    value_structure = @config.end_spike:spike
}
config.end_spike:spike inherit temp/SortedKeymap {
    keys = {
        "centerX" = :Key {types = #int}
        "centerZ" = :Key {types = #int}
        "radius" = :Key {types = #int}
        "height" = :Key {types = #int}
        "guarded" = :Key {types = #bool}
    }
}
config.fill_layer {
    "state" = :Key {types = @a/compound, structure = @bs/block_state}
    "height" = :Key {types = #int}
}
config.fallen_tree {
    "trunk_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "log_length" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "log_decorators" = :Key {types = #list, structure = @tree_decorator/decorator_list}
    "stump_decorators" = :Key {types = #list, structure = @tree_decorator/decorator_list}
}
config.forest_rock {
    "state" = :Key {types = @a/compound, structure = @bs/block_state}
}
config.fossil {
    "fossil_structures" = :Key {types = #list, structure = @misc/named_list{$name="structure"}}
    "overlay_structures" = :Key {types = #list, structure = @misc/named_list{$name="structure"}}
    "fossil_processors" = :Key {types = [#str, #list, #dict], structure = @pl/processor_list_or_id}
    "overlay_processors" = :Key {types = [#str, #list, #dict], structure = @pl/processor_list_or_id}
    "max_empty_corners_allowed" = :Key {types = #int}
}
config.geode {
    "blocks" = :Key {types = #dict, structure = @config.geode:blocks}
    "layers" = :Key {types = #dict, structure = @config.geode:layers}
    "crack" = :Key {types = #dict, structure = @config.geode:crack}
    "noise_multiplier" = :Key {types = #float} // double
    "use_potential_placements_chance" = :Key {types = #float} // double
    "use_alternate_layer0_chance" = :Key {types = #float} // double
    "placements_require_layer0_alternate" = :Key {types = #bool}
    "min_outer_wall_distance" = :Key {types = #int, tags = @t/outdated}
    "max_outer_wall_distance" = :Key {types = #int, tags = @t/outdated}
    "outer_wall_distance" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "min_distribution_points" = :Key {types = #int, tags = @t/outdated}
    "max_distribution_points" = :Key {types = #int, tags = @t/outdated}
    "distribution_points" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "invalid_blocks_threshold" = :Key {types = #int}
    "min_point_offset" = :Key {types = #int, tags = @t/outdated}
    "max_point_offset" = :Key {types = #int, tags = @t/outdated}
    "point_offset" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "min_gen_offset" = :Key {types = #int}
    "max_gen_offset" = :Key {types = #int}
}
config.geode:blocks inherit temp/SortedKeymap {
    keys = {
        "filling_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
        "inner_layer_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
        "alternate_inner_layer_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
        "middle_layer_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
        "outer_layer_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
        "inner_placements" = :Key {types = @a/list, structure = @bs/block_state_list}
        "cannot_replace" = :Key {types = #str}
        "invalid_blocks" = :Key {types = #str}
    }
}
config.geode:layers inherit temp/SortedKeymap {
    keys = { // all doubles
        "filling" = :Key {types = #float}
        "inner_layer" = :Key {types = #float}
        "middle_layer" = :Key {types = #float}
        "outer_layer" = :Key {types = #float}
    }
}
config.geode:crack inherit temp/SortedKeymap {
    keys = {
        "generate_crack_chance" = :Key {types = #float} // double
        "base_crack_size" = :Key {types = #float} // double
        "crack_point_offset" = :Key {types = #int}
    }
}
config.growing_plant {
    "body_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "head_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "allow_water" = :Key {types = #bool}
    "height_distribution" = :Key {types = #list, structure = @config.growing_plant:height_distributions}
    "direction" = :Key {types = #str}
}
config.growing_plant:height_distributions inherit temp/Set {
    $field = "weighted item"
    value_types = #dict
    value_structure = @config.growing_plant:height_distribution
}
config.growing_plant:height_distribution inherit temp/SortedKeymap {
    keys = {
        "data" = :Key {types = [#int, #dict], structure = @ip/int_provider}
        "weight" = :Key {types = #int}
    }
}
config.huge_fungus {
    "hat_state" = :Key {types = @a/compound, structure = @bs/block_state}
    "decor_state" = :Key {types = @a/compound, structure = @bs/block_state}
    "stem_state" = :Key {types = @a/compound, structure = @bs/block_state}
    "valid_base_block" = :Key {types = @a/compound, structure = @bs/block_state}
    "planted" = :Key {types = #bool}
    "replaceable_blocks" = :Key {types = #dict, structure = @bpred/block_predicate}
}
config.huge_mushroom {
    "cap_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "stem_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "foliage_radius" = :Key {types = #int}
}
config.iceberg {
    "state" = :Key {types = @a/compound, structure = @bs/block_state}
}
config.lake {
    "state" = :Key {types = @a/compound, structure = @bs/block_state, tags = @t/outdated}
    "fluid" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "barrier" = :Key {types = #dict, structure = @bsp/block_state_provider}
}
config.large_dripstone {
    "floor_to_ceiling_search_range" = :Key {types = #int}
    "column_radius" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "height_scale" = :Key {types = [#float, #dict], structure = @fp/float_provider}
    "max_column_radius_to_cave_height_ratio" = :Key {types = #float}
    "stalactite_bluntness" = :Key {types = [#float, #dict], structure = @fp/float_provider}
    "stalagmite_bluntness" = :Key {types = [#float, #dict], structure = @fp/float_provider}
    "wind_speed" = :Key {types = [#float, #dict], structure = @fp/float_provider}
    "min_radius_for_wind" = :Key {types = #int}
    "min_bluntness_for_wind" = :Key {types = #float}
}
config.multiface_growth {
    "block" = :Key {types = #str}
    "block_to_place" = :Key {types = #dict, structure = @bs/block_state, tags = @t/outdated}
    "search_range" = :Key {types = #int}
    "chance_of_spreading" = :Key {types = #float}
    "can_place_on_floor" = :Key {types = #bool}
    "can_place_on_ceiling" = :Key {types = #bool}
    "can_place_on_wall" = :Key {types = #bool}
    "can_be_placed_on" = :Key {types = [@a/string, @a/compound, @a/list], structure = @bs/block_state_list_or_id}
    "min_distance_below_surface" = :Key {types = #int, tags = @t/outdated}
}
config.nether_forest_vegetation {
    "state_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "spread_width" = :Key {types = #int}
    "spread_height" = :Key {types = #int}
}
config.netherrack_replace_blobs {
    "state" = :Key {types = @a/compound, structure = @bs/block_state}
    "target" = :Key {types = @a/compound, structure = @bs/block_state}
    "radius" = :Key {types = [#int, #dict], structure = @ip/int_provider}
}
config.ore {
    "size" = :Key {types = #int}
    "discard_chance_on_air_exposure" = :Key {types = #float}
    "targets" = :Key {types = #list, structure = @config.ore:targets}
    "target" = :Key {types = #dict, structure = @rt/rule_test, tags = @t/outdated}
    "state" = :Key {types = @a/compound, structure = @bs/block_state, tags = @t/outdated}
}
config.ore:targets inherit temp/Set {
    $ field = "target"
    value_types = #dict
    value_structure = @config.ore:target
}
config.ore:target inherit temp/SortedKeymap {
    keys = {
        "target" = :Key {types = #dict, structure = @rt/rule_test}
        "state" = :Key {types = @a/compound, structure = @bs/block_state}
    }
}
config.pointed_dripstone {
    "chance_of_taller_dripstone" = :Key {types = #float}
    "chance_of_directional_spread" = :Key {types = #float}
    "chance_of_spread_radius2" = :Key {types = #float}
    "chance_of_spread_radius3" = :Key {types = #float}
}
config.random_boolean_selector {
    "feature_false" = :Key {types = [#str, #dict], structure = @pf/placed_feature_or_id_or_old}
    "feature_true" = :Key {types = [#str, #dict], structure = @pf/placed_feature_or_id_or_old}
}
config.random_selector {
    "default" = :Key {types = [#str, #dict], structure = @pf/placed_feature_or_id_or_old}
    "features" = :Key {types = #list, structure = @config.random_selector:features}
}
config.random_selector:features inherit temp/Set {
    $ field = "feature"
    value_types = #dict
    value_structure = @config.random_selector:feature
}
config.random_selector:feature inherit temp/SortedKeymap {
    keys = {
        "feature" = :Key {types = [#str, #dict], structure = @pf/placed_feature_or_id_or_old}
        "chance" = :Key {types = #float}
    }
}
config.random_patch {
    "tries" = :Key {types = #int}
    "xz_spread" = :Key {types = #int}
    "y_spread" = :Key {types = #int}
    "feature" = :Key {types = [#str, #dict], structure = @pf/placed_feature_or_id}
    "can_replace" = :Key {types = #bool, tags = @t/outdated}
    "project" = :Key {types = #bool, tags = @t/outdated}
    "need_water" = :Key {types = #bool, tags = @t/outdated}
    "xspread" = :Key {types = #int, tags = @t/outdated}
    "yspread" = :Key {types = #int, tags = @t/outdated}
    "zspread" = :Key {types = #int, tags = @t/outdated}
    "whitelist" = :Key {types = @a/list, structure = @bs/block_state_list, tags = @t/outdated}
    "blacklist" = :Key {types = @a/list, structure = @bs/block_state_list, tags = @t/outdated}
    "state_provider" = :Key {types = #dict, structure = @bsp/block_state_provider, tags = @t/outdated}
    "block_placer" = :Key {types = #dict, structure = @bpl/block_placer, tags = @t/outdated}
}
config.replace_single_block {
    "targets" = :Key {types = #list, structure = @config.replace_single_block:targets}
}
config.replace_single_block:targets inherit temp/Set {
    $ field = "target"
    value_types = #dict
    value_structure = @config.replace_single_block:target
}
config.replace_single_block:target inherit temp/SortedKeymap {
    keys = {
        "target" = :Key {types = #dict, structure = @rt/rule_test}
        "state" = :Key {types = @a/compound, structure = @bs/block_state}
    }
}
config.root_system {
    "required_vertical_space_for_tree" = :Key {types = #int}
    "root_radius" = :Key {types = #int}
    "root_placement_attempts" = :Key {types = #int}
    "root_column_max_height" = :Key {types = #int}
    "hanging_root_radius" = :Key {types = #int}
    "hanging_roots_vertical_span" = :Key {types = #int}
    "hanging_root_placement_attempts" = :Key {types = #int}
    "allowed_vertical_water_for_tree" = :Key {types = #int}
    "root_replaceable" = :Key {types = #str}
    "root_state_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "hanging_root_state_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "allowed_tree_position" = :Key {types = #dict, structure = @bpred/block_predicate}
    "feature" = :Key {types = [#str, #dict], structure = @pf/placed_feature_or_id_or_old}
}
config.sculk_patch {
    "charge_count" = :Key {types = #int}
    "amount_per_charge" = :Key {types = #int}
    "spread_attempts" = :Key {types = #int}
    "growth_rounds" = :Key {types = #int}
    "growth_chance" = :Key {types = #float, tags = @t/outdated}
    "spread_rounds" = :Key {types = #int}
    "extra_rare_growths" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "catalyst_chance" = :Key {types = #float}
    "ground_state" = :Key {types = #dict, structure = @bsp/block_state_provider, tags = @t/outdated}
    "growth_feature" = :Key {types = #str, tags = @t/outdated},
    "replaceable" = :Key {types = #str, tags = @t/outdated}
    "surface" = :Key {types = #str, tags = @t/outdated}
    "xz_radius" = :Key {types = [#int, #dict], structure = @ip/int_provider, tags = @t/outdated}
    "vertical_range" = :Key {types = #int, tags = @t/outdated}
}
config.seagrass {
    "probability" = :Key {types = #float}
}
config.sea_pickle {
    "count" = :Key {types = [#int, #dict], structure = @ip/int_provider}
}
config.simple_block {
    "schedule_tick" = :Key {types = #int}
    "to_place" = :Key {types = @a/compound, structure = @config.simple_block:to_place}
    "place_on" = :Key {types = @a/list, structure = @bs/block_state_list, tags = @t/outdated}
    "place_in" = :Key {types = @a/list, structure = @bs/block_state_list, tags = @t/outdated}
    "place_under" = :Key {types = @a/list, structure = @bs/block_state_list, tags = @t/outdated}
}
config.simple_block:to_place :Switch {
    switch_function = :Function {
        function = %feature_simple_block_to_place_switch
    }
    substructures = {
        "block_state" = :Key {types = @a/compound, structure = @bs/block_state, tags = @t/outdated}
        "block_state_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
    }
}
config.simple_random_selector {
    "features" = :Key {types = [#str, #dict, #list], structure = @pf/placed_feature_list_or_feature_or_old}
}
config.small_dripstone {
    "max_placements" = :Key {types = #int}
    "empty_space_search_radius" = :Key {types = #int}
    "max_offset_from_origin" = :Key {types = #int}
    "chance_of_taller_dripstone" = :Key {types = #float}
}
config.spring_feature {
    "state" = :Key {types = @a/compound, structure = @bs/block_state}
    "rock_count" = :Key {types = #int}
    "hole_count" = :Key {types = #int}
    "requires_block_below" = :Key {types = #bool}
    "valid_blocks" = :Key {types = [#str, #list], structure = @misc/named_list_or_item{$name="block"}}
}
config.tree {
    "ignore_vines" = :Key {types = #bool}
    "force_dirt" = :Key {types = #bool}
    "dirt_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "leaves_provider" = :Key {types = #dict, structure = @bsp/block_state_provider, tags = @t/outdated}
    "trunk_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "foliage_provider" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "sapling_provider" = :Key {types = #dict, structure = @bsp/block_state_provider, tags = @t/outdated}
    "minimum_size" = :Key {types = #dict, structure = @minimum_size/minimum_size}
    "trunk_placer" = :Key {types = #dict, structure = @trunk_placer/trunk_placer}
    "foliage_placer" = :Key {types = #dict, structure = @foliage_placer/foliage_placer}
    "root_placer" = :Key {types = #dict, structure = @root_placer/root_placer}
    "decorators" = :Key {types = #list, structure = @tree_decorator/decorator_list}
    "heightmap" = :Key {types = #str, tags = @t/outdated}
    "max_water_depth" = :Key {types = #int, tags = @t/outdated}
}
config.twisting_vines {
    "spread_width" = :Key {types = #int}
    "spread_height" = :Key {types = #int}
    "max_height" = :Key {types = #int}
}
config.underwater_magma {
    "floor_search_range" = :Key {types = #int}
    "placement_radius_around_floor" = :Key {types = #int}
    "placement_probability_per_valid_position" = :Key {types = #float}
    "min_distance_below_surface" = :Key {types = #int, tags = @t/outdated}
}
config.vegetation_patch {
    "surface" = :Key {types = #str}
    "depth" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "vertical_range" = :Key {types = #int}
    "extra_bottom_block_chance" = :Key {types = #float}
    "extra_edge_column_chance" = :Key {types = #float}
    "vegetation_chance" = :Key {types = #float}
    "xz_radius" = :Key {types = [#int, #dict], structure = @ip/int_provider}
    "replaceable" = :Key {types = #str}
    "ground_state" = :Key {types = #dict, structure = @bsp/block_state_provider}
    "vegetation_feature" = :Key {types = [#str, #dict], structure = @pf/placed_feature_or_id_or_old}
}